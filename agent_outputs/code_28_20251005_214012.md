# コード: セキュリティ要件に基づいた実装開発（カスタムケイパビリティ設定、WP_Queryフックによるデータ制御、暗号化/複合化ロジックのプロトタイプ実装）を開始する。

タスクID: 28
作成日時: 2025-10-05T21:40:12.171510

---

お任せください。経験豊富なソフトウェアエンジニアとして、セキュリティ要件とこれまでの設計原則に基づき、WordPressでのカスタムアクセス制御と機密データ暗号化のプロトタイプコードを実装します。

このコードは、案件データ（ma_case）のアクセス制御と、機密フィールド（price_amount）のAES-256-GCM暗号化/複合化ロジックのコア部分を担います。

タスク概要

目的

M&A案件のカスタム投稿タイプ（ma_case）に関連するセキュリティコアモジュールを実装します。具体的には、提携パートナー（ma_partner）の権限設定、管理画面でのデータ閲覧制限、および機密カスタムフィールドのデータベース入出力時の暗号化・複合化プロトコルを確立します。

技術的要点

カスタムケイパビリティ設定: view_sensitive_dataケイパビリティの定義。

データ制御: pre_get_postsフックによる管理画面での投稿者ベースのデータフィルタリング。

暗号化プロトタイプ: PHPのopenssl関数を使用したAES-256-GCM暗号化/複合化関数。

フック統合: update_post_metadataとget_post_metadataフックによる暗号化/複合化の自動実行。

実装内容

WordPressプラグインの形で実装します。セキュリティの観点から、暗号化鍵とSALTはwp-config.phpで定義されるものと仮定し、コード内にはプレースホルダーを使用します。

暗号化の前提

鍵: MA_ENCRYPTION_KEY（32バイト、wp-config.phpに定義）。

IV/認証タグ: 暗号化データと連結し、BASE64エンコードしてDBに保存。

権限: ma_partnerロールにはview_sensitive_dataケイパビリティが必要です。

コード

PHP
<?php
/**
 * Plugin Name: M&A Security Core Module
 * Description: カスタムロール、RBAC、AES-256-GCM暗号化/複合化のコアロジック実装。
 * Version: 1.0
 * Author: Experienced Software Engineer
 */

// ---------------------------------------------------------------------
// セキュリティ定数（wp-config.phpで定義されていると想定）
// ---------------------------------------------------------------------
if ( ! defined('MA_ENCRYPTION_KEY') ) {
    // 開発/テスト環境向けのフォールバック（本番ではwp-config.phpに定義必須）
    define('MA_ENCRYPTION_KEY', '0123456789abcdef0123456789abcdef'); // 32 bytes (256 bit)
}
if ( ! defined('MA_CIPHER_ALGO') ) {
    define('MA_CIPHER_ALGO', 'aes-256-gcm');
}

// 暗号化対象となるカスタムフィールドのキー
define('MA_ENCRYPTED_META_KEYS', ['price_amount', 'financial_data']);

// ---------------------------------------------------------------------
// 1. データ暗号化/複合化関数 (AES-256-GCM)
// ---------------------------------------------------------------------

/**
 * 機密データをAES-256-GCMで暗号化する。
 * IVと認証タグを生成し、暗号化データと連結してBASE64エンコードする。
 * @param string $data 暗号化する平文データ
 * @return string|false BASE64エンコードされた暗号文または失敗時はfalse
 */
function ma_encrypt_data(string $data): string|false {
    $key = MA_ENCRYPTION_KEY;
    $cipher = MA_CIPHER_ALGO;
    $tag = '';
    
    // IV (Nonce) を生成
    $ivlen = openssl_cipher_iv_length($cipher);
    if ($ivlen === false) {
        error_log('Cipher algorithm IV length determination failed: ' . $cipher);
        return false;
    }
    $iv = openssl_random_pseudo_bytes($ivlen);
    if ($iv === false) {
        error_log('Failed to generate random IV.');
        return false;
    }

    // 暗号化実行
    $ciphertext = openssl_encrypt($data, $cipher, $key, OPENSSL_RAW_DATA, $iv, $tag);
    if ($ciphertext === false) {
        error_log('Encryption failed for data.');
        return false;
    }

    // IV (長さ$ivlen), 認証タグ (16バイト), 暗号文 を連結し、BASE64で保存
    return base64_encode($iv . $tag . $ciphertext);
}

/**
 * データベースから取得した暗号文を複合化する。
 * @param string $encoded_data BASE64エンコードされた暗号文
 * @return string|false 複合化された平文データまたは失敗時（改ざん検知含む）はfalse
 */
function ma_decrypt_data(string $encoded_data): string|false {
    $key = MA_ENCRYPTION_KEY;
    $cipher = MA_CIPHER_ALGO;
    $taglen = 16; // AES-256-GCMの認証タグは通常16バイト

    $decoded = base64_decode($encoded_data, true);
    if ($decoded === false) {
        error_log('Decryption failed: Base64 decode failed.');
        return false;
    }

    $ivlen = openssl_cipher_iv_length($cipher);
    if (strlen($decoded) < $ivlen + $taglen) {
        error_log('Decryption failed: Data is too short (IV/Tag missing).');
        return false;
    }

    // IV, Tag, Ciphertextを分離
    $iv = substr($decoded, 0, $ivlen);
    $tag = substr($decoded, $ivlen, $taglen);
    $ciphertext = substr($decoded, $ivlen + $taglen);

    // 複合化実行 (改ざん検知を含む)
    $plaintext = openssl_decrypt($ciphertext, $cipher, $key, OPENSSL_RAW_DATA, $iv, $tag);

    if ($plaintext === false) {
        // 複合化失敗はデータ改ざんまたは鍵/IV/タグの不一致を意味する
        error_log('Decryption failed: Authentication tag mismatch (data may be tampered or key is wrong).');
        return false;
    }

    return $plaintext;
}


// ---------------------------------------------------------------------
// 2. 暗号化/複合化をフックに統合
// ---------------------------------------------------------------------

/**
 * カスタムフィールドの保存時に暗号化を実行する。
 * @param null|bool $check 権限チェックの結果 (未使用)
 * @param mixed $meta_id メタデータID (未使用)
 * @param string $meta_key メタキー名
 * @param mixed $meta_value 保存される値
 * @param mixed $prev_value 以前の値 (未使用)
 * @return mixed 処理後の値
 */
function ma_hook_encrypt_on_save($check, $meta_id, $meta_key, $meta_value, $prev_value) {
    // 暗号化対象のメタキーかチェック
    if ( in_array($meta_key, MA_ENCRYPTED_META_KEYS) ) {
        if ( is_array($meta_value) ) {
            // 配列/オブジェクトの場合、JSONエンコードしてから暗号化
            $meta_value = json_encode($meta_value);
        }

        // 値が空の場合は暗号化せずそのまま返す
        if ( empty($meta_value) ) {
            return $meta_value;
        }

        $encrypted_value = ma_encrypt_data((string) $meta_value);
        if ($encrypted_value !== false) {
            // 暗号化された値をDBに保存させるために返す
            return $encrypted_value;
        }
        
        // 暗号化失敗時は元の値を保存しない（データ破損を防ぐため）
        return false; 
    }
    return $meta_value;
}
add_filter('update_post_metadata', 'ma_hook_encrypt_on_save', 10, 5);


/**
 * カスタムフィールドの取得時に複合化を実行する。
 * 複合化前にユーザーの権限をチェックする。
 * @param null|array|string $check 権限チェックの結果、または値
 * @param int $object_id 投稿ID
 * @param string $meta_key メタキー名
 * @param bool $single 単一値取得か
 * @return mixed 処理後の値
 */
function ma_hook_decrypt_on_get($check, $object_id, $meta_key, $single) {
    // 暗号化対象のメタキーかチェック
    if ( in_array($meta_key, MA_ENCRYPTED_META_KEYS) ) {
        // 1. 複合化の権限チェック: 'view_sensitive_data'を持っているか
        if ( ! current_user_can('view_sensitive_data') ) {
            // 権限がない場合、複合化せず空の値を返す（またはマスキングされた値を返す）
            return $single ? '' : ['']; 
        }

        // 2. DBから暗号文を取得 (再帰防止のためフックを一時的に解除)
        remove_filter('get_post_metadata', 'ma_hook_decrypt_on_get', 10);
        $encrypted_data = get