# main_hybrid_fix.py
"""
ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹è‡ªå¾‹ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  - ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«
æ—¢å­˜ã®MATaskExecutorã¨çµ±åˆ
"""
import sys
from pathlib import Path

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))
import asyncio
import logging
import sys
from typing import Optional, Dict, Any
from pathlib import Path

# æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from task_executor.task_executor_ma import MATaskExecutor
from command_monitor_agent import CommandMonitorAgent
from browser_ai_chat_agent import AIChatAgent
from browser_controller import BrowserController

# æ–°ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from fix_agents.hybrid_fix_orchestrator import HybridFixOrchestrator, FixStrategy
from fix_agents.cloud_fix_agent import CloudFixAgent
from fix_agents.error_classifier import ErrorClassifier
from fix_agents.fix_agent import BaseFixAgent
from wordpress.wp_tester_agent import WPTesterAgent
from github_agent import GitHubAgent
from fix_agents.patch_manager import PatchManager
from cloud_storage_manager import CloudStorageManager

# ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
from .data_models.data_models import BugFixTask, ErrorContextModel, ErrorSeverity, ErrorCategory

# è¨­å®š
from config_hybrid import HybridFixConfig

logger = logging.getLogger(__name__)


class HybridFixSystem:
    """
    ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚¯ãƒ©ã‚¹
    
    æ—¢å­˜ã®MATaskExecutorã¨æ–°ã—ã„è‡ªå¾‹ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã‚’çµ±åˆ
    """
    
    def __init__(
        self,
        config: Optional[HybridFixConfig] = None,
        ma_task_executor: Optional[MATaskExecutor] = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            config: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£è¨­å®š
            ma_task_executor: æ—¢å­˜ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
        """
        self.config = config or HybridFixConfig()
        self.ma_executor = ma_task_executor
        
        # å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        self.cmd_monitor = None
        self.browser_controller = None
        self.ai_chat_agent = None
        
        self.local_agent = None
        self.cloud_agent = None
        self.orchestrator = None
        self.wp_tester = None
        self.github_agent = None
        self.patch_manager = None
        self.storage_manager = None
        
        # çµ±è¨ˆæƒ…å ±
        self.system_stats = {
            "start_time": None,
            "total_errors_detected": 0,
            "auto_fixed_errors": 0,
            "manual_intervention_required": 0
        }
        
        logger.info("ğŸš€ HybridFixSystem åˆæœŸåŒ–é–‹å§‹")
    
    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–"""
        try:
            logger.info("=" * 80)
            logger.info("ğŸ”§ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  åˆæœŸåŒ–")
            logger.info("=" * 80)
            
            # 1. æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å–å¾—
            if self.ma_executor:
                self.cmd_monitor = getattr(self.ma_executor, 'cmd_monitor', None)
                self.browser_controller = getattr(self.ma_executor, 'browser_controller', None)
            
            # CommandMonitorãŒãªã„å ´åˆã¯æ–°è¦ä½œæˆ
            if not self.cmd_monitor:
                self.cmd_monitor = None  # CommandMonitorAgent() requires arguments
                logger.info("âœ… CommandMonitorAgent æ–°è¦ä½œæˆ")
            
            # 2. ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
            self.storage_manager = CloudStorageManager(
                provider=self.config.storage_provider,
                bucket_name=self.config.storage_bucket,
                auto_sync=self.config.auto_sync_storage
            )
            logger.info(f"âœ… CloudStorageManager åˆæœŸåŒ–å®Œäº† (provider={self.config.storage_provider})")
            
            # 3. ãƒ‘ãƒƒãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
            self.patch_manager = PatchManager(
                backup_dir=self.config.backup_dir,
                max_backups=self.config.max_backups
            )
            logger.info("âœ… PatchManager åˆæœŸåŒ–å®Œäº†")
            
            # 4. ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            if self.config.enable_auto_tests:
                self.wp_tester = WPTesterAgent(
                    command_monitor=self.cmd_monitor,
                    wp_path=self.config.wp_path
                )
                logger.info("âœ… WPTesterAgent åˆæœŸåŒ–å®Œäº†")
            
            # 5. GitHubã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            if self.config.enable_auto_pr:
                self.github_agent = GitHubAgent(
                    repo_path=self.config.repo_path,
                    repo_owner=self.config.repo_owner,
                    repo_name=self.config.repo_name
                )
                logger.info("âœ… GitHubAgent åˆæœŸåŒ–å®Œäº†")
            
            # 6. AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«AIç”¨ï¼‰
            if self.browser_controller:
                self.ai_chat_agent = getattr(
                    self.browser_controller, 
                    'ai_chat', 
                    None
                )
            
            # 7. ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            self.local_agent = LocalFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                use_local_ai=self.config.use_local_ai,
                ai_chat_agent=self.ai_chat_agent
            )
            logger.info("âœ… LocalFixAgent åˆæœŸåŒ–å®Œäº†")
            
            # 8. ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            self.cloud_agent = CloudFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                api_provider=self.config.cloud_provider,
                model_name=self.config.cloud_model
            )
            logger.info(f"âœ… CloudFixAgent åˆæœŸåŒ–å®Œäº† (provider={self.config.cloud_provider})")
            
            # 9. ã‚¨ãƒ©ãƒ¼åˆ†é¡å™¨åˆæœŸåŒ–
            error_classifier = ErrorClassifier()
            logger.info("âœ… ErrorClassifier åˆæœŸåŒ–å®Œäº†")
            
            # 10. ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼åˆæœŸåŒ–
            self.orchestrator = HybridFixOrchestrator(
                local_agent=self.local_agent,
                cloud_agent=self.cloud_agent,
                error_classifier=error_classifier,
                default_strategy=FixStrategy[self.config.default_strategy]
            )
            logger.info(f"âœ… HybridFixOrchestrator åˆæœŸåŒ–å®Œäº† (æˆ¦ç•¥={self.config.default_strategy})")
            
            # ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•æ™‚åˆ»ã‚’è¨˜éŒ²
            from datetime import datetime
            self.system_stats["start_time"] = datetime.now()
            
            logger.info("=" * 80)
            logger.info("âœ… ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  åˆæœŸåŒ–å®Œäº†")
            logger.info("=" * 80)
            
            return True
            
        except Exception as e:
            logger.error(f"ğŸ’¥ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return False
    
    async def handle_error(
        self,
        error: Exception,
        task_id: str,
        file_path: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã—ã¦è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œ
        
        Args:
            error: ç™ºç”Ÿã—ãŸä¾‹å¤–
            task_id: ã‚¿ã‚¹ã‚¯ID
            file_path: ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿãƒ•ã‚¡ã‚¤ãƒ«
            context: è¿½åŠ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: å‡¦ç†çµæœ
        """
        try:
            self.system_stats["total_errors_detected"] += 1
            
            logger.info("=" * 80)
            logger.info(f"ğŸ” ã‚¨ãƒ©ãƒ¼æ¤œå‡º: {task_id}")
            logger.info(f"   ã‚¿ã‚¤ãƒ—: {type(error).__name__}")
            logger.info(f"   ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {str(error)}")
            logger.info("=" * 80)
            
            # 1. ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ
            error_context = self._create_error_context(
                error,
                file_path,
                context
            )
            
            # 2. ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
            bug_fix_task = BugFixTask(
                task_id=f"{task_id}-AutoFix",
                error_context=error_context,
                target_files=[file_path],
                priority=self._calculate_priority(error_context),
                run_tests=self.config.enable_auto_tests,
                create_pr=self.config.enable_auto_pr
            )
            
            logger.info(f"ğŸ“‹ ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ä½œæˆ: {bug_fix_task.task_id}")
            logger.info(f"   å„ªå…ˆåº¦: {bug_fix_task.priority}")
            logger.info(f"   æ·±åˆ»åº¦: {error_context.severity.value}")
            
            # 3. è‡ªå‹•ä¿®æ­£ã‚’å®Ÿè¡Œ
            fix_result = await self.orchestrator.execute_fix_task(bug_fix_task)
            
            # 4. çµæœã‚’è¨˜éŒ²
            if fix_result.success:
                self.system_stats["auto_fixed_errors"] += 1
                logger.info(f"âœ… è‡ªå‹•ä¿®æ­£æˆåŠŸ: {bug_fix_task.task_id}")
                
                # GitHub PRä½œæˆï¼ˆæœ‰åŠ¹ãªå ´åˆï¼‰
                if self.config.enable_auto_pr and self.github_agent:
                    await self._create_fix_pr(bug_fix_task, fix_result)
            
            else:
                self.system_stats["manual_intervention_required"] += 1
                logger.warning(f"âš ï¸ è‡ªå‹•ä¿®æ­£å¤±æ•—ï¼ˆæ‰‹å‹•ä»‹å…¥ãŒå¿…è¦ï¼‰: {bug_fix_task.task_id}")
            
            return {
                "success": fix_result.success,
                "task_id": bug_fix_task.task_id,
                "fix_result": fix_result,
                "requires_manual_intervention": not fix_result.success
            }
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚¨ãƒ©ãƒ¼å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.system_stats["manual_intervention_required"] += 1
            
            return {
                "success": False,
                "error": str(e),
                "requires_manual_intervention": True
            }
    
    def _create_error_context(
        self,
        error: Exception,
        file_path: str,
        context: Optional[Dict[str, Any]]
    ) -> ErrorContextModel:
        """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ"""
        import traceback
        import inspect
        
        # ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’å–å¾—
        tb = traceback.extract_tb(error.__traceback__)
        
        # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿè¡Œç•ªå·
        line_number = None
        if tb:
            line_number = tb[-1].lineno
        
        # å‘¨è¾ºã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
        surrounding_code = None
        try:
            if Path(file_path).exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    if line_number:
                        start = max(0, line_number - 6)
                        end = min(len(lines), line_number + 5)
                        surrounding_code = ''.join(lines[start:end])
        except:
            pass
        
        # ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªã‚’æ¨å®š
        error_category = self._infer_error_category(error)
        
        # æ·±åˆ»åº¦ã‚’æ¨å®š
        severity = self._infer_severity(error, error_category)
        
        return ErrorContextModel(
            error_type=type(error).__name__,
            error_message=str(error),
            severity=severity,
            error_category=error_category,
            file_path=file_path,
            line_number=line_number,
            full_traceback=traceback.format_exc(),
            surrounding_code=surrounding_code,
            context_info=context or {}
        )
    
    def _infer_error_category(self, error: Exception) -> ErrorCategory:
        """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªã‚’æ¨å®š"""
        error_type = type(error).__name__
        
        if "Import" in error_type or "Module" in error_type:
            return ErrorCategory.IMPORT
        elif "Syntax" in error_type or "Indent" in error_type:
            return ErrorCategory.SYNTAX
        elif error_type in ["AttributeError", "NameError", "TypeError", "KeyError"]:
            return ErrorCategory.RUNTIME
        elif "Recursion" in error_type or "Memory" in error_type:
            return ErrorCategory.PERFORMANCE
        else:
            return ErrorCategory.UNKNOWN
    
    def _infer_severity(
        self,
        error: Exception,
        category: ErrorCategory
    ) -> ErrorSeverity:
        """æ·±åˆ»åº¦ã‚’æ¨å®š"""
        error_type = type(error).__name__
        
        # è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼
        if error_type in ["MemoryError", "RecursionError", "SystemError"]:
            return ErrorSeverity.CRITICAL
        
        # é«˜å„ªå…ˆåº¦
        if category == ErrorCategory.LOGIC or "Runtime" in error_type:
            return ErrorSeverity.HIGH
        
        # ä¸­å„ªå…ˆåº¦
        if category in [ErrorCategory.RUNTIME, ErrorCategory.IMPORT]:
            return ErrorSeverity.MEDIUM
        
        # ä½å„ªå…ˆåº¦
        return ErrorSeverity.LOW
    
    def _calculate_priority(self, error_context: ErrorContextModel) -> int:
        """å„ªå…ˆåº¦ã‚’è¨ˆç®—ï¼ˆ1-10ï¼‰"""
        severity_scores = {
            ErrorSeverity.CRITICAL: 10,
            ErrorSeverity.HIGH: 8,
            ErrorSeverity.MEDIUM: 5,
            ErrorSeverity.LOW: 3
        }
        
        return severity_scores.get(error_context.severity, 5)
    
    async def _create_fix_pr(
        self,
        bug_fix_task: BugFixTask,
        fix_result
    ):
        """ä¿®æ­£ã®PRã‚’ä½œæˆ"""
        try:
            if not self.github_agent:
                return
            
            logger.info("ğŸŒ¿ GitHub PRä½œæˆé–‹å§‹")
            
            pr_result = await self.github_agent.create_full_fix_workflow(
                task_id=bug_fix_task.task_id,
                modified_files=fix_result.modified_files,
                fix_description=fix_result.reasoning or "Automated bug fix"
            )
            
            if pr_result["success"]:
                logger.info(f"âœ… PRä½œæˆæˆåŠŸ: {pr_result['pr_url']}")
                fix_result.pr_url = pr_result["pr_url"]
            else:
                logger.warning(f"âš ï¸ PRä½œæˆå¤±æ•—: {pr_result.get('error')}")
                
        except Exception as e:
            logger.error(f"âŒ PRä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
    
    def get_system_stats(self) -> Dict[str, Any]:
        """ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã‚’å–å¾—"""
        from datetime import datetime
        
        uptime = 0.0
        if self.system_stats["start_time"]:
            uptime = (datetime.now() - self.system_stats["start_time"]).total_seconds()
        
        auto_fix_rate = 0.0
        if self.system_stats["total_errors_detected"] > 0:
            auto_fix_rate = (
                self.system_stats["auto_fixed_errors"] / 
                self.system_stats["total_errors_detected"]
            )
        
        return {
            **self.system_stats,
            "uptime_seconds": uptime,
            "auto_fix_rate": auto_fix_rate,
            "orchestrator_stats": self.orchestrator.get_stats() if self.orchestrator else {},
            "local_agent_stats": self.local_agent.get_stats() if self.local_agent else {},
            "cloud_agent_stats": self.cloud_agent.get_stats() if self.cloud_agent else {}
        }
    
    def print_system_stats(self):
        """ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã‚’è¡¨ç¤º"""
        stats = self.get_system_stats()
        
        print("\n" + "=" * 80)
        print("ğŸ“Š ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  çµ±è¨ˆæƒ…å ±")
        print("=" * 80)
        print(f"ç¨¼åƒæ™‚é–“: {stats['uptime_seconds'] / 3600:.1f}æ™‚é–“")
        print(f"\næ¤œå‡ºã‚¨ãƒ©ãƒ¼ç·æ•°: {stats['total_errors_detected']}")
        print(f"è‡ªå‹•ä¿®æ­£æˆåŠŸ: {stats['auto_fixed_errors']}")
        print(f"æ‰‹å‹•ä»‹å…¥å¿…è¦: {stats['manual_intervention_required']}")
        print(f"è‡ªå‹•ä¿®æ­£ç‡: {stats['auto_fix_rate']:.1%}")
        
        if self.orchestrator:
            print("\n" + "-" * 80)
            self.orchestrator.print_stats()
        
        print("=" * 80 + "\n")


async def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    
    # ãƒ­ã‚°è¨­å®š
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # è¨­å®šèª­ã¿è¾¼ã¿
    config = HybridFixConfig()
    
    # ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
    system = HybridFixSystem(config=config)
    
    success = await system.initialize()
    
    if not success:
        logger.error("âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—")
        return 1
    
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    logger.info("\nğŸ§ª ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿæˆã—ã¦è‡ªå‹•ä¿®æ­£ã‚’ãƒ†ã‚¹ãƒˆ")
    
    try:
        # æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹
        test_data = None
        result = test_data.get('key')  # AttributeError
    
    except Exception as e:
        # ã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã«é€ä¿¡
        handle_result = await system.handle_error(
            error=e,
            task_id="Test-AutoFix-Demo",
            file_path="main_hybrid_fix.py",
            context={"test": True}
        )
        
        logger.info(f"\nå‡¦ç†çµæœ: {handle_result}")
    
    # ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆè¡¨ç¤º
    system.print_system_stats()
    
    return 0


if __name__ == "__main__":
    # Windowsç’°å¢ƒå¯¾å¿œ
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    # å®Ÿè¡Œ
    exit_code = asyncio.run(main())
    sys.exit(exit_code)