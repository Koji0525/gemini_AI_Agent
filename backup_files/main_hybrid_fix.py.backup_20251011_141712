# main_hybrid_fix.py
"""
ハイブリッド型自律コード修正システム - メイン実行ファイル
既存のMATaskExecutorと統合
"""
import sys
from pathlib import Path

# プロジェクトルートをパスに追加
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))
import asyncio
import logging
import sys
from typing import Optional, Dict, Any
from pathlib import Path

# 既存システムのインポート
from task_executor.task_executor_ma import MATaskExecutor
from command_monitor_agent import CommandMonitorAgent
from browser_ai_chat_agent import AIChatAgent
from browser_controller import BrowserController

# 新システムのインポート
from fix_agents.hybrid_fix_orchestrator import HybridFixOrchestrator, FixStrategy
from fix_agents.cloud_fix_agent import CloudFixAgent
from fix_agents.error_classifier import ErrorClassifier
from fix_agents.fix_agent import BaseFixAgent
from wordpress.wp_tester_agent import WPTesterAgent
from github_agent import GitHubAgent
from fix_agents.patch_manager import PatchManager
from cloud_storage_manager import CloudStorageManager

# データモデル
from .data_models.data_models import BugFixTask, ErrorContextModel, ErrorSeverity, ErrorCategory

# 設定
from config_hybrid import HybridFixConfig

logger = logging.getLogger(__name__)


class HybridFixSystem:
    """
    ハイブリッド修正システムの統合クラス
    
    既存のMATaskExecutorと新しい自律修正システムを統合
    """
    
    def __init__(
        self,
        config: Optional[HybridFixConfig] = None,
        ma_task_executor: Optional[MATaskExecutor] = None
    ):
        """
        初期化
        
        Args:
            config: ハイブリッド修正設定
            ma_task_executor: 既存のタスク実行エンジン
        """
        self.config = config or HybridFixConfig()
        self.ma_executor = ma_task_executor
        
        # 各エージェントの初期化
        self.cmd_monitor = None
        self.browser_controller = None
        self.ai_chat_agent = None
        
        self.local_agent = None
        self.cloud_agent = None
        self.orchestrator = None
        self.wp_tester = None
        self.github_agent = None
        self.patch_manager = None
        self.storage_manager = None
        
        # 統計情報
        self.system_stats = {
            "start_time": None,
            "total_errors_detected": 0,
            "auto_fixed_errors": 0,
            "manual_intervention_required": 0
        }
        
        logger.info("🚀 HybridFixSystem 初期化開始")
    
    async def initialize(self):
        """システムを初期化"""
        try:
            logger.info("=" * 80)
            logger.info("🔧 ハイブリッド修正システム 初期化")
            logger.info("=" * 80)
            
            # 1. 既存システムのコンポーネントを取得
            if self.ma_executor:
                self.cmd_monitor = getattr(self.ma_executor, 'cmd_monitor', None)
                self.browser_controller = getattr(self.ma_executor, 'browser_controller', None)
            
            # CommandMonitorがない場合は新規作成
            if not self.cmd_monitor:
                self.cmd_monitor = None  # CommandMonitorAgent() requires arguments
                logger.info("✅ CommandMonitorAgent 新規作成")
            
            # 2. ストレージマネージャー初期化
            self.storage_manager = CloudStorageManager(
                provider=self.config.storage_provider,
                bucket_name=self.config.storage_bucket,
                auto_sync=self.config.auto_sync_storage
            )
            logger.info(f"✅ CloudStorageManager 初期化完了 (provider={self.config.storage_provider})")
            
            # 3. パッチマネージャー初期化
            self.patch_manager = PatchManager(
                backup_dir=self.config.backup_dir,
                max_backups=self.config.max_backups
            )
            logger.info("✅ PatchManager 初期化完了")
            
            # 4. テスターエージェント初期化
            if self.config.enable_auto_tests:
                self.wp_tester = WPTesterAgent(
                    command_monitor=self.cmd_monitor,
                    wp_path=self.config.wp_path
                )
                logger.info("✅ WPTesterAgent 初期化完了")
            
            # 5. GitHubエージェント初期化
            if self.config.enable_auto_pr:
                self.github_agent = GitHubAgent(
                    repo_path=self.config.repo_path,
                    repo_owner=self.config.repo_owner,
                    repo_name=self.config.repo_name
                )
                logger.info("✅ GitHubAgent 初期化完了")
            
            # 6. AIチャットエージェント取得（ローカルAI用）
            if self.browser_controller:
                self.ai_chat_agent = getattr(
                    self.browser_controller, 
                    'ai_chat', 
                    None
                )
            
            # 7. ローカル修正エージェント初期化
            self.local_agent = LocalFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                use_local_ai=self.config.use_local_ai,
                ai_chat_agent=self.ai_chat_agent
            )
            logger.info("✅ LocalFixAgent 初期化完了")
            
            # 8. クラウド修正エージェント初期化
            self.cloud_agent = CloudFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                api_provider=self.config.cloud_provider,
                model_name=self.config.cloud_model
            )
            logger.info(f"✅ CloudFixAgent 初期化完了 (provider={self.config.cloud_provider})")
            
            # 9. エラー分類器初期化
            error_classifier = ErrorClassifier()
            logger.info("✅ ErrorClassifier 初期化完了")
            
            # 10. オーケストレーター初期化
            self.orchestrator = HybridFixOrchestrator(
                local_agent=self.local_agent,
                cloud_agent=self.cloud_agent,
                error_classifier=error_classifier,
                default_strategy=FixStrategy[self.config.default_strategy]
            )
            logger.info(f"✅ HybridFixOrchestrator 初期化完了 (戦略={self.config.default_strategy})")
            
            # システム起動時刻を記録
            from datetime import datetime
            self.system_stats["start_time"] = datetime.now()
            
            logger.info("=" * 80)
            logger.info("✅ ハイブリッド修正システム 初期化完了")
            logger.info("=" * 80)
            
            return True
            
        except Exception as e:
            logger.error(f"💥 初期化エラー: {e}", exc_info=True)
            return False
    
    async def handle_error(
        self,
        error: Exception,
        task_id: str,
        file_path: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        エラーを処理して自動修正を試行
        
        Args:
            error: 発生した例外
            task_id: タスクID
            file_path: エラー発生ファイル
            context: 追加コンテキスト
            
        Returns:
            Dict: 処理結果
        """
        try:
            self.system_stats["total_errors_detected"] += 1
            
            logger.info("=" * 80)
            logger.info(f"🔍 エラー検出: {task_id}")
            logger.info(f"   タイプ: {type(error).__name__}")
            logger.info(f"   メッセージ: {str(error)}")
            logger.info("=" * 80)
            
            # 1. エラーコンテキストを作成
            error_context = self._create_error_context(
                error,
                file_path,
                context
            )
            
            # 2. バグ修正タスクを作成
            bug_fix_task = BugFixTask(
                task_id=f"{task_id}-AutoFix",
                error_context=error_context,
                target_files=[file_path],
                priority=self._calculate_priority(error_context),
                run_tests=self.config.enable_auto_tests,
                create_pr=self.config.enable_auto_pr
            )
            
            logger.info(f"📋 バグ修正タスク作成: {bug_fix_task.task_id}")
            logger.info(f"   優先度: {bug_fix_task.priority}")
            logger.info(f"   深刻度: {error_context.severity.value}")
            
            # 3. 自動修正を実行
            fix_result = await self.orchestrator.execute_fix_task(bug_fix_task)
            
            # 4. 結果を記録
            if fix_result.success:
                self.system_stats["auto_fixed_errors"] += 1
                logger.info(f"✅ 自動修正成功: {bug_fix_task.task_id}")
                
                # GitHub PR作成（有効な場合）
                if self.config.enable_auto_pr and self.github_agent:
                    await self._create_fix_pr(bug_fix_task, fix_result)
            
            else:
                self.system_stats["manual_intervention_required"] += 1
                logger.warning(f"⚠️ 自動修正失敗（手動介入が必要）: {bug_fix_task.task_id}")
            
            return {
                "success": fix_result.success,
                "task_id": bug_fix_task.task_id,
                "fix_result": fix_result,
                "requires_manual_intervention": not fix_result.success
            }
            
        except Exception as e:
            logger.error(f"💥 エラー処理中にエラー: {e}", exc_info=True)
            self.system_stats["manual_intervention_required"] += 1
            
            return {
                "success": False,
                "error": str(e),
                "requires_manual_intervention": True
            }
    
    def _create_error_context(
        self,
        error: Exception,
        file_path: str,
        context: Optional[Dict[str, Any]]
    ) -> ErrorContextModel:
        """エラーコンテキストを作成"""
        import traceback
        import inspect
        
        # スタックトレースを取得
        tb = traceback.extract_tb(error.__traceback__)
        
        # エラー発生行番号
        line_number = None
        if tb:
            line_number = tb[-1].lineno
        
        # 周辺コードを取得（可能な場合）
        surrounding_code = None
        try:
            if Path(file_path).exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    if line_number:
                        start = max(0, line_number - 6)
                        end = min(len(lines), line_number + 5)
                        surrounding_code = ''.join(lines[start:end])
        except:
            pass
        
        # エラーカテゴリを推定
        error_category = self._infer_error_category(error)
        
        # 深刻度を推定
        severity = self._infer_severity(error, error_category)
        
        return ErrorContextModel(
            error_type=type(error).__name__,
            error_message=str(error),
            severity=severity,
            error_category=error_category,
            file_path=file_path,
            line_number=line_number,
            full_traceback=traceback.format_exc(),
            surrounding_code=surrounding_code,
            context_info=context or {}
        )
    
    def _infer_error_category(self, error: Exception) -> ErrorCategory:
        """エラーカテゴリを推定"""
        error_type = type(error).__name__
        
        if "Import" in error_type or "Module" in error_type:
            return ErrorCategory.IMPORT
        elif "Syntax" in error_type or "Indent" in error_type:
            return ErrorCategory.SYNTAX
        elif error_type in ["AttributeError", "NameError", "TypeError", "KeyError"]:
            return ErrorCategory.RUNTIME
        elif "Recursion" in error_type or "Memory" in error_type:
            return ErrorCategory.PERFORMANCE
        else:
            return ErrorCategory.UNKNOWN
    
    def _infer_severity(
        self,
        error: Exception,
        category: ErrorCategory
    ) -> ErrorSeverity:
        """深刻度を推定"""
        error_type = type(error).__name__
        
        # 致命的なエラー
        if error_type in ["MemoryError", "RecursionError", "SystemError"]:
            return ErrorSeverity.CRITICAL
        
        # 高優先度
        if category == ErrorCategory.LOGIC or "Runtime" in error_type:
            return ErrorSeverity.HIGH
        
        # 中優先度
        if category in [ErrorCategory.RUNTIME, ErrorCategory.IMPORT]:
            return ErrorSeverity.MEDIUM
        
        # 低優先度
        return ErrorSeverity.LOW
    
    def _calculate_priority(self, error_context: ErrorContextModel) -> int:
        """優先度を計算（1-10）"""
        severity_scores = {
            ErrorSeverity.CRITICAL: 10,
            ErrorSeverity.HIGH: 8,
            ErrorSeverity.MEDIUM: 5,
            ErrorSeverity.LOW: 3
        }
        
        return severity_scores.get(error_context.severity, 5)
    
    async def _create_fix_pr(
        self,
        bug_fix_task: BugFixTask,
        fix_result
    ):
        """修正のPRを作成"""
        try:
            if not self.github_agent:
                return
            
            logger.info("🌿 GitHub PR作成開始")
            
            pr_result = await self.github_agent.create_full_fix_workflow(
                task_id=bug_fix_task.task_id,
                modified_files=fix_result.modified_files,
                fix_description=fix_result.reasoning or "Automated bug fix"
            )
            
            if pr_result["success"]:
                logger.info(f"✅ PR作成成功: {pr_result['pr_url']}")
                fix_result.pr_url = pr_result["pr_url"]
            else:
                logger.warning(f"⚠️ PR作成失敗: {pr_result.get('error')}")
                
        except Exception as e:
            logger.error(f"❌ PR作成エラー: {e}")
    
    def get_system_stats(self) -> Dict[str, Any]:
        """システム統計を取得"""
        from datetime import datetime
        
        uptime = 0.0
        if self.system_stats["start_time"]:
            uptime = (datetime.now() - self.system_stats["start_time"]).total_seconds()
        
        auto_fix_rate = 0.0
        if self.system_stats["total_errors_detected"] > 0:
            auto_fix_rate = (
                self.system_stats["auto_fixed_errors"] / 
                self.system_stats["total_errors_detected"]
            )
        
        return {
            **self.system_stats,
            "uptime_seconds": uptime,
            "auto_fix_rate": auto_fix_rate,
            "orchestrator_stats": self.orchestrator.get_stats() if self.orchestrator else {},
            "local_agent_stats": self.local_agent.get_stats() if self.local_agent else {},
            "cloud_agent_stats": self.cloud_agent.get_stats() if self.cloud_agent else {}
        }
    
    def print_system_stats(self):
        """システム統計を表示"""
        stats = self.get_system_stats()
        
        print("\n" + "=" * 80)
        print("📊 ハイブリッド修正システム 統計情報")
        print("=" * 80)
        print(f"稼働時間: {stats['uptime_seconds'] / 3600:.1f}時間")
        print(f"\n検出エラー総数: {stats['total_errors_detected']}")
        print(f"自動修正成功: {stats['auto_fixed_errors']}")
        print(f"手動介入必要: {stats['manual_intervention_required']}")
        print(f"自動修正率: {stats['auto_fix_rate']:.1%}")
        
        if self.orchestrator:
            print("\n" + "-" * 80)
            self.orchestrator.print_stats()
        
        print("=" * 80 + "\n")


async def main():
    """メイン実行関数"""
    
    # ログ設定
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 設定読み込み
    config = HybridFixConfig()
    
    # システム初期化
    system = HybridFixSystem(config=config)
    
    success = await system.initialize()
    
    if not success:
        logger.error("❌ システム初期化失敗")
        return 1
    
    # テスト実行
    logger.info("\n🧪 テストエラーを生成して自動修正をテスト")
    
    try:
        # 意図的にエラーを発生させる
        test_data = None
        result = test_data.get('key')  # AttributeError
    
    except Exception as e:
        # エラーを自動修正システムに送信
        handle_result = await system.handle_error(
            error=e,
            task_id="Test-AutoFix-Demo",
            file_path="main_hybrid_fix.py",
            context={"test": True}
        )
        
        logger.info(f"\n処理結果: {handle_result}")
    
    # システム統計表示
    system.print_system_stats()
    
    return 0


if __name__ == "__main__":
    # Windows環境対応
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    # 実行
    exit_code = asyncio.run(main())
    sys.exit(exit_code)