# review_agent.py
"""ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from configuration.config_utils import ErrorHandler
from browser_control.browser_controller import BrowserController
from tools.sheets_manager import GoogleSheetsManager
from core_agents.review_agent_prompts import REVIEW_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class ReviewAgent:
    """ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
    
    def __init__(self, browser_controller=None, browser=None, output_folder: Path = None):
        """
        ReviewAgentåˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆäº’æ›æ€§ç”¨ï¼‰
            output_folder: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹
        """
        # ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šï¼ˆbrowser_controllerå„ªå…ˆï¼‰
        if browser_controller is not None:
            self.browser = browser_controller
        elif browser is not None:
            self.browser = browser
        else:
        
        # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š
        if output_folder:
            self.output_folder = Path(output_folder)
        else:
            self.output_folder = Path("agent_outputs/review")
        
        self.output_folder.mkdir(parents=True, exist_ok=True)
        self.system_prompt = REVIEW_SYSTEM_PROMPT

    async def process_task(self, task: Dict) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰"""
        return await self.review_completed_task(task, task.get('output_content', ''))

    async def review_completed_task(self, task: Dict, output_content: str) -> Dict:
        """å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå¤±æ•—åŸå› åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹å‡¦ç† ===
            logger.info("="*60)
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¹ã‚¯ {task['task_id']} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹")
            logger.info("="*60)
            
            # ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç¢ºèª
            task_status = task.get('status', 'unknown')
            is_failed_task = task_status in ['failed', 'error', 'timeout']
            
            # äº‹å‰ãƒã‚§ãƒƒã‚¯ï¼šå‡ºåŠ›å†…å®¹ã®æ§‹é€ ã‚’æ¤œè¨¼
            pre_check_result = self._pre_check_content(output_content, task['required_role'])
            if pre_check_result:
                logger.info(f"äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœ: {pre_check_result}")
            
            # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’å–å¾—
            error_info = task.get('error', '')
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰ã¨Geminié€ä¿¡ ===
            full_prompt = self._build_review_prompt(
                task, task_status, is_failed_task, 
                output_content, error_info, pre_check_result
            )
            
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’Geminiã«ä¾é ¼ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
                return self._create_default_review(task, is_failed_task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: å¿œç­”å–å¾—ã¨çµæœè§£æ ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
            
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            review_result = self._parse_review_json(response_text)
            
            if review_result:
                # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
                validated_review = self._validate_review_result(review_result, output_content)
                self._display_review_summary(validated_review, is_failed_task)
                return {
                    'success': True,
                    'review': validated_review,
                    'summary': validated_review.get('evaluation', {}).get('overall_assessment', ''),
                    'full_text': response_text
                }
            else:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONè§£æã«å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ¬ãƒ“ãƒ¥ãƒ¼AIå‡¦ç†")
            return self._create_default_review(task, False)

    def _build_review_prompt(self, task: Dict, task_status: str, is_failed_task: bool,
                           output_content: str, error_info: str, pre_check_result: str) -> str:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰(ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£æƒ…å ±ä»˜ã)"""
    
        # === ğŸ†• æ–°è¦è¿½åŠ : ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£æƒ…å ±ã®æŠ½å‡º ===
        traceability = task.get('_traceability', {})
        executed_by = traceability.get('executed_by_agent', 'ä¸æ˜')
        agent_class = traceability.get('agent_class', 'ä¸æ˜')
    
        return f"""{self.system_prompt}

    ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚¿ã‚¹ã‚¯ã€‘
    ã‚¿ã‚¹ã‚¯ID: {task['task_id']}
    å†…å®¹: {task['description']}
    æ‹…å½“: {task['required_role']}
    ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task_status}
    å‡ºåŠ›æ–‡å­—æ•°: {len(output_content)}æ–‡å­—

    ğŸ†•ã€å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæƒ…å ±ã€‘(åŸå› åˆ‡ã‚Šåˆ†ã‘ç”¨)
    å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {executed_by}
    ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹: {agent_class}
    å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—: {traceability.get('execution_timestamp', 'N/A')}

    ã€ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ã€‘
    {'âŒ ã“ã®ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸ' if is_failed_task else 'âœ… ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã—ã¾ã—ãŸ'}
    {f'ã‚¨ãƒ©ãƒ¼æƒ…å ±: {error_info}' if error_info else ''}

    ã€äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœã€‘
    {pre_check_result if pre_check_result else 'ç‰¹è¨˜äº‹é …ãªã—'}

    ã€ã‚¿ã‚¹ã‚¯ã®å‡ºåŠ›ã€‘
    {output_content[:4000] if output_content else '(å‡ºåŠ›ãªã—)'}

    ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã€æŒ‡å®šã•ã‚ŒãŸJSONå½¢å¼ã§è©•ä¾¡ã¨æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚
    {'ç‰¹ã«å¤±æ•—åŸå› ã‚’è©³ç´°ã«åˆ†æã—ã€é©åˆ‡ãªæ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚' if is_failed_task else 'ç‰¹ã«ã€æ§‹é€ çš„ã«å®Œçµã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’é‡ç‚¹çš„ã«ç¢ºèªã—ã¦ãã ã•ã„ã€‚'}

    ğŸ†•ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã®æ³¨æ„ã€‘
    - ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒé€”ä¸­ã§é€”åˆ‡ã‚Œã¦ã„ã‚‹å ´åˆã¯å¿…ãšæŒ‡æ‘˜ã—ã¦ãã ã•ã„
    - å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ({executed_by})ã®å‡ºåŠ›å“è³ªã«å•é¡ŒãŒã‚ã‚‹å ´åˆã€ãã®æ—¨ã‚’æ˜è¨˜ã—ã¦ãã ã•ã„
    - æ‰‹å‹•ä½œæ¥­ãŒå¿…è¦ãªæ‰‹é †ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€è‡ªå‹•åŒ–ã®ææ¡ˆã‚‚å«ã‚ã¦ãã ã•ã„
    """


    def _pre_check_content(self, content: str, role: str) -> str:
        """å‡ºåŠ›å†…å®¹ã®äº‹å‰ãƒã‚§ãƒƒã‚¯"""
        checks = []
        
        # === ãƒ‘ãƒ¼ãƒˆ1: æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯ ===
        if len(content) < 100:
            checks.append("âš ï¸ æ–‡å­—æ•°ãŒå°‘ãªã™ãã¾ã™ï¼ˆ100æ–‡å­—æœªæº€ï¼‰")
        elif len(content) > 5000:
            checks.append("âœ… æ–‡å­—æ•°ãŒååˆ†ã§ã™")
        
        # === ãƒ‘ãƒ¼ãƒˆ2: è¨˜äº‹ãƒ»æ–‡æ›¸ç³»ã‚¿ã‚¹ã‚¯ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯ ===
        if role in ['writer', 'content', 'wordpress', 'writer_ja', 'writer_en', 'writer_ru']:
            if '<h1' in content or '<h2' in content or '# ' in content:
                checks.append("âœ… è¦‹å‡ºã—æ§‹é€ ãŒã‚ã‚Šã¾ã™")
            
            if any(phrase in content for phrase in ['ã¾ã¨ã‚', 'çµè«–', 'çµ‚ã‚ã‚Š', 'ä»¥ä¸Š', 'æœ€å¾Œã«', 'Conclusion', 'Summary']):
                checks.append("âœ… çµè«–ãƒ»ã¾ã¨ã‚ãŒã‚ã‚Šã¾ã™")
            else:
                checks.append("âš ï¸ æ˜ç¤ºçš„ãªçµè«–ãƒ»ã¾ã¨ã‚ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®é–‰ã˜å¿˜ã‚Œãƒã‚§ãƒƒã‚¯
            if content.count('<div') > content.count('</div'):
                checks.append("âš ï¸ HTMLã®divã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
            if content.count('<p>') > content.count('</p>'):
                checks.append("âš ï¸ HTMLã®pã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚³ãƒ¼ãƒ‰ç³»ã‚¿ã‚¹ã‚¯ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯ ===
        if role in ['dev', 'programming']:
            if 'def ' in content or 'function ' in content or 'class ' in content:
                checks.append("âœ… é–¢æ•°/ã‚¯ãƒ©ã‚¹å®šç¾©ãŒã‚ã‚Šã¾ã™")
            if 'import ' in content or 'require ' in content:
                checks.append("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚Šã¾ã™")
        
        return " | ".join(checks) if checks else "âœ… åŸºæœ¬çš„ãªæ§‹é€ ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“"

    def _validate_review_result(self, review: Dict, original_content: str) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼"""
        evaluation = review.get('evaluation', {})
        next_actions = review.get('next_actions', {})
        
        # === ãƒ‘ãƒ¼ãƒˆ1: ã€Œéƒ¨åˆ†çš„ã€åˆ¤å®šã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ ===
        if evaluation.get('completeness') == 'éƒ¨åˆ†çš„':
            issues = evaluation.get('issues', [])
            new_issues = []
            
            for issue in issues:
                # æ–‡å­—æ•°é–¢é€£ã®æŒ‡æ‘˜ã‚’æ¤œè¨¼
                if any(word in issue for word in ['æ–‡å­—æ•°', 'æ–‡å­—', 'çŸ­ã„', 'å°‘ãªã„']):
                    if len(original_content) > 1000:  # 1000æ–‡å­—ä»¥ä¸Šã‚ã‚Œã°æ–‡å­—æ•°ä¸è¶³ã§ã¯ãªã„
                        continue
                # æ§‹é€ çš„ãªæŒ‡æ‘˜ã‚’æ¤œè¨¼
                elif 'åˆ‡ã‚Œã¦' in issue or 'é€”åˆ‡ã‚Œ' in issue:
                    # å®Ÿéš›ã«æ–‡ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if self._is_content_properly_ended(original_content):
                        continue
                
                new_issues.append(issue)
            
            # å•é¡Œç‚¹ã‚’æ›´æ–°
            evaluation['issues'] = new_issues
            
            # å•é¡Œç‚¹ãŒãªããªã£ãŸå ´åˆã¯ã€Œå®Œäº†ã€ã«å¤‰æ›´
            if not new_issues and len(original_content) > 500:
                evaluation['completeness'] = 'å®Œäº†'
                evaluation['overall_assessment'] = 'å†è©•ä¾¡: å†…å®¹ã¯å®Œçµã—ã¦ãŠã‚Šã€æ–‡å­—æ•°ã‚‚ååˆ†ã§ã™'
                next_actions['required'] = False
                next_actions['suggested_tasks'] = []
        
        return review

    def _is_content_properly_ended(self, content: str) -> bool:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒé©åˆ‡ã«çµ‚äº†ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        # === ãƒ‘ãƒ¼ãƒˆ1: æ–‡ã®çµ‚äº†ãƒã‚§ãƒƒã‚¯ ===
        sentences = re.split(r'[ã€‚ï¼ï¼Ÿ!?\.]', content.strip())
        if sentences and sentences[-1].strip():
            return False  # æœ€å¾Œã®æ–‡ãŒçµ‚äº†è¨˜å·ã§çµ‚ã‚ã£ã¦ã„ãªã„
        
        # === ãƒ‘ãƒ¼ãƒˆ2: HTMLã‚¿ã‚°ã®é–‰ã˜ãƒã‚§ãƒƒã‚¯ ===
        if content.count('<') > 0 and content.count('>') > 0:
            open_tags = len(re.findall(r'<(?!\/)[^>]+>', content))
            close_tags = len(re.findall(r'<\/[^>]+>', content))
            if open_tags != close_tags:
                return False
        
        return True

    def _parse_review_json(self, text: str) -> Optional[Dict]:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONã‚’ãƒ‘ãƒ¼ã‚¹"""
        try:
            import re
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ```json ... ``` å½¢å¼ã®æŠ½å‡º ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡º ===
            json_match = re.search(r'(\{.*\})', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            logger.warning("JSONå½¢å¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None
            
        except json.JSONDecodeError as e:
            logger.error(f"JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def _create_default_review(self, task: Dict, is_failed: bool = False) -> Dict:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœï¼ˆå¤±æ•—æ™‚ï¼‰"""
        if is_failed:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å¤±æ•—',
                        'quality_score': 3,
                        'issues': ['ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ'],
                        'good_points': [],
                        'overall_assessment': 'ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸãŒã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚‚å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ',
                        'failure_analysis': {
                            'is_failed': True,
                            'failure_category': 'ç’°å¢ƒå•é¡Œ',
                            'root_cause': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—',
                            'impact': 'å¤±æ•—åŸå› ã®è©³ç´°ãŒä¸æ˜',
                            'recommended_action': 'immediate_retry',
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': True,
                        'reasoning': 'ã‚¿ã‚¹ã‚¯ã®å†å®Ÿè¡Œã¾ãŸã¯ä¿®æ­£ãŒå¿…è¦',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ã‚¿ã‚¹ã‚¯å¤±æ•—',
                'full_text': ''
            }
        else:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å®Œäº†',
                        'quality_score': 7,
                        'issues': [],
                        'good_points': ['ã‚¿ã‚¹ã‚¯å®Œäº†'],
                        'overall_assessment': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸãŒã€ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã¨ã¿ãªã—ã¾ã™',
                        'failure_analysis': {
                            'is_failed': False,
                            'failure_category': None,
                            'root_cause': None,
                            'impact': None,
                            'recommended_action': None,
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': False,
                        'reasoning': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—ã—ãŸãŸã‚ã€è¿½åŠ ã‚¿ã‚¹ã‚¯ãªã—',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè©•ä¾¡',
                'full_text': ''
            }

    def _display_review_summary(self, review: Dict, is_failed_task: bool = False):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’è¡¨ç¤ºï¼ˆå¤±æ•—åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        
        print("\n" + "ğŸ¯" * 30)
        print("ğŸ“‹ ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ")
        print("ğŸ¯" * 30)
        
        evaluation = review.get('evaluation', {})
        
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬æƒ…å ±è¡¨ç¤º ===
        completeness = evaluation.get('completeness', 'N/A')
        completeness_icon = {
            'å®Œäº†': 'âœ…',
            'éƒ¨åˆ†çš„': 'âš ï¸',
            'ä¸å®Œå…¨': 'âŒ',
            'å¤±æ•—': 'ğŸ’¥'
        }.get(completeness, 'â“')
        
        print(f"\n{completeness_icon} å®Œæˆåº¦: {completeness}")
        print(f"â­ å“è³ªã‚¹ã‚³ã‚¢: {evaluation.get('quality_score', 'N/A')}/10")
        
        # === ãƒ‘ãƒ¼ãƒˆ2: å¤±æ•—åˆ†æè¡¨ç¤º ===
        failure_analysis = evaluation.get('failure_analysis', {})
        if failure_analysis.get('is_failed'):
            print("\n" + "ğŸ’¥" * 30)
            print("ğŸ” å¤±æ•—åŸå› åˆ†æ")
            print("ğŸ’¥" * 30)
            
            category = failure_analysis.get('failure_category', 'N/A')
            category_icon = {
                'è¦ä»¶ä¸æ˜ç­': 'ğŸ“',
                'æŠ€è¡“çš„å•é¡Œ': 'âš™ï¸',
                'ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³': 'ğŸ“¦',
                'ä¾å­˜é–¢ä¿‚': 'ğŸ”—',
                'ç’°å¢ƒå•é¡Œ': 'ğŸŒ',
                'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ': 'â±ï¸',
                'å‡ºåŠ›ä¸å®Œå…¨': 'âœ‚ï¸',
                'å“è³ªä¸è¶³': 'ğŸ“‰'
            }.get(category, 'â“')
            
            print(f"\n{category_icon} å¤±æ•—ã‚«ãƒ†ã‚´ãƒª: {category}")
            print(f"ğŸ” æ ¹æœ¬åŸå› : {failure_analysis.get('root_cause', 'N/A')}")
            print(f"ğŸ’¡ å½±éŸ¿: {failure_analysis.get('impact', 'N/A')}")
            
            action = failure_analysis.get('recommended_action', 'N/A')
            action_map = {
                'immediate_retry': 'ğŸ”„ å³åº§ã«å†å®Ÿè¡Œ',
                'modify_task': 'âœï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¿®æ­£',
                'add_prerequisite': 'â• å‰æã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ',
                'escalate': 'ğŸš¨ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆäººé–“ã®åˆ¤æ–­ãŒå¿…è¦ï¼‰',
                'skip': 'â­ï¸ ã‚¹ã‚­ãƒƒãƒ—ã¾ãŸã¯å¾Œå›ã—'
            }
            print(f"ğŸ“Œ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_map.get(action, action)}")
            
            prereqs = failure_analysis.get('prerequisites', [])
            if prereqs:
                print(f"\nğŸ“‹ å‰ææ¡ä»¶:")
                for prereq in prereqs:
                    print(f"   â€¢ {prereq}")
            
            print("ğŸ’¥" * 30)
        
        # === ãƒ‘ãƒ¼ãƒˆ3: è‰¯ã„ç‚¹ãƒ»å•é¡Œç‚¹è¡¨ç¤º ===
        good_points = evaluation.get('good_points', [])
        if good_points:
            print(f"\nâœ¨ è‰¯ã„ç‚¹:")
            for point in good_points:
                print(f"   âœ… {point}")
        
        issues = evaluation.get('issues', [])
        if issues:
            print(f"\nâš ï¸ å•é¡Œç‚¹:")
            for issue in issues:
                print(f"   âŒ {issue}")
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ç·åˆè©•ä¾¡è¡¨ç¤º ===
        overall = evaluation.get('overall_assessment', '')
        if overall:
            print(f"\nğŸ’ ç·åˆè©•ä¾¡:")
            print(f"   {overall}")
        
        # === ãƒ‘ãƒ¼ãƒˆ5: æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤º ===
        next_actions = review.get('next_actions', {})
        required = next_actions.get('required', False)
        
        action_icon = 'ğŸ”´' if required else 'ğŸŸ¢'
        print(f"\nğŸ¯ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_icon} {'å¿…è¦' if required else 'ä¸è¦'}")
        
        if required:
            reasoning = next_actions.get('reasoning', '')
            if reasoning:
                print(f"   ğŸ“Œ ç†ç”±: {reasoning}")
            
            # ææ¡ˆã‚¿ã‚¹ã‚¯
            suggested_tasks = next_actions.get('suggested_tasks', [])
            if suggested_tasks:
                print(f"\nğŸš€ ææ¡ˆã‚¿ã‚¹ã‚¯ ({len(suggested_tasks)}ä»¶):")
                for i, task in enumerate(suggested_tasks, 1):
                    priority_icon = {
                        'high': 'ğŸ”´',
                        'medium': 'ğŸŸ¡',
                        'low': 'ğŸŸ¢'
                    }.get(task.get('priority', 'medium'), 'âšª')
                    
                    role_icon = {
                        'design': 'ğŸ“',
                        'dev': 'ğŸ’»',
                        'ui': 'ğŸ¨',
                        'review': 'âœ…',
                        'wordpress': 'ğŸŒ',
                        'content': 'âœï¸',
                        'writer': 'ğŸ“',
                        'writer_ja': 'ğŸ—¾',
                        'writer_en': 'ğŸ” ',
                        'writer_ru': 'ğŸ‡·ğŸ‡º'
                    }.get(task.get('required_role', 'dev'), 'ğŸ“‹')
                    
                    print(f"   {i}. {priority_icon} {role_icon} {task.get('description', 'N/A')}")
                    
                    deps = task.get('dependencies', [])
                    if deps:
                        print(f"      ğŸ“ ä¾å­˜: {', '.join(map(str, deps))}")
        
        print("ğŸ¯" * 30 + "\n")

    async def add_suggested_tasks_to_sheet(self, parent_task_id: str, suggested_tasks: List[Dict]) -> int:
        """ææ¡ˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’pm_tasksã‚·ãƒ¼ãƒˆã«è¿½åŠ ï¼ˆæ­£ã—ã„åˆ—é…ç½®ç‰ˆï¼‰"""
        try:
            if not suggested_tasks:
                return 0
            
            logger.info(f"ææ¡ˆã‚¿ã‚¹ã‚¯ {len(suggested_tasks)} ä»¶ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«è¿½åŠ ä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæº–å‚™ ===
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            task_sheet = sheet.worksheet("pm_tasks")
            
            # æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            all_values = task_sheet.get_all_values()
            
            if len(all_values) < 1:
                logger.error("pm_tasksã‚·ãƒ¼ãƒˆãŒç©ºã§ã™")
                return 0
            
            # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ç¢ºèª
            headers = all_values[0]
            logger.info(f"åˆ—ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯IDã®æ±ºå®š ===
            existing_task_ids = []
            for row in all_values[1:]:  # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if row and len(row) > 0:
                    try:
                        task_id = int(row[0])
                        existing_task_ids.append(task_id)
                    except (ValueError, IndexError):
                        continue
            
            # æ¬¡ã®ã‚¿ã‚¹ã‚¯IDã‚’æ±ºå®š
            if existing_task_ids:
                next_task_id = max(existing_task_ids) + 1
            else:
                next_task_id = 1
            
            logger.info(f"æ¬¡ã®ã‚¿ã‚¹ã‚¯ID: {next_task_id}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ ===
            rows_to_add = []
            for task in suggested_tasks:
                row = [
                    next_task_id,  # A: task_id
                    '',  # B: parent_goal_idï¼ˆç©ºæ¬„ï¼‰
                    task.get('description', ''),  # C: task_description
                    task.get('required_role', 'dev'),  # D: required_role
                    'pending',  # E: status
                    task.get('priority', 'medium'),  # F: priority
                    task.get('estimated_time', ''),  # G: estimated_time
                    ','.join(map(str, task.get('dependencies', [parent_task_id]))),  # H: dependencies
                    datetime.now().isoformat(),  # I: created_at
                    f"Review suggested from task {parent_task_id}"  # J: notes
                ]
                rows_to_add.append(row)
                logger.info(f"è¿½åŠ äºˆå®šã‚¿ã‚¹ã‚¯: ID={next_task_id}, å†…å®¹={task.get('description', '')[:50]}")
                next_task_id += 1
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‡ãƒ¼ã‚¿è¿½åŠ å‡¦ç† ===
            if rows_to_add:
                # æœ€çµ‚è¡Œã®æ¬¡ã®è¡Œã‹ã‚‰è¿½åŠ 
                start_row = len(all_values) + 1
                
                # ã‚»ãƒ«ç¯„å›²ã‚’æŒ‡å®šã—ã¦è¿½åŠ 
                range_notation = f'A{start_row}:J{start_row + len(rows_to_add) - 1}'
                
                logger.info(f"ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ : {range_notation}")
                task_sheet.update(range_notation, rows_to_add)
                
                logger.info(f"âœ… ææ¡ˆã‚¿ã‚¹ã‚¯ {len(rows_to_add)} ä»¶ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
                
                # è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯IDã‚’ãƒ­ã‚°å‡ºåŠ›
                added_ids = [row[0] for row in rows_to_add]
                logger.info(f"è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ID: {added_ids}")
            
            return len(rows_to_add)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ææ¡ˆã‚¿ã‚¹ã‚¯è¿½åŠ ")
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return 0