# notification_agent.py
"""
ÈÄöÁü•„Ç®„Éº„Ç∏„Çß„É≥„Éà
Slack/„É°„Éº„É´/„Åù„ÅÆ‰ªñ„ÅÆÈÄöÁü•ÁÆ°ÁêÜ
"""

import asyncio
import logging
import json
import smtplib
from typing import Dict, Any, List, Optional
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from enum import Enum

import aiohttp

logger = logging.getLogger(__name__)


class NotificationLevel(Enum):
    """ÈÄöÁü•„É¨„Éô„É´"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
    SUCCESS = "success"


class NotificationChannel(Enum):
    """ÈÄöÁü•„ÉÅ„É£„Éç„É´"""
    SLACK = "slack"
    EMAIL = "email"
    DISCORD = "discord"
    WEBHOOK = "webhook"


class NotificationAgent:
    """
    ÈÄöÁü•„Ç®„Éº„Ç∏„Çß„É≥„Éà
    
    Ê©üËÉΩ:
    - SlackÈÄöÁü•
    - „É°„Éº„É´ÈÄöÁü•
    - DiscordÈÄöÁü•
    - WebhookÈÄöÁü•
    - ÈÄöÁü•„ÅÆ„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
    - ÈÄöÁü•„ÉÜ„É≥„Éó„É¨„Éº„ÉàÁÆ°ÁêÜ
    """
    
    def __init__(
        self,
        slack_webhook_url: Optional[str] = None,
        email_config: Optional[Dict[str, str]] = None,
        discord_webhook_url: Optional[str] = None,
        min_notification_level: NotificationLevel = NotificationLevel.WARNING
    ):
        """
        ÂàùÊúüÂåñ
        
        Args:
            slack_webhook_url: Slack Webhook URL
            email_config: „É°„Éº„É´Ë®≠ÂÆöÔºàsmtp_server, smtp_port, username, password, recipientsÔºâ
            discord_webhook_url: Discord Webhook URL
            min_notification_level: ÊúÄÂ∞èÈÄöÁü•„É¨„Éô„É´
        """
        self.slack_webhook_url = slack_webhook_url
        self.email_config = email_config or {}
        self.discord_webhook_url = discord_webhook_url
        self.min_notification_level = min_notification_level
        
        # ÈÄöÁü•Â±•Ê≠¥
        self.notification_history = []
        
        # Áµ±Ë®àÊÉÖÂ†±
        self.stats = {
            "total_notifications": 0,
            "slack_notifications": 0,
            "email_notifications": 0,
            "discord_notifications": 0,
            "failed_notifications": 0
        }
        
        # ÈÄöÁü•„ÉÜ„É≥„Éó„É¨„Éº„Éà
        self._init_templates()
        
        logger.info("‚úÖ NotificationAgent ÂàùÊúüÂåñÂÆå‰∫Ü")
    
    def _init_templates(self):
        """ÈÄöÁü•„ÉÜ„É≥„Éó„É¨„Éº„Éà„ÇíÂàùÊúüÂåñ"""
        self.templates = {
            "fix_success": {
                "title": "‚úÖ Ëá™Âãï‰øÆÊ≠£ÊàêÂäü",
                "color": "#36a64f",
                "emoji": "‚úÖ"
            },
            "fix_failure": {
                "title": "‚ùå Ëá™Âãï‰øÆÊ≠£Â§±Êïó",
                "color": "#ff0000",
                "emoji": "‚ùå"
            },
            "error_detected": {
                "title": "üîç „Ç®„É©„ÉºÊ§úÂá∫",
                "color": "#ff9900",
                "emoji": "üîç"
            },
            "system_warning": {
                "title": "‚ö†Ô∏è „Ç∑„Çπ„ÉÜ„É†Ë≠¶Âëä",
                "color": "#ffcc00",
                "emoji": "‚ö†Ô∏è"
            },
            "system_critical": {
                "title": "üö® „Ç∑„Çπ„ÉÜ„É†ÈáçÂ§ß",
                "color": "#cc0000",
                "emoji": "üö®"
            },
            "pr_created": {
                "title": "üåø PR‰ΩúÊàêÂÆå‰∫Ü",
                "color": "#0366d6",
                "emoji": "üåø"
            }
        }
    
    async def send_notification(
        self,
        message: str,
        level: NotificationLevel = NotificationLevel.INFO,
        channels: Optional[List[NotificationChannel]] = None,
        template_name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        ÈÄöÁü•„ÇíÈÄÅ‰ø°
        
        Args:
            message: ÈÄöÁü•„É°„ÉÉ„Çª„Éº„Ç∏
            level: ÈÄöÁü•„É¨„Éô„É´
            channels: ÈÄöÁü•„ÉÅ„É£„Éç„É´ÔºàÁúÅÁï•ÊôÇ„ÅØÂÖ®„ÉÅ„É£„Éç„É´Ôºâ
            template_name: „ÉÜ„É≥„Éó„É¨„Éº„ÉàÂêç
            metadata: ËøΩÂä†„É°„Çø„Éá„Éº„Çø
            
        Returns:
            Dict: ÈÄÅ‰ø°ÁµêÊûú
        """
        try:
            # „É¨„Éô„É´„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            if not self._should_notify(level):
                logger.debug(f"ÈÄöÁü•„Çπ„Ç≠„ÉÉ„Éó: „É¨„Éô„É´={level.value}")
                return {"success": True, "skipped": True}
            
            self.stats["total_notifications"] += 1
            
            # „ÉÅ„É£„Éç„É´„ÅÆÊ±∫ÂÆö
            if channels is None:
                channels = self._get_available_channels()
            
            # ÈÄöÁü•ÂÜÖÂÆπ„ÇíÊßãÁØâ
            notification = self._build_notification(
                message=message,
                level=level,
                template_name=template_name,
                metadata=metadata
            )
            
            # ÂêÑ„ÉÅ„É£„Éç„É´„Å´ÈÄÅ‰ø°
            results = {}
            
            for channel in channels:
                try:
                    if channel == NotificationChannel.SLACK:
                        result = await self._send_slack_notification(notification)
                        results["slack"] = result
                        
                    elif channel == NotificationChannel.EMAIL:
                        result = await self._send_email_notification(notification)
                        results["email"] = result
                        
                    elif channel == NotificationChannel.DISCORD:
                        result = await self._send_discord_notification(notification)
                        results["discord"] = result
                        
                except Exception as e:
                    logger.error(f"‚ùå {channel.value}ÈÄöÁü•„Ç®„É©„Éº: {e}")
                    results[channel.value] = {"success": False, "error": str(e)}
                    self.stats["failed_notifications"] += 1
            
            # Â±•Ê≠¥„Å´ËøΩÂä†
            self.notification_history.append({
                "timestamp": datetime.now().isoformat(),
                "message": message,
                "level": level.value,
                "channels": [c.value for c in channels],
                "results": results
            })
            
            # Âè§„ÅÑÂ±•Ê≠¥„ÇíÂâäÈô§ÔºàÁõ¥Ëøë100‰ª∂„ÅÆ„ÅøÔºâ
            if len(self.notification_history) > 100:
                self.notification_history = self.notification_history[-100:]
            
            logger.info(f"üì§ ÈÄöÁü•ÈÄÅ‰ø°ÂÆå‰∫Ü: {message[:50]}...")
            
            return {
                "success": True,
                "channels": results
            }
            
        except Exception as e:
            logger.error(f"‚ùå ÈÄöÁü•ÈÄÅ‰ø°„Ç®„É©„Éº: {e}", exc_info=True)
            self.stats["failed_notifications"] += 1
            return {
                "success": False,
                "error": str(e)
            }
    
    async def notify_fix_success(
        self,
        task_id: str,
        modified_files: List[str],
        execution_time: float,
        confidence: float
    ):
        """‰øÆÊ≠£ÊàêÂäü„ÅÆÈÄöÁü•"""
        message = (
            f"„Çø„Çπ„ÇØ {task_id} „ÅÆËá™Âãï‰øÆÊ≠£„ÅåÊàêÂäü„Åó„Åæ„Åó„Åü\n"
            f"‰øÆÊ≠£„Éï„Ç°„Ç§„É´: {', '.join(modified_files)}\n"
            f"ÂÆüË°åÊôÇÈñì: {execution_time:.2f}Áßí\n"
            f"‰ø°È†ºÂ∫¶: {confidence:.1%}"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.SUCCESS,
            template_name="fix_success",
            metadata={
                "task_id": task_id,
                "modified_files": modified_files,
                "execution_time": execution_time,
                "confidence": confidence
            }
        )
    
    async def notify_fix_failure(
        self,
        task_id: str,
        error_message: str
    ):
        """‰øÆÊ≠£Â§±Êïó„ÅÆÈÄöÁü•"""
        message = (
            f"„Çø„Çπ„ÇØ {task_id} „ÅÆËá™Âãï‰øÆÊ≠£„ÅåÂ§±Êïó„Åó„Åæ„Åó„Åü\n"
            f"„Ç®„É©„Éº: {error_message}\n"
            f"ÊâãÂãï‰ªãÂÖ•„ÅåÂøÖË¶Å„Åß„Åô"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.ERROR,
            template_name="fix_failure",
            metadata={
                "task_id": task_id,
                "error_message": error_message
            }
        )
    
    async def notify_system_warning(
        self,
        warning_type: str,
        details: str
    ):
        """„Ç∑„Çπ„ÉÜ„É†Ë≠¶Âëä„ÅÆÈÄöÁü•"""
        message = f"„Ç∑„Çπ„ÉÜ„É†Ë≠¶Âëä: {warning_type}\nË©≥Á¥∞: {details}"
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.WARNING,
            template_name="system_warning",
            metadata={
                "warning_type": warning_type,
                "details": details
            }
        )
    
    async def notify_pr_created(
        self,
        task_id: str,
        pr_url: str,
        branch_name: str
    ):
        """PR‰ΩúÊàê„ÅÆÈÄöÁü•"""
        message = (
            f"„Çø„Çπ„ÇØ {task_id} „ÅÆ‰øÆÊ≠£PR„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü\n"
            f"„Éñ„É©„É≥„ÉÅ: {branch_name}\n"
            f"PR URL: {pr_url}"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.INFO,
            template_name="pr_created",
            metadata={
                "task_id": task_id,
                "pr_url": pr_url,
                "branch_name": branch_name
            }
        )
    
    # ========================================
    # ÂÜÖÈÉ®„É°„ÇΩ„ÉÉ„Éâ
    # ========================================
    
    def _should_notify(self, level: NotificationLevel) -> bool:
        """ÈÄöÁü•„Åô„Åπ„Åç„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        level_priority = {
            NotificationLevel.INFO: 0,
            NotificationLevel.SUCCESS: 1,
            NotificationLevel.WARNING: 2,
            NotificationLevel.ERROR: 3,
            NotificationLevel.CRITICAL: 4
        }
        
        return level_priority.get(level, 0) >= level_priority.get(self.min_notification_level, 0)
    
    def _get_available_channels(self) -> List[NotificationChannel]:
        """Âà©Áî®ÂèØËÉΩ„Å™„ÉÅ„É£„Éç„É´„ÇíÂèñÂæó"""
        channels = []
        
        if self.slack_webhook_url:
            channels.append(NotificationChannel.SLACK)
        
        if self.email_config.get("smtp_server"):
            channels.append(NotificationChannel.EMAIL)
        
        if self.discord_webhook_url:
            channels.append(NotificationChannel.DISCORD)
        
        return channels
    
    def _build_notification(
        self,
        message: str,
        level: NotificationLevel,
        template_name: Optional[str],
        metadata: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """ÈÄöÁü•ÂÜÖÂÆπ„ÇíÊßãÁØâ"""
        template = self.templates.get(template_name, {}) if template_name else {}
        
        return {
            "message": message,
            "level": level.value,
            "title": template.get("title", f"{level.value.upper()} Notification"),
            "color": template.get("color", "#cccccc"),
            "emoji": template.get("emoji", "üì¢"),
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {}
        }
    
    async def _send_slack_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """SlackÈÄöÁü•„ÇíÈÄÅ‰ø°"""
        if not self.slack_webhook_url:
            return {"success": False, "error": "Slack webhook URL not configured"}
        
        try:
            # Slack„Éö„Ç§„É≠„Éº„ÉâÊßãÁØâ
            payload = {
                "text": f"{notification['emoji']} {notification['title']}",
                "attachments": [{
                    "color": notification['color'],
                    "text": notification['message'],
                    "footer": "Hybrid Fix System",
                    "ts": int(datetime.now().timestamp())
                }]
            }
            
            # „É°„Çø„Éá„Éº„Çø„ÇíËøΩÂä†
            if notification.get('metadata'):
                fields = []
                for key, value in notification['metadata'].items():
                    fields.append({
                        "title": key,
                        "value": str(value),
                        "short": True
                    })
                payload["attachments"][0]["fields"] = fields
            
            # WebhookÈÄÅ‰ø°
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.slack_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        self.stats["slack_notifications"] += 1
                        return {"success": True}
                    else:
                        error_text = await response.text()
                        return {"success": False, "error": f"HTTP {response.status}: {error_text}"}
            
        except Exception as e:
            logger.error(f"‚ùå SlackÈÄöÁü•„Ç®„É©„Éº: {e}")
            return {"success": False, "error": str(e)}
    
    async def _send_email_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """„É°„Éº„É´ÈÄöÁü•„ÇíÈÄÅ‰ø°"""
        if not self.email_config.get("smtp_server"):
            return {"success": False, "error": "Email not configured"}
        
        try:
            # „É°„Éº„É´‰ΩúÊàê
            msg = MIMEMultipart()
            msg['From'] = self.email_config.get("username", "noreply@example.com")
            msg['To'] = self.email_config.get("recipients", "admin@example.com")
            msg['Subject'] = f"{notification['emoji']} {notification['title']}"
            
            # Êú¨Êñá
            body = f"""
{notification['title']}

{notification['message']}

---
Timestamp: {notification['timestamp']}
System: Hybrid Fix System
"""
            
            if notification.get('metadata'):
                body += "\nDetails:\n"
                for key, value in notification['metadata'].items():
                    body += f"  {key}: {value}\n"
            
            msg.attach(MIMEText(body, 'plain'))
            
            # SMTPÈÄÅ‰ø°
            await asyncio.to_thread(self._send_smtp_email, msg)
            
            self.stats["email_notifications"] += 1
            return {"success": True}
            
        except Exception as e:
            logger.error(f"‚ùå „É°„Éº„É´ÈÄöÁü•„Ç®„É©„Éº: {e}")
            return {"success": False, "error": str(e)}
    
    def _send_smtp_email(self, msg: MIMEMultipart):
        """SMTPÁµåÁî±„Åß„É°„Éº„É´ÈÄÅ‰ø°ÔºàÂêåÊúüÔºâ"""
        server = smtplib.SMTP(
            self.email_config["smtp_server"],
            int(self.email_config.get("smtp_port", 587))
        )
        server.starttls()
        server.login(
            self.email_config["username"],
            self.email_config["password"]
        )
        server.send_message(msg)
        server.quit()
    
    async def _send_discord_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """DiscordÈÄöÁü•„ÇíÈÄÅ‰ø°"""
        if not self.discord_webhook_url:
            return {"success": False, "error": "Discord webhook URL not configured"}
        
        try:
            # Discord„Éö„Ç§„É≠„Éº„ÉâÊßãÁØâ
            payload = {
                "content": f"{notification['emoji']} **{notification['title']}**",
                "embeds": [{
                    "description": notification['message'],
                    "color": int(notification['color'].replace('#', ''), 16),
                    "timestamp": notification['timestamp'],
                    "footer": {
                        "text": "Hybrid Fix System"
                    }
                }]
            }
            
            # „É°„Çø„Éá„Éº„Çø„ÇíËøΩÂä†
            if notification.get('metadata'):
                fields = []
                for key, value in notification['metadata'].items():
                    fields.append({
                        "name": key,
                        "value": str(value),
                        "inline": True
                    })
                payload["embeds"][0]["fields"] = fields
            
            # WebhookÈÄÅ‰ø°
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.discord_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status in [200, 204]:
                        self.stats["discord_notifications"] += 1
                        return {"success": True}
                    else:
                        error_text = await response.text()
                        return {"success": False, "error": f"HTTP {response.status}: {error_text}"}
            
        except Exception as e:
            logger.error(f"‚ùå DiscordÈÄöÁü•„Ç®„É©„Éº: {e}")
            return {"success": False, "error": str(e)}
    
    def get_stats(self) -> Dict[str, Any]:
        """Áµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó"""
        success_rate = 0.0
        if self.stats["total_notifications"] > 0:
            success_rate = (
                (self.stats["total_notifications"] - self.stats["failed_notifications"]) /
                self.stats["total_notifications"]
            )
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "recent_notifications": self.notification_history[-10:]
        }
    
    def print_stats(self):
        """Áµ±Ë®àÊÉÖÂ†±„ÇíË°®Á§∫"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("üì§ ÈÄöÁü•„Ç®„Éº„Ç∏„Çß„É≥„Éà Áµ±Ë®àÊÉÖÂ†±")
        print("=" * 80)
        print(f"Á∑èÈÄöÁü•Êï∞: {stats['total_notifications']}")
        print(f"ÊàêÂäüÁéá: {stats['success_rate']:.1%}")
        print(f"\n„ÉÅ„É£„Éç„É´Âà•:")
        print(f"  Slack: {stats['slack_notifications']}Âõû")
        print(f"  „É°„Éº„É´: {stats['email_notifications']}Âõû")
        print(f"  Discord: {stats['discord_notifications']}Âõû")
        print(f"\nÂ§±Êïó: {stats['failed_notifications']}Âõû")
        print("=" * 80 + "\n")