# pm_agent.py ã® _parse_json_response ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä»¥ä¸‹ã«ç½®ãæ›ãˆ

def _parse_json_response(self, text: str) -> Optional[Dict]:
    """å¿œç­”ã‹ã‚‰JSONéƒ¨åˆ†ã‚’æŠ½å‡ºã—ã¦ãƒ‘ãƒ¼ã‚¹ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
    try:
        if not text:
            logger.warning("ç©ºã®å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆ")
            return None
        
        logger.info("="*60)
        logger.info("JSONè§£æé–‹å§‹")
        logger.info("="*60)
        logger.info(f"å¿œç­”å…¨ä½“ã®é•·ã•: {len(text)}æ–‡å­—")
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json ... ``` ã§å›²ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
        import re
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
        if json_match:
            json_str = json_match.group(1)
            logger.info("âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json...``` å½¢å¼ã‚’æ¤œå‡º")
            try:
                result = json.loads(json_str)
                logger.info(f"âœ… JSONè§£ææˆåŠŸï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³1ï¼‰: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                return result
            except json.JSONDecodeError as e:
                logger.warning(f"ãƒ‘ã‚¿ãƒ¼ãƒ³1ã§JSONè§£æå¤±æ•—: {e}")
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³2: { ã‹ã‚‰å§‹ã¾ã‚‹æœ€åˆã®JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã‚’æŠ½å‡º
        start_idx = text.find('{')
        if start_idx != -1:
            logger.info(f"âœ… '{' ã‚’ä½ç½® {start_idx} ã§æ¤œå‡º")
            
            # ãƒã‚¹ãƒˆã•ã‚ŒãŸæ‹¬å¼§ã‚’æ­£ã—ãã‚«ã‚¦ãƒ³ãƒˆ
            brace_count = 0
            in_string = False
            escape_next = False
            
            for i, char in enumerate(text[start_idx:], start=start_idx):
                if escape_next:
                    escape_next = False
                    continue
                
                if char == '\\':
                    escape_next = True
                    continue
                
                if char == '"' and not escape_next:
                    in_string = not in_string
                    continue
                
                if not in_string:
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            # JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çµ‚ã‚ã‚Šã‚’ç™ºè¦‹
                            potential_json = text[start_idx:i+1]
                            logger.info(f"âœ… å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡º: {len(potential_json)}æ–‡å­—")
                            
                            try:
                                result = json.loads(potential_json)
                                logger.info(f"âœ… JSONè§£ææˆåŠŸ: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                                return result
                            except json.JSONDecodeError as e:
                                logger.error(f"âŒ JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
                                logger.error(f"ã‚¨ãƒ©ãƒ¼ä½ç½®: line {e.lineno}, column {e.colno}")
                                
                                # ã‚¨ãƒ©ãƒ¼ç®‡æ‰€å‘¨è¾ºã‚’è¡¨ç¤º
                                error_pos = e.pos if hasattr(e, 'pos') else 0
                                context_start = max(0, error_pos - 100)
                                context_end = min(len(potential_json), error_pos + 100)
                                logger.error(f"ã‚¨ãƒ©ãƒ¼å‘¨è¾ºã®ãƒ†ã‚­ã‚¹ãƒˆ:\n{potential_json[context_start:context_end]}")
                                
                                # ä¿®å¾©ã‚’è©¦ã¿ã‚‹
                                repaired_json = self._attempt_json_repair(potential_json, e)
                                if repaired_json:
                                    return repaired_json
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³3: æœ€å¾Œã®æ‰‹æ®µ - å…¨ä½“ã‚’JSONã¨ã—ã¦è©¦ã™
        logger.info("ãƒ‘ã‚¿ãƒ¼ãƒ³3: ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’JSONã¨ã—ã¦è§£æ")
        try:
            result = json.loads(text)
            logger.info(f"âœ… JSONè§£ææˆåŠŸï¼ˆå…¨ä½“è§£æï¼‰: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
            return result
        except json.JSONDecodeError as e:
            logger.error(f"âŒ å…¨ä½“è§£æã‚‚å¤±æ•—: {e}")
        
        # ã™ã¹ã¦å¤±æ•—
        logger.error("="*60)
        logger.error("âŒ ã™ã¹ã¦ã®JSONè§£æãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå¤±æ•—")
        logger.error("="*60)
        logger.error(f"å¿œç­”ã®å…ˆé ­500æ–‡å­—:\n{text[:500]}")
        logger.error(f"å¿œç­”ã®æœ«å°¾500æ–‡å­—:\n{text[-500:]}")
        
        return None
        
    except Exception as e:
        logger.error(f"âŒ JSONè§£æã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None

def _attempt_json_repair(self, json_str: str, error: json.JSONDecodeError) -> Optional[Dict]:
    """å£Šã‚ŒãŸJSONã®ä¿®å¾©ã‚’è©¦ã¿ã‚‹"""
    try:
        logger.info("ğŸ”§ JSONä¿®å¾©ã‚’è©¦ã¿ã¾ã™...")
        
        # ã‚¨ãƒ©ãƒ¼ä½ç½®ã‚’å–å¾—
        error_pos = error.pos if hasattr(error, 'pos') else len(json_str)
        
        # ä¿®å¾©æ–¹æ³•1: ã‚¨ãƒ©ãƒ¼ä½ç½®ã®ç›´å‰ã§åˆ‡ã‚Šæ¨ã¦ã¦é–‰ã˜ã‚‹
        if "Expecting ',' delimiter" in str(error) or "Expecting ':' delimiter" in str(error):
            # æœ€å¾Œã®å®Œå…¨ãªã‚¿ã‚¹ã‚¯ã¾ã§æˆ»ã‚‹
            last_complete_task = json_str.rfind('},', 0, error_pos)
            if last_complete_task > 0:
                # tasksãƒªã‚¹ãƒˆã‚’é–‰ã˜ã‚‹
                repaired = json_str[:last_complete_task + 1] + '], "risks": [], "success_criteria": []}'
                logger.info(f"ä¿®å¾©è©¦è¡Œ1: ä½ç½®{last_complete_task}ã§åˆ‡ã‚Šæ¨ã¦")
                try:
                    result = json.loads(repaired)
                    logger.info(f"âœ… ä¿®å¾©æˆåŠŸ! ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                    return result
                except:
                    pass
        
        # ä¿®å¾©æ–¹æ³•2: ä¸å®Œå…¨ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å‰Šé™¤
        lines = json_str.split('\n')
        error_line = error.lineno if hasattr(error, 'lineno') else len(lines)
        
        if error_line > 0 and error_line <= len(lines):
            # ã‚¨ãƒ©ãƒ¼è¡Œä»¥é™ã‚’å‰Šé™¤ã—ã¦å†æ§‹ç¯‰
            truncated_lines = lines[:error_line-1]
            
            # é–‹ã„ã¦ã„ã‚‹æ‹¬å¼§ã‚’é–‰ã˜ã‚‹
            truncated = '\n'.join(truncated_lines)
            open_braces = truncated.count('{') - truncated.count('}')
            open_brackets = truncated.count('[') - truncated.count(']')
            
            repaired = truncated
            if ',"tasks":[' in repaired and not repaired.rstrip().endswith(']'):
                repaired += ']'
            
            for _ in range(open_braces):
                repaired += '}'
            
            logger.info("ä¿®å¾©è©¦è¡Œ2: ä¸å®Œå…¨ãªéƒ¨åˆ†ã‚’å‰Šé™¤ã—ã¦é–‰ã˜ã‚‹")
            try:
                result = json.loads(repaired)
                logger.info(f"âœ… ä¿®å¾©æˆåŠŸ! ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                return result
            except:
                pass
        
        logger.warning("âŒ JSONä¿®å¾©ã«å¤±æ•—")
        return None
        
    except Exception as e:
        logger.error(f"JSONä¿®å¾©ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")
        return None