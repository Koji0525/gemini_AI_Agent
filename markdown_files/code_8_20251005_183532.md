# コード: 主要SNS（Instagram/Telegram/Twitter/YouTube）への自動配信連携スクリプトの設計とプロトタイプ実装

タスクID: 8
作成日時: 2025-10-05T18:35:32.357372

---

提供されたタスクは、主要SNSへの自動配信連携スクリプトのプロトタイプ実装です。実際の商用サービスへの自動配信連携では、各プラットフォームの複雑なOAuth認証、APIレート制限、そして非同期処理が不可欠です。

しかし、単一のコードブロックで「完全に動作する」マルチプラットフォーム連携を実装することは、機密情報（APIキー、シークレット）の埋め込みが必要であり、セキュリティ上のリスクが大きいため不適切です（原則2）。また、Twitter (X) や Instagram のAPIは非常に複雑で、プロトタイプとして一つのファイルに収めることは困難です。

そこで、経験豊富なエンジニアとして、このタスクの核となる「配信ロジック」と「設定管理」の設計に焦点を当て、Pythonを使用して、外部API通信の共通インターフェースと非同期処理のプロトタイプを実装します。これにより、**テスト可能（原則4）で拡張性の高い（原則5）**基盤を提供します。

タスク概要

主要SNS（Instagram, Telegram, Twitter (X), YouTube）へのコンテンツ自動配信をシミュレートするための、非同期処理とAPIインターフェースを備えたPythonプロトタイプスクリプトを設計・実装します。

目標は、各SNSへの配信プロセスを抽象化し、将来的に実際のAPIキーを組み込むだけで動作するモジュール化された基盤を構築することです。

実装内容

以下の要素を持つPythonスクリプトを実装します。

SocialMediaAPI クラス: 各SNSへの配信処理を抽象化するインターフェースを定義します。

SNS固有のクラス: InstagramAPI, TelegramAPI, TwitterAPI, YouTubeAPI としてインターフェースを継承し、各プラットフォームの配信ロジックをシミュレートします。

非同期処理: Pythonの asyncio を使用し、複数のSNSへの配信を並行して行うことで、全体の処理時間を短縮します（原則5）。

設定とエラーハンドリング: os モジュールを使用してAPIキーの存在を確認し、配信失敗をシミュレートするエラーハンドリングを含めます（原則3）。

コード

このコードはPython 3.8以降で動作します。

Python
import asyncio
import os
import random
from typing import List, Dict, Any, Optional

# 1. APIインターフェースの抽象化と設定の定義
class SocialMediaAPI:
    """
    全てのソーシャルメディアAPIの基本インターフェース。
    配信処理を抽象化し、テスト可能性を高める (原則4)。
    """
    def __init__(self, platform: str, api_key: str):
        """
        コンストラクタでプラットフォーム名とAPIキー（シミュレーション用）を初期化。
        :param platform: SNSプラットフォーム名
        :param api_key: 認証キー（実際にはトークンやシークレットも必要）
        """
        self.platform = platform
        self.api_key = api_key
        # APIキーが存在するか検証 (原則3)
        if not api_key:
            raise ValueError(f"Error: API Key for {platform} is missing.")
        
        # 認証処理のシミュレーション（実際はここで認証トークン取得などを行う）
        self.is_authenticated = True

    async def post_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """
        コンテンツをSNSに配信する抽象メソッド。
        各子クラスでオーバーライドされる。
        :param content: 配信するコンテンツデータ
        :return: 配信結果（成功/失敗）
        """
        raise NotImplementedError("Subclass must implement abstract method 'post_content'")

# 2. 各SNS固有の配信ロジックのシミュレーション
class InstagramAPI(SocialMediaAPI):
    """Instagramの配信をシミュレート。主に画像/動画とキャプション。"""
    def __init__(self, api_key: str):
        super().__init__("Instagram", api_key)
    
    async def post_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """非同期でコンテンツをInstagramに配信するシミュレーション"""
        # ネットワーク遅延のシミュレーション
        await asyncio.sleep(random.uniform(0.5, 2.0))
        
        # 配信失敗のシミュレーション (約20%の確率で失敗)
        if random.random() < 0.2:
            # 🚨 エラーハンドリング (原則3)
            error_message = f"{self.platform} API: Rate limit exceeded or image processing failed."
            return {"platform": self.platform, "success": False, "message": error_message}
        
        # 成功時の処理
        return {
            "platform": self.platform,
            "success": True,
            "post_id": f"IG-{random.randint(1000, 9999)}",
            "message": f"Content posted successfully: {content.get('caption', '')[:20]}..."
        }

class TelegramAPI(SocialMediaAPI):
    """Telegramの配信をシミュレート。メッセージ送信。"""
    def __init__(self, api_key: str):
        super().__init__("Telegram", api_key)

    async def post_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """非同期でコンテンツをTelegramに配信するシミュレーション"""
        await asyncio.sleep(random.uniform(0.3, 1.5))
        
        # 認証エラーのシミュレーション
        if self.api_key == "SIMULATED_INVALID_TELEGRAM_KEY":
            error_message = f"{self.platform} API: Invalid bot token."
            return {"platform": self.platform, "success": False, "message": error_message}

        return {
            "platform": self.platform,
            "success": True,
            "message_id": f"TG-{random.randint(1000, 9999)}",
            "message": f"Message sent to channel: {content.get('text', '')[:20]}..."
        }

class TwitterAPI(SocialMediaAPI):
    """Twitter (X) の配信をシミュレート。ツイート投稿。"""
    def __init__(self, api_key: str):
        super().__init__("Twitter", api_key)

    async def post_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """非同期でコンテンツをTwitter (X) に配信するシミュレーション"""
        await asyncio.sleep(random.uniform(1.0, 3.0)) # Twitter APIは通常遅延が大きい
        
        # 配信失敗のシミュレーション (認証・レート制限以外の予期せぬエラー)
        if "sensitive_topic" in content.get('tags', []):
            error_message = f"{self.platform} API: Policy violation detected."
            return {"platform": self.platform, "success": False, "message": error_message}

        return {
            "platform": self.platform,
            "success": True,
            "tweet_id": f"TW-{random.randint(1000, 9999)}",
            "message": f"Tweet posted: {content.get('text', '')[:20]}..."
        }

class YouTubeAPI(SocialMediaAPI):
    """YouTubeの配信をシミュレート。動画アップロード。"""
    def __init__(self, api_key: str):
        super().__init__("YouTube", api_key)

    async def post_content(self, content: Dict[str, Any]) -> Dict[str, Any]:
        """非同期で動画をYouTubeにアップロードするシミュレーション"""
        # 動画アップロードは時間がかかるため、長い遅延をシミュレート
        await asyncio.sleep(random.uniform(3.0, 5.0)) 
        
        # 配信失敗のシミュレーション
        if not content.get('video_file_path'):
            error_message = f"{self.platform} API: Video file is missing."
            return {"platform": self.platform, "success": False, "message": error_message}

        return {
            "platform": self.platform,
            "success": True,
            "video_id": f"YT-{random.randint(1000, 9999)}",
            "message": f"Video uploaded: {content.get('title', '')[:20]}..."
        }


# 3. 実行ロジック
async def distribute_content(content: Dict[str, Any], apis: List[SocialMediaAPI]) -> List[Dict[str, Any]]:
    """
    複数のSNS APIに対してコンテンツ配信を非同期で実行する。
    
    :param content: 配信するコンテンツデータ
    :param apis: SocialMediaAPIを継承したAPIインスタンスのリスト
    :return: 全てのプラットフォームからの配信結果のリスト
    """
    print(f"\n--- Starting Distribution for Content ID: {content.get('id')} ---")
    
    # 全てのAPIインスタンスに対して post_content のタスクを作成
    tasks = []
    for api in apis:
        # 配信処理を非同期タスクとして実行
        task = asyncio.create_task(api.post_content(content))
        tasks.append(task)
        
    # 全てのタスクが完了するのを待つ (非同期並行実行)
    results = await asyncio.gather(*tasks)
    
    print("--- Distribution Complete ---")
    return results

def main_distribution_script():
    """
    メインの実行関数。APIインスタンスの準備とコンテンツの定義を行う。
    """
    # 🚨 セキュリティ考慮 (原則2)
    # 実際には環境変数からシークレットキーをロードする
    # 例: os.environ.get('INSTAGRAM_API_KEY', 'default_key')
    
    # 認証キーのシミュレーション（実際はここで正しいキーを設定）
    INSTAGRAM_KEY = "IG_SECURE_KEY_123"
    TELEGRAM_KEY = "TG_SECURE_KEY_4