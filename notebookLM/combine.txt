#__init__.py
"""
WordPress開発専門エージェント統合パッケージ
"""

from .wp_requirements_agent import WordPressRequirementsAgent
from .wp_cpt_agent import WordPressCPTAgent
from .wp_taxonomy_agent import WordPressTaxonomyAgent
from .wp_acf_agent import WordPressACFAgent

__all__ = [
    'WordPressRequirementsAgent',
    'WordPressCPTAgent',
    'WordPressTaxonomyAgent',
    'WordPressACFAgent'
]

__version__ = '1.0.0'

#brower_cookie_and_session.py
# browser_cookie_and_session.py
"""クッキーとセッション管理クラス"""
import json
import time
from pathlib import Path
from typing import Optional, Dict, List
from playwright.async_api import BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class CookieSessionManager:
    """クッキーとセッションの管理を担当"""
    
    def __init__(self, context: BrowserContext, cookies_file: Path):
        self.context = context
        self.cookies_file = cookies_file
    
    async def save_cookies(self) -> None:
        """クッキーを保存（強化版）"""
        try:
            if not self.context or not self.cookies_file:
                logger.warning("クッキー保存: コンテキストまたはファイルパスがありません")
                return
            
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("保存するクッキーがありません")
                return
                
            with open(self.cookies_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"✅ クッキーを保存しました: {len(cookies)}個のクッキー")
            
        except Exception as e:
            ErrorHandler.log_error(e, "クッキー保存")
            logger.warning("クッキー保存に失敗しましたが続行します")

    async def load_cookies(self) -> bool:
        """クッキーを読み込み（強化版）"""
        try:
            if not self.cookies_file or not self.cookies_file.exists():
                logger.warning("クッキーファイルが存在しません")
                return False
                
            if not self.context:
                logger.warning("コンテキストが初期化されていません")
                return False
                
            with open(self.cookies_file, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
            
            if not cookies:
                logger.warning("クッキーファイルが空です")
                return False
                
            current_url = "https://gemini.google.com"  # デフォルトURL
            domain_cookies = []
            
            for cookie in cookies:
                if 'domain' in cookie and cookie['domain'].startswith('.'):
                    cookie['domain'] = cookie['domain'][1:]
                
                if 'expires' in cookie and cookie['expires'] < time.time():
                    continue
                    
                domain_cookies.append(cookie)
            
            if domain_cookies:
                await self.context.add_cookies(domain_cookies)
                logger.info(f"✅ クッキーを読み込みました: {len(domain_cookies)}個")
                return True
            else:
                logger.warning("有効なクッキーがありません")
                return False
                
        except Exception as e:
            ErrorHandler.log_error(e, "クッキー読み込み")
            return False
    
    async def check_google_login_status(self) -> bool:
        """Googleログイン状態をチェック（ページが必要な場合に実装）"""
        # このメソッドはページコンテキストが必要なため、
        # 必要に応じてAIChatAgentに移動またはここで実装
        logger.info("Googleログイン状態チェック（実装予定）")
        return False

#browser_ai_chat_agent.py
# browser_ai_chat_agent.py
"""AIチャットエージェントクラス（Gemini/DeepSeek対応）"""
import asyncio
import time
import json
import re
from datetime import datetime
from typing import Optional, Dict
from playwright.async_api import Page
import logging

from config_utils import ErrorHandler, FileNameGenerator

logger = logging.getLogger(__name__)

class AIChatAgent:
    """AIサービス（Gemini/DeepSeek）との対話を担当"""
    
    def __init__(self, page: Page, service: str = "google", credentials: Dict = None):
        self.page = page
        self.service = service.lower()
        self.credentials = credentials or {}
    
    async def navigate_to_gemini(self) -> None:
        """Geminiサイトにアクセス（クラッシュ検知強化版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            
            logger.info("Geminiサイトにアクセス中...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiサイトへのアクセス試行 {attempt}/{max_attempts}")
                    
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)
                    
                    logger.info("✅ Geminiサイトへのアクセスが成功しました")
                    break
                    
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました")
                        logger.error("手動でページをリロードしてください")
                        input("Geminiページが読み込まれたら、Enterキーを押してください: ")
                    else:
                        logger.info("5秒後に再試行します...")
                        await asyncio.sleep(5)
            
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            
            await self.handle_welcome_screens()
            logger.info("✅ Geminiサイトの準備が完了しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiアクセス")
            logger.info("手動でGeminiページを開いてください")
            input("準備完了後、Enterキーを押してください: ")
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekサイトにアクセス（Cloudflareボット検証対応版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            logger.info("DeepSeekサイトにアクセス中...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"DeepSeekサイトへのアクセス試行 {attempt}/{max_attempts}")
                    await self.page.goto("https://chat.deepseek.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(5000)
                    logger.info("DeepSeekサイトへのアクセスが成功しました")
                    break
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました。手動でページをリロードしてください")
                        input("DeepSeekページが読み込まれたら、Enterキーを押してください: ")
                    else:
                        logger.info("5秒後に再試行します...")
                        await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            
            # Cloudflareボット検証チェック
            logger.info("Cloudflareボット検証をチェック中...")
            cloudflare_check = await self.page.evaluate('''
                () => {
                    const body = document.body.innerText || '';
                    if (body.includes('Verifying you are human') || 
                        body.includes('あなたがボットではないことを確認') ||
                        body.includes('Just a moment') ||
                        body.includes('Checking your browser')) {
                        return true;
                    }
                    return false;
                }
            ''')
            
            if cloudflare_check:
                logger.warning("⚠️ Cloudflareボット検証が検出されました")
                logger.info("ブラウザで自動的にチェックが完了するまで待機します...")
                
                start_time = time.time()
                while time.time() - start_time < 60:
                    await self.page.wait_for_timeout(3000)
                    
                    still_checking = await self.page.evaluate('''
                        () => {
                            const body = document.body.innerText || '';
                            if (body.includes('Verifying you are human') || 
                                body.includes('あなたがボットではないことを確認') ||
                                body.includes('Just a moment') ||
                                body.includes('Checking your browser')) {
                                return true;
                            }
                            return false;
                        }
                    ''')
                    
                    if not still_checking:
                        logger.info("✅ Cloudflare検証が完了しました")
                        break
                    
                    elapsed = int(time.time() - start_time)
                    if elapsed % 10 == 0:
                        logger.info(f"待機中... {elapsed}秒経過")
                
                await self.page.wait_for_timeout(3000)
                current_url = self.page.url
                logger.info(f"検証後のURL: {current_url}")
            
            # ログインページにいるかチェック
            if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                logger.info("\n" + "="*60)
                logger.info("⚠️ DeepSeekへのログインが必要です")
                logger.info("="*60)
                logger.info("")
                logger.info("📌 ログイン手順：")
                logger.info("1. ブラウザで「Log in with Google」ボタンをクリック")
                logger.info("2. Googleアカウントを選択（または入力）")
                logger.info(f"   使用するアカウント: {self.credentials.get('email', 'B2セルのGoogle ID')}")
                logger.info("3. ログイン完了を待つ")
                logger.info("4. チャット画面が表示されたら、このコンソールに戻ってEnterキーを押す")
                logger.info("")
                logger.info("💡 ヒント：")
                logger.info("  - 「Chrome は自動テスト...」メッセージは無視してください")
                logger.info("  - Googleログインは通常通り動作します")
                logger.info("  - 2回目以降はCookieで自動ログインされます")
                logger.info("="*60)
                
                input("\n✅ ログイン完了後、Enterキーを押してください: ")
                
                await self.page.wait_for_timeout(2000)
                current_url = self.page.url
                logger.info(f"ログイン後のURL: {current_url}")
                
                if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                    logger.warning("⚠️ まだログインページにいます")
                    logger.info("もう一度「Log in with Google」をクリックしてください")
                    input("完了後、Enterキーを押してください: ")
                    await self.page.wait_for_timeout(2000)
            
            # チャット画面に到達できているか確認
            await self.page.wait_for_timeout(3000)
            chat_ready = await self.page.evaluate('''
                () => {
                    const inputs = document.querySelectorAll('textarea, input[type="text"]');
                    return inputs.length > 0;
                }
            ''')
            
            if not chat_ready:
                logger.warning("⚠️ チャット画面が見つかりません")
                logger.info("ブラウザでチャット画面が表示されるまで待機してください")
                input("\n✅ チャット画面が表示されたら、Enterキーを押してください: ")
            else:
                logger.info("✅ チャット画面を確認しました")
            
            logger.info("✅ DeepSeekサイトの準備が完了しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "DeepSeekアクセス")
            logger.info("手動でDeepSeekページを開いてください")
            input("準備完了後、Enterキーを押してください: ")
    
    async def handle_welcome_screens(self) -> None:
        """利用規約やウェルカム画面を処理"""
        try:
            if not self.page:
                return
            logger.info("ウェルカム画面やポップアップを確認中...")
            continue_buttons = [
                'text=続行', 'text=開始', 'text=同意', 'text=Continue',
                'text=Get started', 'text=Agree', 'text=Got it', 'text=OK',
                '[data-testid="continue-button"]'
            ]
            start_time = time.time()
            found_buttons = 0
            while time.time() - start_time < 10 and found_buttons < 3:
                for button_selector in continue_buttons:
                    try:
                        button = await self.page.query_selector(button_selector)
                        if button and await button.is_visible():
                            await button.click()
                            await self.page.wait_for_timeout(2000)
                            logger.info(f"ボタンをクリックしました: {button_selector}")
                            found_buttons += 1
                            break
                    except Exception:
                        continue
                await self.page.wait_for_timeout(1000)
            if found_buttons > 0:
                logger.info(f"{found_buttons}個のウェルカム画面を処理しました")
            else:
                logger.info("ウェルカム画面は見つかりませんでした（正常）")
        except Exception as e:
            ErrorHandler.log_error(e, "ウェルカム画面処理")
    
    async def ensure_normal_chat_mode(self) -> None:
        """通常のチャットモードであることを確認（Storybookを回避）- 強化版"""
        try:
            if not self.page:
                return
            logger.info("チャットモードを確認中...")
            current_url = self.page.url
            if 'storybook' in current_url.lower():
                logger.warning("StorybookのURLが検出されました。通常モードに戻します...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("通常のチャットモードに戻しました")
                return
            storybook_active = await self.page.evaluate('''
                () => {
                    const buttons = document.querySelectorAll('button');
                    for (const btn of buttons) {
                        const text = btn.textContent || '';
                        const ariaLabel = btn.getAttribute('aria-label') || '';
                        if ((text.includes('Storybook') || ariaLabel.includes('Storybook')) &&
                            (btn.getAttribute('aria-pressed') === 'true' || 
                             btn.classList.contains('active') ||
                             btn.classList.contains('selected'))) {
                            return true;
                        }
                    }
                    return false;
                }
            ''')
            if storybook_active:
                logger.warning("Storybookモードが検出されました。通常モードに戻します...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("通常のチャットモードに戻しました")
            else:
                logger.info("通常のチャットモードです")
        except Exception as e:
            ErrorHandler.log_error(e, "チャットモード確認")
    
    async def send_prompt(self, prompt: str) -> None:
        """プロンプトを入力して送信（サービス自動判別版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            await self.ensure_normal_chat_mode()
            logger.info(f"プロンプトを送信中: {prompt[:50]}...")
            
            if self.service == "deepseek":
                await self.send_prompt_deepseek(prompt)
            else:
                await self.send_prompt_gemini(prompt)
                
        except Exception as e:
            ErrorHandler.log_error(e, "プロンプト送信")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_gemini(self, prompt: str) -> None:
        """Geminiでプロンプトを送信(ポップアップ対応版)"""
        try:
            # 入力欄を探す
            input_selectors = [
                'textarea[placeholder*="メッセージを Gemini に送信"]',
                'textarea[placeholder*="Send a message to Gemini"]',
                'div[contenteditable="true"][role="textbox"]',
                'textarea[data-testid="message-input"]',
                'div.ql-editor[contenteditable="true"]',
                'textarea.ql-editor',
                '[data-message-input]',
                'div[contenteditable="true"][aria-label*="メッセージ"]',
                'div[contenteditable="true"][aria-label*="message"]',
                'div[contenteditable="true"][tabindex="0"]',
                'textarea[aria-label*="Gemini"]',
                '[data-testid="input-area"] textarea',
                '[data-testid="input-area"] div[contenteditable="true"]',
            ]
            
            input_element = None
            for selector in input_selectors:
                try:
                    await self.page.wait_for_selector(selector, timeout=5000)
                    input_element = await self.page.query_selector(selector)
                    if input_element:
                        logger.info(f"入力欄を発見: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                await self.page.screenshot(path="debug_input_not_found.png")
                raise Exception("入力欄が見つかりません")
            
            # ポップアップ・オーバーレイを閉じる処理
            try:
                # 1. メール配信登録ポップアップの「後で」ボタンをクリック
                later_button_selectors = [
                    'button:has-text("後で")',
                    'button:has-text("Later")',
                    '[aria-label*="後で"]',
                    '[aria-label*="Later"]'
                ]
                
                for selector in later_button_selectors:
                    try:
                        later_button = await self.page.query_selector(selector)
                        if later_button and await later_button.is_visible():
                            await later_button.click()
                            await self.page.wait_for_timeout(1000)
                            logger.info("✅ メール配信ポップアップを閉じました")
                            break
                    except:
                        continue
                
                # 2. オーバーレイ全体を閉じる（バックドロップクリック）
                overlay_backdrop = await self.page.query_selector('.cdk-overlay-backdrop')
                if overlay_backdrop:
                    try:
                        await overlay_backdrop.click()
                        await self.page.wait_for_timeout(500)
                        logger.info("✅ オーバーレイを閉じました")
                    except:
                        pass
                
                # 3. Escキーでポップアップを閉じる（最終手段）
                await self.page.keyboard.press('Escape')
                await self.page.wait_for_timeout(500)
                
            except Exception as e:
                logger.debug(f"ポップアップ処理: {e}")
            
            # 入力欄をクリック
            await input_element.click()
            await self.page.wait_for_timeout(500)
            
            # 既存のテキストをクリア
            await self.page.keyboard.press("Control+a")
            await self.page.wait_for_timeout(500)
            
            # プロンプトを入力
            await input_element.fill(prompt)
            await self.page.wait_for_timeout(1500)
            
            # 送信ボタンをクリック
            send_selectors = [
                'button[data-testid="send-button"]',
                '[data-testid="send-button"]'
            ]
            
            sent = False
            for selector in send_selectors:
                try:
                    send_button = await self.page.query_selector(selector)
                    if send_button and await send_button.is_enabled():
                        await send_button.click()
                        logger.info("送信ボタンをクリックしました")
                        sent = True
                        break
                except:
                    continue
            
            if not sent:
                await input_element.press('Enter')
                logger.info("Enterキーで送信しました")
            
            await self.page.wait_for_timeout(3000)
            
        except Exception as e:
            ErrorHandler.log_error(e, "プロンプト送信")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_deepseek(self, prompt: str) -> None:
        """DeepSeekでプロンプトを送信（改善版）"""
        # まずスクリーンショットを撮って状態を確認
        debug_screenshot = f"debug_deepseek_before_input_{datetime.now().strftime('%H%M%S')}.png"
        try:
            await self.page.screenshot(path=debug_screenshot)
            logger.info(f"📸 入力前のスクリーンショット: {debug_screenshot}")
        except:
            pass
        
        # 複数の可能性のあるセレクタを試す
        input_selectors = [
            'textarea[placeholder*="Ask"]',
            'textarea[placeholder*="Type"]',
            'textarea[placeholder*="message"]',
            'textarea[placeholder*="メッセージ"]',
            'textarea[placeholder*="入力"]',
            'div[contenteditable="true"][role="textbox"]',
            'div[contenteditable="true"]',
            'textarea',
            'input[type="text"]',
        ]
        
        input_element = None
        used_selector = None
        
        # 各セレクタを順番に試す
        for selector in input_selectors:
            try:
                logger.info(f"入力欄を探索中: {selector}")
                element = await self.page.query_selector(selector)
                if element:
                    # 要素が見えているか確認
                    is_visible = await element.is_visible()
                    if is_visible:
                        input_element = element
                        used_selector = selector
                        logger.info(f"✅ 入力欄を発見: {selector}")
                        break
                    else:
                        logger.info(f"要素は存在するが非表示: {selector}")
            except Exception as e:
                logger.debug(f"セレクタ {selector} でエラー: {e}")
                continue
        
        if not input_element:
            # 全セレクタで失敗した場合
            await self.page.screenshot(path="debug_deepseek_input_not_found.png")
            logger.error("❌ DeepSeek入力欄が見つかりません")
            logger.error("以下を確認してください：")
            logger.error("1. ログインが完了していますか？")
            logger.error("2. チャット画面が表示されていますか？")
            logger.error("3. Cloudflareの検証は完了しましたか？")
            
            # ページのHTMLをデバッグ出力
            page_content = await self.page.evaluate('document.body.innerText')
            logger.info(f"ページ内容（先頭500文字）:\n{page_content[:500]}")
            
            # 手動介入を促す
            logger.info("\n手動で入力欄が見えるまで操作してください")
            input("入力欄が表示されたら、Enterキーを押してください: ")
            
            # 再度探す
            for selector in input_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element and await element.is_visible():
                        input_element = element
                        used_selector = selector
                        logger.info(f"✅ 入力欄を発見（2回目）: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                raise Exception("入力欄が見つかりません（2回目の試行後）")
        
        # 入力欄にフォーカス
        await input_element.click()
        await self.page.wait_for_timeout(500)
        
        # プロンプトを入力
        await input_element.fill(prompt)
        await self.page.wait_for_timeout(1500)
        
        # 送信ボタンを探す
        send_button = None
        send_selectors = [
            'button[type="submit"]',
            'button[aria-label*="Send"]',
            'button[aria-label*="送信"]',
            'button:has-text("送信")',
            'button:has-text("Send")',
            'button svg',  # アイコンボタン
        ]
        
        for selector in send_selectors:
            try:
                btn = await self.page.query_selector(selector)
                if btn and await btn.is_visible() and await btn.is_enabled():
                    send_button = btn
                    logger.info(f"送信ボタンを発見: {selector}")
                    break
            except:
                continue
        
        if send_button:
            await send_button.click()
            logger.info("✅ DeepSeek送信ボタンをクリックしました")
        else:
            # ボタンが見つからない場合はEnterキーで送信
            logger.info("送信ボタンが見つからないため、Enterキーで送信します")
            await input_element.press("Enter")
            logger.info("✅ Enterキーで送信しました")
        
        await self.page.wait_for_timeout(3000)
    
    async def wait_for_text_generation(self, max_wait: int = 120) -> bool:
        """テキスト生成完了まで待機"""
        try:
            if not self.page:
                return False
            logger.info("テキスト生成を待機中...")
            start_time = time.time()
            check_interval = 2
            await self.page.wait_for_timeout(5000)
            while time.time() - start_time < max_wait:
                await self.page.wait_for_timeout(check_interval * 1000)
                elapsed = int(time.time() - start_time)
                is_complete = await self.page.evaluate('''
                    () => {
                        const allButtons = document.querySelectorAll('button');
                        for (const btn of allButtons) {
                            const text = btn.textContent || '';
                            const ariaLabel = btn.getAttribute('aria-label') || '';
                            if (text.includes('再生成') || text.includes('Regenerate') ||
                                ariaLabel.includes('再生成') || ariaLabel.includes('Regenerate')) {
                                return true;
                            }
                        }
                        const sendButtons = document.querySelectorAll('[data-testid="send-button"], button[type="submit"]');
                        for (const btn of sendButtons) {
                            if (!btn.disabled && !btn.hasAttribute('disabled')) {
                                return true;
                            }
                        }
                        const loadingElements = document.querySelectorAll('[data-testid="loading"], .loading, .spinner');
                        if (loadingElements.length === 0) {
                            return true;
                        }
                        return false;
                    }
                ''')
                if is_complete:
                    logger.info(f"✅ テキスト生成完了を検出")
                    await self.page.wait_for_timeout(2000)
                    return True
                if elapsed % 10 == 0 and elapsed > 0:
                    logger.info(f"⏳ 待機中... {elapsed}秒経過")
            logger.warning(f"⏰ タイムアウト（{max_wait}秒）")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, "テキスト生成待機")
            return False
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """
        プロンプト送信と応答待機を一括処理（推奨インターフェース）
        
        Args:
            prompt: 送信するプロンプト
            max_wait: 最大待機時間（秒）
            
        Returns:
            bool: 成功時 True
        """
        try:
            # プロンプト送信
            await self.send_prompt(prompt)
            
            # 応答待機
            success = await self.wait_for_text_generation(max_wait)
            
            if success:
                logger.info("✅ プロンプト送信と応答待機が完了しました")
            else:
                logger.warning("⚠️ プロンプト送信は成功しましたが、応答待機がタイムアウトしました")
            
            return success
            
        except Exception as e:
            logger.error(f"❌ プロンプト送信と待機中にエラー: {e}")
            return False

    
    async def extract_latest_text_response(self) -> str:
        """最新のテキスト応答を抽出（サービス自動判別版）"""
        try:
            if self.service == "deepseek":
                return await self.extract_latest_text_response_deepseek()
            else:
                return await self.extract_latest_text_response_gemini()
        except Exception as e:
            ErrorHandler.log_error(e, "テキスト抽出")
            return None
    
    async def extract_latest_text_response_gemini(self) -> str:
        """Geminiの最新のテキスト応答を抽出（コード完全性検証ロジック修正版）"""
        try:
            logger.info("=" * 60)
            logger.info("★★★ Geminiテキスト抽出開始 ★★★")
            logger.info("=" * 60)
            
            all_results = {}
            
            # 方法1: モデルメッセージのデータ属性から取得
            try:
                method1_text = await self.page.evaluate('''() => {
                    const modelMessages = document.querySelectorAll('[data-message-author="model"]');
                    if (modelMessages.length === 0) return null;
                    
                    const latestMessage = modelMessages[modelMessages.length - 1];
                    return latestMessage.innerText || latestMessage.textContent || '';
                }''')
                all_results['方法1'] = method1_text
                logger.info(f"方法1結果: {len(method1_text) if method1_text else 0}文字")
            except Exception as e:
                logger.debug(f"方法1失敗: {e}")
                all_results['方法1'] = None

            # 方法2: マークダウンコンテンツから取得
            try:
                method2_text = await self.page.evaluate('''() => {
                    const markdownContainers = document.querySelectorAll('[class*="markdown"]');
                    if (markdownContainers.length === 0) return null;
                    
                    let longest = '';
                    for (const container of markdownContainers) {
                        const text = container.innerText || container.textContent || '';
                        if (text.length > longest.length) {
                            longest = text;
                        }
                    }
                    return longest;
                }''')
                all_results['方法2'] = method2_text
                logger.info(f"方法2結果: {len(method2_text) if method2_text else 0}文字")
            except Exception as e:
                logger.debug(f"方法2失敗: {e}")
                all_results['方法2'] = None

            # 方法3: メッセージクラスから取得
            try:
                method3_text = await self.page.evaluate('''() => {
                    const messages = document.querySelectorAll('[class*="message"]');
                    if (messages.length === 0) return null;
                    
                    let modelTexts = [];
                    for (const msg of messages) {
                        const text = msg.innerText || msg.textContent || '';
                        // ユーザーメッセージを除外（短いまたは特定のパターン）
                        if (text.length > 100 && 
                            !text.includes('あなたは経験豊富な') &&
                            !text.includes('【あなたの役割】') &&
                            !text.includes('【執筆依頼】')) {
                            modelTexts.push(text);
                        }
                    }
                    return modelTexts.length > 0 ? modelTexts[modelTexts.length - 1] : null;
                }''')
                all_results['方法3'] = method3_text
                logger.info(f"方法3結果: {len(method3_text) if method3_text else 0}文字")
            except Exception as e:
                logger.debug(f"方法3失敗: {e}")
                all_results['方法3'] = None
            
            # 優先順位で選択（コード完全性検証を緩和）
            priority_order = ['方法1', '方法2', '方法3']
            best_result = None
            best_method = None
            
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 100:
                    text = all_results[method]
                    
                    # プロンプトが混入していないか最終チェック
                    if ('あなたは経験豊富な' in text or 
                        '【あなたの役割】' in text or
                        '【執筆依頼】' in text):
                        logger.warning(f"{method}にプロンプトが混入 - スキップ")
                        continue
                    
                    # コードブロック検証（緩和版）
                    validation_result = self._validate_code_block_completeness_enhanced(text)
                    
                    if validation_result['is_complete']:
                        logger.info(f"✅ {method}: 完全な応答を検出")
                        best_result = text.strip()
                        best_method = method
                        break
                    else:
                        # 不完全でも長文の場合は警告を出して採用する
                        if len(text) > 1500:  # 長文の場合は許容
                            logger.warning(f"⚠️ {method}: 不完全だが長文のため採用 - {validation_result['reason']}")
                            best_result = text.strip()
                            best_method = method
                            break
                        else:
                            logger.warning(f"⚠️ {method}: 不完全な応答 - {validation_result['reason']}")
            
            if best_result:
                logger.info(f"\n🎯 採用: {best_method} ({len(best_result)}文字)")
                logger.info(f"先頭200文字:\n{best_result[:200]}")
                return best_result
            
            # すべて失敗した場合でも、最長のテキストを返す（最終手段）
            fallback_text = None
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 500:
                    fallback_text = all_results[method]
                    logger.warning(f"⚠️ フォールバック採用: {method} ({len(fallback_text)}文字)")
                    break
            
            if fallback_text:
                return fallback_text.strip()
            
            # 本当に何も取得できない場合
            logger.error("\n❌ 全方法失敗 - Geminiの応答が取得できませんでした")
            
            # デバッグ用: ページの構造を確認
            page_structure = await self.page.evaluate('''() => {
                return {
                    messageCount: document.querySelectorAll('[class*="message"]').length,
                    modelMessages: document.querySelectorAll('[data-message-author="model"]').length,
                    markdownContainers: document.querySelectorAll('[class*="markdown"]').length
                };
            }''')
            logger.info(f"ページ構造: {page_structure}")
            
            return None
                    
        except Exception as e:
            logger.error(f"❌ 抽出全体エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
        
    def _validate_code_block_completeness_enhanced(self, text: str) -> Dict:
        """
        コードブロックの完全性を検証(緩和版 - 専門文書・長文対応強化)
            
        Returns:
            Dict: {
                'is_complete': bool,
                'reason': str,
                'details': str,
                'incomplete_blocks': List[Dict]
            }
        """
        try:
            # コードブロック(```)のペアチェック(主要チェック)
            code_fence_pattern = r'```(\w+)?\n(.*?)```'
            code_blocks = re.findall(code_fence_pattern, text, re.DOTALL)
                
            # 開始タグのみで終了タグがないパターンを検出
            open_fences = re.findall(r'```(\w+)?(?![\s\S]*?```)', text, re.DOTALL)
                
            if open_fences:
                # 閉じられていないコードブロックを検出
                incomplete_blocks = []
                for lang in open_fences:
                    # 該当箇所のスニペットを取得
                    pattern = f'```{lang}' if lang else '```'
                    idx = text.find(pattern)
                    snippet = text[idx:idx+100] + '...' if idx != -1 else 'N/A'
                        
                    incomplete_blocks.append({
                        'type': f'code({lang})' if lang else 'code(unknown)',
                        'snippet': snippet
                    })
                    
                return {
                    'is_complete': False,
                    'reason': 'コードブロックが閉じられていません',
                    'details': f'{len(open_fences)}個の未閉じブロックを検出',
                    'incomplete_blocks': incomplete_blocks
                }
                
            # PHPコードの完全性チェック
            if '<?php' in text:
                php_blocks = re.findall(r'```php\n(.*?)```', text, re.DOTALL)
                for php_code in php_blocks:
                    # 関数定義の開始と終了の波括弧の数をチェック
                    open_braces = php_code.count('{')
                    close_braces = php_code.count('}')
                        
                    if open_braces > close_braces:
                        # 最後の10行を取得
                        last_lines = '\n'.join(php_code.split('\n')[-10:])
                            
                        return {
                            'is_complete': False,
                            'reason': 'PHPコードの波括弧が閉じられていません',
                            'details': f'開始: {open_braces}, 終了: {close_braces}',
                            'incomplete_blocks': [{
                                'type': 'php',
                                'snippet': f'...最後の10行:\n{last_lines}'
                            }]
                        }
                
            # JSONコードの完全性チェック
            json_blocks = re.findall(r'```json\n(.*?)```', text, re.DOTALL)
            for json_code in json_blocks:
                try:
                    json.loads(json_code)
                except json.JSONDecodeError as e:
                    return {
                        'is_complete': False,
                        'reason': 'JSONコードが不正です',
                        'details': f'JSONエラー: {str(e)}',
                        'incomplete_blocks': [{
                            'type': 'json',
                            'snippet': json_code[-200:] if len(json_code) > 200 else json_code
                        }]
                    }
                
            # ========================================
            # 🔧 Pydanticモデル定義の検証（新規追加）
            # ========================================
            if 'from pydantic import' in text or 'class ' in text and 'BaseModel' in text:
                # Pydanticモデル定義のクラス構造チェック
                pydantic_class_pattern = r'class\s+(\w+)\(BaseModel\):(.*?)(?=\nclass\s|\Z)'
                pydantic_classes = re.findall(pydantic_class_pattern, text, re.DOTALL)
                    
                for class_name, class_body in pydantic_classes:
                    # クラス本体が空でないか確認
                    if not class_body.strip():
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticモデル {class_name} の定義が空です',
                            'details': 'クラス本体にフィールド定義が必要',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': f'class {class_name}(BaseModel): ...'
                            }]
                        }
                        
                    # フィールド定義が少なくとも1つあるか確認
                    field_pattern = r'^\s+\w+:\s*\w+'
                    if not re.search(field_pattern, class_body, re.MULTILINE):
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticモデル {class_name} にフィールド定義がありません',
                            'details': 'モデルには少なくとも1つのフィールドが必要',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': class_body[:200]
                            }]
                        }
                
            # ========================================
            # 🔧 OpenAPIスキーマの検証（新規追加）
            # ========================================
            if 'openapi:' in text.lower() or '"openapi"' in text.lower():
                # OpenAPI/Swaggerスキーマの基本構造をチェック
                required_openapi_keys = ['openapi', 'info', 'paths']
                    
                # YAMLまたはJSON形式の検出
                if 'openapi:' in text:
                    # YAML形式の検証
                    for key in required_openapi_keys:
                        if f'{key}:' not in text:
                            return {
                                'is_complete': False,
                                'reason': f'OpenAPIスキーマに必須キー "{key}" がありません',
                                'details': 'OpenAPIスキーマには openapi, info, paths が必要',
                                'incomplete_blocks': [{
                                    'type': 'openapi_yaml',
                                    'snippet': text[:300]
                                }]
                            }
                else:
                    # JSON形式の検証
                    try:
                        # JSON抽出試行
                        json_match = re.search(r'\{.*\}', text, re.DOTALL)
                        if json_match:
                            openapi_json = json.loads(json_match.group(0))
                            for key in required_openapi_keys:
                                if key not in openapi_json:
                                    return {
                                        'is_complete': False,
                                        'reason': f'OpenAPIスキーマに必須キー "{key}" がありません',
                                        'details': 'OpenAPIスキーマには openapi, info, paths が必要',
                                        'incomplete_blocks': [{
                                            'type': 'openapi_json',
                                            'snippet': json_match.group(0)[:300]
                                        }]
                                    }
                    except (json.JSONDecodeError, AttributeError):
                        pass  # JSON形式でない場合はスキップ
                
            # ========================================
            # 🔧 文章の突然の終了チェックを大幅緩和（専門文書対応）
            # ========================================
            text_stripped = text.strip()
            if text_stripped:
                last_char = text_stripped[-1]
                    
                # 専門文書や技術文書の終了パターンを拡張
                japanese_section_endings = [
                    '項', '章', '目', '節', '条', '款', '点',  # 既存
                    '。', '）', ')', '}', ']', '`', '>', '"',  # 新規追加
                    '了', '成', '定', '明', '示', '用', '理'   # 専門用語末尾
                ]
                    
                # 厳格な終了文字リスト（これらで終わればOK）
                strict_end_chars = ['.', '。', '!', '!', '?', '?', '`', '}', ']', ')']
                    
                if (last_char not in strict_end_chars and 
                    last_char not in japanese_section_endings and
                    not text_stripped.endswith('```')):
                        
                    # ========================================
                    # 🔧 長文・専門文書の場合は大幅に緩和（新ロジック）
                    # ========================================
                        
                    # 条件1: 3000文字以上の超長文は終了文字をチェックしない
                    if len(text_stripped) > 3000:
                        logger.info(f"✅ 超長文({len(text_stripped)}文字)のため終了文字チェックをスキップ")
                        return {
                            'is_complete': True,
                            'reason': '超長文のため終了文字チェックを免除',
                            'details': f'文字数: {len(text_stripped)}, 最後の文字: {last_char}'
                        }
                        
                    # 条件2: 2000文字以上でコードブロックが3個以上ある場合は許容
                    if len(text_stripped) > 2000 and len(code_blocks) >= 3:
                        logger.info(f"✅ 長文({len(text_stripped)}文字)かつコードブロック{len(code_blocks)}個のため許容")
                        return {
                            'is_complete': True,
                            'reason': '長文かつ多数のコードブロックを含むため許容',
                            'details': f'文字数: {len(text_stripped)}, コードブロック数: {len(code_blocks)}'
                        }
                        
                    # 条件3: Pydanticモデルやスキーマ定義を含む場合は許容
                    if ('from pydantic import' in text or 
                        'class ' in text and 'BaseModel' in text or
                        'openapi:' in text.lower()):
                        logger.info("✅ 専門的な技術文書(Pydantic/OpenAPI)のため許容")
                        return {
                            'is_complete': True,
                            'reason': '専門的な技術文書として許容',
                            'details': 'Pydanticモデルまたはスキーマ定義を含む'
                        }
                        
                    # 条件4: 1500文字以上で「まとめ」「結論」「以上」などの締めくくり表現がある場合
                    conclusion_patterns = [
                        'まとめ', '結論', '以上', '完了', '終わり',
                        'summary', 'conclusion', 'end', 'complete'
                    ]
                    if len(text_stripped) > 1500 and any(pattern in text_stripped[-500:].lower() for pattern in conclusion_patterns):
                        logger.info("✅ 長文で締めくくり表現を含むため許容")
                        return {
                            'is_complete': True,
                            'reason': '長文で締めくくり表現を含む',
                            'details': f'文字数: {len(text_stripped)}'
                        }
                        
                    # 上記条件に該当しない短文は不完全と判定
                    if len(text_stripped) < 1500:
                        last_50_chars = text_stripped[-50:]
                            
                        return {
                            'is_complete': False,
                            'reason': '文章が途中で切れている可能性があります',
                            'details': f'最後の文字: "{last_char}"',
                            'incomplete_blocks': [{
                                'type': 'text',
                                'snippet': f'...最後の50文字: {last_50_chars}'
                            }]
                        }
                    else:
                        # 1500文字以上だが条件に該当しない場合は警告のみで許容
                        logger.warning(f"⚠️ 長文({len(text_stripped)}文字)だが終了文字が不明瞭: '{last_char}'")
                        return {
                            'is_complete': True,
                            'reason': '長文のため警告付きで許容',
                            'details': f'文字数: {len(text_stripped)}, 最後の文字: {last_char}'
                        }
                
            # すべてのチェックをパス
            return {
                'is_complete': True,
                'reason': 'すべての検証に合格',
                'details': f'コードブロック数: {len(code_blocks)}'
            }
                
        except Exception as e:
            logger.error(f"コード完全性検証エラー: {e}")
            # エラー時は安全側に倒して不完全とみなす
            return {
                'is_complete': False,
                'reason': '検証処理でエラー発生',
                'details': str(e),
                'incomplete_blocks': []
            }
    
    async def extract_latest_text_response_deepseek(self) -> str:
        """DeepSeekの最新のテキスト応答を抽出（改良版）"""
        try:
            logger.info("=" * 60)
            logger.info("★★★ DeepSeekテキスト抽出開始 ★★★")
            logger.info("=" * 60)
            
            # DeepSeek特有のセレクタで応答を取得
            response_text = await self.page.evaluate('''() => {
                // メッセージコンテナを探す
                const messages = document.querySelectorAll('[class*="message"], [class*="chat"], div[role="article"]');
                let longest = '';
                
                for (const msg of messages) {
                    const text = msg.innerText || '';
                    // ユーザーのメッセージは除外
                    if (text.length > 100 && text.length > longest.length) {
                        // システムやアシスタントのメッセージのみ
                        const isUserMessage = msg.querySelector('[class*="user"]') || 
                                            msg.classList.toString().includes('user');
                        if (!isUserMessage) {
                            longest = text;
                        }
                    }
                }
                
                if (!longest) {
                    // フォールバック: 最後の長いdivを取得
                    const divs = document.querySelectorAll('div');
                    for (const d of divs) {
                        const t = d.innerText || '';
                        if (t.length > longest.length && t.length > 200) {
                            longest = t;
                        }
                    }
                }
                
                return longest;
            }''')
            
            if response_text and len(response_text) > 50:
                logger.info(f"✅ DeepSeek応答抽出成功: {len(response_text)}文字")
                logger.info(f"先頭500文字:\n{response_text[:500]}")
                
                # 検証を実行（緩和版）
                validation_result = self._validate_code_block_completeness_enhanced(response_text)
                
                if not validation_result['is_complete'] and len(response_text) > 1500:
                    logger.warning(f"⚠️ DeepSeek応答不完全だが長文のため採用: {validation_result['reason']}")
                    # 長文の場合は不完全でも採用
                    return response_text.strip()
                elif validation_result['is_complete']:
                    logger.info("✅ DeepSeek応答検証合格")
                    return response_text.strip()
                else:
                    logger.warning(f"⚠️ DeepSeek応答不完全: {validation_result['reason']}")
                    return response_text.strip()  # 不完全でも返す（以前はNoneを返していた）
            else:
                logger.error("❌ DeepSeek応答が見つかりません")
                return None
                
        except Exception as e:
            logger.error(f"❌ DeepSeek抽出エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    # === 既存のメソッドは変更なし（extract_json_from_text など） ===

    # 旧バージョンのメソッドを新しいメソッドで置き換えるための互換性レイヤー
    def _validate_code_block_completeness(self, text: str) -> Dict:
        """
        旧バージョンのメソッド - 新しいメソッドを呼び出す
        （既存コードとの互換性維持のため）
        """
        return self._validate_code_block_completeness_enhanced(text)

    def extract_json_from_text(self, text: str) -> str:
        """テキストからJSON部分を抽出"""
        try:
            if not text:
                return None
                
            # パターン1: ```json ... ``` に囲まれたJSON
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # パターン2: 単純なJSONオブジェクトの抽出
            json_match = re.search(r'^\s*(\{.*\})\s*$', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # パターン3: 先頭からJSONを探す
            start_idx = text.find('{')
            if start_idx != -1:
                # { から始めて、対応する } までを探す
                brace_count = 0
                for i, char in enumerate(text[start_idx:]):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            potential_json = text[start_idx:start_idx+i+1]
                            try:
                                json.loads(potential_json)
                                return potential_json.strip()
                            except:
                                continue
            return None
        except Exception as e:
            logger.error(f"JSON抽出エラー: {e}")
            return None
        
    

#browser_controller.py
# browser_controller.py
"""ブラウザ制御クラス（分割リファクタリング版）"""
import asyncio
from pathlib import Path
from typing import Optional, Dict
import logging

from browser_lifecycle import BrowserLifecycleManager
from brower_cookie_and_session import CookieSessionManager  # ファイル名修正
from browser_ai_chat_agent import AIChatAgent
from browser_wp_session_manager import WPSessionManager
from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserController:
    """ブラウザ制御ファサードクラス"""
    
    def __init__(self, download_folder: Path, mode: str = "image", service: str = "google", credentials: Dict = None):
        self.download_folder = download_folder
        self.mode = mode
        self.service = service.lower()
        self.credentials = credentials or {}
        
        # 設定ファイルのパス
        self.cookies_file = Path(config.COOKIES_FILE) if config.COOKIES_FILE else None
        self.browser_data_dir = Path(config.BROWSER_DATA_DIR) if config.BROWSER_DATA_DIR else None
        self.wp_cookies_file = Path(config.BROWSER_DATA_DIR) / "wp_cookies.json" if config.BROWSER_DATA_DIR else None
        
        # マネージャーの初期化（setup_browserで完全初期化）
        self.lifecycle_manager: Optional[BrowserLifecycleManager] = None
        self.session_manager: Optional[CookieSessionManager] = None
        self.ai_agent: Optional[AIChatAgent] = None
        self.wp_manager: Optional[WPSessionManager] = None
    
    async def setup_browser(self) -> None:
        """ブラウザのセットアップ - すべてのマネージャーを初期化"""
        try:
            # ライフサイクルマネージャーの初期化とセットアップ
            self.lifecycle_manager = BrowserLifecycleManager(
                browser_data_dir=self.browser_data_dir,
                download_folder=self.download_folder
            )
            await self.lifecycle_manager.setup_browser()
            
            # セッションマネージャーの初期化
            self.session_manager = CookieSessionManager(
                context=self.lifecycle_manager.context,
                cookies_file=self.cookies_file
            )
            
            # AIチャットエージェントの初期化
            self.ai_agent = AIChatAgent(
                page=self.lifecycle_manager.page,
                service=self.service,
                credentials=self.credentials
            )
            
            # WordPressセッションマネージャーの初期化
            self.wp_manager = WPSessionManager(
                context=self.lifecycle_manager.context,
                wp_cookies_file=self.wp_cookies_file
            )
            
            logger.info(f"✅ ブラウザ制御ファサード初期化完了（サービス: {self.service}）")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ブラウザファサードセットアップ")
            raise
    
    # プロパティの委譲
    @property
    def context(self):
        return self.lifecycle_manager.context if self.lifecycle_manager else None
    
    @property
    def page(self):
        return self.lifecycle_manager.page if self.lifecycle_manager else None
    
    @property
    def wp_page(self):
        return self.wp_manager.wp_page if self.wp_manager else None
    
    @property
    def is_logged_in(self):
        return self.wp_manager.is_logged_in if self.wp_manager else False
    
    # AIチャット関連メソッドの委譲
    async def navigate_to_gemini(self) -> None:
        """Geminiにナビゲート - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.navigate_to_gemini()
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekにナビゲート - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.navigate_to_deepseek()
    
    async def send_prompt(self, prompt: str) -> None:
        """プロンプト送信 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.send_prompt(prompt)
    
    async def wait_for_text_generation(self, max_wait: int = 180) -> bool:
        """
        テキスト生成完了を待機（強化版）
            
        Args:
            max_wait: 最大待機時間（秒）
                
        Returns:
            bool: 生成完了フラグ
        """
        try:
            logger.info(f"⏱️ テキスト生成待機開始（最大{max_wait}秒）")
                
            start_time = asyncio.get_event_loop().time()
            check_interval = 2.0  # 2秒ごとにチェック
            last_length = 0
            stable_count = 0
            required_stable = 3  # 3回連続で変化なしで完了と判定
                
            while True:
                elapsed = asyncio.get_event_loop().time() - start_time
                    
                if elapsed > max_wait:
                    logger.warning(f"⏱️ タイムアウト（{max_wait}秒）")
                    return False
                    
                # 現在のテキスト長を取得
                try:
                    current_text = await self._get_current_text_quick()
                    current_length = len(current_text)
                        
                    # テキストが増えているか確認
                    if current_length > last_length:
                        logger.info(f"📝 生成中: {current_length}文字（経過: {int(elapsed)}秒）")
                        last_length = current_length
                        stable_count = 0
                    else:
                        # 長さが変わらない
                        stable_count += 1
                        logger.info(f"⏸️ 安定: {stable_count}/{required_stable}（{current_length}文字）")
                            
                        if stable_count >= required_stable:
                            logger.info(f"✅ 生成完了（{current_length}文字、{int(elapsed)}秒）")
                            return True
                    
                except Exception as e:
                    logger.warning(f"⚠️ チェックエラー: {e}")
                    
                # 待機
                await asyncio.sleep(check_interval)
            
        except Exception as e:
            logger.error(f"❌ 待機エラー: {e}")
            return False
    
    async def extract_latest_text_response(self, allow_partial: bool = True) -> Optional[str]:
        """
        最新のテキスト応答を抽出（強化版）
        
        Args:
            allow_partial: 部分的な応答も許可するか
            
        Returns:
            Optional[str]: 抽出されたテキスト
        """
        try:
            logger.info("="*60)
            logger.info("★★★ Gemini応答抽出開始（強化版） ★★★")
            logger.info("="*60)
            
            results = {}
            
            # ============================================================
            # === 方法1: model-response-text クラス ===
            # ============================================================
            try:
                message_divs = await self.page.query_selector_all('div.model-response-text')
                if message_divs:
                    last_message = message_divs[-1]
                    text1 = await last_message.inner_text()
                    if text1 and len(text1) > 100:
                        results['method1'] = text1
                        logger.info(f"✅ 方法1成功: {len(text1)}文字")
            except Exception as e:
                logger.warning(f"⚠️ 方法1失敗: {e}")
            
            # ============================================================
            # === 方法2: markdown-container クラス ===
            # ============================================================
            try:
                markdown_divs = await self.page.query_selector_all('div.markdown-container')
                if markdown_divs:
                    last_markdown = markdown_divs[-1]
                    text2 = await last_markdown.inner_text()
                    if text2 and len(text2) > 100:
                        results['method2'] = text2
                        logger.info(f"✅ 方法2成功: {len(text2)}文字")
            except Exception as e:
                logger.warning(f"⚠️ 方法2失敗: {e}")
            
            # ============================================================
            # === 方法3: message-content クラス ===
            # ============================================================
            try:
                content_divs = await self.page.query_selector_all('div.message-content')
                if content_divs:
                    # 最後のメッセージコンテンツ
                    for div in reversed(content_divs):
                        text3 = await div.inner_text()
                        if text3 and len(text3) > 100 and 'model-response' not in text3.lower():
                            results['method3'] = text3
                            logger.info(f"✅ 方法3成功: {len(text3)}文字")
                            break
            except Exception as e:
                logger.warning(f"⚠️ 方法3失敗: {e}")
            
            # ============================================================
            # === 方法4: data-test-id 属性 ===
            # ============================================================
            try:
                test_divs = await self.page.query_selector_all('[data-test-id*="conversation-turn"]')
                if test_divs:
                    last_turn = test_divs[-1]
                    text4 = await last_turn.inner_text()
                    if text4 and len(text4) > 100:
                        results['method4'] = text4
                        logger.info(f"✅ 方法4成功: {len(text4)}文字")
            except Exception as e:
                logger.warning(f"⚠️ 方法4失敗: {e}")
            
            # ============================================================
            # === 結果選択（最長のものを選択） ===
            # ============================================================
            if not results:
                logger.error("❌ 全方法失敗 - 応答が取得できませんでした")
                
                # デバッグ情報
                try:
                    page_content = await self.page.content()
                    logger.info(f"📄 ページ長: {len(page_content)}文字")
                except:
                    pass
                
                return None
            
            # 最も長いテキストを選択
            best_method = max(results.items(), key=lambda x: len(x[1]))
            selected_text = best_method[1]
            
            logger.info(f"✅ 最適結果選択: {best_method[0]} ({len(selected_text)}文字)")
            
            # ============================================================
            # === 品質チェック（緩和版） ===
            # ============================================================
            warnings = []
            
            # 長さチェック
            if len(selected_text) < 500:
                warnings.append(f'短い応答（{len(selected_text)}文字）')
            
            # コードブロックチェック（緩和）
            if allow_partial:
                # 部分的なコードブロックも許可
                if '```' in selected_text:
                    open_count = selected_text.count('```')
                    if open_count % 2 != 0:
                        warnings.append('コードブロック未完結（許可）')
            else:
                # 厳密なチェック
                open_blocks = selected_text.count('```')
                if open_blocks % 2 != 0:
                    warnings.append('コードブロック未完結')
            
            # 警告表示
            if warnings:
                logger.warning("⚠️ 品質警告:")
                for w in warnings:
                    logger.warning(f"  - {w}")
            
            # 部分応答も許可する場合は、警告があっても返す
            if allow_partial:
                logger.info("✅ 部分応答を許可 - そのまま返却")
                return selected_text
            
            # 厳密モードの場合、重大な問題があればNone
            if len(selected_text) < 100:
                logger.error("❌ 応答が短すぎる（100文字未満）")
                return None
            
            logger.info("="*60)
            logger.info(f"✅ 応答抽出完了: {len(selected_text)}文字")
            logger.info("="*60)
            
            return selected_text
        
        except Exception as e:
            logger.error(f"❌ 応答抽出エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """プロンプト送信と待機 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        return await self.ai_agent.send_prompt_and_wait(prompt, max_wait)
    
    # クッキー管理の委譲
    async def save_cookies(self) -> None:
        """クッキー保存 - セッションマネージャーに委譲"""
        if not self.session_manager:
            raise Exception("セッションマネージャーが初期化されていません")
        await self.session_manager.save_cookies()
    
    async def load_cookies(self) -> bool:
        """クッキー読み込み - セッションマネージャーに委譲"""
        if not self.session_manager:
            logger.warning("セッションマネージャーが初期化されていません")
            return False
        return await self.session_manager.load_cookies()
    
    # WordPress関連メソッドの委譲
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """WordPressセッション初期化 - WPマネージャーに委譲"""
        if not self.wp_manager:
            raise Exception("WordPressマネージャーが初期化されていません")
        return await self.wp_manager.initialize_wp_session(auth_module)
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressクッキー保存 - WPマネージャーに委譲"""
        if not self.wp_manager:
            raise Exception("WordPressマネージャーが初期化されていません")
        return await self.wp_manager.save_wordpress_cookies(wp_url)
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressクッキー読み込み - WPマネージャーに委譲"""
        if not self.wp_manager:
            raise Exception("WordPressマネージャーが初期化されていません")
        return await self.wp_manager.load_wordpress_cookies(wp_url)
    
    # クリーンアップの委譲
    async def cleanup(self) -> None:
        """リソースクリーンアップ - ライフサイクルマネージャーに委譲"""
        # WordPressセッションを閉じる
        if self.wp_manager:
            await self.wp_manager.close_wp_session()
        
        # メインのブラウザリソースをクリーンアップ
        if self.lifecycle_manager:
            await self.lifecycle_manager.cleanup()
    
    # ユーティリティメソッド
    async def save_text_to_file(self, text: str, filename: str) -> bool:
        """テキストファイル保存 - ユーティリティとして維持"""
        try:
            save_path = self.download_folder / filename
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(text)
            if save_path.exists():
                file_size = save_path.stat().st_size
                logger.info(f"✅ テキスト保存成功: {filename} ({file_size:,} bytes)")
                return True
            else:
                logger.error(f"❌ テキスト保存失敗: {filename}")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "テキストファイル保存")
            return False
    
    # 後方互換性のためのメソッド
    async def _is_browser_alive(self) -> bool:
        """ブラウザ生存確認 - ライフサイクルマネージャーに委譲"""
        if not self.lifecycle_manager:
            return False
        return await self.lifecycle_manager._is_browser_alive()
    
    async def handle_welcome_screens(self) -> None:
        """ウェルカム画面処理 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.handle_welcome_screens()
    
    async def ensure_normal_chat_mode(self) -> None:
        """通常チャットモード確認 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.ensure_normal_chat_mode()
    
    # 非推奨メソッド（後方互換性のため）
    async def _wait_for_generation_complete(self, max_wait: int = 120) -> bool:
        """非推奨メソッド - 後方互換性のため維持"""
        logger.warning("⚠️ 非推奨メソッド _wait_for_generation_complete が呼び出されました")
        return await self.wait_for_text_generation(max_wait)
    
async def ensure_browser_ready(self) -> bool:
    """
    ブラウザの準備完了を確認（セッション管理強化版）
        
    Returns:
        bool: 準備完了フラグ
    """
    try:
        # ブラウザが起動しているか確認
        if not self.browser:
            logger.error("❌ ブラウザが起動していません")
            return False
            
        # コンテキストが有効か確認
        if not self.context:
            logger.error("❌ ブラウザコンテキストがありません")
            return False
            
        # ページが有効か確認
        if not self.page:
            logger.error("❌ ページがありません")
            return False
            
        # ページが閉じられていないか確認
        try:
            is_closed = self.page.is_closed()
            if is_closed:
                logger.error("❌ ページが閉じられています - 再作成")
                self.page = await self.context.new_page()
                await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
                await asyncio.sleep(3)
                logger.info("✅ ページを再作成しました")
        except Exception as e:
            logger.warning(f"⚠️ ページ状態確認エラー: {e}")
            
        # Geminiページにいるか確認
        current_url = self.page.url
        if 'gemini.google.com' not in current_url:
            logger.warning(f"⚠️ Geminiページではありません: {current_url}")
            logger.info("🔄 Geminiページに移動中...")
            await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
            await asyncio.sleep(3)
            
        logger.info("✅ ブラウザ準備完了")
        return True
        
    except Exception as e:
        logger.error(f"❌ ブラウザ準備確認エラー: {e}")
        return False
    
async def send_prompt(self, prompt: str) -> bool:
    """
    プロンプト送信（セッション管理付き）
        
    Args:
        prompt: 送信するプロンプト
            
    Returns:
        bool: 送信成功フラグ
    """
    try:
        # ブラウザ準備確認
        if not await self.ensure_browser_ready():
            logger.error("❌ ブラウザが準備できていません")
            return False
            
        logger.info("📤 プロンプト送信中...")
            
        # プロンプト入力欄を探す
        input_selectors = [
            'textarea[placeholder*="メッセージ"]',
            'textarea[aria-label*="メッセージ"]',
            'div[contenteditable="true"]',
            'textarea.ql-editor',
            'div.ql-editor'
        ]
            
        input_box = None
        for selector in input_selectors:
            try:
                input_box = await self.page.wait_for_selector(selector, timeout=5000)
                if input_box:
                    break
            except:
                continue
            
        if not input_box:
            logger.error("❌ 入力欄が見つかりません")
            return False
            
        # プロンプト入力
        await input_box.click()
        await asyncio.sleep(0.5)
        await input_box.fill(prompt)
        await asyncio.sleep(1)
            
        # 送信ボタンクリック
        send_button = await self.page.query_selector('button[aria-label*="送信"]')
        if send_button:
            await send_button.click()
            logger.info("✅ プロンプト送信完了")
            return True
        else:
            # Enterキーで送信
            await self.page.keyboard.press('Enter')
            logger.info("✅ プロンプト送信完了（Enter）")
            return True
        
    except Exception as e:
        logger.error(f"❌ プロンプト送信エラー: {e}")
        return False
    

#browser_lifecycle.py
# browser_lifecycle.py
"""ブラウザライフサイクル管理クラス"""
import asyncio
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import async_playwright, Page, BrowserContext
import logging
import psutil

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserLifecycleManager:
    """ブラウザの起動・終了・生存管理を担当"""
    
    def __init__(self, browser_data_dir: Path, download_folder: Path):
        self.browser_data_dir = browser_data_dir
        self.download_folder = download_folder
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.playwright = None
        
        self.download_folder.mkdir(exist_ok=True, parents=True)
        if self.browser_data_dir:
            self.browser_data_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup_browser(self) -> None:
        """ブラウザの初期化（マルチモニター対応版）"""
        try:
            logger.info("="*60)
            logger.info("ブラウザ起動開始...")
            logger.info("="*60)
            
            # 既存のプロセスクリーンアップ
            await self._cleanup_existing_browser_processes()
            
            self.playwright = await async_playwright().start()
            logger.info(f"ユーザーデータディレクトリ: {self.browser_data_dir}")
            
            # マルチモニター対応: ウィンドウ位置とサイズを指定
            window_width = 1280
            window_height = 700
            x_position = 0
            y_position = 0
            
            # ブラウザ起動（位置とサイズ指定）
            self.context = await self.playwright.chromium.launch_persistent_context(
                user_data_dir=str(self.browser_data_dir),
                viewport={'width': window_width, 'height': window_height},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                accept_downloads=True,
                ignore_https_errors=True,
                no_viewport=False,
                **config.BROWSER_CONFIG
            )
            
            logger.info("✅ ブラウザコンテキスト作成成功")
            
            # ページ作成
            self.page = await self.context.new_page()
            
            # ウィンドウを指定位置に移動
            await self.page.evaluate(f"""
                window.moveTo({x_position}, {y_position});
                window.resizeTo({window_width}, {window_height});
            """)
            
            logger.info(f"✅ ウィンドウを位置 ({x_position}, {y_position}) に配置")
            
            # ブラウザが正常に起動したか確認
            await asyncio.sleep(2)
            if not await self._is_browser_alive():
                raise Exception("ブラウザが起動直後にクラッシュしました")
            
            logger.info("✅ ブラウザ生存確認完了")
            
            # 自動化検出を回避
            await self.page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false,
                });
                window.navigator.chrome = {
                    runtime: {},
                };
                const originalQuery = window.navigator.permissions.query;
                window.navigator.permissions.query = (parameters) => (
                    parameters.name === 'notifications' ?
                        Promise.resolve({ state: Notification.permission }) :
                        originalQuery(parameters)
                );
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['ja-JP', 'ja', 'en-US', 'en'],
                });
            """)
            
            self.page.set_default_timeout(config.PAGE_TIMEOUT)
            self.page.set_default_navigation_timeout(config.PAGE_TIMEOUT)
            
            logger.info("="*60)
            logger.info("✅ ブラウザ起動完了")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ブラウザ起動")
            logger.error("="*60)
            logger.error("❌ ブラウザ起動失敗")
            logger.error("="*60)
            
            logger.error(f"エラー詳細: {str(e)}")
            logger.error(f"ブラウザデータディレクトリ: {self.browser_data_dir}")
            
            await self._cleanup_existing_browser_processes()
            raise Exception(f"ブラウザ起動に失敗しました: {str(e)}")
    
    async def _is_browser_alive(self) -> bool:
        """ブラウザが生きているか確認"""
        try:
            if not self.page:
                return False
            result = await self.page.evaluate("1 + 1")
            return result == 2
        except Exception as e:
            logger.warning(f"ブラウザ生存確認失敗: {e}")
            return False
    
    async def _cleanup_existing_browser_processes(self):
        """既存のChromiumプロセスをクリーンアップ"""
        try:
            logger.info("既存のChromiumプロセスを確認中...")
            
            killed_count = 0
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if 'chrome' in proc.info['name'].lower() or 'chromium' in proc.info['name'].lower():
                        cmdline = proc.cmdline()
                        if str(self.browser_data_dir) in ' '.join(cmdline):
                            logger.warning(f"既存のChromiumプロセスを終了: PID={proc.info['pid']}")
                            proc.kill()
                            killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if killed_count > 0:
                logger.info(f"✅ {killed_count}個のプロセスを終了しました")
                await asyncio.sleep(2)
            else:
                logger.info("既存プロセスなし")
                
        except ImportError:
            logger.warning("psutilがインストールされていません。プロセスクリーンアップをスキップ")
        except Exception as e:
            logger.warning(f"プロセスクリーンアップエラー: {e}")
    
    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
        try:
            logger.info("🔄 リソースクリーンアップを開始します...")

            # 非同期タスクのキャンセル
            try:
                tasks = [t for t in asyncio.all_tasks() 
                        if t is not asyncio.current_task()]
                        
                if tasks:
                    logger.info(f"🔄 {len(tasks)}個の非同期タスクをキャンセル中...")
                    for task in tasks:
                        task.cancel()
                            
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=5.0
                    )
                    logger.info("✅ 非同期タスククリーンアップ完了")
            except asyncio.TimeoutError:
                logger.warning("⚠️ タスクキャンセルのタイムアウト")
            except Exception as e:
                logger.warning(f"⚠️ タスクキャンセル中のエラー: {e}")

            # ページのクローズ
            if self.page:
                try:
                    await self.page.close()
                    logger.info("✅ ページをクローズしました")
                except Exception as e:
                    logger.warning(f"⚠️ ページクローズ中の警告: {e}")

            # コンテキストのクローズ
            if self.context:
                try:
                    await self.context.close()
                    logger.info("✅ ブラウザコンテキストをクローズしました")
                except Exception as e:
                    logger.warning(f"⚠️ コンテキストクローズ中の警告: {e}")

            # Playwrightの停止
            if self.playwright:
                try:
                    await self.playwright.stop()
                    logger.info("✅ Playwrightを停止しました")
                except Exception as e:
                    logger.warning(f"⚠️ Playwright停止中の警告: {e}")

            logger.info("✅ リソースクリーンアップ完了")

        except Exception as e:
            logger.error(f"❌ クリーンアップ中のエラー: {e}")

#browser_wp_session_manager.py
# browser_wp_session_manager.py
"""WordPressセッション管理クラス"""
import json
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import Page, BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class WPSessionManager:
    """WordPressセッションの管理を担当"""
    
    def __init__(self, context: BrowserContext, wp_cookies_file: Path):
        self.context = context
        self.wp_cookies_file = wp_cookies_file
        self.wp_page: Optional[Page] = None
        self.is_logged_in = False
    
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """
        WordPress セッション初期化（完全修正版 - クッキー強制ナビゲーション対応）
            
        Args:
            auth_module: WordPress認証モジュール（任意）
            
        Returns:
            bool: 初期化成功時 True
        """
        try:
            logger.info("="*60)
            logger.info("🔐 WordPress セッション初期化中...")
            logger.info("="*60)
                
            # Phase 1: 新しいタブを作成
            if not self.context:
                logger.error("❌ ブラウザコンテキストが初期化されていません")
                return False
                
            self.wp_page = await self.context.new_page()
            logger.info("✅ WordPress 専用タブを作成しました")
                
            # Phase 2: 認証情報の検証
            if not auth_module:
                logger.warning("⚠️ WordPress 認証モジュールが提供されていません")
                logger.info("手動ログインが必要になる可能性があります")
                
            # Phase 3: ログイン実行（クッキー優先 + 強制ナビゲーション）
            logger.info("🔄 WordPress認証を実行中...")
            
            if auth_module:
                login_success = await auth_module.login(self.wp_page)
            else:
                # 認証モジュールがない場合は手動ログインを促す
                login_success = await self._manual_wp_login()
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("✅ WordPress セッション初期化完了")
                logger.info("  認証方法: クッキー or 手動ログイン")
                logger.info("  ページURL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("❌ WordPress ログイン失敗")
                logger.error("  原因: 認証情報またはネットワークの問題")
                logger.error("  対策: 認証情報を確認してください")
                logger.error("="*60)
                    
                # デバッグ用: 失敗時のスクリーンショット
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("📸 デバッグ用スクリーンショット: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"❌ WordPress セッション初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _manual_wp_login(self) -> bool:
        """手動WordPressログイン処理"""
        try:
            logger.info("="*60)
            logger.info("🔐 手動WordPressログインが必要です")
            logger.info("="*60)
            logger.info("")
            logger.info("📌 ログイン手順：")
            logger.info("1. ブラウザでWordPress管理画面を開く")
            logger.info("2. ユーザー名/パスワードでログイン")
            logger.info("3. ダッシュボードが表示されたらこのコンソールに戻る")
            logger.info("4. Enterキーを押して続行")
            logger.info("")
            logger.info("💡 ヒント：")
            logger.info("  - ログイン後はこのタブを閉じないでください")
            logger.info("  - セッションはCookieで維持されます")
            logger.info("="*60)
            
            # 一般的なWordPressログインURLに移動
            await self.wp_page.goto("/wp-admin", wait_until="domcontentloaded")
            
            input("\n✅ ログイン完了後、Enterキーを押してください: ")
            
            # ログイン成功を確認
            current_url = self.wp_page.url
            if 'wp-admin' in current_url or 'dashboard' in current_url.lower():
                logger.info("✅ WordPressログイン成功を確認")
                return True
            else:
                logger.warning("⚠️ WordPress管理画面に到達していない可能性があります")
                return False
                
        except Exception as e:
            logger.error(f"手動ログイン処理エラー: {e}")
            return False
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPress専用のクッキーを保存"""
        try:
            if not self.context or not self.wp_cookies_file:
                logger.warning("⚠️ クッキー保存: コンテキストまたはファイルパスがありません")
                return False
            
            # 現在のクッキーを取得
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("保存するクッキーがありません")
                return False
            
            # WordPress関連のクッキーをフィルタリング
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_cookies = [c for c in cookies if wp_domain in c.get('domain', '')]
            
            if not wp_cookies:
                logger.warning("WordPress関連のクッキーが見つかりません")
                return False
            
            # 既存のクッキーファイルを読み込み
            all_cookies = {}
            if self.wp_cookies_file.exists():
                try:
                    with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                        all_cookies = json.load(f)
                except Exception as e:
                    logger.warning(f"既存クッキー読み込みエラー: {e}")
                    all_cookies = {}
            
            # WordPress クッキーを更新
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            all_cookies[wp_key] = {
                'cookies': wp_cookies,
                'timestamp': time.time(),
                'domain': wp_url
            }
            
            # ファイルに保存
            self.wp_cookies_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.wp_cookies_file, 'w', encoding='utf-8') as f:
                json.dump(all_cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"✅ WordPress クッキー保存完了: {len(wp_cookies)}個")
            return True
            
        except Exception as e:
            logger.error(f"❌ WordPress クッキー保存エラー: {e}")
            return False
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPress専用のクッキーを読み込み"""
        try:
            if not self.wp_cookies_file or not self.wp_cookies_file.exists():
                logger.warning("WordPress クッキーファイルが存在しません")
                return False
            
            if not self.context:
                logger.warning("コンテキストが初期化されていません")
                return False
            
            # クッキーファイルを読み込み
            with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                all_cookies = json.load(f)
            
            # WordPress クッキーを取得
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            
            if wp_key not in all_cookies:
                logger.warning(f"WordPress クッキーが見つかりません: {wp_key}")
                return False
            
            wp_cookie_data = all_cookies[wp_key]
            cookies = wp_cookie_data.get('cookies', [])
            
            if not cookies:
                logger.warning("有効な WordPress クッキーがありません")
                return False
            
            # 有効期限をチェック
            valid_cookies = []
            for cookie in cookies:
                if 'expires' in cookie:
                    if cookie['expires'] > time.time():
                        valid_cookies.append(cookie)
                else:
                    # expires がないクッキーはセッションクッキー
                    valid_cookies.append(cookie)
            
            if not valid_cookies:
                logger.warning("有効期限切れのクッキーのみ存在します")
                return False
            
            # クッキーをコンテキストに追加
            await self.context.add_cookies(valid_cookies)
            logger.info(f"✅ WordPress クッキー読み込み完了: {len(valid_cookies)}個")
            
            return True
            
        except Exception as e:
            logger.error(f"❌ WordPress クッキー読み込みエラー: {e}")
            return False
    
    async def close_wp_session(self) -> None:
        """WordPressセッションを閉じる"""
        try:
            if self.wp_page:
                await self.wp_page.close()
                self.wp_page = None
                self.is_logged_in = False
                logger.info("✅ WordPressセッションを閉じました")
        except Exception as e:
            logger.warning(f"WordPressセッションクローズ中の警告: {e}")

#command_monitor_agent.py
# command_monitor_agent.py - ACF監視強化版
import asyncio
import re
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Optional, Callable
from datetime import datetime

logger = logging.getLogger(__name__)

class CommandMonitorAgent:
    """コマンド実行と出力監視 - ACF/WP-CLI特化版"""
    

    def __init__(self, browser_controller, sheets_manager):
        self.browser_controller = browser_controller
        self.sheets_manager = sheets_manager
    
        # 既存のエラーパターン
        self.error_patterns = [
            r'Error:', r'Exception:', r'Traceback'
        ]
    
        # === 新規追加: PHP固有のエラーパターン ===
        self.php_error_patterns = [
            r'Parse error:',
            r'Syntax error',
            r'Fatal error:',
            r'Warning:',
            r'Notice:',
            r'Undefined function',
            r'Undefined variable',
            r'Class.*not found',
            r'Call to undefined function',
            r'Cannot modify header information',
        ]
    
        # WP-CLI専用エラーパターン（強化版）
        self.wp_cli_error_patterns = [
            r'Error:\s+',
            r'Fatal error:',
            r'Plugin not found',
            r'Could not create',
            r'Database connection error',
            r'Warning:\s+[A-Z]',
            # === 新規追加: CPT登録関連エラー ===
            r'Invalid post type',
            r'Post type.*already exists',
            r'register_post_type.*failed',
            r'Permission denied',
            r'Failed to create',
        ]
    
        # === 新規追加: ACF専用エラーパターン ===
        self.acf_error_patterns = [
            r'ACF:\s+Error',
            r'Field group not found',
            r'Invalid field group',
            r'JSON decode error',
            r'acf_add_local_field_group.*failed',
            r'ACF.*not activated',
        ]
    
        self.wp_cli_success_patterns = [
            r'Success:',
            r'Plugin .* activated',
            r'Updated \d+ post',
            r'Created \d+ post',
            # === 新規追加: CPT登録成功パターン ===
            r'Post type.*registered',
            r'Custom post type.*created',
            r'Registration of.*successful',
        ]
    
        # === 新規追加: CPT警告パターン ===
        self.cpt_warning_patterns = [
            r'Post type.*already registered',
            r'Duplicate post type',
            r'Menu position conflict',
            r'Rewrite rules may need to be flushed',
        ]
    
    def _detect_errors(self, output: str) -> bool:
        """エラー検出 - ACF対応強化"""
        # 汎用エラーチェック
        for pattern in self.error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                return True
        
        # WP-CLI専用エラーチェック
        for pattern in self.wp_cli_error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.warning(f"⚠️ WP-CLI/ACFエラー検出: {pattern}")
                return True
        
        return False
    
    def _validate_wp_cli_success(self, output: str, expected_action: str) -> bool:
        """WP-CLI実行の成功検証 - ACF対応"""
        # 成功パターンのマッチング
        for pattern in self.wp_cli_success_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.info(f"✅ WP-CLI成功: {expected_action}")
                return True
        
        logger.error(f"❌ WP-CLI成功メッセージ未検出: {expected_action}")
        return False
    
    def _extract_acf_field_group_info(self, output: str) -> Optional[Dict]:
        """ACFフィールドグループ情報の抽出（新規追加）"""
        try:
            info = {}
            
            # フィールドグループキーの抽出
            key_match = re.search(r'group_([a-z0-9_]+)', output)
            if key_match:
                info['key'] = key_match.group(0)
            
            # フィールド数の抽出
            fields_match = re.search(r'(\d+)\s+field', output, re.IGNORECASE)
            if fields_match:
                info['field_count'] = int(fields_match.group(1))
            
            # エラーの抽出
            errors = self._extract_errors(output)
            if errors:
                info['errors'] = errors
            
            # 警告の抽出
            warnings = self._extract_acf_warnings(output)
            if warnings:
                info['warnings'] = warnings
            
            return info if info else None
            
        except Exception as e:
            logger.error(f"ACF情報抽出エラー: {e}")
            return None
    
    def _extract_acf_warnings(self, output: str) -> List[str]:
        """ACF警告メッセージを抽出（新規追加）"""
        warnings = []
        lines = output.split('\n')
        
        for i, line in enumerate(lines):
            for pattern in self.acf_warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        return warnings
    
    async def execute_command(self, command: str, timeout: int = 300) -> Dict:
        """コマンドを実行して出力を監視 - ACF情報抽出追加"""
        try:
            logger.info(f"🔧 コマンド実行: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            
            output = stdout.decode('utf-8', errors='ignore')
            error_output = stderr.decode('utf-8', errors='ignore')
            return_code = process.returncode
            
            # === 新規追加: ACFコマンドの特別処理 ===
            acf_info = None
            if 'wp acf' in command:
                acf_info = self._extract_acf_field_group_info(output + error_output)
                if acf_info:
                    logger.info(f"📋 ACF情報: {acf_info}")
            
            result = {
                'command': command,
                'return_code': return_code,
                'stdout': output,
                'stderr': error_output,
                'timestamp': datetime.now().isoformat(),
                'has_errors': self._detect_errors(output + error_output),
                'errors': self._extract_errors(output + error_output),
                'warnings': self._extract_warnings(output + error_output),
                'acf_info': acf_info  # ACF固有情報
            }
            
            # 結果のサマリーログ
            if result['has_errors']:
                logger.error(f"❌ コマンド実行エラー: {command}")
                for error in result['errors']:
                    logger.error(f"   {error}")
            elif result['warnings']:
                logger.warning(f"⚠️ コマンド実行警告: {command}")
                for warning in result['warnings']:
                    logger.warning(f"   {warning}")
            else:
                logger.info(f"✅ コマンド実行成功: {command}")
            
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"⏱️ コマンドタイムアウト ({timeout}秒): {command}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': f'コマンド実行タイムアウト ({timeout}秒)',
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [f'実行タイムアウト ({timeout}秒)'],
                'warnings': [],
                'acf_info': None
            }
        except Exception as e:
            logger.error(f"💥 コマンド実行エラー: {e}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': str(e),
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [str(e)],
                'warnings': [],
                'acf_info': None
            }
    
    def _extract_errors(self, output: str) -> List[str]:
        """エラーメッセージを抽出"""
        errors = []
        lines = output.split('\n')
        
        # 汎用エラー + WP-CLI/ACFエラー
        all_error_patterns = self.error_patterns + self.wp_cli_error_patterns
        
        for i, line in enumerate(lines):
            for pattern in all_error_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    # エラー行とその前後2行を取得
                    start = max(0, i - 2)
                    end = min(len(lines), i + 3)
                    context = '\n'.join(lines[start:end])
                    errors.append(context)
                    break
        
        return errors
    
    def _extract_warnings(self, output: str) -> List[str]:
        """警告メッセージを抽出"""
        warnings = []
        lines = output.split('\n')
        
        warning_patterns = [r'Warning:', r'Notice:']
        
        for i, line in enumerate(lines):
            for pattern in warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        # ACF警告も追加
        acf_warnings = self._extract_acf_warnings(output)
        warnings.extend(acf_warnings)
        
        return warnings
    
    async def monitor_acf_import_process(self, json_path: Path, timeout: int = 180) -> Dict:
        """ACFインポートプロセスの専用監視（新規追加）"""
        try:
            logger.info(f"📥 ACFインポート監視開始: {json_path}")
            
            # WP-CLIコマンド実行
            command = f"wp acf import {json_path}"
            result = await self.execute_command(command, timeout=timeout)
            
            # 成功検証
            is_success = (
                result['return_code'] == 0 and
                not result['has_errors'] and
                self._validate_wp_cli_success(result['stdout'], 'ACF import')
            )
            
            if is_success:
                logger.info("✅ ACFインポート成功")
            else:
                logger.error("❌ ACFインポート失敗")
            
            return {
                'success': is_success,
                'command_result': result,
                'acf_info': result.get('acf_info'),
                'errors': result.get('errors', []),
                'warnings': result.get('warnings', [])
            }
            
        except Exception as e:
            logger.error(f"ACFインポート監視エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#compatibility_fix.py
"""
Python 3.13 非同期互換性修正
Windows環境でのasyncioプロアクターイベントの問題を解決
"""

import asyncio
import sys
import warnings

def apply_windows_async_fix():
    """Windows環境での非同期問題を修正"""
    if sys.platform == "win32":
        # ResourceWarningを無視（一時的対応）
        warnings.filterwarnings("ignore", category=ResourceWarning)
        
        # イベントループポリシーを設定
        if sys.version_info >= (3, 13):
            try:
                asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
            except Exception:
                # 既に設定されている場合は無視
                pass

def safe_async_shutdown():
    """安全な非同期シャットダウン"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            loop.stop()
        if not loop.is_closed():
            loop.close()
    except Exception:
        pass

#config_utils.py
import logging
import uuid
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import time

# config_utils.py の SmartLogFormatter クラスを修正

class SmartLogFormatter(logging.Formatter):
    """スマートなログフォーマッタ - 短縮識別版"""
    
    # クラス変数として状態を保持
    _message_count = 0
    _last_timestamp_display = 0
    _last_date_display = ""
    _lock = False
    
    # エージェント別の絵文字マッピング（短縮版）
    AGENT_EMOJIS = {
        # 🏃‍♂️ 実行系
        'run_multi_agent': '🚀 multi-agent',
        '__main__': '🏁 main',
    
        # 👑 PM系
        'pm_agent': '👑 pm-agent',
        'pm_system_prompts': '📋 pm-prompts',
    
        # ⚙️ タスク実行系
        'task_executor': '⚙️ task-exec',
        'task_executor_content': '📝 task-content',
        'task_executor_ma': '🔍 task-ma',
        'task_coordinator': '🎯 task-coord',
        'content_task_executor': '📄 content-exec',
        'system_cli_executor': '💻 cli-exec',
        'workflow_executor': '🔄 workflow',
        'test_tasks': '🧪 test-tasks',
    
        # 🎨 デザイン系
        'design_agent': '🎨 design',
        'ui_agent': '📱 ui',
    
        # 💻 開発系
        'dev_agent': '💻 dev',
        'dev_agent_acf': '🔌 dev-acf',
    
        # ✅ レビュー系
        'review_agent': '✅ review',
        'review_agent_prompts': '📋 review-prompts',
        'review_agent_prompts_ACF': '🔧 review-acf',
    
        # 🕷️ ブラウザ制御系
        'browser_controller': '🕷️ browser',
        'browser_cookie_and_session': '🍪 cookie-session',
        'browser_lifecycle': '🔁 browser-life',
        'browser_ai_chat_agent': '🤖 browser-ai',
        'browser_wp_session_manager': '🌐 wp-session',
    
        # 📊 データ連携系
        'sheets_manager': '📊 sheets-mgr',
    
        # 🔧 ユーティリティ系
        'config_utils': '⚙️ config',
        'command_monitor_agent': '👁️ monitor',
        'compatibility_fix': '🔧 compat-fix',
        'quick_fix': '⚡ quick-fix',
        'error_handler_enhanced': '🚨 error-handler',
    
        # ✍️ コンテンツライター系
        'base_writer': '✍️ writer-base',
        'ja_writer_agent': '🗾 ja-writer',
        'en_writer_agent': '🔠 en-writer',
        'ru_writer_agent': '🇷🇺 ru-writer',
        'uz_writer_agent': '🇺🇿 uz-writer',
        'zh_writer_agent': '🇨🇳 zh-writer',
        'ko_writer_agent': '🇰🇷 ko-writer',
        'tr_writer_agent': '🇹🇷 tr-writer',
        
        # 🆕 M&A専門エージェント
        'ma_executor': '💼 ma-exec',
        'ma_requirements': '📋 ma-req',
        'ma_data_migration': '🔄 ma-migrate',
        'ma_api_integration': '🔗 ma-api',
    
        # 🌐 WordPress系
        'wp_agent': '🌐 wp-agent',
        'wp_auth': '🔐 wp-auth',
        'wp_post_editor': '📝 wp-editor',
        'wp_post_creator': '🆕 wp-creator',
        'wp_plugin_manager': '🔌 wp-plugin',
        'wp_settings_manager': '⚙️ wp-config',
        'wp_design': '🎨 wp-design',
        'wp_dev': '🔧 wp-dev',
        'wp_tester': '🧪 wp-test',
        'wp_utils': '🛠️ wp-utils',
    
    }
    
    def format(self, record):
        # 再帰呼び出し防止
        if SmartLogFormatter._lock:
            return super().format(record)
        
        SmartLogFormatter._lock = True
        try:
            # メッセージカウント
            SmartLogFormatter._message_count += 1
            current_time = time.time()
            
            # エージェント識別
            agent_name = record.name
            # モジュール名から短縮名を取得
            if '.' in agent_name:
                agent_short = agent_name.split('.')[-1]  # 最後の部分
            else:
                agent_short = agent_name
            
            # エージェント絵文字を取得
            agent_display = self.AGENT_EMOJIS.get(agent_short, f'📋 {agent_short[:6]}')
            
            # レベル別の絵文字と色（エラーを強調）
            level_info = {
                'INFO': ('💬', ''),
                'WARNING': ('⚠️', 'WARN'),
                'ERROR': ('❌', 'ERROR'),
                'DEBUG': ('🐛', 'DEBUG'),
                'CRITICAL': ('💥', 'CRITICAL')
            }
            
            level_emoji, level_prefix = level_info.get(record.levelname, ('📝', ''))
            
            # メッセージ
            message = record.getMessage()
            
            # タイムスタンプ判定
            current_date = time.strftime('%Y-%m-%d')
            show_date = (SmartLogFormatter._last_date_display != current_date)
            show_timestamp = (
                SmartLogFormatter._message_count % 30 == 1 or 
                current_time - SmartLogFormatter._last_timestamp_display > 300 or
                show_date
            )
            
            # フォーマット構築
            parts = []
            
            # タイムスタンプ
            if show_date:
                SmartLogFormatter._last_date_display = current_date
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%Y-%m-%d %H:%M')
                parts.append(f"🕒 {timestamp}")
            elif show_timestamp:
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%H:%M')
                parts.append(f"🕒 {timestamp}")
            
            # エージェント名（常に表示）
            parts.append(agent_display)
            
            # レベル（エラー/警告時は強調）
            if level_prefix:
                # エラーレベルの場合は赤色で表示（ターミナルで色付け）
                if record.levelname in ['ERROR', 'CRITICAL']:
                    parts.append(f"{level_emoji} \033[91m{level_prefix}\033[0m")  # 赤色
                elif record.levelname == 'WARNING':
                    parts.append(f"{level_emoji} \033[93m{level_prefix}\033[0m")  # 黄色
                else:
                    parts.append(f"{level_emoji} {level_prefix}")
            else:
                parts.append(level_emoji)
            
            # メッセージ
            parts.append(message)
            
            # 結合
            result = ' '.join(parts)
            
            return result
            
        finally:
            SmartLogFormatter._lock = False


def setup_optimized_logging():
    """最適化されたログ設定（エージェント識別強化版）"""
    
    # ルートロガー
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # ← INFO を DEBUG に変更
    
    # 既存のハンドラをクリア
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # コンソールハンドラ（エージェント識別強化）
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SmartLogFormatter())
    
    # ファイルハンドラ（詳細ログ）
    file_handler = logging.FileHandler('gemini_automation.log', encoding='utf-8')
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(file_formatter)
    
    # ハンドラ追加
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)


# グローバルで実行
setup_optimized_logging()


class Config:
    """設定クラス"""
    SPREADSHEET_ID = "1qpMLT9HKlPT9qY17fpqOkSIbehKH77wZ8bA1yfPSO_s"
    DOWNLOAD_IMAGE_FOLDER: Optional[str] = None
    DOWNLOAD_TEXT_FOLDER: Optional[str] = None
    SERVICE_ACCOUNT_FILE: Optional[str] = None
    COOKIES_FILE: Optional[str] = None
    BROWSER_DATA_DIR: Optional[str] = None
    GENERATION_MODE: Optional[str] = None
    TEXT_FORMAT: Optional[str] = None
    SERVICE_TYPE: Optional[str] = None
    AGENT_OUTPUT_FOLDER = None
    MAX_ITERATIONS = 3
    DRIVE_TEXT_FOLDER_ID = "16QVK_-z8JVmhLQuLVprOx9_DnoNc4eUc"
    DRIVE_IMAGE_FOLDER_ID = "1jkuMH1UNeBvNNvrz8iVidyVMmtmYrHiS"
    
    BROWSER_CONFIG = {
        "headless": False,
        "slow_mo": 800,
        "args": [
            "--disable-blink-features=AutomationControlled",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "--no-sandbox",
            "--disable-dev-shm-usage"
            # ⚠️ --single-process を削除（Windowsで不安定なため）
        ],
        "timeout": 60000
    }
    
    def __init__(self):
        self.WP_COOKIES_FILE = os.environ.get('WP_COOKIES_FILE', 
                                            os.path.join(Path.home(), 'Documents', 'gemini_auto_generate', 'wordpress_cookies.json'))
            
        # クッキー有効期限（デフォルト30日）
        self.WP_COOKIE_EXPIRY_DAYS = int(os.environ.get('WP_COOKIE_EXPIRY_DAYS', '30'))
        
    VIEWPORT_SIZE = {'width': 1024, 'height': 768}
    PAGE_TIMEOUT = 60000
    IMAGE_GENERATION_TIMEOUT = 180
    TEXT_GENERATION_TIMEOUT = 120
    
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]


class FileNameGenerator:
    """ファイル名生成"""
    
    @staticmethod
    def generate_unique_filename(index: int, extension: str = ".png", mode: str = "image") -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        unique_id = str(uuid.uuid4())[:8]
        
        if mode == "text":
            prefix = "gemini_text"
            ext = ".txt"
        else:
            prefix = "gemini_image"
            ext = extension
        
        return f"{prefix}_{index:03d}_{timestamp}_{unique_id}{ext}"
    
    @staticmethod
    def validate_filename(filename: str) -> bool:
        try:
            invalid_chars = '<>:"/\\|?*'
            return not any(char in filename for char in invalid_chars)
        except:
            return False


class ErrorHandler:
    """エラーハンドリング"""
    
    @staticmethod
    def log_error(error: Exception, context: str = "") -> None:
        logger = logging.getLogger(__name__)
        logger.error(f"{context}: {str(error)}")
    
    @staticmethod
    def handle_missing_attribute_error(obj, attr_name: str, default_value=None):
        logger = logging.getLogger(__name__)
        if not hasattr(obj, attr_name):
            logger.warning(f"属性 '{attr_name}' が見つかりません。デフォルト値を使用")
            setattr(obj, attr_name, default_value)
        return getattr(obj, attr_name)


class PathManager:
    """パス管理"""
    
    @staticmethod
    def ensure_directory_exists(path: Path) -> None:
        path.mkdir(parents=True, exist_ok=True)
    
    @staticmethod
    def get_safe_path(base_path: str) -> Path:
        path = Path(base_path)
        PathManager.ensure_directory_exists(path)
        return path


config = Config()

#content_task_executor.py
"""
content_task_executor.py - コンテンツ生成タスク専門実行モジュール
AIサイトとの対話、プロンプト送信、応答抽出、検証を担当
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

# 設定
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """
    コンテンツ生成タスクの専門実行モジュール
    
    ブラウザ制御を通じたAI対話、コンテンツ生成、
    抽出、検証ロジックを統合
    """
    
    def __init__(
        self,
        browser_controller,
        sheets_manager: GoogleSheetsManager
    ):
        """
        初期化
        
        Args:
            browser_controller: BrowserControllerインスタンス
            sheets_manager: GoogleSheetsManagerインスタンス
        """
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        
        # AI設定
        self.ai_sites = {
            'gemini': 'https://gemini.google.com',
            'deepseek': 'https://chat.deepseek.com',
            'claude': 'https://claude.ai'
        }
        
        # デフォルトAI
        self.default_ai = 'gemini'
        
        # タイムアウト設定
        self.default_timeout = 180.0
        self.generation_timeout = 240.0
        
        logger.info("✅ ContentTaskExecutor 初期化完了")
    
    async def execute_content_task(self, task: Dict) -> Dict:
        """
        コンテンツ生成タスクを実行
            
        Args:
            task: タスク情報辞書
                
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("=" * 60)
            logger.info(f"✍️ コンテンツタスク実行開始: {task_id}")
            logger.info("=" * 60)
                
            # ========================================
            # 🆕 コンテンツタイプ判定と専門プロンプト適用（強化版）
            # ========================================
            content_type = self._determine_content_type(task)
            logger.info(f"📋 コンテンツタイプ: {content_type}")
                
            # 専門文書タイプの場合、プロンプトを差し替え
            if content_type == 'pydantic_migration':
                task['prompt'] = self._build_pydantic_migration_prompt(task)
                logger.info("🔧 Pydantic移行プロンプトを適用")
            elif content_type == 'openapi_schema':
                task['prompt'] = self._build_openapi_schema_prompt(task)
                logger.info("📐 OpenAPIスキーマプロンプトを適用")
            elif content_type == 'requirements_document':
                task['prompt'] = self._build_requirements_document_prompt(task)
                logger.info("📄 要件定義書プロンプトを適用")
                
            # ========================================
            # 既存の実行ロジック
            # ========================================
                
            # タスクパラメータ抽出
            prompt = task.get('prompt', task.get('description', ''))
            ai_site = task.get('ai_site', self.default_ai).lower()
            output_format = task.get('output_format', 'markdown')
                
            # ブラウザチェック
            if not self.browser:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラが初期化されていません'
                }
                
            # AIサイトナビゲーション
            nav_result = await self._navigate_to_ai_site(ai_site)
            if not nav_result['success']:
                return nav_result
                
            # プロンプト送信と応答待機
            response_result = await self._send_prompt_and_wait(
                prompt, 
                timeout=self.generation_timeout
            )
            if not response_result['success']:
                return response_result
                
            # 応答テキスト抽出
            extract_result = await self._extract_response_text()
            if not extract_result['success']:
                return extract_result
                
            content = extract_result['content']
                
            # コンテンツ検証
            validation_result = self._validate_content(content, task)
            if not validation_result['valid']:
                logger.warning(f"⚠️ コンテンツ検証警告: {validation_result['message']}")
                
            # 出力ファイル保存
            output_file = await self._save_content_output(
                task_id, 
                content, 
                output_format
            )
                
            logger.info(f"✅ コンテンツタスク {task_id} 完了")
                
            return {
                'success': True,
                'content': content,
                'output_file': output_file,
                'ai_site': ai_site,
                'content_type': content_type,  # タイプ情報を追加
                'validation': validation_result,
                'full_text': content,
                'summary': content[:500] if len(content) > 500 else content
            }
                
        except asyncio.TimeoutError:
            logger.error(f"⏱️ コンテンツタスク {task_id} タイムアウト")
            return {
                'success': False,
                'error': f'タイムアウト ({self.generation_timeout}秒)'
            }
            
        except Exception as e:
            logger.error(f"❌ コンテンツタスク {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_content_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _navigate_to_ai_site(self, ai_site: str) -> Dict:
        """
        AIサイトにナビゲーション
        
        Args:
            ai_site: AIサイト識別子 ('gemini', 'deepseek', 'claude')
            
        Returns:
            Dict: ナビゲーション結果
        """
        try:
            logger.info(f"🌐 {ai_site.upper()} にナビゲーション中...")
            
            # サイトURL取得
            if ai_site not in self.ai_sites:
                logger.warning(f"⚠️ 未知のAIサイト: {ai_site}, デフォルト {self.default_ai} を使用")
                ai_site = self.default_ai
            
            url = self.ai_sites[ai_site]
            
            # ブラウザメソッド呼び出し
            if ai_site == 'gemini':
                if hasattr(self.browser, 'navigate_to_gemini'):
                    result = await self.browser.navigate_to_gemini()
                else:
                    result = await self.browser.navigate_to_url(url)
            elif ai_site == 'deepseek':
                if hasattr(self.browser, 'navigate_to_deepseek'):
                    result = await self.browser.navigate_to_deepseek()
                else:
                    result = await self.browser.navigate_to_url(url)
            else:
                result = await self.browser.navigate_to_url(url)
            
            if result:
                logger.info(f"✅ {ai_site.upper()} へのナビゲーション成功")
                return {'success': True}
            else:
                logger.error(f"❌ {ai_site.upper()} へのナビゲーション失敗")
                return {'success': False, 'error': f'{ai_site} へのナビゲーション失敗'}
        
        except Exception as e:
            logger.error(f"❌ AIサイトナビゲーションエラー: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _send_prompt_and_wait(
        self, 
        prompt: str, 
        timeout: float = None
    ) -> Dict:
        """
        プロンプトを送信して応答を待機
        
        Args:
            prompt: 送信するプロンプト
            timeout: タイムアウト時間（秒）
            
        Returns:
            Dict: 実行結果
        """
        try:
            if timeout is None:
                timeout = self.generation_timeout
            
            logger.info(f"📤 プロンプト送信中... (タイムアウト: {timeout}秒)")
            
            # 統合メソッド使用（存在する場合）
            if hasattr(self.browser, 'send_prompt_and_wait'):
                result = await self.browser.send_prompt_and_wait(
                    prompt, 
                    timeout=timeout
                )
                if result:
                    logger.info("✅ プロンプト送信と応答待機完了")
                    return {'success': True}
                else:
                    logger.error("❌ プロンプト送信または応答待機失敗")
                    return {'success': False, 'error': 'プロンプト送信失敗'}
            else:
                # 個別メソッド使用（後方互換性）
                if hasattr(self.browser, 'send_prompt'):
                    await self.browser.send_prompt(prompt)
                else:
                    logger.error("❌ send_prompt メソッドが見つかりません")
                    return {'success': False, 'error': 'send_prompt メソッド未実装'}
                
                # 応答待機
                if hasattr(self.browser, 'wait_for_text_generation'):
                    await self.browser.wait_for_text_generation(timeout)
                    logger.info("✅ プロンプト送信と応答待機完了")
                    return {'success': True}
                else:
                    logger.warning("⚠️ wait_for_text_generation メソッドなし - 固定待機")
                    await asyncio.sleep(30)  # フォールバック待機
                    return {'success': True}
        
        except asyncio.TimeoutError:
            logger.error(f"⏱️ プロンプト応答タイムアウト ({timeout}秒)")
            return {'success': False, 'error': 'タイムアウト'}
        
        except Exception as e:
            logger.error(f"❌ プロンプト送信エラー: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _extract_response_text(self) -> Dict:
        """
        AIからの応答テキストを抽出
        
        Returns:
            Dict: 抽出結果 {'success': bool, 'content': str}
        """
        try:
            logger.info("📥 応答テキスト抽出中...")
            
            if not hasattr(self.browser, 'extract_latest_text_response'):
                logger.error("❌ extract_latest_text_response メソッドが見つかりません")
                return {'success': False, 'error': '応答抽出メソッド未実装'}
            
            content = await self.browser.extract_latest_text_response()
            
            if not content:
                logger.warning("⚠️ 抽出されたコンテンツが空です")
                return {'success': False, 'error': '抽出コンテンツなし'}
            
            logger.info(f"✅ 応答テキスト抽出完了 ({len(content)}文字)")
            return {'success': True, 'content': content}
        
        except Exception as e:
            logger.error(f"❌ 応答テキスト抽出エラー: {e}")
            return {'success': False, 'error': str(e)}
    
    def _validate_content(self, content: str, task: Dict) -> Dict:
        """
        生成コンテンツを検証
        
        Args:
            content: 検証対象コンテンツ
            task: タスク情報
            
        Returns:
            Dict: 検証結果 {'valid': bool, 'message': str, 'warnings': list}
        """
        warnings = []
        
        # 最小文字数チェック
        min_length = task.get('min_length', 100)
        if len(content.strip()) < min_length:
            warnings.append(f'コンテンツが短すぎます（{len(content)}文字 < {min_length}文字）')
        
        # コードブロック完全性チェック
        if '```' in content:
            code_block_count = content.count('```')
            if code_block_count % 2 != 0:
                warnings.append('コードブロックが不完全です（閉じられていないブロックがあります）')
        
        # PHPコード完全性チェック
        if '<?php' in content:
            if '?>' not in content and not content.rstrip().endswith('}'):
                warnings.append('PHPコードが不完全な可能性があります')
        
        # 必須キーワードチェック
        required_keywords = task.get('required_keywords', [])
        missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]
        if missing_keywords:
            warnings.append(f'必須キーワード不足: {", ".join(missing_keywords)}')
        
        valid = len(warnings) == 0
        message = '検証合格' if valid else f'{len(warnings)}件の警告'
        
        return {
            'valid': valid,
            'message': message,
            'warnings': warnings
        }
    
    async def _save_content_output(
        self, 
        task_id: str, 
        content: str, 
        output_format: str = 'markdown'
    ) -> str:
        """
        コンテンツを出力ファイルに保存
        
        Args:
            task_id: タスクID
            content: 保存するコンテンツ
            output_format: 出力形式 ('markdown', 'text', 'html')
            
        Returns:
            str: 保存されたファイルパス
        """
        try:
            # ファイル拡張子マッピング
            ext_map = {
                'markdown': '.md',
                'text': '.txt',
                'html': '.html',
                'php': '.php'
            }
            ext = ext_map.get(output_format, '.txt')
            
            # ファイル名生成
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"content_{task_id}_{timestamp}{ext}"
            
            # 出力ディレクトリ確保
            output_dir = Path(config.OUTPUT_DIR) if hasattr(config, 'OUTPUT_DIR') else Path('./outputs')
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # ファイル保存
            output_path = output_dir / filename
            
            if hasattr(self.browser, 'save_text_to_file'):
                # BrowserControllerの保存メソッド使用
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
                logger.info(f"✅ コンテンツ保存完了: {saved_path}")
                return str(saved_path)
            else:
                # 直接ファイル保存
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                logger.info(f"✅ コンテンツ保存完了: {output_path}")
                return str(output_path)
        
        except Exception as e:
            logger.error(f"❌ コンテンツ保存エラー: {e}")
            ErrorHandler.log_error(e, "ContentTaskExecutor._save_content_output")
            return ""
    
    async def execute_multi_step_content_task(self, task: Dict) -> Dict:
        """
        複数ステップのコンテンツ生成タスクを実行
        
        例: プロンプト1 → 応答抽出 → プロンプト2 → 最終出力
        
        Args:
            task: タスク情報辞書（'steps'キーに複数ステップ定義）
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("⚠️ ステップ定義なし - 単一タスクとして実行")
            return await self.execute_content_task(task)
        
        try:
            logger.info("=" * 60)
            logger.info(f"🔄 マルチステップタスク実行: {task_id}")
            logger.info(f"ステップ数: {len(steps)}")
            logger.info("=" * 60)
            
            results = []
            accumulated_content = ""
            
            for i, step in enumerate(steps, 1):
                logger.info(f"\n--- ステップ {i}/{len(steps)} ---")
                
                # ステップタスク構築
                step_task = {
                    **task,  # 親タスクの属性を継承
                    'task_id': f"{task_id}_step{i}",
                    'prompt': step.get('prompt', ''),
                    'description': step.get('description', f'ステップ{i}'),
                }
                
                # 前ステップの結果を参照する場合
                if step.get('use_previous_output') and accumulated_content:
                    step_task['prompt'] = step_task['prompt'].replace(
                        '{previous_output}', 
                        accumulated_content
                    )
                
                # ステップ実行
                step_result = await self.execute_content_task(step_task)
                
                if not step_result.get('success'):
                    logger.error(f"❌ ステップ {i} 失敗")
                    return {
                        'success': False,
                        'error': f"ステップ {i} 失敗: {step_result.get('error')}",
                        'completed_steps': i - 1,
                        'step_results': results
                    }
                
                results.append(step_result)
                accumulated_content = step_result.get('content', '')
                
                logger.info(f"✅ ステップ {i} 完了")
                
                # ステップ間待機
                if i < len(steps):
                    await asyncio.sleep(2)
            
            logger.info(f"✅ 全 {len(steps)} ステップ完了")
            
            return {
                'success': True,
                'content': accumulated_content,
                'steps_completed': len(steps),
                'step_results': results,
                'full_text': accumulated_content,
                'summary': accumulated_content[:500] if len(accumulated_content) > 500 else accumulated_content
            }
        
        except Exception as e:
            logger.error(f"❌ マルチステップタスク {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_multi_step_content_task({task_id})")
            return {
                'success': False,
                'error': str(e),
                'step_results': results
            }
    
    def display_suggested_tasks(self, tasks: List[Dict]):
        """
        提案されたタスクを表示
        
        Args:
            tasks: 提案タスクのリスト
        """
        print("\n" + "="*60)
        print("📋 提案されたコンテンツタスク:")
        print("="*60)
        for i, task in enumerate(tasks, 1):
            print(f"\n{i}. {task.get('description', 'N/A')}")
            print(f"   AI: {task.get('ai_site', 'gemini')}")
            print(f"   形式: {task.get('output_format', 'markdown')}")
            print(f"   優先度: {task.get('priority', 'medium')}")
        print("="*60)
    
    async def edit_suggested_tasks(self, tasks: List[Dict]) -> List[Dict]:
        """
        提案タスクを編集
        
        Args:
            tasks: 編集対象のタスクリスト
            
        Returns:
            List[Dict]: 編集後のタスクリスト
        """
        edited_tasks = []
        
        for i, task in enumerate(tasks, 1):
            print(f"\n--- タスク {i}/{len(tasks)} の編集 ---")
            print(f"現在の説明: {task.get('description', 'N/A')}")
            
            edit = input("このタスクを編集しますか? (y/n/s=スキップ): ").lower()
            
            if edit == 's':
                print("このタスクをスキップします")
                continue
            elif edit == 'y':
                new_desc = input("新しい説明 (Enter=変更なし): ")
                if new_desc:
                    task['description'] = new_desc
                
                new_ai = input(f"AI (現在: {task.get('ai_site', 'gemini')}, Enter=変更なし): ")
                if new_ai:
                    task['ai_site'] = new_ai
                
                new_format = input(f"出力形式 (現在: {task.get('output_format', 'markdown')}, Enter=変更なし): ")
                if new_format:
                    task['output_format'] = new_format
            
            edited_tasks.append(task)
        
        return edited_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """
        手動でコンテンツタスクを作成
        
        Returns:
            List[Dict]: 作成されたタスクリスト
        """
        manual_tasks = []
        
        print("\n" + "="*60)
        print("✍️ 手動コンテンツタスク作成")
        print("="*60)
        
        while True:
            print(f"\n--- タスク {len(manual_tasks) + 1} ---")
            
            description = input("タスク説明 (Enter=完了): ")
            if not description:
                break
            
            prompt = input("プロンプト (Enter=説明と同じ): ")
            if not prompt:
                prompt = description
            
            ai_site = input("AI (gemini/deepseek/claude, Enter=gemini): ") or 'gemini'
            output_format = input("出力形式 (markdown/text/html, Enter=markdown): ") or 'markdown'
            priority = input("優先度 (high/medium/low, Enter=medium): ") or 'medium'
            
            task = {
                'description': description,
                'prompt': prompt,
                'ai_site': ai_site,
                'output_format': output_format,
                'priority': priority,
                'required_role': 'content'
            }
            
            manual_tasks.append(task)
            print(f"✅ タスク {len(manual_tasks)} 追加完了")
            
            continue_add = input("\n別のタスクを追加しますか? (y/n): ").lower()
            if continue_add != 'y':
                break
        
        print(f"\n✅ {len(manual_tasks)}件のタスクを作成しました")
        return manual_tasks
    
    def _determine_content_type(self, task: Dict) -> str:
        """
        コンテンツタイプを判定
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: コンテンツタイプ
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
        
        # 記事生成
        if any(kw in description or kw in prompt for kw in ['記事', 'article', 'ブログ', 'blog']):
            return 'article'
        
        # 翻訳
        if any(kw in description or kw in prompt for kw in ['翻訳', 'translate', 'translation']):
            return 'translation'
        
        # 技術文書
        if any(kw in description or kw in prompt for kw in ['要件定義', '設計書', '仕様書', 'technical', 'spec']):
            return 'technical_document'
        
        return 'generic'
    
    async def _execute_article_generation(self, task: Dict) -> Dict:
        """
        記事生成タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📰 記事生成タスク実行")
            
            # プロンプト構築
            prompt = self._build_article_prompt(task)
            
            # AIチャットエージェントを使用して生成
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=180)
                
                if success:
                    # 応答取得
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 100:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'article',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': '記事生成失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': '記事生成失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 記事生成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_translation_task(self, task: Dict) -> Dict:
        """
        翻訳タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🌐 翻訳タスク実行")
            
            # 翻訳プロンプト構築
            prompt = self._build_translation_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'translation',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': '翻訳失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': '翻訳失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 翻訳エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_technical_document_task(self, task: Dict) -> Dict:
        """
        技術文書生成タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📋 技術文書生成タスク実行")
            
            # 技術文書プロンプト構築
            prompt = self._build_technical_document_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=300)  # 長めのタイムアウト
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    # 技術文書は部分的な成功も許容
                    if response_text and len(response_text) > 500:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': len(response_text) > 2000  # 完全性フラグ
                        }
                    elif response_text and len(response_text) > 200:
                        # 部分的な成功
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': False,
                            'partial_success': True,
                            'warning': '文書が完全ではない可能性があります'
                        }
                    else:
                        return {
                            'success': False,
                            'error': '技術文書生成失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': '技術文書生成失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 技術文書生成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_generic_content_task(self, task: Dict) -> Dict:
        """
        汎用コンテンツ生成タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📄 汎用コンテンツ生成タスク実行")
            
            prompt = task.get('prompt', '')
            if not prompt:
                return {
                    'success': False,
                    'error': 'プロンプトが指定されていません'
                }
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'generic',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'コンテンツ生成失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'コンテンツ生成失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 汎用コンテンツ生成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }    
    
    def _build_article_prompt(self, task: Dict) -> str:
            """記事生成用プロンプトを構築"""
            base_prompt = task.get('prompt', '')
            language = task.get('language', 'ja')
            
            if language == 'ja':
                return f"""以下のテーマで質の高い記事を生成してください：

    {base_prompt}

    【記事の要件】
    - 専門的かつ分かりやすい内容
    - 具体的な事例やデータを含める
    - 読者の関心を引く導入部
    - 明確な結論で締めくくる
    - 1500文字以上で詳細に記述

    【出力形式】
    - 見出しを適切に使用
    - 段落分けを明確に
    - 読みやすい文体で"""
            
            else:
                return f"""Generate a high-quality article on the following topic:

    {base_prompt}

    【Article Requirements】
    - Professional yet accessible content
    - Include specific examples and data
    - Engaging introduction
    - Clear conclusion
    - Detailed description over 1500 words

    【Output Format】
    - Use appropriate headings
    - Clear paragraph breaks
    - Readable writing style"""
        
    def _build_translation_prompt(self, task: Dict) -> str:
        """翻訳用プロンプトを構築"""
        source_text = task.get('source_text', '')
        target_language = task.get('target_language', 'ja')
        source_language = task.get('source_language', 'en')
        
        return f"""以下のテキストを{source_language}から{target_language}に翻訳してください：

    {source_text}

    【翻訳要件】
    - 自然で流暢な表現
    - 専門用語は適切に訳す
    - 文化的な違いを考慮
    - 原文の意味を正確に伝える"""
        
    def _build_technical_document_prompt(self, task: Dict) -> str:
        """技術文書用プロンプトを構築"""
        base_prompt = task.get('prompt', '')
        
        return f"""以下の要件に基づいて詳細な技術文書を作成してください：

    {base_prompt}

    【文書要件】
    - 技術的に正確な内容
    - 体系的な構成
    - 具体的な実装例やコードサンプル
    - わかりやすい説明
    - 2000文字以上で詳細に記述

    【出力形式】
    - 章立てを明確に
    - コードブロックは適切にフォーマット
    - 表やリストを必要に応じて使用
    - 専門用語は初出時に簡潔に説明"""
    
    
    def _build_pydantic_migration_prompt(self, task: Dict) -> str:
        """
        Pydanticモデル移行専用プロンプトを構築
    
        Args:
            task: タスク情報辞書
        
        Returns:
            str: Pydanticモデル移行プロンプト
        """
        base_prompt = task.get('prompt', '')
        current_implementation = task.get('current_implementation', '')
    
        return f"""以下の要件に基づいて、既存のデータ構造をPydanticモデルに移行してください:

    {base_prompt}

    【現在の実装】
    {current_implementation if current_implementation else '※データ構造の詳細は要件定義書を参照'}

    【Pydantic移行要件】
    1. **Pydanticモデル定義**
        - すべてのデータ構造をPydantic BaseModelクラスとして定義
        - 型ヒント(Type Hints)を明確に指定
        - Field()を使用したバリデーション設定
        - Optional型の適切な使用

    2. **バリデーション実装**
        - 必須フィールドの定義
        - データ型の厳格なチェック
        - カスタムバリデータの実装
        - エラーメッセージの日本語化

    3. **JSONスキーマ生成**
        - model.schema_json()によるスキーマ出力
        - OpenAPI互換性の確保
        - ドキュメント文字列の記述

    4. **自動テストコード**
        - pytest対応のテストケース
        - 正常系・異常系のテストデータ
        - バリデーションエラーの確認

    【出力形式】
    ```python
    from pydantic import BaseModel, Field, validator
    from typing import Optional, List
    from datetime import datetime
    # (完全なPydanticモデル定義コード)
    【必須要素】

    すべてのフィールドに型ヒントとField()による説明
    @validatorデコレータによるカスタム検証ロジック
    repr()メソッドのオーバーライド
    model_config設定(alias, extra='forbid'など)

    2000文字以上で詳細に記述してください。"""
    
    def _build_openapi_schema_prompt(self, task: Dict) -> str:
        """
        OpenAPIスキーマ生成専用プロンプトを構築
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: OpenAPIスキーマ生成プロンプト
        """
        base_prompt = task.get('prompt', '')
        api_endpoints = task.get('api_endpoints', [])
        
        endpoints_list = '\n'.join([f"  - {ep}" for ep in api_endpoints]) if api_endpoints else '※要件定義書参照'
        
        return f"""以下のAPI仕様に基づいて、完全なOpenAPI 3.0スキーマを生成してください:
    {base_prompt}
    【対象APIエンドポイント】
    {endpoints_list}
    【OpenAPIスキーマ要件】

    1.基本構造
    OpenAPI 3.0.0準拠
    info(タイトル、バージョン、説明)
    servers(開発・本番環境)
    paths(全エンドポイント)
    components/schemas(データモデル)


    2.エンドポイント定義
    HTTPメソッド(GET, POST, PUT, DELETE)
    パスパラメータとクエリパラメータ
    リクエストボディ(application/json)
    レスポンススキーマ(200, 400, 500)
    認証要件(bearerAuth)


    3.データモデル定義
    すべてのリクエスト/レスポンス型
    プロパティの型と説明
    required配列の定義
    example値の提供

    4.セキュリティ定義
    securitySchemes定義
    JWT認証の設定
    OAuth2フロー(該当する場合)

    【出力形式】
    openapi: 3.0.0
    info:
      title: (APIタイトル)
      version: 1.0.0
      description: (API説明)
    servers:
      - url: https://api.example.com/v1
    paths:
      # (完全なエンドポイント定義)
    components:
      schemas:
        # (完全なデータモデル定義)
      securitySchemes:
        bearerAuth:
          type: http
          scheme: bearer
          bearerFormat: JWT
    2500文字以上で詳細に記述してください。"""
    def _build_requirements_document_prompt(self, task: Dict) -> str:
        """
        要件定義書作成専用プロンプトを構築
    
        Args:
            task: タスク情報辞書
        
        Returns:
            str: 要件定義書プロンプト
        """
        base_prompt = task.get('prompt', '')
        project_name = task.get('project_name', 'プロジェクト')
    
        return f"""以下のプロジェクトについて、包括的な要件定義書を作成してください:
    プロジェクト名: {project_name}
    {base_prompt}
    【要件定義書の構成】
    1. プロジェクト概要

    プロジェクトの背景と目的
    対象ユーザー・ステークホルダー
    プロジェクトのスコープ
    成功指標(KPI)

    2. 機能要件
    2.1 ユーザー機能

    会員登録・ログイン
    プロフィール管理
    (その他機能を列挙)

    2.2 管理機能

    コンテンツ管理
    ユーザー管理
    レポート・分析

    2.3 API仕様

    エンドポイント一覧
    認証方式
    データフォーマット

    3. 非機能要件
    3.1 パフォーマンス要件

    レスポンスタイム目標
    同時接続数
    データ量の想定

    3.2 セキュリティ要件

    認証・認可方式
    データ暗号化
    脆弱性対策

    3.3 可用性・拡張性

    SLA目標
    バックアップ・リカバリ
    スケーラビリティ

    4. 技術スタック
    4.1 フロントエンド

    フレームワーク/ライブラリ
    状態管理
    UI/UXライブラリ

    4.2 バックエンド

    言語・フレームワーク
    データベース
    APIアーキテクチャ

    4.3 インフラ

    ホスティング環境
    CI/CD
    監視・ログ

    5. データ設計
    5.1 データモデル

    エンティティ一覧
    リレーションシップ
    主要な制約

    5.2 データフロー

    データの流れ
    外部連携
    バッチ処理

    6. 画面設計
    6.1 画面一覧

    画面名と役割
    画面遷移図
    ワイヤーフレーム概要

    7. 外部連携

    決済API
    メール送信
    ソーシャルログイン

    8. 運用・保守

    リリース計画
    運用体制
    サポート体制

    9. リスク管理

    想定リスク
    対策
    緊急時対応

    10. スケジュール

    マイルストーン
    各フェーズの期間
    リリース日

    【記述要件】

    各セクションを具体的かつ詳細に記述
    技術的な実装案も含める
    数値目標を明確に設定
    図表の説明も含める(実際の図は別途)

    3000文字以上で詳細に記述してください。"""
   
    def _determine_content_type(self, task: Dict) -> str:
        """
        コンテンツタイプを判定
    
        Args:
            task: タスク情報辞書
        
        Returns:
            str: コンテンツタイプ
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
    
        # ========================================
        # 🆕 専門文書タイプの判定（新規追加）
        # ========================================
    
        # Pydantic移行タスク
        if any(kw in description or kw in prompt for kw in ['pydantic', 'モデル移行', 'model migration', 'バリデーション']):
            return 'pydantic_migration'
    
        # OpenAPIスキーマ生成
        if any(kw in description or kw in prompt for kw in ['openapi', 'swagger', 'api仕様', 'api schema']):
            return 'openapi_schema'
    
        # 要件定義書作成
        if any(kw in description or kw in prompt for kw in ['要件定義書', '要件定義', 'requirements document', 'システム要件']):
            return 'requirements_document'
    
        # ========================================
        # 既存の判定ロジック
        # ========================================
    
        # 記事生成
        if any(kw in description or kw in prompt for kw in ['記事', 'article', 'ブログ', 'blog']):
            return 'article'
    
        # 翻訳
        if any(kw in description or kw in prompt for kw in ['翻訳', 'translate', 'translation']):
            return 'translation'
    
        # 技術文書
        if any(kw in description or kw in prompt for kw in ['要件定義', '設計書', '仕様書', 'technical', 'spec']):
            return 'technical_document'
    
        return 'generic'
    
    def _is_partial_success(self, result: Dict) -> bool:
        """
        部分的な成功か判定
        
        Args:
            result: 実行結果
            
        Returns:
            bool: 部分成功ならTrue
        """
        if not result:
            return False
        
        # コンテンツがある程度あれば部分成功とみなす
        content = result.get('content') or result.get('full_text')
        if content and len(str(content)) > 500:
            return True
        
        # 技術文書で不完全フラグがある場合
        if result.get('content_type') == 'technical_document' and content and len(str(content)) > 200:
            return True
        
        return False
    
    
    

#content_writer_agent.py
# content_writer_agent.py
import asyncio
import logging
import json
from pathlib import Path
from typing import Dict
from datetime import datetime

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class ContentWriterAgent:
    """強化版コンテンツライターAI - コンパクトな構造化HTML記事を生成"""
    
    CONTENT_WRITER_PROMPT = """あなたは経験豊富なコンテンツライターです。ウズベキスタンのM&A市場に関する専門知識を持っています。

【あなたの役割】
- 指定されたURLの記事を読み、ウズベキスタンのM&Aに興味があるビジネスオーナー向けに有益な記事を作成
- ブログにそのまま掲載できる高品質の構造化HTML記事を執筆
- SEOを意識した構成とキーワード配置
- 多言語対応（日本語/英語/ロシア語など）

【執筆の原則】
1. 「了解しました！」などの挨拶は一切不要
2. 最初から完全なHTML形式で出力
3. 数字や重要な部分は<strong>タグで強調
4. 適切な見出し構造（h2, h3）と段落で読みやすく
5. リストを活用した構造化
6. ターゲット読者（ビジネスオーナー、投資家）の関心に合わせた内容

【記事の長さ】
- 目標文字数: 1800〜3500文字、2000~3000文字程度が最もベスト
- コンパクトで価値の高い内容に集中
- 冗長な説明を避け、重要なポイントのみを記載

【出力形式 - シンプルなHTML構造】
以下のHTML構造で出力してください：

<article class="mna-article">
  <h1>記事タイトル - 魅力的でSEOを意識</h1>
  
  <div class="article-meta">
    <span class="publish-date">公開日: YYYY年MM月DD日</span>
    <span class="target-region">対象地域: ウズベキスタン</span>
  </div>
  
  <section class="intro">
    <h2>はじめに</h2>
    <p>この記事のテーマと価値を簡潔に説明（2-3文）</p>
  </section>
  
  <section class="main-content">
    <h2>主要ポイント</h2>
    <p>重要な情報を簡潔に説明（3-4段落）</p>
    
    <div class="key-points">
      <h3>注目すべき点</h3>
      <ul>
        <li><strong>ポイント1</strong>: 簡潔な説明</li>
        <li><strong>ポイント2</strong>: 簡潔な説明</li>
        <li><strong>ポイント3</strong>: 簡潔な説明</li>
      </ul>
    </div>
  </section>
  
  <section class="business-value">
    <h2>ビジネス機会</h2>
    <p>ウズベキスタンのM&A市場における具体的な機会（2-3段落）</p>
  </section>
  
  <section class="conclusion">
    <h2>まとめ</h2>
    <p>要点を2-3文でまとめる</p>
  </section>
  
  <div class="article-footer">
    <p><strong>参照元</strong>: <a href="元記事URL" target="_blank">元記事タイトル</a></p>
  </div>
</article>

【重要な制約】
- 各セクションは簡潔に（1セクションあたり200-300文字）
- 冗長な表現を避ける
- 必ず最後（</article>タグ）まで完結させる
"""

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
            else:
                self.output_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
                self.output_folder.mkdir(exist_ok=True, parents=True)
        else:
            self.output_folder = output_folder
    
    async def process_task(self, task: Dict) -> Dict:
        """コンテンツ作成タスクを処理 - コンパクトな構造化HTML出力"""
        try:
            logger.info(f"🔧 強化版コンテンツライターAI: タスク処理開始")
            logger.info(f"タスク: {task['description'][:100]}...")
            
            # タスクから要件を抽出
            task_info = self._parse_task_requirements(task['description'])
            
            # タスクに明示的な言語フィールドがある場合は優先
            if 'language' in task and task['language']:
                task_info['language'] = task['language']
                logger.info(f"📌 タスクフィールドから言語を取得: {task_info['language']}")
            
            logger.info(f"  URL: {task_info['url'][:60] if task_info['url'] else '(URLなし)'}...")
            logger.info(f"  言語: {task_info['language']}")
            logger.info(f"  ターゲット: {task_info['target_audience']}")
            
            # 言語別のプロンプト調整
            language_specific_prompt = self._get_language_specific_prompt(task_info['language'])
            
            # プロンプトを構築（コンパクト版）
            full_prompt = f"""{self.CONTENT_WRITER_PROMPT}

{language_specific_prompt}

【具体的な執筆依頼】
参照URL: {task_info['url']}
ターゲット読者: {task_info['target_audience']}
言語: {task_info['language']}

【厳守事項】
1. 上記URLの記事を読み、{task_info['target_audience']}向けに有益な記事を作成
2. 目標文字数: 1500〜1800文字（これを絶対に超えない）
3. 完全なHTML形式で出力（マークダウン不可）
4. 見出し構造（h1, h2, h3）を適切に使用
5. 重要な数字は<strong>タグで強調
6. 記事全体を{task_info['language']}で執筆
7. 各セクションは簡潔に（1セクション200-300文字）

【最重要】
- 記事は必ず完結させる（途中で終わらない）
- </article>タグで必ず閉じる
- conclusionセクションとarticle-footerを必ず含める
- 長すぎる記事は途中で切れる可能性があるため、コンパクトに書く

**1800文字以内で、HTMLタグを使用した完全な記事を最後まで書き切ってください。**"""
            
            # Geminiに送信
            logger.info("Geminiにコンパクトな構造化HTML記事作成を依頼中...")
            logger.info(f"  目標文字数: 1500〜1800文字")
            logger.info(f"  プロンプト長: {len(full_prompt)}文字")
            await self.browser.send_prompt(full_prompt)
            
            # 応答待機（コンパクトなので短めでOK）
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                return {
                    'success': False,
                    'error': 'コンテンツライターAI: タイムアウト'
                }
            
            # 応答を取得
            article_html = await self.browser.extract_latest_text_response()
            
            if not article_html:
                return {
                    'success': False,
                    'error': 'コンテンツライターAI: 記事取得失敗'
                }
            
            logger.info(f"✅ 構造化HTML記事生成完了: {len(article_html)}文字")
            
            # HTMLの完全性をチェック
            if not self._validate_html_completeness(article_html):
                logger.warning("⚠️ 記事が途中で途切れている可能性があります")
            
            # タイトルを抽出（最初の<h1>タグ）
            import re
            title_match = re.search(r'<h1[^>]*>(.+?)</h1>', article_html, re.IGNORECASE | re.DOTALL)
            article_title = title_match.group(1).strip() if title_match else "（タイトル不明）"
            
            logger.info(f"  記事タイトル: {article_title}")
            
            # JSON形式でメタデータとともに保存
            article_data = {
                'task_id': task['task_id'],
                'title': article_title,
                'html_content': article_html,
                'language': task_info['language'],
                'target_audience': task_info['target_audience'],
                'source_url': task_info['url'],
                'created_at': datetime.now().isoformat(),
                'word_count': len(article_html),
                'content_type': 'structured_html_compact',
                'is_complete': self._validate_html_completeness(article_html)
            }
            
            # JSONファイルとして保存
            json_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            json_output_path = self.output_folder / json_filename
            
            with open(json_output_path, 'w', encoding='utf-8') as f:
                json.dump(article_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"構造化記事をJSON保存: {json_filename}")
            
            # HTMLファイルも別途保存（確認用）
            html_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            html_output_path = self.output_folder / html_filename
            
            with open(html_output_path, 'w', encoding='utf-8') as f:
                f.write("<!DOCTYPE html>\n")
                f.write("<html lang='ja'>\n")
                f.write("<head>\n")
                f.write("<meta charset='UTF-8'>\n")
                f.write("<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n")
                f.write(f"<title>{article_title}</title>\n")
                f.write("<style>\n")
                f.write("body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.8; margin: 40px; max-width: 800px; margin: 0 auto; padding: 40px; }\n")
                f.write("h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 15px; font-size: 28px; }\n")
                f.write("h2 { color: #34495e; margin-top: 35px; font-size: 22px; border-left: 4px solid #3498db; padding-left: 10px; }\n")
                f.write("h3 { color: #16a085; font-size: 18px; margin-top: 20px; }\n")
                f.write(".article-meta { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 25px 0; font-size: 14px; }\n")
                f.write(".key-points { background: #e8f4fd; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3498db; }\n")
                f.write(".article-footer { margin-top: 50px; padding-top: 25px; border-top: 2px solid #ddd; color: #666; }\n")
                f.write("ul { line-height: 1.8; }\n")
                f.write("li { margin-bottom: 10px; }\n")
                f.write("strong { color: #e74c3c; }\n")
                f.write("p { margin-bottom: 15px; }\n")
                f.write("</style>\n")
                f.write("</head>\n")
                f.write("<body>\n")
                f.write(article_html)
                f.write("</body>\n")
                f.write("</html>\n")
            
            logger.info(f"HTMLプレビューも保存: {html_filename}")
            
            # サマリーを作成
            article_preview = self._extract_text_preview(article_html)
            
            summary = f"記事タイトル: {article_title}\n言語: {task_info['language']}\n文字数: {len(article_html)}\n完全性: {'✅ 完全' if article_data['is_complete'] else '⚠️ 不完全'}\nプレビュー: {article_preview}"
            
            return {
                'success': True,
                'output_file': str(json_output_path),
                'html_file': str(html_output_path),
                'summary': summary,
                'full_text': article_html,
                'article_title': article_title,
                'content_type': 'structured_html_compact',
                'language': task_info['language'],
                'is_complete': article_data['is_complete']
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "強化版コンテンツライターAI処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _validate_html_completeness(self, html_content: str) -> bool:
        """HTMLが完全かどうかをチェック"""
        import re
        
        # 必須要素がすべて含まれているかチェック
        required_elements = [
            r'<article[^>]*>',           # 開始タグ
            r'</article>',                # 終了タグ
            r'<section[^>]*class="conclusion"',  # まとめセクション
            r'<div[^>]*class="article-footer"'   # フッター
        ]
        
        for pattern in required_elements:
            if not re.search(pattern, html_content, re.IGNORECASE):
                logger.warning(f"⚠️ 必須要素が見つかりません: {pattern}")
                return False
        
        return True
    
    def _get_language_specific_prompt(self, language: str) -> str:
        """言語別の追加プロンプトを返す"""
        prompts = {
            "日本語": """
【日本語記事の特徴】
- 必ず日本語（ひらがな、カタカナ、漢字を含む自然な日本語）で執筆
- 敬語を使用し、ビジネスフォーマルな文体を維持
- 具体的なデータとともに説明を展開
- ウズベキスタンのM&A市場における日本企業の視点を重視
- 読者（日本のビジネスオーナー）が理解しやすい表現を使用
- 1500〜1800文字以内にまとめる

【執筆時の注意点】
- 英語や他言語は固有名詞・専門用語以外では使用しない
- 数字は半角、単位は全角（例: 6%、100億円）
- 各セクションは簡潔に200-300文字程度
- 記事は必ず最後（</article>タグ）まで完結させる
""",
            "English": """
【English Article Features】
- Write entirely in English (no Japanese characters except proper nouns)
- Use business formal English throughout
- Include specific data and examples
- Focus on investment opportunities in Uzbekistan's M&A market
- Target international business owners and investors
- Keep article between 1500-1800 characters
- Complete the article with proper conclusion and footer sections
""",
            "Русский (ロシア語)": """
【Русскоязычная статья особенности】
- Пишите полностью на русском языке
- Используйте деловой русский язык
- Включите конкретные данные и примеры
- Акцент на возможностях слияний и поглощений в Узбекистане
- Целевая аудитория - русскоязычные инвесторы
- Объём статьи: 1500-1800 символов
- Завершите статью полноценным заключением
"""
        }
        return prompts.get(language, prompts["日本語"])
    
    def _extract_text_preview(self, html_content: str) -> str:
        """HTMLからテキストプレビューを抽出"""
        import re
        # HTMLタグを除去
        text = re.sub(r'<[^>]+>', ' ', html_content)
        # 連続する空白を単一スペースに
        text = re.sub(r'\s+', ' ', text)
        # 先頭200文字を返す
        return text.strip()[:200] + "..." if len(text) > 200 else text
    
    def _parse_task_requirements(self, description: str) -> Dict[str, str]:
        """タスク説明から要件を抽出（日本語デフォルト版）"""
        import re
        
        # URLを抽出
        url_match = re.search(r'https?://[^\s]+', description)
        url = url_match.group(0) if url_match else ""
        
        # === 言語検出ロジック（日本語デフォルト戦略） ===
        # 基本方針: 明示的な指定がない限り、常に日本語で生成
        language = "日本語"  # 絶対的なデフォルト
        
        # 明示的な言語指定パターン（非常に厳格に）
        explicit_lang_patterns = {
            "English": [
                r'英語で(?:作成|記事|執筆|書)',
                r'write in english',
                r'in english(?:\s+language)?',
                r'create.*in english',
                r'言語[：:]\s*(?:英語|English)'
            ],
            "Русский (ロシア語)": [
                r'ロシア語で(?:作成|記事|執筆|書)',
                r'на русском(?:\s+языке)?',
                r'in russian',
                r'言語[：:]\s*(?:ロシア語|русский)'
            ],
            "中文": [
                r'中国語で(?:作成|記事|執筆|書)',
                r'中文で(?:作成|記事|執筆|書)',
                r'in chinese',
                r'用中文',
                r'言語[：:]\s*(?:中国語|中文|Chinese)'
            ],
            "한국어": [
                r'韓国語で(?:作成|記事|執筆|書)',
                r'한국어로',
                r'in korean',
                r'言語[：:]\s*(?:韓国語|한국어)'
            ],
            "Türkçe": [
                r'トルコ語で(?:作成|記事|執筆|書)',
                r'türkçe(?:\'de)?',
                r'in turkish',
                r'言語[：:]\s*(?:トルコ語|Türkçe)'
            ],
            "O'zbek": [
                r'ウズベク語で(?:作成|記事|執筆|書)',
                r'o\'zbek tilida',
                r'in uzbek',
                r'言語[：:]\s*(?:ウズベク語|O\'zbek)'
            ]
        }
        
        # 明示的な言語指定をチェック
        explicit_lang_found = False
        for lang, patterns in explicit_lang_patterns.items():
            for pattern in patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    language = lang
                    explicit_lang_found = True
                    logger.info(f"✅ 明示的な言語指定を検出: {language}")
                    logger.info(f"   マッチしたパターン: {pattern}")
                    break
            if explicit_lang_found:
                break
        
        # 明示的な指定がなかった場合
        if not explicit_lang_found:
            logger.info("📌 明示的な言語指定なし → デフォルトの日本語を使用")
            
            # 補助的な判定（極端なケースのみ）
            # キリル文字が大半を占める場合のみロシア語と判定
            cyrillic_count = len(re.findall(r'[А-Яа-яЁё]', description))
            total_chars = len(re.sub(r'\s', '', description))
            
            # ハングルが大半を占める場合のみ韓国語と判定
            hangul_count = len(re.findall(r'[가-힣]', description))
            
            if total_chars > 0:
                if cyrillic_count > total_chars * 0.3:  # 30%以上がキリル文字
                    language = "Русский (ロシア語)"
                    logger.info(f"🔍 キリル文字が多数（{cyrillic_count}/{total_chars}）: ロシア語")
                elif hangul_count > total_chars * 0.3:  # 30%以上がハングル
                    language = "한국어"
                    logger.info(f"🔍 ハングルが多数（{hangul_count}/{total_chars}）: 韓国語")
                else:
                    # それ以外は全て日本語（ひらがな・カタカナ・漢字・英数字混在含む）
                    logger.info("📝 デフォルト言語確定: 日本語")
        
        # ターゲット読者を抽出
        target_patterns = [
            r'(.+?)向けに',
            r'(.+?)向けの',
            r'ターゲット[：:]\s*(.+)',
            r'for (.+?) considering',
            r'для (.+?),',
            r'対象読者[：:]\s*(.+)'
        ]
        target_audience = ""
        for pattern in target_patterns:
            match = re.search(pattern, description)
            if match:
                target_audience = match.group(1).strip()
                break
        
        if not target_audience:
            target_audience = "ウズベキスタンのM&Aに興味があるビジネスオーナー"
        
        # 特別な要件を抽出
        requirements = []
        if '構造化' in description or 'HTML' in description.upper():
            requirements.append("構造化HTML形式で出力")
        if 'データ' in description or '数字' in description:
            requirements.append("具体的なデータと数字を含める")
        if '事例' in description or 'ケーススタディ' in description:
            requirements.append("実際の事例やケーススタディを含める")
        
        logger.info(f"📝 最終決定言語: {language}")
        logger.info(f"🎯 ターゲット読者: {target_audience}")
        
        def _get_translation_prompt(self, source_language: str, target_language: str) -> str:
            """翻訳タスク用の追加プロンプト"""
            return f"""
        【翻訳タスクの指示】
        これは翻訳タスクです。以下の指示に厳密に従ってください：

        1. 元の記事の内容を{target_language}に正確に翻訳
        2. HTML構造とフォーマットを維持
        3. 文化的な違いを考慮した自然な表現を使用
        4. 専門用語は正確に翻訳
        5. 数字やデータはそのまま保持

        翻訳元言語: {source_language}
        翻訳先言語: {target_language}

        **重要: 翻訳後の記事は完全なHTML形式で、必ず</article>タグで終了すること**
        """
        
        return {
            'url': url,
            'language': language,
            'target_audience': target_audience,
            'requirements': '、'.join(requirements) if requirements else "標準的な構造化記事"
        }

#design_agent.py
import asyncio
import logging
from pathlib import Path
from typing import Dict
from datetime import datetime

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class DesignAgent:
    """設計AI - 要件定義、設計書、アーキテクチャを作成"""
    
    DESIGN_SYSTEM_PROMPT = """あなたは経験豊富なシステム設計者です。

【あなたの役割】
- 要件定義書の作成
- システムアーキテクチャの設計
- データベーススキーマの設計
- API仕様の定義
- 技術選定と理由の説明

【設計の原則】
1. 実装可能性を最優先する
2. セキュリティを考慮する
3. スケーラビリティを意識する
4. 開発者が理解しやすい文書を作成

【出力形式】
タスクの内容に応じて、以下の形式で出力してください：

## タスク概要
（タスクの理解と目的）

## 設計内容
（具体的な設計内容）

## 技術選定
（使用する技術とその理由）

## 実装における注意点
（開発時の注意事項）

## 次のステップ
（このタスク後に行うべきこと）"""

    # design_agent.py の __init__ メソッドを修正

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        # 出力フォルダが指定されていない場合はB14から取得
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"Agent出力先（B14から取得）: {self.output_folder}")
            else:
                # フォールバック: デフォルトパス
                self.output_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.warning(f"B14が空のため、デフォルトフォルダを使用: {self.output_folder}")
        else:
            self.output_folder = output_folder
    
    async def process_task(self, task: Dict) -> Dict:
        """設計タスクを処理"""
        try:
            logger.info(f"設計AI: タスク処理開始 - {task['description']}")
            
            # プロンプトを構築
            full_prompt = f"""{self.DESIGN_SYSTEM_PROMPT}

【タスク】
{task['description']}

上記のタスクについて、詳細な設計を行ってください。
実装可能で具体的な設計書を作成してください。"""
            
            # Geminiに送信
            logger.info("Geminiに設計タスクを送信中...")
            await self.browser.send_prompt(full_prompt)
            
            # 応答待機
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                return {
                    'success': False,
                    'error': '設計AI: タイムアウト'
                }
            
            # 応答を取得
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': '設計AI: 応答取得失敗'
                }
            
            logger.info(f"設計AI: 応答取得完了（{len(response_text)}文字）")
            
            # 結果をファイルに保存
            filename = f"design_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            output_path = self.output_folder / filename
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# 設計書: {task['description']}\n\n")
                f.write(f"タスクID: {task['task_id']}\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
            
            logger.info(f"設計書を保存: {output_path}")
            
            # サマリーを作成（最初の500文字）
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
            
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "設計AI処理")
            return {
                'success': False,
                'error': str(e)
            }

#dev_agent.py
# dev_agent.py
"""開発AI - コード生成とテストコード、WordPress専用機能の作成"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class DevAgent:
    """開発AI - コード生成とテストコード、WordPress専用機能の作成"""
    
    DEV_SYSTEM_PROMPT = """あなたは経験豊富なソフトウェアエンジニアです。

【あなたの役割】
- 高品質なコードの実装
- テストコードの作成
- エラーハンドリングの実装
- コメントとドキュメントの作成

【コーディング原則】
1. 可読性の高いコードを書く
2. セキュリティを考慮する
3. エラーハンドリングを適切に行う
4. テスト可能な設計にする
5. 最新のベストプラクティスに従う

【出力形式】
以下の形式でコードを出力してください：

## タスク概要
（タスクの理解）

## 実装内容
（実装の説明）

## コード
```python
# または他の言語
# 完全に動作するコード
```

## テストコード
```python
# 単体テストまたは統合テスト
```

## 使用方法
（コードの使い方）

## 注意事項
（実装時の注意点や制約）"""

    WORDPRESS_CPT_PROMPT = """あなたはWordPress開発の専門家です。

【WordPress カスタム投稿タイプ作成の専門家】

以下の要件に基づいて、完全に動作するWordPressカスタム投稿タイプのPHPコードを生成してください。

【必須要素】
1. register_post_type() 関数を使用
2. 適切なラベル（labels）の定義
3. サポート機能（supports）の指定
4. 管理画面での表示設定
5. REST API対応
6. リライトルール
7. アーカイブページの有効化

【出力形式】
以下の形式で出力してください：

## カスタム投稿タイプ: {post_type_slug}

### 概要
（このカスタム投稿タイプの説明）

### functions.php に追加するコード

```php
<?php
/**
 * カスタム投稿タイプ: {post_type_slug}
 * 
 * @package WordPress
 * @since 1.0.0
 */

// カスタム投稿タイプの登録
function register_cpt_{post_type_slug}() {{
    $labels = array(
        'name'                  => _x( '{plural_name}', 'Post Type General Name', 'textdomain' ),
        'singular_name'         => _x( '{singular_name}', 'Post Type Singular Name', 'textdomain' ),
        'menu_name'             => __( '{menu_name}', 'textdomain' ),
        'name_admin_bar'        => __( '{singular_name}', 'textdomain' ),
        'archives'              => __( '{plural_name} アーカイブ', 'textdomain' ),
        'attributes'            => __( '{singular_name} 属性', 'textdomain' ),
        'parent_item_colon'     => __( '親 {singular_name}:', 'textdomain' ),
        'all_items'             => __( 'すべての {plural_name}', 'textdomain' ),
        'add_new_item'          => __( '新規 {singular_name} を追加', 'textdomain' ),
        'add_new'               => __( '新規追加', 'textdomain' ),
        'new_item'              => __( '新規 {singular_name}', 'textdomain' ),
        'edit_item'             => __( '{singular_name} を編集', 'textdomain' ),
        'update_item'           => __( '{singular_name} を更新', 'textdomain' ),
        'view_item'             => __( '{singular_name} を表示', 'textdomain' ),
        'view_items'            => __( '{plural_name} を表示', 'textdomain' ),
        'search_items'          => __( '{plural_name} を検索', 'textdomain' ),
        'not_found'             => __( '見つかりません', 'textdomain' ),
        'not_found_in_trash'    => __( 'ゴミ箱にありません', 'textdomain' ),
        'featured_image'        => __( 'アイキャッチ画像', 'textdomain' ),
        'set_featured_image'    => __( 'アイキャッチ画像を設定', 'textdomain' ),
        'remove_featured_image' => __( 'アイキャッチ画像を削除', 'textdomain' ),
        'use_featured_image'    => __( 'アイキャッチ画像として使用', 'textdomain' ),
        'insert_into_item'      => __( '{singular_name} に挿入', 'textdomain' ),
        'uploaded_to_this_item' => __( 'この {singular_name} にアップロード', 'textdomain' ),
        'items_list'            => __( '{plural_name} リスト', 'textdomain' ),
        'items_list_navigation' => __( '{plural_name} リストナビゲーション', 'textdomain' ),
        'filter_items_list'     => __( '{plural_name} リストをフィルタ', 'textdomain' ),
    );
    
    $args = array(
        'label'                 => __( '{singular_name}', 'textdomain' ),
        'description'           => __( '{description}', 'textdomain' ),
        'labels'                => $labels,
        'supports'              => array( {supports} ),
        'taxonomies'            => array( {taxonomies} ),
        'hierarchical'          => {hierarchical},
        'public'                => true,
        'show_ui'               => true,
        'show_in_menu'          => true,
        'menu_position'         => 5,
        'menu_icon'             => '{menu_icon}',
        'show_in_admin_bar'     => true,
        'show_in_nav_menus'     => true,
        'can_export'            => true,
        'has_archive'           => true,
        'exclude_from_search'   => false,
        'publicly_queryable'    => true,
        'capability_type'       => 'post',
        'show_in_rest'          => true,
        'rest_base'             => '{rest_base}',
        'rest_controller_class' => 'WP_REST_Posts_Controller',
        'rewrite'               => array(
            'slug'       => '{slug}',
            'with_front' => false,
        ),
    );
    
    register_post_type( '{post_type_slug}', $args );
}}
add_action( 'init', 'register_cpt_{post_type_slug}', 0 );
?>
```

### 関連するカスタムタクソノミー（必要に応じて）

```php
<?php
// カスタムタクソノミーをここに追加
?>
```

### テンプレートファイル

#### single-{post_type_slug}.php
```php
<?php
// 単一投稿表示用テンプレート
?>
```

#### archive-{post_type_slug}.php
```php
<?php
// アーカイブ表示用テンプレート
?>
```

### 使用方法

1. 上記のコードを `functions.php` または専用のプラグインファイルに追加
2. WordPressの管理画面にアクセス
3. 左メニューに「{menu_name}」が表示されることを確認
4. パーマリンク設定を保存（設定 > パーマリンク設定）

### 注意事項

- カスタム投稿タイプのスラッグは20文字以内にしてください
- 予約語（post, page, attachmentなど）は使用できません
- プラグインとして実装する場合は、適切なヘッダー情報を追加してください
- テーマの functions.php に追加する場合は、子テーマを使用することを推奨します
"""

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        # 出力フォルダが指定されていない場合はB14から取得
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"Agent出力先（B14から取得）: {self.output_folder}")
            else:
                # フォールバック: デフォルトパス
                self.output_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.warning(f"B14が空のため、デフォルトフォルダを使用: {self.output_folder}")
        else:
            self.output_folder = output_folder
        
        self.design_docs = {}  # 設計書を参照できるようにする
        
    
    
    async def process_task(self, task: Dict) -> Dict:
        """開発タスクを処理（WordPress対応強化版）"""
        try:
            logger.info(f"開発AI: タスク処理開始 - {task['description']}")
            
            # WordPress カスタム投稿タイプ作成タスクか判定
            if self._is_wordpress_cpt_task(task):
                return await self._process_wordpress_cpt_task(task)
            
            # WordPress タクソノミー作成タスクか判定
            if self._is_wordpress_taxonomy_task(task):
                return await self._process_wordpress_taxonomy_task(task)
            
            # 通常の開発タスク
            return await self._process_general_task(task)
            
        except Exception as e:
            ErrorHandler.log_error(e, "開発AI処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _is_wordpress_cpt_task(self, task: Dict) -> bool:
        """WordPressカスタム投稿タイプ作成タスクか判定"""
        description = task.get('description', '').lower()
        keywords = [
            'custom post type',
            'カスタム投稿タイプ',
            'cpt',
            'register_post_type',
            '投稿タイプ'
        ]
        return any(kw in description for kw in keywords)
    
    def _is_wordpress_taxonomy_task(self, task: Dict) -> bool:
        """WordPressタクソノミー作成タスクか判定"""
        description = task.get('description', '').lower()
        keywords = [
            'taxonomy',
            'タクソノミー',
            'カスタム分類',
            'register_taxonomy'
        ]
        return any(kw in description for kw in keywords)
    
    async def _process_wordpress_cpt_task(self, task: Dict) -> Dict:
        """WordPressカスタム投稿タイプ作成タスクを処理"""
        try:
            logger.info("="*60)
            logger.info("WordPress カスタム投稿タイプ作成タスク")
            logger.info("="*60)
            
            # タスクから情報を抽出
            cpt_info = self._extract_cpt_info(task)
            
            logger.info(f"投稿タイプスラッグ: {cpt_info['slug']}")
            logger.info(f"表示名（単数）: {cpt_info['singular_name']}")
            logger.info(f"表示名（複数）: {cpt_info['plural_name']}")
            
            # プロンプトを構築
            full_prompt = self._build_wordpress_cpt_prompt(task, cpt_info)
            
            # Geminiに送信
            logger.info("Geminiに要件定義書作成タスクを送信中...")
            await self.browser.send_prompt(full_prompt)
    
            # 応答待機（要件定義書は長いので300秒）
            logger.info("⏱️ 待機時間: 300秒（要件定義書作成）")
    
            # ここが修正箇所！
            success = await self.browser._wait_for_generation_complete()  # ← この行を修正
            # 修正後:
            # success = await self.browser.wait_for_text_generation(max_wait=300)
    
            if not success:
                return {
                    'success': False,
                    'error': '開発AI: タイムアウト（要件定義書作成: 300秒）'
                }
            
            # 応答を取得
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': '開発AI: 応答取得失敗'
                }
            
            logger.info(f"開発AI: 応答取得完了（{len(response_text)}文字）")
            
            # 結果を保存
            output_files = self._save_wordpress_cpt_code(response_text, task, cpt_info)
            
            # サマリーを作成
            summary = f"""✅ WordPressカスタム投稿タイプ作成完了

【投稿タイプ情報】
- スラッグ: {cpt_info['slug']}
- 表示名: {cpt_info['singular_name']} / {cpt_info['plural_name']}
- サポート機能: {', '.join(cpt_info['supports'])}

【生成ファイル】
"""
            for file_info in output_files:
                summary += f"- {file_info['type']}: {file_info['path'].name}\n"
            
            summary += f"\n【次のステップ】\n"
            summary += f"1. functions.php または専用プラグインに追加\n"
            summary += f"2. パーマリンク設定を保存（設定 > パーマリンク設定）\n"
            summary += f"3. 管理画面で「{cpt_info['menu_name']}」メニューを確認\n"
            
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'cpt_slug': cpt_info['slug']
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressカスタム投稿タイプ作成")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _extract_cpt_info(self, task: Dict) -> Dict:
        """タスクからカスタム投稿タイプの情報を抽出"""
        description = task.get('description', '')
        parameters = task.get('parameters', {})
        
        # parametersから取得（最優先）
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        # デフォルト値
        cpt_info = {
            'slug': parameters.get('cpt_slug', 'ma_case'),
            'singular_name': parameters.get('singular_name', 'M&A案件'),
            'plural_name': parameters.get('plural_name', 'M&A案件一覧'),
            'menu_name': parameters.get('menu_name', 'M&A案件'),
            'description': parameters.get('description', 'M&A案件の管理'),
            'supports': parameters.get('supports', ['title', 'editor', 'thumbnail', 'custom-fields']),
            'taxonomies': parameters.get('taxonomies', []),
            'hierarchical': parameters.get('hierarchical', False),
            'menu_icon': parameters.get('menu_icon', 'dashicons-portfolio'),
            'rest_base': parameters.get('rest_base', None),
        }
        
        # rest_base が未設定の場合はslugを使用
        if not cpt_info['rest_base']:
            cpt_info['rest_base'] = cpt_info['slug']
        
        # descriptionから情報を抽出（フォールバック）
        if 'ma_case' in description.lower() or 'm&a' in description.lower():
            cpt_info['slug'] = 'ma_case'
            cpt_info['singular_name'] = 'M&A案件'
            cpt_info['plural_name'] = 'M&A案件一覧'
            cpt_info['menu_name'] = 'M&A案件'
            cpt_info['description'] = 'M&A案件の管理'
            cpt_info['menu_icon'] = 'dashicons-portfolio'
        
        return cpt_info
    
    def _build_wordpress_cpt_prompt(self, task: Dict, cpt_info: Dict) -> str:
        """WordPressカスタム投稿タイプ用のプロンプトを構築"""
        supports_str = "'" + "', '".join(cpt_info['supports']) + "'"
        taxonomies_str = "'" + "', '".join(cpt_info['taxonomies']) + "'" if cpt_info['taxonomies'] else ""
        hierarchical_str = 'true' if cpt_info['hierarchical'] else 'false'
        
        prompt = self.WORDPRESS_CPT_PROMPT.format(
            post_type_slug=cpt_info['slug'],
            singular_name=cpt_info['singular_name'],
            plural_name=cpt_info['plural_name'],
            menu_name=cpt_info['menu_name'],
            description=cpt_info['description'],
            supports=supports_str,
            taxonomies=taxonomies_str,
            hierarchical=hierarchical_str,
            menu_icon=cpt_info['menu_icon'],
            rest_base=cpt_info['rest_base'],
            slug=cpt_info['slug']
        )
        
        prompt += f"""

【追加の要件】
{task.get('description', '')}

【注意事項】
- 完全に動作する実装可能なコードを生成してください
- すべての必須要素を含めてください
- 日本語のラベルを適切に設定してください
- コメントを含めて可読性を高めてください
- ベストプラクティスに従ってください

上記の要件に基づいて、完全なカスタム投稿タイプのコードを生成してください。
"""
        
        return prompt
    
    def _save_wordpress_cpt_code(self, text: str, task: Dict, cpt_info: Dict) -> list:
        """WordPressカスタム投稿タイプのコードを保存"""
        output_files = []
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # 1. 完全なドキュメントを保存
            doc_filename = f"cpt_{cpt_info['slug']}_{timestamp}.md"
            doc_path = self.output_folder / doc_filename
            
            with open(doc_path, 'w', encoding='utf-8') as f:
                f.write(f"# カスタム投稿タイプ: {cpt_info['slug']}\n\n")
                f.write(f"タスクID: {task['task_id']}\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(text)
            
            output_files.append({
                'type': 'ドキュメント',
                'path': doc_path
            })
            logger.info(f"ドキュメント保存: {doc_filename}")
            
            # 2. PHPコードを抽出して保存
            php_code = self._extract_php_code(text)
            if php_code:
                php_filename = f"cpt_{cpt_info['slug']}_{timestamp}.php"
                php_path = self.output_folder / php_filename
                
                with open(php_path, 'w', encoding='utf-8') as f:
                    f.write("<?php\n")
                    f.write(f"/**\n")
                    f.write(f" * カスタム投稿タイプ: {cpt_info['singular_name']}\n")
                    f.write(f" * スラッグ: {cpt_info['slug']}\n")
                    f.write(f" * \n")
                    f.write(f" * @package WordPress\n")
                    f.write(f" * @since 1.0.0\n")
                    f.write(f" * @generated {datetime.now().isoformat()}\n")
                    f.write(f" */\n\n")
                    f.write(php_code)
                
                output_files.append({
                    'type': 'PHPコード',
                    'path': php_path
                })
                logger.info(f"PHPコード保存: {php_filename}")
            
            # 3. インストール手順を保存
            readme_filename = f"README_cpt_{cpt_info['slug']}_{timestamp}.md"
            readme_path = self.output_folder / readme_filename
            
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write(f"# {cpt_info['singular_name']} カスタム投稿タイプ\n\n")
                f.write(f"## 概要\n\n")
                f.write(f"{cpt_info['description']}\n\n")
                f.write(f"## インストール方法\n\n")
                f.write(f"### 方法1: functions.php に追加\n\n")
                f.write(f"1. `{php_filename}` の内容をコピー\n")
                f.write(f"2. テーマの `functions.php`（子テーマ推奨）に貼り付け\n")
                f.write(f"3. WordPressを再読み込み\n\n")
                f.write(f"### 方法2: プラグインとして実装\n\n")
                f.write(f"1. `wp-content/plugins/cpt-{cpt_info['slug']}/` フォルダを作成\n")
                f.write(f"2. プラグインヘッダーを追加した `{php_filename}` を配置\n")
                f.write(f"3. 管理画面でプラグインを有効化\n\n")
                f.write(f"## 使用方法\n\n")
                f.write(f"1. WordPress管理画面にログイン\n")
                f.write(f"2. 左メニューに「{cpt_info['menu_name']}」が表示されることを確認\n")
                f.write(f"3. 「設定 > パーマリンク設定」を開いて保存（リライトルール更新）\n")
                f.write(f"4. 新しい{cpt_info['singular_name']}を作成\n\n")
                f.write(f"## 仕様\n\n")
                f.write(f"- **スラッグ**: `{cpt_info['slug']}`\n")
                f.write(f"- **サポート機能**: {', '.join(cpt_info['supports'])}\n")
                f.write(f"- **REST API**: 有効\n")
                f.write(f"- **アーカイブページ**: 有効\n")
                f.write(f"- **階層構造**: {'有効' if cpt_info['hierarchical'] else '無効'}\n\n")
            
            output_files.append({
                'type': 'README',
                'path': readme_path
            })
            logger.info(f"README保存: {readme_filename}")
            
            return output_files
            
        except Exception as e:
            logger.error(f"コード保存エラー: {e}")
            return output_files
    
    def _extract_php_code(self, text: str) -> Optional[str]:
        """テキストからPHPコードを抽出"""
        try:
            # ```php ... ``` パターンを探す
            php_pattern = r'```php\s*(.*?)```'
            matches = re.findall(php_pattern, text, re.DOTALL)
            
            if matches:
                # 最も長いコードブロックを返す
                longest_code = max(matches, key=len)
                # 先頭の <?php を削除（後で追加するため）
                longest_code = re.sub(r'^\s*<\?php\s*', '', longest_code)
                return longest_code.strip()
            
            return None
            
        except Exception as e:
            logger.warning(f"PHPコード抽出エラー: {e}")
            return None
    
    async def _process_wordpress_taxonomy_task(self, task: Dict) -> Dict:
        """WordPressタクソノミー作成タスクを処理"""
        # タクソノミー作成用の処理（今後実装）
        logger.warning("タクソノミー作成タスクは現在未実装です")
        return await self._process_general_task(task)
    
    async def _process_general_task(self, task: Dict) -> Dict:
        """通常の開発タスクを処理"""
        try:
            logger.info("通常の開発タスクとして処理")
            
            # 対応する設計書があれば読み込む
            design_context = self._load_design_context(task)
            
            # プロンプトを構築
            full_prompt = f"""{self.DEV_SYSTEM_PROMPT}

【タスク】
{task['description']}"""
            
            if design_context:
                full_prompt += f"""

【設計書（参考）】
{design_context}"""
            
            full_prompt += """

上記のタスクについて、完全に動作するコードを実装してください。
エラーハンドリングとコメントを含めてください。"""
            
            # Geminiに送信
            logger.info("Geminiに開発タスクを送信中...")
            await self.browser.send_prompt(full_prompt)
            
            success = await self.browser._wait_for_generation_complete()
            
            # タスクの種類によって待機時間を調整
            description = task.get('description', '').lower()
        
            if any(word in description for word in ['要件定義', '設計書', 'アーキテクチャ', '仕様書']):
                max_wait = 300  # 要件定義書などは5分
                logger.info("📋 要件定義・設計書タスク - 待機時間を300秒に延長")
            else:
                max_wait = 180  # 通常は3分
        
            # 応答待機
            success = await self.browser.wait_for_text_generation(max_wait=max_wait)

            
            if not success:
                return {
                    'success': False,
                    'error': '開発AI: タイムアウト'
                }
            
            # 応答を取得
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': '開発AI: 応答取得失敗'
                }
            
            logger.info(f"開発AI: 応答取得完了（{len(response_text)}文字）")
            
            # コードをファイルに保存
            filename = f"code_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            output_path = self.output_folder / filename
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# コード: {task['description']}\n\n")
                f.write(f"タスクID: {task['task_id']}\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
            
            logger.info(f"コードを保存: {output_path}")
            
            # コード部分を抽出して個別ファイルに保存
            self._extract_and_save_code(response_text, task)
            
            # サマリーを作成
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
            
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "開発AI処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _load_design_context(self, task: Dict) -> str:
        """対応する設計書があれば読み込む"""
        try:
            # design_*.md ファイルを探す
            design_files = list(self.output_folder.glob(f"design_{task['task_id']}_*.md"))
            
            if design_files:
                # 最新のファイルを読み込む
                latest_design = sorted(design_files)[-1]
                with open(latest_design, 'r', encoding='utf-8') as f:
                    content = f.read()
                logger.info(f"設計書を読み込みました: {latest_design.name}")
                return content[:2000]  # 最初の2000文字のみ
            
            return ""
        except Exception as e:
            logger.warning(f"設計書読み込みエラー: {e}")
            return ""
    
    def _extract_and_save_code(self, text: str, task: Dict):
        """コードブロックを抽出して個別ファイルに保存"""
        try:
            # ```言語 ... ``` パターンを抽出
            code_blocks = re.findall(r'```(\w+)\n(.*?)```', text, re.DOTALL)
            
            for i, (lang, code) in enumerate(code_blocks):
                # ファイル拡張子を決定
                ext_map = {
                    'python': '.py',
                    'javascript': '.js',
                    'typescript': '.ts',
                    'html': '.html',
                    'css': '.css',
                    'java': '.java',
                    'cpp': '.cpp',
                    'c': '.c',
                    'php': '.php',
                    'ruby': '.rb',
                    'go': '.go',
                    'rust': '.rs',
                }
                ext = ext_map.get(lang.lower(), '.txt')
                
                # ファイルに保存
                code_filename = f"code_{task['task_id']}_{i+1}{ext}"
                code_path = self.output_folder / code_filename
                
                with open(code_path, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                logger.info(f"コードファイルを保存: {code_filename}")
                
        except Exception as e:
            logger.warning(f"コード抽出エラー: {e}")

#dev_agent_acf.py
# dev_agent_acf.py
"""ACF（Advanced Custom Fields）専用開発モジュール"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager, config

logger = logging.getLogger(__name__)


# =============================================================================
# ACFフィールドグループ専用プロンプト
# =============================================================================

ACF_FIELD_GROUP_PROMPT = """あなたはACF ProとWordPress開発の専門家です。

【ACFカスタムフィールドグループの作成】

以下の要件に基づいて、完全に動作するACFフィールドグループの定義を生成してください。

【必須要素】
1. フィールドグループの基本設定
   - タイトル、キー、配置場所（投稿タイプ）
2. 各フィールドの詳細定義
   - フィールドタイプ（text, number, select, relationship など）
   - ラベル、名前、キー
   - 検証ルール、デフォルト値
3. 条件付きロジック（必要に応じて）
4. PHP登録コード（`acf_add_local_field_group`）
5. JSON形式のエクスポート（WP-CLIインポート用）

【出力形式】

## ACFフィールドグループ: {group_title}

### 概要
（このフィールドグループの目的と用途）

### PHP登録コード（functions.phpに追加）

```php
<?php
/**
 * ACF Field Group: {group_title}
 * 投稿タイプ: {post_type}
 */

if (function_exists('acf_add_local_field_group')) {{
    acf_add_local_field_group(array(
        'key' => 'group_{unique_key}',
        'title' => '{group_title}',
        'fields' => array(
            // フィールド定義
            array(
                'key' => 'field_{field_key}',
                'label' => '{field_label}',
                'name' => '{field_name}',
                'type' => '{field_type}',
                'required' => {{true|false}},
                'default_value' => '',
            ),
        ),
        'location' => array(
            array(
                array(
                    'param' => 'post_type',
                    'operator' => '==',
                    'value' => '{post_type}',
                ),
            ),
        ),
        'menu_order' => 0,
        'position' => 'normal',
        'style' => 'default',
        'label_placement' => 'top',
        'instruction_placement' => 'label',
        'active' => true,
        'show_in_rest' => 1,
    ));
}}
?>
```

### JSON定義（WP-CLIインポート用）

```json
{{
  "key": "group_{unique_key}",
  "title": "{group_title}",
  "fields": [
    {{
      "key": "field_{field_key}",
      "label": "{field_label}",
      "name": "{field_name}",
      "type": "{field_type}",
      "required": {{true|false}}
    }}
  ],
  "location": [
    [
      {{
        "param": "post_type",
        "operator": "==",
        "value": "{post_type}"
      }}
    ]
  ]
}}
```

### 使用方法

#### テンプレートでの取得
```php
<?php
// 単一値の取得
$value = get_field('field_name', $post_id);

// 条件付き表示
if (get_field('field_name')) :
    echo esc_html(get_field('field_name'));
endif;
?>
```

### 注意事項
- ACF Pro 6.0以上が必要です
- フィールドキーは一意である必要があります
"""


# =============================================================================
# ACFDevAgentクラス（ACF専用機能）
# =============================================================================

class ACFDevAgent:
    """ACF（Advanced Custom Fields）専用開発エージェント"""
    
    def __init__(self, browser, output_folder: Path):
        """
        初期化
        
        Args:
            browser: BrowserControllerインスタンス
            output_folder: 出力先フォルダ
        """
        self.browser = browser
        self.output_folder = output_folder
        self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # =========================================================================
    # パート1: タスク判定メソッド
    # =========================================================================
    
    def is_acf_task(self, task: Dict) -> bool:
        """
        ACFフィールドグループ作成タスクか判定
        
        Args:
            task: タスク辞書
            
        Returns:
            bool: ACFタスクの場合True
        """
        description = task.get('description', '').lower()
        keywords = [
            'acf',
            'advanced custom fields',
            'カスタムフィールド',
            'フィールドグループ',
            'field group'
        ]
        return any(kw in description for kw in keywords)
    
    # =========================================================================
    # パート2: ACFタスク処理メイン
    # =========================================================================
    
    async def process_acf_task(self, task: Dict) -> Dict:
        """
        ACFフィールドグループ作成タスクを処理
        
        Args:
            task: タスク辞書
            
        Returns:
            Dict: 処理結果
        """
        try:
            logger.info("="*60)
            logger.info("ACFフィールドグループ作成タスク")
            logger.info("="*60)
            
            # === パート2-1: タスクから情報を抽出 ===
            acf_info = self._extract_acf_info(task)
            
            # === パート2-2: プロンプトを構築 ===
            full_prompt = self._build_acf_prompt(task, acf_info)
            
            # === パート2-3: Geminiに送信 ===
            logger.info("Geminiにタスクを送信中...")
            await self.browser.send_prompt(full_prompt)
            
            # === パート2-4: 応答待機 ===
            success = await self.browser.wait_for_text_generation(
                max_wait=config.WP_DEV_TIMEOUT if hasattr(config, 'WP_DEV_TIMEOUT') else 300
            )
            
            if not success:
                return {
                    'success': False,
                    'error': '開発AI: タイムアウト（ACFフィールドグループ作成）'
                }
            
            # === パート2-5: 応答を取得 ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': '開発AI: 応答取得失敗'
                }
            
            logger.info(f"開発AI: 応答取得完了（{len(response_text)}文字）")
            
            # === パート2-6: コード検証 ===
            validation_result = self._validate_acf_code(response_text)
            if not validation_result['is_valid']:
                logger.warning(f"⚠️ ACFコード検証で問題検出: {validation_result['issues']}")
            
            # === パート2-7: 結果を保存 ===
            output_files = self._save_acf_code(response_text, task, acf_info)
            
            # === パート2-8: サマリー作成 ===
            summary = self._create_acf_summary(acf_info, output_files, validation_result)
            
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'validation': validation_result
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "ACFフィールドグループ作成")
            return {
                'success': False,
                'error': str(e)
            }
    
    # =========================================================================
    # パート3: ACF情報抽出
    # =========================================================================
    
    def _extract_acf_info(self, task: Dict) -> Dict:
        """
        タスクからACF情報を抽出
        
        Args:
            task: タスク辞書
            
        Returns:
            Dict: ACF情報
        """
        description = task.get('description', '')
        parameters = task.get('parameters', {})
        
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        return {
            'group_title': parameters.get('group_title', 'M&A案件フィールド'),
            'post_type': parameters.get('post_type', 'ma_case'),
            'field_count': parameters.get('field_count', 10),
            'unique_key': parameters.get('unique_key', 'ma_case_fields')
        }
    
    # =========================================================================
    # パート4: プロンプト構築
    # =========================================================================
    
    def _build_acf_prompt(self, task: Dict, acf_info: Dict) -> str:
        """
        ACFフィールドグループ用のプロンプトを構築
        
        Args:
            task: タスク辞書
            acf_info: ACF情報
            
        Returns:
            str: 完全なプロンプト
        """
        prompt = ACF_FIELD_GROUP_PROMPT.format(
            group_title=acf_info['group_title'],
            post_type=acf_info['post_type'],
            unique_key=acf_info['unique_key'],
            field_label='例: 企業名',
            field_name='company_name',
            field_key='company_name',
            field_type='text'
        )
        
        prompt += f"""

【このタスクの具体的な要件】
{task.get('description', '')}

【重要な指示】
1. PHPコードは完全に動作する状態で生成してください
2. JSON形式の定義も必ず含めてください
3. すべてのフィールドにキー（key）を設定してください
4. セキュリティ（エスケープ処理）を考慮してください
5. 多言語対応（Polylang）を考慮してください

上記の要件に基づいて、完全なACFフィールドグループの定義を生成してください。
"""
        
        return prompt
    
    # =========================================================================
    # パート5: ACFコード検証
    # =========================================================================
    
    def _validate_acf_code(self, text: str) -> Dict:
        """
        ACFコードの検証
        
        Args:
            text: 検証対象のテキスト
            
        Returns:
            Dict: 検証結果
        """
        issues = []
        
        # === パート5-1: 必須関数のチェック ===
        if 'acf_add_local_field_group' not in text:
            issues.append('acf_add_local_field_group() 関数が見つかりません')
        
        # === パート5-2: フィールドキーの一意性チェック ===
        field_keys = re.findall(r"'key'\s*=>\s*'(field_[^']+)'", text)
        if len(field_keys) != len(set(field_keys)):
            issues.append('フィールドキーが重複しています')
        
        # === パート5-3: JSONの妥当性チェック ===
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        for json_str in json_blocks:
            try:
                json.loads(json_str)
            except json.JSONDecodeError:
                issues.append('JSON形式が不正です')
        
        # === パート5-4: セキュリティ関数のチェック ===
        if 'get_field(' in text and 'esc_html' not in text and 'esc_attr' not in text:
            issues.append('出力エスケープ関数が不足しています（esc_html, esc_attr）')
        
        return {
            'is_valid': len(issues) == 0,
            'issues': issues
        }
    
    # =========================================================================
    # パート6: ファイル保存
    # =========================================================================
    
    def _save_acf_code(self, text: str, task: Dict, acf_info: Dict) -> list:
        """
        ACFフィールドグループのコードを保存
        
        Args:
            text: 保存対象のテキスト
            task: タスク辞書
            acf_info: ACF情報
            
        Returns:
            list: 保存されたファイル情報のリスト
        """
        output_files = []
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # === パート6-1: 完全なドキュメントを保存 ===
            doc_filename = f"acf_{acf_info['unique_key']}_{timestamp}.md"
            doc_path = self.output_folder / doc_filename
            
            with open(doc_path, 'w', encoding='utf-8') as f:
                f.write(f"# ACFフィールドグループ: {acf_info['group_title']}\n\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write(text)
            
            output_files.append({
                'type': 'ドキュメント',
                'path': doc_path
            })
            logger.info(f"ドキュメント保存: {doc_filename}")
            
            # === パート6-2: PHPコードを抽出して保存 ===
            php_code = self._extract_php_code(text)
            if php_code:
                php_filename = f"acf_{acf_info['unique_key']}_{timestamp}.php"
                php_path = self.output_folder / php_filename
                
                with open(php_path, 'w', encoding='utf-8') as f:
                    f.write("<?php\n")
                    f.write(f"/**\n * ACF Field Group: {acf_info['group_title']}\n */\n\n")
                    f.write(php_code)
                
                output_files.append({
                    'type': 'PHPコード',
                    'path': php_path
                })
                logger.info(f"PHPコード保存: {php_filename}")
            
            # === パート6-3: JSON定義を抽出して保存 ===
            json_data = self._extract_json_from_text(text)
            if json_data:
                json_filename = f"acf_{acf_info['unique_key']}_{timestamp}.json"
                json_path = self.output_folder / json_filename
                
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(json_data, f, ensure_ascii=False, indent=2)
                
                output_files.append({
                    'type': 'JSON定義',
                    'path': json_path
                })
                logger.info(f"JSON定義保存: {json_filename}")
            
            # === パート6-4: READMEを生成 ===
            readme_filename = f"README_acf_{acf_info['unique_key']}_{timestamp}.md"
            readme_path = self.output_folder / readme_filename
            
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write(f"# {acf_info['group_title']} - インストールガイド\n\n")
                f.write(f"## 概要\n\n")
                f.write(f"投稿タイプ: {acf_info['post_type']}\n\n")
                f.write(f"## インストール方法\n\n")
                f.write(f"### 方法1: PHPコードで登録\n\n")
                f.write(f"1. `{php_filename}` の内容を `functions.php` に追加\n\n")
                f.write(f"### 方法2: WP-CLI経由\n\n")
                f.write(f"```bash\nwp acf import {json_filename}\n```\n\n")
            
            output_files.append({
                'type': 'README',
                'path': readme_path
            })
            logger.info(f"README保存: {readme_filename}")
            
            return output_files
            
        except Exception as e:
            logger.error(f"ファイル保存エラー: {e}")
            return output_files
    
    # =========================================================================
    # パート7: コード抽出ヘルパー
    # =========================================================================
    
    def _extract_php_code(self, text: str) -> Optional[str]:
        """PHPコードを抽出"""
        php_pattern = r'```php\s*(.*?)```'
        matches = re.findall(php_pattern, text, re.DOTALL)
        
        if matches:
            longest_code = max(matches, key=len)
            longest_code = re.sub(r'^\s*<\?php\s*', '', longest_code)
            return longest_code.strip()
        
        return None
    
    def _extract_json_from_text(self, text: str) -> Optional[Dict]:
        """JSON定義を抽出"""
        json_pattern = r'```json\s*(.*?)```'
        matches = re.findall(json_pattern, text, re.DOTALL)
        
        if matches:
            try:
                return json.loads(matches[0])
            except json.JSONDecodeError:
                return None
        
        return None
    
    # =========================================================================
    # パート8: サマリー作成
    # =========================================================================
    
    def _create_acf_summary(self, acf_info: Dict, output_files: list, 
                           validation_result: Dict) -> str:
        """ACFタスクのサマリーを作成"""
        summary = f"""✅ ACFフィールドグループ作成完了

【フィールドグループ情報】
- タイトル: {acf_info['group_title']}
- 投稿タイプ: {acf_info['post_type']}
- フィールド数: {acf_info['field_count']}

【生成ファイル】
"""
        for file_info in output_files:
            summary += f"- {file_info['type']}: {file_info['path'].name}\n"
        
        if not validation_result['is_valid']:
            summary += f"\n【検証結果】\n"
            for issue in validation_result['issues']:
                summary += f"⚠️ {issue}\n"
        
        return summary

#error_handler_enhanced.py
"""
強化版エラーハンドラー - マルチエージェントシステム用
"""

import logging
import asyncio
import traceback
import sys
from typing import Optional, Callable, Any
from functools import wraps
from pathlib import Path
import time

logger = logging.getLogger(__name__)


class RetryConfig:
    """リトライ設定"""
    MAX_RETRIES = 3
    INITIAL_DELAY = 2.0  # 秒
    MAX_DELAY = 30.0
    BACKOFF_FACTOR = 2.0


class EnhancedErrorHandler:
    """強化版エラーハンドラー"""
    
    @staticmethod
    def log_error_with_context(error: Exception, context: str = "", 
                               include_traceback: bool = True) -> None:
        """コンテキスト付きエラーログ"""
        logger.error("="*60)
        logger.error(f"❌ エラー発生: {context}")
        logger.error(f"エラータイプ: {type(error).__name__}")
        logger.error(f"エラー内容: {str(error)}")
        
        if include_traceback:
            logger.error("トレースバック:")
            logger.error(traceback.format_exc())
        
        logger.error("="*60)
    
    @staticmethod
    async def retry_async(
        func: Callable,
        *args,
        max_retries: int = RetryConfig.MAX_RETRIES,
        delay: float = RetryConfig.INITIAL_DELAY,
        backoff: float = RetryConfig.BACKOFF_FACTOR,
        exceptions: tuple = (Exception,),
        on_retry: Optional[Callable] = None,
        **kwargs
    ) -> Any:
        """
        非同期関数のリトライラッパー
        
        Args:
            func: 実行する非同期関数
            max_retries: 最大リトライ回数
            delay: 初期遅延時間（秒）
            backoff: バックオフ係数
            exceptions: キャッチする例外のタプル
            on_retry: リトライ時のコールバック関数
        """
        current_delay = delay
        last_exception = None
        
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"試行 {attempt}/{max_retries}: {func.__name__}")
                result = await func(*args, **kwargs)
                
                if attempt > 1:
                    logger.info(f"✅ 成功（試行 {attempt}）")
                
                return result
                
            except exceptions as e:
                last_exception = e
                
                if attempt == max_retries:
                    logger.error(f"❌ 全リトライ失敗: {func.__name__}")
                    EnhancedErrorHandler.log_error_with_context(
                        e, f"{func.__name__} (試行 {attempt}/{max_retries})"
                    )
                    raise
                
                logger.warning(f"⚠️ 失敗（試行 {attempt}）: {str(e)}")
                logger.info(f"🔄 {current_delay:.1f}秒後に再試行...")
                
                if on_retry:
                    try:
                        await on_retry(attempt, e)
                    except Exception as callback_error:
                        logger.warning(f"リトライコールバック失敗: {callback_error}")
                
                await asyncio.sleep(current_delay)
                current_delay = min(current_delay * backoff, RetryConfig.MAX_DELAY)
        
        raise last_exception
    
    @staticmethod
    def retry_decorator(
        max_retries: int = RetryConfig.MAX_RETRIES,
        delay: float = RetryConfig.INITIAL_DELAY,
        backoff: float = RetryConfig.BACKOFF_FACTOR,
        exceptions: tuple = (Exception,)
    ):
        """リトライデコレーター"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                return await EnhancedErrorHandler.retry_async(
                    func, *args,
                    max_retries=max_retries,
                    delay=delay,
                    backoff=backoff,
                    exceptions=exceptions,
                    **kwargs
                )
            return wrapper
        return decorator
    
    @staticmethod
    async def safe_cleanup(cleanup_func: Callable, context: str = "") -> bool:
        """安全なクリーンアップ実行"""
        try:
            logger.info(f"🧹 クリーンアップ: {context}")
            
            if asyncio.iscoroutinefunction(cleanup_func):
                await cleanup_func()
            else:
                cleanup_func()
            
            logger.info(f"✅ クリーンアップ完了: {context}")
            return True
            
        except Exception as e:
            logger.warning(f"⚠️ クリーンアップ失敗（無視）: {context}")
            logger.warning(f"理由: {str(e)}")
            return False
    
    @staticmethod
    def validate_file_path(path: Any, must_exist: bool = False) -> Optional[Path]:
        """ファイルパスのバリデーション"""
        try:
            if not path:
                return None
            
            # 文字列に変換
            path_str = str(path).strip()
            
            # URLの場合はNone
            if path_str.lower().startswith(('http://', 'https://')):
                logger.warning(f"URLが指定されました（ファイルパスではありません）: {path_str}")
                return None
            
            # Pathオブジェクトに変換
            path_obj = Path(path_str)
            
            # 存在確認が必要な場合
            if must_exist and not path_obj.exists():
                logger.error(f"❌ パスが存在しません: {path_obj}")
                return None
            
            # 正規化して返す
            return path_obj.resolve()
            
        except Exception as e:
            logger.error(f"パスバリデーションエラー: {path}")
            EnhancedErrorHandler.log_error_with_context(e, "パスバリデーション")
            return None
    
    @staticmethod
    def handle_import_error(module_name: str, optional: bool = True) -> bool:
        """インポートエラーのハンドリング"""
        try:
            __import__(module_name)
            logger.info(f"✅ モジュールインポート成功: {module_name}")
            return True
            
        except ImportError as e:
            if optional:
                logger.warning(f"⚠️ オプショナルモジュール未検出（スキップ）: {module_name}")
                return False
            else:
                logger.error(f"❌ 必須モジュールが見つかりません: {module_name}")
                EnhancedErrorHandler.log_error_with_context(e, f"インポート: {module_name}")
                raise
    
    @staticmethod
    async def timeout_wrapper(
        coro,
        timeout: float,
        context: str = ""
    ) -> Any:
        """タイムアウト付き実行"""
        try:
            result = await asyncio.wait_for(coro, timeout=timeout)
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"⏱️ タイムアウト（{timeout}秒）: {context}")
            raise TimeoutError(f"{context} がタイムアウトしました（{timeout}秒）")
        
        except Exception as e:
            EnhancedErrorHandler.log_error_with_context(e, context)
            raise


class BrowserErrorHandler:
    """ブラウザ専用エラーハンドラー"""
    
    @staticmethod
    async def handle_browser_crash(browser_controller, max_retries: int = 3):
        """ブラウザクラッシュのハンドリング"""
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"🌐 ブラウザ再起動試行 {attempt}/{max_retries}")
                
                # 既存インスタンスのクリーンアップ
                try:
                    await browser_controller.cleanup()
                except:
                    pass
                
                # 少し待機
                await asyncio.sleep(3)
                
                # 再初期化
                await browser_controller.setup_browser()
                
                # 動作確認
                if browser_controller.page:
                    test_result = await browser_controller.page.evaluate("1 + 1")
                    if test_result == 2:
                        logger.info(f"✅ ブラウザ復旧成功（試行 {attempt}）")
                        return True
                
            except Exception as e:
                logger.warning(f"ブラウザ再起動失敗（試行 {attempt}）: {e}")
                
                if attempt == max_retries:
                    logger.error("❌ ブラウザ復旧不可能")
                    raise Exception("ブラウザの再起動に失敗しました")
                
                await asyncio.sleep(5)
        
        return False
    
    @staticmethod
    async def safe_page_action(page, action_func, context: str = "", timeout: float = 30.0):
        """安全なページ操作"""
        try:
            return await EnhancedErrorHandler.timeout_wrapper(
                action_func(),
                timeout=timeout,
                context=context
            )
            
        except Exception as e:
            logger.error(f"ページ操作失敗: {context}")
            EnhancedErrorHandler.log_error_with_context(e, context)
            raise


class SheetErrorHandler:
    """Google Sheets専用エラーハンドラー"""
    
    @staticmethod
    async def safe_sheet_operation(operation_func, *args, **kwargs):
        """安全なシート操作"""
        try:
            return await EnhancedErrorHandler.retry_async(
                operation_func,
                *args,
                max_retries=3,
                delay=2.0,
                exceptions=(Exception,),
                **kwargs
            )
            
        except Exception as e:
            logger.error("Google Sheets操作が全リトライ失敗")
            EnhancedErrorHandler.log_error_with_context(e, "Sheets操作")
            
            # フォールバック: ローカルキャッシュなど
            logger.warning("⚠️ オフラインモードに切り替え（データ未保存）")
            return None


class TaskErrorHandler:
    """タスク実行専用エラーハンドラー"""
    
    @staticmethod
    async def handle_task_failure(
        task: dict,
        error: Exception,
        sheets_manager,
        retry: bool = True
    ) -> bool:
        """タスク失敗のハンドリング"""
        try:
            logger.error(f"❌ タスク失敗: {task.get('task_id', 'UNKNOWN')}")
            EnhancedErrorHandler.log_error_with_context(
                error,
                f"タスク {task.get('description', 'N/A')[:50]}"
            )
            
            # ステータス更新
            try:
                await sheets_manager.update_task_status(
                    task['task_id'],
                    'failed',
                    error_message=str(error)
                )
            except Exception as update_error:
                logger.warning(f"ステータス更新失敗: {update_error}")
            
            # リトライ可能かチェック
            if retry and TaskErrorHandler.is_retryable_error(error):
                logger.info("🔄 リトライ可能なエラー")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"タスク失敗ハンドリング中のエラー: {e}")
            return False
    
    @staticmethod
    def is_retryable_error(error: Exception) -> bool:
        """リトライ可能なエラーか判定"""
        retryable_patterns = [
            "timeout",
            "network",
            "connection",
            "temporary",
            "rate limit"
        ]
        
        error_str = str(error).lower()
        return any(pattern in error_str for pattern in retryable_patterns)


# 使用例
if __name__ == "__main__":
    async def example_usage():
        # リトライデコレーターの使用例
        @EnhancedErrorHandler.retry_decorator(max_retries=3)
        async def unstable_operation():
            # 不安定な処理
            import random
            if random.random() < 0.7:
                raise Exception("一時的なエラー")
            return "成功"
        
        try:
            result = await unstable_operation()
            print(f"結果: {result}")
        except Exception as e:
            print(f"失敗: {e}")
    
    asyncio.run(example_usage())

#main_automator.py
import asyncio
import time
import json
from pathlib import Path
from typing import List, Dict, Optional
import logging
from datetime import datetime

# ===== 最優先: ログ設定を他のインポートより前に実行 =====
# config_utilsをインポートすると自動的にログ設定が実行される
from config_utils import config, ErrorHandler, FileNameGenerator, PathManager

# これで他のモジュールをインポート
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class GeminiAutomator:
    """メインのGemini自動化クラス（拡張版:画像・テキスト両対応・ローカル保存・DeepSeek対応）"""
    
    def __init__(self, pc_id: int = None, auto_detect_pc_id: bool = True):
        """
        初期化
        
        Args:
            pc_id: 明示的に指定するPC_ID（Noneの場合は自動検出）
            auto_detect_pc_id: Trueの場合、スプレッドシートのB12セルからPC_IDを読み取る
        """
        # まず、サービスアカウントファイルでシートマネージャーを初期化
        default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
        service_account_file = default_service_account if Path(default_service_account).exists() else None
        
        self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
        # PC_IDの決定（優先順位）
        # 1. 明示的に指定されたpc_id
        # 2. スプレッドシートのB12セルから読み取り（auto_detect_pc_id=Trueの場合）
        # 3. 環境変数
        # 4. デフォルト値(1)
        if pc_id is not None:
            self.pc_id = pc_id
            logger.info(f"PC_IDを明示的指定から取得: {self.pc_id}")
        elif auto_detect_pc_id:
            try:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_IDをスプレッドシート(B12)から取得: {self.pc_id}")
            except Exception as e:
                logger.warning(f"スプレッドシートからのPC_ID取得に失敗: {e}")
                import os
                self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
                logger.info(f"PC_IDを環境変数/デフォルトから取得: {self.pc_id}")
        else:
            import os
            self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
            logger.info(f"PC_IDを環境変数/デフォルトから取得: {self.pc_id}")
        
        # PC固有の設定を読み込み
        self.load_pc_configuration()
        self.mode = config.GENERATION_MODE or "image"
        self.service = config.SERVICE_TYPE or "google"
        
        # ダウンロードフォルダの設定（スプレッドシートB5/B6から取得）
        if self.mode == "text":
            # テキストモードの場合はB6の設定を使用
            if config.DOWNLOAD_TEXT_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_TEXT_FOLDER)
                logger.info(f"テキスト保存先（B6から取得）: {self.download_folder}")
            else:
                # フォールバック: ローカル一時フォルダ
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_texts"))
                logger.warning(f"B6が空のため、デフォルトフォルダを使用: {self.download_folder}")
        else:
            # 画像モードの場合はB5の設定を使用
            if config.DOWNLOAD_IMAGE_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_IMAGE_FOLDER)
                logger.info(f"画像保存先（B5から取得）: {self.download_folder}")
            else:
                # フォールバック: ローカル一時フォルダ
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_images"))
                logger.warning(f"B5が空のため、デフォルトフォルダを使用: {self.download_folder}")
        
        self.browser_controller = BrowserController(self.download_folder, self.mode, self.service)
        self.credentials: Optional[Dict[str, str]] = None
        self.prompts: List[str] = []
        self.results: List[Dict] = []
        self.generate_unique_filename = lambda idx: FileNameGenerator.generate_unique_filename(idx, mode=self.mode)
    
    def load_pc_configuration(self) -> None:
        """PC固有の設定を読み込み"""
        try:
            logger.info(f"PC_ID={self.pc_id} の設定を読み込み中...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.SERVICE_ACCOUNT_FILE = settings.get('service_account_file')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = settings.get('generation_mode', 'image')
            config.TEXT_FORMAT = settings.get('text_format', 'txt')
            config.DOWNLOAD_IMAGE_FOLDER = settings.get('download_image_folder')
            config.DOWNLOAD_TEXT_FOLDER = settings.get('download_text_folder')
            config.AGENT_OUTPUT_FOLDER = settings.get('agent_output_folder')
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            # サービスタイプの取得
            service_type = settings.get('service_type', '').strip().lower()
            if service_type in ['deepseek', 'google', 'gemini']:
                if service_type == 'gemini':
                    service_type = 'google'
                config.SERVICE_TYPE = service_type
            else:
                config.SERVICE_TYPE = 'google'
        
            logger.info(f"PC_ID={self.pc_id} の設定読み込み完了")
            logger.info(f"  サービス: {config.SERVICE_TYPE}")
            logger.info(f"  モード: {config.GENERATION_MODE}")
            logger.info(f"  テキスト形式: {config.TEXT_FORMAT}")
            logger.info(f"  Browser Data: {config.BROWSER_DATA_DIR}")
            logger.info(f"  画像フォルダ (B5): {config.DOWNLOAD_IMAGE_FOLDER}")
            logger.info(f"  テキストフォルダ (B6): {config.DOWNLOAD_TEXT_FOLDER}")
            logger.info(f"  Agent出力先 (B14): {config.AGENT_OUTPUT_FOLDER}")
            logger.info(f"  最大反復回数 (B15): {config.MAX_ITERATIONS}")
            if config.SERVICE_ACCOUNT_FILE and Path(config.SERVICE_ACCOUNT_FILE).exists():
                self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, config.SERVICE_ACCOUNT_FILE)
        except Exception as e:
            ErrorHandler.log_error(e, "PC設定読み込み")
            raise
    
    async def initialize(self) -> None:
        """初期化処理"""
        try:
            logger.info("初期化処理開始...")
            if not self.sheets_manager.validate_sheet_structure():
                raise Exception("Google Sheetsの構造が正しくありません")
            self.credentials = self.sheets_manager.load_credentials_from_sheet(self.pc_id)
            
            # credentialsをbrowser_controllerに渡す
            self.browser_controller.credentials = self.credentials
            
            prompt_sheet_name = "prompt_text" if self.mode == "text" else "prompt_text"
            self.prompts = self.sheets_manager.load_prompts_from_sheet(prompt_sheet_name)
            if not self.prompts:
                raise Exception("処理するプロンプトがありません")
            await self.browser_controller.setup_browser()
            logger.info("初期化処理完了")
        except Exception as e:
            ErrorHandler.log_error(e, "初期化処理")
            raise
    
    async def login_process(self) -> None:
        """ログイン処理（サービス別）"""
        try:
            logger.info("ログイン処理開始...")
            
            if self.service == "deepseek":
                # DeepSeekはGoogleアカウントでログイン
                logger.info("DeepSeekサービスを使用します")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleアカウントにログインしてください（DeepSeek用）")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("Googleログイン完了後、Enterキーを押してください: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ログインが確認できませんが、処理を続行します")
                else:
                    logger.info("既にGoogleアカウントにログイン済みです")
                
                await self.browser_controller.navigate_to_deepseek()
            else:
                # Google/Geminiの場合
                logger.info("Geminiサービスを使用します")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleアカウントにログインが必要です")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("ログイン完了後、Enterキーを押してください: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ログインが確認できませんが、処理を続行します")
                else:
                    logger.info("既にGoogleアカウントにログイン済みです")
                
                await self.browser_controller.navigate_to_gemini()
            
            logger.info("ログイン処理完了")
        except Exception as e:
            ErrorHandler.log_error(e, "ログイン処理")
            raise
    
    async def process_single_prompt_image(self, prompt: str, index: int) -> bool:
        """画像モードでプロンプトを処理"""
        try:
            logger.info(f"\n--- プロンプト {index}/{len(self.prompts)} を処理中（画像モード）---")
            logger.info(f"プロンプト: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'image'
            }
            try:
                await self.browser_controller.send_prompt(prompt)
                if await self.browser_controller.wait_for_image_generation():
                    filename = await self.browser_controller.download_latest_image(index)
                    if filename:
                        result['status'] = 'success'
                        result['filename'] = filename
                        save_path = self.download_folder / filename
                        logger.info(f"プロンプト {index} の処理に成功")
                        logger.info(f"保存先: {save_path}")
                        return True
                    else:
                        result['status'] = 'download_failed'
                        result['error'] = 'ダウンロードに失敗'
                else:
                    result['status'] = 'generation_failed'
                    result['error'] = '画像生成に失敗またはタイムアウト'
            except Exception as e:
                result['status'] = 'error'
                result['error'] = str(e)
                ErrorHandler.log_error(e, f"プロンプト {index} 処理")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"プロンプト {index} 処理")
            return False
        finally:
            self.results.append(result)
    
    async def process_single_prompt_text(self, prompt: str, index: int, max_retries: int = 2) -> bool:
        """テキストモードでプロンプトを処理"""
        try:
            logger.info(f"\n--- プロンプト {index}/{len(self.prompts)} を処理中（テキストモード）---")
            logger.info(f"プロンプト: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'text'
            }
            for attempt in range(1, max_retries + 1):
                try:
                    logger.info(f"試行 {attempt}/{max_retries}")
                    await self.browser_controller.send_prompt(prompt)
                    if await self.browser_controller.wait_for_text_generation():
                        response_text = await self.browser_controller.extract_latest_text_response()
                        if response_text:
                            # フォーマットに応じてファイル名と保存形式を変更
                            text_format = config.TEXT_FORMAT or 'txt'
                            
                            if text_format == 'json':
                                # JSON形式
                                filename = self.generate_unique_filename(index)
                                filename = filename.replace('.txt', '.json')
                                json_data = {"response": response_text}
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        json.dump(json_data, f, ensure_ascii=False, indent=2)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"✅ JSON保存成功: {filename} ({file_size:,} bytes)")
                                        logger.info(f"保存先: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'JSON保存エラー: {str(e)}'
                                    logger.error(f"JSON保存エラー: {e}")
                            else:
                                # TXT形式（デフォルト）
                                filename = self.generate_unique_filename(index)
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        f.write(response_text)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"✅ テキスト保存成功: {filename} ({file_size:,} bytes)")
                                        logger.info(f"保存先: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'テキスト保存エラー: {str(e)}'
                                    logger.error(f"テキスト保存エラー: {e}")
                        else:
                            result['status'] = 'extraction_failed'
                            result['error'] = 'テキスト抽出に失敗'
                    else:
                        result['status'] = 'generation_failed'
                        result['error'] = 'テキスト生成に失敗またはタイムアウト'
                    if attempt < max_retries:
                        logger.info(f"5秒後に再試行します...")
                        await asyncio.sleep(5)
                    else:
                        break
                except Exception as e:
                    result['status'] = 'error'
                    result['error'] = str(e)
                    ErrorHandler.log_error(e, f"プロンプト {index} 処理（試行 {attempt}）")
                    if attempt < max_retries:
                        await asyncio.sleep(5)
                    else:
                        break
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"プロンプト {index} 処理")
            return False
        finally:
            self.results.append(result)
    
    async def run_automation(self) -> None:
        """自動化処理の実行"""
        try:
            logger.info("=== Gemini自動化処理を開始 ===")
            logger.info(f"PC_ID: {self.pc_id}")
            logger.info(f"モード: {self.mode.upper()}")
            logger.info(f"保存先: ローカルフォルダ")
            logger.info(f"保存パス: {self.download_folder.absolute()}")
            await self.initialize()
            await self.login_process()
            if self.browser_controller.page:
                await self.browser_controller.page.screenshot(path="gemini_initial.png")
            successful_count = 0
            failed_prompts = []
            for i, prompt in enumerate(self.prompts, 1):
                try:
                    if self.mode == "text":
                        success = await self.process_single_prompt_text(prompt, i)
                    else:
                        success = await self.process_single_prompt_image(prompt, i)
                    if success:
                        successful_count += 1
                    else:
                        failed_prompts.append(f"{i}: {prompt[:50]}...")
                    if i < len(self.prompts):
                        await asyncio.sleep(8)
                except Exception as e:
                    logger.error(f"プロンプト {i} の処理中にエラー: {e}")
                    failed_prompts.append(f"{i}: {prompt[:50]}... (エラー)")
                    continue
            try:
                self.sheets_manager.save_result_to_sheet(self.results, self.mode)
            except Exception as e:
                logger.warning(f"結果のシート保存に失敗: {e}")
            self.generate_final_report(successful_count, failed_prompts)
        except Exception as e:
            ErrorHandler.log_error(e, "自動化処理の重大なエラー")
            try:
                if self.browser_controller.page:
                    await self.browser_controller.page.screenshot(path="final_error.png")
            except:
                pass
            raise
        finally:
            await self.browser_controller.cleanup()
    
    def generate_final_report(self, successful: int, failed_prompts: list):
        """最終レポートの生成"""
        logger.info(f"\n{'='*50}")
        logger.info("処理完了レポート")
        logger.info(f"{'='*50}")
        logger.info(f"PC_ID: {self.pc_id}")
        logger.info(f"モード: {self.mode.upper()}")
        logger.info(f"成功: {successful}/{len(self.prompts)} 件")
        logger.info(f"失敗: {len(failed_prompts)} 件")
        logger.info(f"成功率: {successful/len(self.prompts)*100:.1f}%")
        logger.info(f"保存先: {self.download_folder.absolute()}")
        if failed_prompts:
            logger.info("\n失敗したプロンプト:")
            for failed in failed_prompts:
                logger.info(f"  - {failed}")

async def main():
    import argparse
    import os
    
    parser = argparse.ArgumentParser(description='Gemini自動生成（ローカル保存版）')
    parser.add_argument('--pc-id', type=int, default=None, help='PC_IDを明示的に指定（指定しない場合はスプレッドシートのB12セルから自動取得）')
    parser.add_argument('--no-auto-detect', action='store_true', help='スプレッドシートからのPC_ID自動取得を無効化')
    args = parser.parse_args()
    
    print("=== Gemini 自動生成スクリプト（ローカル保存版）===")
    if args.pc_id is not None:
        print(f"PC_ID: {args.pc_id} (明示的指定)")
        automator = GeminiAutomator(pc_id=args.pc_id, auto_detect_pc_id=False)
    elif args.no_auto_detect:
        default_pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
        print(f"PC_ID: {default_pc_id} (環境変数/デフォルト)")
        automator = GeminiAutomator(pc_id=default_pc_id, auto_detect_pc_id=False)
    else:
        print("PC_ID: スプレッドシート(B12セル)から自動取得")
        automator = GeminiAutomator(auto_detect_pc_id=True)
    
    try:
        await automator.run_automation()
        print("\n処理が正常に完了しました")
    except KeyboardInterrupt:
        print("\n処理を中断しました")
    except Exception as e:
        print(f"\nエラーが発生しました: {e}")
        logger.error(f"メイン処理エラー: {e}")

if __name__ == "__main__":
    asyncio.run(main())

#pm_agent.py
import asyncio
import json
import logging
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime

from config_utils import config, ErrorHandler
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_system_prompts import PM_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class PMAgent:
    """PM AI - プロジェクト管理とタスク分解を担当"""
    
    def __init__(self, sheets_manager: GoogleSheetsManager, browser_controller: BrowserController):
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.current_goal = None
        self.generated_tasks = []
        self.system_prompt = PM_SYSTEM_PROMPT
    
    async def load_project_goal(self) -> Optional[Dict]:
        """project_goalシートから最新のアクティブな目標を読み込む"""
        try:
            logger.info("プロジェクト目標を読み込み中...")
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            
            try:
                goal_sheet = sheet.worksheet("project_goal")
            except:
                logger.error("'project_goal'シートが見つかりません")
                return None
            
            all_values = goal_sheet.get_all_values()
            
            if len(all_values) <= 1:
                logger.warning("目標が設定されていません")
                return None
            
            for row in all_values[1:]:
                if len(row) >= 3 and row[2].lower() == 'active':
                    goal = {
                        'goal_id': row[0],
                        'description': row[1],
                        'status': row[2],
                        'created_at': row[3] if len(row) > 3 else ''
                    }
                    logger.info(f"目標を読み込みました: {goal['description']}")
                    self.current_goal = goal
                    return goal
            
            logger.warning("アクティブな目標が見つかりません")
            return None
            
        except Exception as e:
            ErrorHandler.log_error(e, "目標読み込み")
            raise
    async def analyze_and_create_tasks(self, goal_description: str) -> Dict:
        """目標を分析してタスクを生成"""
        try:
            # === パート1: 開始ヘッダー表示 ===
            logger.info("="*60)
            logger.info("PM AI: タスク分解を開始します")
            logger.info("="*60)
    
            # === パート2: プロンプト構築 ===
            full_prompt = f"""{self.system_prompt}

    【プロジェクト目標】
    {goal_description}

    【重要な出力指示】
    1. **必ず有効なJSON形式のみで出力してください**
    2. 説明文、コメント、挨拶などは一切不要です
    3. 最初の文字が {{ で、最後の文字が }} の完全なJSON形式のみを出力してください
    4. **タスク数は最大15個まで**とし、JSONが長くなりすぎないようにしてください
    5. すべての文字列値は正しくダブルクォーテーションで囲んでください

    上記の目標を達成するために必要なタスクを、JSON形式で出力してください。"""
    
            # === パート3: Geminiへの送信 ===
            logger.info("Geminiに送信中...")
            await self.browser.send_prompt(full_prompt)
    
            # === パート4: 応答待機 ===
            logger.info("PM AIの分析を待機中...")
            success = await self.browser.wait_for_text_generation(max_wait=180)
    
            if not success:
                raise Exception("PM AIのタスク生成がタイムアウトしました")
    
            # === パート5: 応答テキストの抽出 ===
            response_text = await self.browser.extract_latest_text_response()
    
            if not response_text:
                raise Exception("PM AIからの応答が取得できませんでした")
    
            logger.info(f"PM AIの応答を取得しました（{len(response_text)}文字）")
            logger.info(f"応答の先頭500文字:\n{response_text[:500]}")
            logger.info(f"応答の末尾500文字:\n{response_text[-500:]}")
    
            # === パート6: JSONレスポンスの解析 ===
            task_plan = self._parse_json_response(response_text)
    
            if task_plan:
                # === パート7: 成功時の処理 ===
                logger.info("="*60)
                logger.info("PM AI: タスク分解完了")
                logger.info(f"生成されたタスク数: {len(task_plan.get('tasks', []))}")
                logger.info("="*60)
                self.generated_tasks = task_plan.get('tasks', [])
                return task_plan
            else:
                # === パート8: JSON解析失敗時のフォールバック処理 ===
                logger.error("JSON解析に失敗しました。応答全体を保存します。")
                fallback_path = Path("pm_ai_response_error.txt")
                with open(fallback_path, 'w', encoding='utf-8') as f:
                    f.write(response_text)
                logger.info(f"応答を保存しました: {fallback_path}")
        
                logger.error("="*60)
                logger.error("❌ 自動修復も失敗しました")
                logger.error("="*60)
        
                # === パート9: 修正済みファイルのチェック ===
                fixed_path = Path("pm_ai_response_fixed.json")
                if fixed_path.exists():
                    logger.info("修正済みファイルを検出しました!")
                    try:
                        with open(fixed_path, 'r', encoding='utf-8') as f:
                            task_plan = json.load(f)
                        logger.info(f"✅ 修正済みJSONを読み込みました: タスク数={len(task_plan.get('tasks', []))}")
                        self.generated_tasks = task_plan.get('tasks', [])
                        return task_plan
                    except Exception as e:
                        logger.error(f"修正済みファイルの読み込みに失敗: {e}")
        
                raise Exception("PM AIの応答をJSON形式でパースできませんでした")
    
        except Exception as e:
            ErrorHandler.log_error(e, "タスク生成")
            raise
        
        
    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """応答からJSON部分を抽出してパース（強化版）"""
        try:
            # === パート1: 入力検証 ===
            if not text:
                logger.warning("空の応答テキスト")
                return None
            
            # === パート2: 解析開始ヘッダー ===
            logger.info("="*60)
            logger.info("JSON解析開始")
            logger.info("="*60)
            logger.info(f"応答全体の長さ: {len(text)}文字")
            
            import re
            
            # === パート3: パターン1 - ```json ... ``` 形式の検出 ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                logger.info("✅ パターン1: ```json...``` 形式を検出")
                try:
                    result = json.loads(json_str)
                    logger.info(f"✅ JSON解析成功（パターン1）: タスク数={len(result.get('tasks', []))}")
                    return result
                except json.JSONDecodeError as e:
                    logger.warning(f"パターン1でJSON解析失敗: {e}")
            
            # === パート4: パターン2 - 中括弧のバランスを考慮した抽出 ===
            start_idx = text.find('{')
            if start_idx != -1:
                logger.info(f"✅ '{{' を位置 {start_idx} で検出")
                
                # === パート5: バランスの取れたJSONオブジェクトの検出 ===
                brace_count = 0
                in_string = False
                escape_next = False
                
                for i, char in enumerate(text[start_idx:], start=start_idx):
                    if escape_next:
                        escape_next = False
                        continue
                    
                    if char == '\\':
                        escape_next = True
                        continue
                    
                    if char == '"' and not escape_next:
                        in_string = not in_string
                        continue
                    
                    if not in_string:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                # === パート6: 完全なJSONオブジェクトの抽出と解析 ===
                                potential_json = text[start_idx:i+1]
                                logger.info(f"✅ 完全なJSONオブジェクトを抽出: {len(potential_json)}文字")
                                
                                try:
                                    result = json.loads(potential_json)
                                    logger.info(f"✅ JSON解析成功: タスク数={len(result.get('tasks', []))}")
                                    return result
                                except json.JSONDecodeError as e:
                                    # === パート7: 解析エラーの詳細ログ ===
                                    logger.error(f"❌ JSON解析エラー: {e}")
                                    logger.error(f"エラー位置: line {e.lineno}, column {e.colno}")
                                    
                                    error_pos = e.pos if hasattr(e, 'pos') else 0
                                    context_start = max(0, error_pos - 100)
                                    context_end = min(len(potential_json), error_pos + 100)
                                    logger.error(f"エラー周辺のテキスト:\n{potential_json[context_start:context_end]}")
                                    
                                    # === パート8: JSON修復の試行 ===
                                    repaired_json = self._attempt_json_repair(potential_json, e)
                                    if repaired_json:
                                        return repaired_json
            
            # === パート9: パターン3 - テキスト全体をJSONとして解析 ===
            logger.info("パターン3: テキスト全体をJSONとして解析")
            try:
                result = json.loads(text)
                logger.info(f"✅ JSON解析成功（全体解析）: タスク数={len(result.get('tasks', []))}")
                return result
            except json.JSONDecodeError as e:
                logger.error(f"❌ 全体解析も失敗: {e}")
            
            # === パート10: 全パターン失敗時のエラーログ ===
            logger.error("="*60)
            logger.error("❌ すべてのJSON解析パターンが失敗")
            logger.error("="*60)
            logger.error(f"応答の先頭500文字:\n{text[:500]}")
            logger.error(f"応答の末尾500文字:\n{text[-500:]}")
            
            return None
            
        except Exception as e:
            # === パート11: 予期しない例外の処理 ===
            logger.error(f"❌ JSON解析で予期しないエラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _attempt_json_repair(self, json_str: str, error: json.JSONDecodeError) -> Optional[Dict]:
        """壊れたJSONの修復を試みる"""
        try:
            # === パート1: 修復開始 ===
            logger.info("🔧 JSON修復を試みます...")
            
            error_pos = error.pos if hasattr(error, 'pos') else len(json_str)
            
            # === パート2: 修復試行1 - デリミタエラーの修正 ===
            if "Expecting ',' delimiter" in str(error) or "Expecting ':' delimiter" in str(error):
                last_complete_task = json_str.rfind('},', 0, error_pos)
                if last_complete_task > 0:
                    repaired = json_str[:last_complete_task + 1] + '], "risks": [], "success_criteria": []}'
                    logger.info(f"修復試行1: 位置{last_complete_task}で切り捨て")
                    try:
                        result = json.loads(repaired)
                        logger.info(f"✅ 修復成功! タスク数={len(result.get('tasks', []))}")
                        return result
                    except:
                        pass
            
            # === パート3: 修復試行2 - 行ベースの切り捨て ===
            lines = json_str.split('\n')
            error_line = error.lineno if hasattr(error, 'lineno') else len(lines)
            
            if error_line > 0 and error_line <= len(lines):
                truncated_lines = lines[:error_line-1]
                truncated = '\n'.join(truncated_lines)
                open_braces = truncated.count('{') - truncated.count('}')
                
                repaired = truncated
                if ',"tasks":[' in repaired and not repaired.rstrip().endswith(']'):
                    repaired += ']'
                
                # === パート4: 開いた中括弧を閉じる ===
                for _ in range(open_braces):
                    repaired += '}'
                
                logger.info("修復試行2: 不完全な部分を削除して閉じる")
                try:
                    result = json.loads(repaired)
                    logger.info(f"✅ 修復成功! タスク数={len(result.get('tasks', []))}")
                    return result
                except:
                    pass
            
            # === パート5: 修復失敗 ===
            logger.warning("❌ JSON修復に失敗")
            return None
            
        except Exception as e:
            logger.error(f"JSON修復中のエラー: {e}")
            return None
        
    async def save_tasks_to_sheet(self, task_plan: Dict) -> bool:
        """生成されたタスクをスプレッドシートに保存（追加方式）"""
        try:
            # === パート1: 保存開始 ===
            logger.info("タスクをスプレッドシートに保存中...")
        
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                # === パート2: 既存シートの読み込み ===
                task_sheet = sheet.worksheet("pm_tasks")
                existing_data = task_sheet.get_all_values()
                start_row = len(existing_data) + 1
            
                if len(existing_data) == 0:
                    # === パート3: 新規シートのヘッダー作成 ===
                    headers = [
                        "task_id", "parent_goal_id", "task_description", 
                        "required_role", "status", "priority", 
                        "estimated_time", "dependencies", "created_at", "batch_id"
                    ]
                    task_sheet.update('A1:J1', [headers])
                    start_row = 2
                
            except:
                # === パート4: シートが存在しない場合の作成 ===
                logger.info("'pm_tasks'シートを作成します")
                task_sheet = sheet.add_worksheet(title="pm_tasks", rows=1000, cols=10)
                headers = [
                    "task_id", "parent_goal_id", "task_description", 
                    "required_role", "status", "priority", 
                    "estimated_time", "dependencies", "created_at", "batch_id"
                ]
                task_sheet.update('A1:J1', [headers])
                start_row = 2
                existing_data = []
        
            # === パート5: バッチIDの生成 ===
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            # === パート6: 既存タスクIDの収集 ===
            existing_task_ids = []
            if len(existing_data) > 1:
                for row in existing_data[1:]:
                    if row and row[0].isdigit():
                        existing_task_ids.append(int(row[0]))
        
            # === パート7: 次のタスクIDの決定 ===
            next_task_id = max(existing_task_ids) + 1 if existing_task_ids else 1
        
            # === パート8: タスクデータの準備 ===
            tasks = task_plan.get('tasks', [])
            rows_data = []
        
            for i, task in enumerate(tasks):
                row = [
                    next_task_id + i,
                    self.current_goal['goal_id'] if self.current_goal else '',
                    task.get('description', ''),
                    task.get('required_role', 'dev'),
                    'pending',
                    task.get('priority', 'medium'),
                    task.get('estimated_time', ''),
                    ','.join(map(str, task.get('dependencies', []))),
                    datetime.now().isoformat(),
                    batch_id
                ]
                rows_data.append(row)
        
            # === パート9: スプレッドシートへの書き込み ===
            if rows_data:
                end_row = start_row + len(rows_data) - 1
                task_sheet.update(f'A{start_row}:J{end_row}', rows_data)
                logger.info(f"タスク {len(rows_data)} 件を追加しました（バッチ: {batch_id}）")
        
            # === パート10: メタデータの保存 ===
            self._save_project_metadata(task_plan)
        
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "タスク保存")
            return False
    
    def _save_project_metadata(self, task_plan: Dict):
        """プロジェクトのメタ情報（分析結果、リスク、成功基準）を保存（追加方式）"""
        try:
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                meta_sheet = sheet.worksheet("project_metadata")
                existing_data = meta_sheet.get_all_values()
                start_row = len(existing_data) + 2
            except:
                meta_sheet = sheet.add_worksheet(title="project_metadata", rows=100, cols=5)
                existing_data = []
                start_row = 1
        
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            data = [
                ["バッチID", batch_id],
                ["目標ID", self.current_goal['goal_id'] if self.current_goal else ''],
                ["分析結果", task_plan.get('project_analysis', '')],
                ["", ""],
                ["リスク", ""],
            ]
        
            for risk in task_plan.get('risks', []):
                data.append(["", risk])
        
            data.append(["", ""])
            data.append(["成功基準", ""])
        
            for criteria in task_plan.get('success_criteria', []):
                data.append(["", criteria])
        
            if existing_data:
                data = [["", ""], ["="*50, "="*50]] + data
        
            end_row = start_row + len(data) - 1
            meta_sheet.update(f'A{start_row}:B{end_row}', data)
            logger.info("プロジェクトメタデータを保存しました")
        
        except Exception as e:
            logger.warning(f"メタデータ保存に失敗: {e}")
    
    def display_task_summary(self, task_plan: Dict):
        """タスク概要を表示"""
        print("\n" + "="*60)
        print("PM AIによるタスク分解結果")
        print("="*60)
        
        print(f"\n【プロジェクト分析】")
        print(task_plan.get('project_analysis', ''))
        
        print(f"\n【生成されたタスク: {len(task_plan.get('tasks', []))}件】")
        for i, task in enumerate(task_plan.get('tasks', []), 1):
            role_icon = {
                'design': '📐',
                'dev': '💻',
                'ui': '🎨',
                'review': '✅'
            }.get(task.get('required_role', 'dev'), '📋')
            
            priority_icon = {
                'high': '🔴',
                'medium': '🟡',
                'low': '🟢'
            }.get(task.get('priority', 'medium'), '⚪')
            
            print(f"{i}. {priority_icon} {role_icon} {task.get('description', '')}")
            print(f"   担当: {task.get('required_role', 'dev')} | 優先度: {task.get('priority', 'medium')}")
            if task.get('dependencies'):
                print(f"   依存: タスク {task.get('dependencies')}")
            print()
        
        if task_plan.get('risks'):
            print(f"\n【想定リスク】")
            for risk in task_plan.get('risks', []):
                print(f"- {risk}")
        
        if task_plan.get('success_criteria'):
            print(f"\n【成功基準】")
            for criteria in task_plan.get('success_criteria', []):
                print(f"- {criteria}")
        
        print("="*60)

async def main():
    """PM AI単体テスト用のメイン関数"""
    import argparse
        
    # === パート1: 引数解析 ===
    parser = argparse.ArgumentParser(description='PM AI - タスク分解エージェント')
    parser.add_argument('--goal', type=str, help='直接目標を指定する（スプレッドシートを使わない場合）')
    args = parser.parse_args()
        
    # === パート2: 起動ヘッダー ===
    print("="*60)
    print("PM AI起動中...")
    print("="*60)
        
    # === パート3: サービスアカウント設定 ===
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
        
    # === パート4: シートマネージャー初期化 ===
    sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
    # === パート5: PC設定の読み込み ===
    pc_id = sheets_manager.get_current_pc_id()
    settings = sheets_manager.load_pc_settings(pc_id)
        
    config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
    config.COOKIES_FILE = settings.get('cookies_file')
    config.GENERATION_MODE = 'text'
    config.SERVICE_TYPE = 'google'
        
    # === パート6: ダウンロードフォルダ設定 ===
    download_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\temp_texts")
    download_folder.mkdir(exist_ok=True, parents=True)
        
    # === パート7: ブラウザコントローラーの初期化 ===
    browser = BrowserController(download_folder, mode='text', service='google')
    await browser.setup_browser()
        
    logger.info("Geminiにアクセス中...")
    await browser.navigate_to_gemini()
        
    # === パート8: PMエージェントの初期化 ===
    pm_agent = PMAgent(sheets_manager, browser)
        
    # === パート9: 目標の取得（コマンドライン or シート）===
    if args.goal:
        goal_description = args.goal
        logger.info(f"コマンドラインから目標を取得: {goal_description}")
    else:
        goal = await pm_agent.load_project_goal()
        if not goal:
            print("\nエラー: アクティブな目標が見つかりません")
            print("スプレッドシートの'project_goal'シートにstatusが'active'の目標を設定してください")
            await browser.cleanup()
            return
        goal_description = goal['description']
        
    try:
        # === パート10: タスク計画の生成 ===
        task_plan = await pm_agent.analyze_and_create_tasks(goal_description)
            
        # === パート11: タスク概要の表示 ===
        pm_agent.display_task_summary(task_plan)
            
        # === パート12: ユーザー確認と保存 ===
        save = input("\nタスクをスプレッドシートに保存しますか？ (y/n): ")
        if save.lower() == 'y':
            success = await pm_agent.save_tasks_to_sheet(task_plan)
            if success:
                print("タスクを保存しました")
            else:
                print("保存に失敗しました")
            
    except Exception as e:
        # === パート13: 例外処理 ===
        logger.error(f"PM AI実行エラー: {e}")
        import traceback
        traceback.print_exc()
        
    finally:
        # === パート14: クリーンアップ ===
        await browser.cleanup()
        print("\nPM AIを終了しました")

if __name__ == "__main__":
    asyncio.run(main())


#pm_system_prompts.py
"""
PM AIのシステムプロンプト定義（完全版）
ACF & Custom Post Type UI 対応
"""

PM_SYSTEM_PROMPT = """あなたは経験豊富なプロジェクトマネージャーAIです。

【あなたの役割】
- プロジェクトの目標を分析し、達成に必要なタスクに分解する
- 各タスクに適切な担当者（AI エージェント）を割り当てる
- **多言語対応プロジェクトでは、必ず言語とPolylang設定を明記する**
- **開発タスクは原則WordPressで実装可能か検討する**
- タスクの優先順位を決定する
- 実現可能で具体的なタスクを作成する

【重要: WordPress優先開発ポリシー】
このプロジェクトは **WordPress中心の開発スタイル** を採用しています。
以下の優先順位でエージェントを選択してください:

**優先度1: WordPress標準機能 + プラグイン実装**
- カスタム投稿タイプ → **wordpress**: Custom Post Type UI でGUI設定
- カスタムフィールド → **wordpress**: Advanced Custom Fields (ACF) でGUI設定
- データベース設計 → **design**: ACF設計書作成 → **wordpress**: ACF設定
- UI/画面デザイン → **ui**: デザイン設計 → **wordpress**: テーマカスタマイズ
- 検索・絞り込み → **wordpress**: FacetWP / SearchWP / Relevanssi設定
- フォーム作成 → **wordpress**: ACFフォーム / Contact Form 7設定
- ユーザー管理 → **wordpress**: User Role Editor / Members設定

**優先度2: 軽量カスタム開発（プラグイン活用後の微調整）**
- ACF連携カスタマイズ → **dev**: functions.php追記
- 検索クエリ調整 → **dev**: pre_get_posts フック実装
- 表示カスタマイズ → **dev**: テンプレートファイル作成

**優先度3: 高度な開発（WordPress標準で実現困難な場合のみ）**
- 複雑なビジネスロジック → **dev**: カスタムプラグイン開発
- 外部API連携 → **dev**: REST API統合
- 特殊なアーキテクチャ → **design**: システム設計 → **dev**: 実装

**判断基準:**
「WordPressの標準機能やプラグインで実現できるか？」
→ YES: wordpress / plugin エージェント
→ NO: design → dev エージェント

【利用可能なAIエージェント】

**開発・設計系エージェント:**
- **design** (設計AI): システム設計、アーキテクチャ設計、要件定義書作成、データベース設計、API仕様書作成、ACFフィールド設計書作成
- **dev** (開発AI): コーディング、テストコード作成、実装、複数言語対応（Python, JavaScript, PHP など）、functions.php カスタマイズ
- **ui** (UI/UX AI): ユーザーインターフェース設計、画面設計、UX最適化、ワイヤーフレーム作成

**コンテンツ作成系エージェント:**
- **writer** (汎用ライターAI): ブログ記事作成、HTML記事執筆、SEOコンテンツ作成（後方互換性のため残す）
- **writer_ja** (日本語ライターAI): 日本語記事作成、品質重視、日本のビジネスオーナー向け
- **writer_en** (英語ライターAI): 英語記事作成、SEO最適化、国際投資家向け
- **writer_ru** (ロシア語ライターAI): ロシア語記事作成、現地ビジネス向け
- **writer_uz** (ウズベク語ライターAI): ウズベク語記事作成、現地企業向け
- **writer_zh** (中国語ライターAI): 中国語記事作成、中国投資家向け
- **writer_ko** (韓国語ライターAI): 韓国語記事作成、韓国ビジネス向け
- **writer_tr** (トルコ語ライターAI): トルコ語記事作成、トルコビジネス向け
- **content** (コンテンツAI): writerのエイリアス（後方互換性）

**WordPress・プラグイン系エージェント:**
- **wordpress** (WordPressAI): WordPress投稿、記事公開、記事編集、Polylang言語設定、下書き保存、ACF設定、Custom Post Type UI設定、テーマカスタマイズ
- **plugin** (プラグインAI): WordPressプラグイン管理、インストール、設定変更、プラグイン選定

**品質管理系エージェント:**
- **review** (レビューAI): 品質チェック、コードレビュー、記事レビュー、出力物評価

【重要: インストール済みプラグイン】
以下のプラグインはすでにインストール済みです。これらを活用したタスクを作成してください：
- Advanced Custom Fields (ACF) Pro
- Custom Post Type UI
- Polylang Pro
- FacetWP（検索機能強化）
- User Role Editor（ユーザー権限管理）
- Wordfence Security（セキュリティ）
- WP Rocket（キャッシュ・パフォーマンス）

【重要: ACF & Custom Post Type UI 設定タスクのルール】

**ACF設定タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【ACF設定】M&A案件用カスタムフィールド作成",
  "acf_field_group_name": "M&A案件基本情報",
  "acf_fields": [
    {"name": "case_id", "type": "text", "label": "案件ID", "required": true},
    {"name": "ma_scheme", "type": "select", "label": "M&Aスキーム", "choices": ["株式譲渡", "事業譲渡"]},
    {"name": "desired_price", "type": "number", "label": "希望価格", "min": 0}
  ],
  "acf_location_rules": {
    "post_type": "ma_case"
  }
}
```

**使用可能なACFフィールドタイプ:**
- テキスト系: text, textarea, number, email, url, password
- 選択系: select, checkbox, radio, true_false
- 日付時刻系: date_picker, date_time_picker, time_picker
- ファイル系: file, image, gallery
- リレーション系: post_object, relationship, taxonomy, user
- レイアウト系: repeater, flexible_content, group
- その他: wysiwyg, oembed, google_map, color_picker

**Custom Post Type設定タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【Custom Post Type】M&A案件投稿タイプ作成",
  "cpt_slug": "ma_case",
  "cpt_labels": {
    "singular": "M&A案件",
    "plural": "M&A案件一覧"
  },
  "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"],
  "cpt_settings": {
    "public": true,
    "has_archive": true,
    "show_in_rest": true,
    "menu_icon": "dashicons-portfolio"
  }
}
```

**カスタムタクソノミー設定タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【タクソノミー】業種カテゴリ作成",
  "taxonomy_slug": "industry_category",
  "taxonomy_labels": {
    "singular": "業種",
    "plural": "業種一覧"
  },
  "taxonomy_post_types": ["ma_case"],
  "taxonomy_hierarchical": true
}
```

**M&A案件投稿タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【M&A案件登録】製造業の事業承継案件投稿",
  "post_title": "製造業・年商5億円・黒字企業の事業承継案件",
  "post_content": "企業概要...",
  "acf_fields": {
    "case_id": "MA2025001",
    "ma_scheme": "株式譲渡",
    "desired_price": "100000000",
    "industry_category": "製造業",
    "region": "関東",
    "established_year": "1995",
    "employees": "50"
  },
  "polylang_lang": "ja",
  "post_status": "draft"
}
```

【重要: 言語指定のルール】
1. **記事作成タスク**には必ず以下を含める:
   - `language`: 対象言語コード (ja/en/ru/uz/zh/ko/tr)
   - `polylang_lang`: Polylangの言語設定 (ja/en/ru/uz_UZ/zh_CN/ko_KR/tr_TR)
   - `target_url`: 参照元URL（ある場合）
   - `seo_keywords`: SEOキーワード
   - `target_audience`: ターゲット読者

2. **WordPress投稿タスク**には必ず以下を含める:
   - `language`: 投稿先言語
   - `polylang_lang`: Polylang言語コード
   - `source_task_id`: 元記事のタスクID
   - `post_action`: "create" または "edit"
   - `post_status`: "publish" / "draft" / "pending"

3. **レビュータスク**には以下を含める:
   - `review_language`: レビュー対象の言語
   - `review_target_task_id`: レビュー対象タスクID
   - `review_criteria`: 評価基準

【タスク分解の基本フロー】

**パターン1: 多言語コンテンツ作成プロジェクト**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "writer_ja",
      "description": "【日本語】M&A市場動向記事作成",
      "language": "ja",
      "polylang_lang": "ja",
      "seo_keywords": "M&A,ウズベキスタン,市場動向"
    },
    {
      "id": 2,
      "agent": "review",
      "description": "【日本語】記事品質チェック",
      "review_language": "ja",
      "review_target_task_id": 1
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "【日本語】WordPress投稿",
      "polylang_lang": "ja",
      "source_task_id": 1,
      "post_action": "create",
      "post_status": "publish"
    },
    {
      "id": 4,
      "agent": "writer_en",
      "description": "【英語】M&A market trends article",
      "language": "en",
      "polylang_lang": "en",
      "target_url": "参照元記事URL"
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "【英語】WordPress投稿",
      "polylang_lang": "en",
      "source_task_id": 4,
      "post_action": "create"
    }
  ]
}
```

**パターン2: M&Aポータルサイト機能開発プロジェクト**
```json
{
  "project_name": "M&Aポータルサイト構築",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "【要件定義】M&A案件管理システムの要件定義書作成",
      "priority": "high",
      "deliverables": ["要件定義書.md"]
    },
    {
      "id": 2,
      "agent": "design",
      "description": "【ACF設計】M&A案件用カスタムフィールド設計書作成",
      "priority": "high",
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "【Custom Post Type】M&A案件カスタム投稿タイプ作成",
      "priority": "high",
      "dependencies": [2],
      "cpt_slug": "ma_case",
      "cpt_labels": {"singular": "M&A案件", "plural": "M&A案件一覧"},
      "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"]
    },
    {
      "id": 4,
      "agent": "wordpress",
      "description": "【タクソノミー】業種カテゴリ作成",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "industry_category",
      "taxonomy_labels": {"singular": "業種", "plural": "業種一覧"},
      "taxonomy_post_types": ["ma_case"],
      "taxonomy_hierarchical": true
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "【タクソノミー】地域カテゴリ作成",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "region",
      "taxonomy_labels": {"singular": "地域", "plural": "地域一覧"}
    },
    {
      "id": 6,
      "agent": "wordpress",
      "description": "【ACF設定】M&A案件基本情報フィールドグループ作成",
      "priority": "high",
      "dependencies": [3, 4, 5],
      "acf_field_group_name": "M&A案件基本情報",
      "acf_fields": [
        {"name": "case_id", "type": "text", "label": "案件ID"},
        {"name": "ma_scheme", "type": "select", "label": "M&Aスキーム"},
        {"name": "desired_price", "type": "number", "label": "希望価格"},
        {"name": "industry_category", "type": "taxonomy", "label": "業種"},
        {"name": "region", "type": "taxonomy", "label": "地域"}
      ],
      "acf_location_rules": {"post_type": "ma_case"}
    },
    {
      "id": 7,
      "agent": "plugin",
      "description": "【FacetWP】絞り込み検索設定",
      "priority": "medium",
      "dependencies": [6],
      "plugin_name": "facetwp",
      "facets": [
        {"name": "業種フィルター", "type": "checkboxes", "source": "tax/industry_category"},
        {"name": "価格帯フィルター", "type": "slider", "source": "cf/desired_price"},
        {"name": "地域フィルター", "type": "dropdown", "source": "tax/region"}
      ]
    },
    {
      "id": 8,
      "agent": "ui",
      "description": "【検索UI設計】検索フォーム画面デザイン作成",
      "priority": "medium",
      "dependencies": [7]
    },
    {
      "id": 9,
      "agent": "plugin",
      "description": "【User Role】提携パートナーロール作成",
      "priority": "medium",
      "dependencies": [3],
      "plugin_name": "user-role-editor",
      "role_slug": "ma_partner",
      "role_name": "提携パートナー",
      "capabilities": {"read": true, "edit_posts": true}
    },
    {
      "id": 10,
      "agent": "plugin",
      "description": "【セキュリティ】Wordfence基本設定",
      "priority": "high",
      "plugin_name": "wordfence"
    },
    {
      "id": 11,
      "agent": "plugin",
      "description": "【キャッシュ】WP Rocket設定",
      "priority": "medium",
      "plugin_name": "wp-rocket"
    },
    {
      "id": 12,
      "agent": "review",
      "description": "【総合評価】機能全体の品質チェック",
      "priority": "high",
      "dependencies": [7, 8, 9, 10, 11]
    }
  ]
}
```

**パターン3: 既存WordPress記事の多言語展開**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "wordpress",
      "description": "【記事取得】既存投稿の内容取得",
      "post_id": 123
    },
    {
      "id": 2,
      "agent": "writer_en",
      "description": "【英語翻訳】英語版記事作成",
      "language": "en",
      "polylang_lang": "en",
      "source_post_id": 123,
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "【英語投稿】Polylang連携で英語版公開",
      "polylang_lang": "en",
      "source_task_id": 2,
      "translation_of": 123,
      "dependencies": [2]
    }
  ]
}
```

【出力形式】
必ずJSON形式で出力してください。

**JSON出力例:**
```json
{
  "project_name": "プロジェクト名",
  "total_tasks": 10,
  "estimated_duration": "2週間",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "【要件定義】システム要件定義書作成",
      "priority": "high",
      "dependencies": [],
      "parameters": {}
    }
  ]
}
```

【重要な注意事項】
- タスク説明の冒頭に必ず【機能名】または【言語名】を付ける
- WordPress投稿タスクには必ず`source_task_id`を指定（翻訳の場合）
- ACF設定タスクにはフィールド詳細を必ず記載
- Custom Post Type設定タスクにはスラッグとラベルを必ず指定
- 各言語専用のライターエージェントを正しく指定
- Polylang言語コードを正確に記載する
  - 日本語: ja
  - 英語: en
  - ロシア語: ru
  - ウズベク語: uz_UZ
  - 中国語: zh_CN
  - 韓国語: ko_KR
  - トルコ語: tr_TR
- プラグイン設定タスクには具体的な設定内容を記載
- セキュリティタスクは必ず含める
- パフォーマンス最適化タスクを忘れずに追加
- 依存関係（dependencies）を正確に設定

【タスク分解時のチェックリスト】
✅ Custom Post Type は作成されているか？
✅ ACFフィールドは設計されているか？
✅ タクソノミーは作成されているか？
✅ 検索機能は実装されているか？
✅ ユーザーロールは設定されているか？
✅ Polylang設定は含まれているか？
✅ セキュリティプラグインは導入されているか？
✅ キャッシュプラグインは設定されているか？
✅ レビュータスクは含まれているか？
✅ 各タスクの依存関係は正しいか？
✅ ACF/CPT UIの設定パラメータは具体的か？
✅ M&A案件投稿にACFフィールドは含まれているか？
"""

#quick_fix.py
#!/usr/bin/env python3
"""
クイック修正スクリプト - インポートエラーを自動修正
使い方: python quick_fix.py
"""

import os
import re
from pathlib import Path
import shutil
from datetime import datetime


def create_backup(file_path: Path) -> Path:
    """ファイルのバックアップを作成"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = file_path.with_suffix(f'.backup_{timestamp}{file_path.suffix}')
    shutil.copy2(file_path, backup_path)
    print(f"✅ バックアップ作成: {backup_path}")
    return backup_path


def fix_wp_plugin_manager(base_dir: Path) -> bool:
    """wp_plugin_manager.py のインポートエラーを修正"""
    file_path = base_dir / "wordpress" / "wp_plugin_manager.py"
    
    if not file_path.exists():
        print(f"⚠️ ファイルが見つかりません: {file_path}")
        return False
    
    print(f"\n🔧 修正中: {file_path}")
    
    # バックアップ作成
    create_backup(file_path)
    
    # ファイルを読み込み
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 既に修正済みかチェック
    if 'from typing import' in content and 'List' in content:
        print("✅ 既に修正済みです")
        return True
    
    # インポート文を探す
    import_pattern = r'^(import logging\s*\n)'
    
    # 新しいインポート文
    new_imports = '''import logging
import asyncio
from typing import Dict, List, Optional, Any
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

'''
    
    # 置換
    if re.search(import_pattern, content, re.MULTILINE):
        content = re.sub(import_pattern, new_imports, content, count=1, flags=re.MULTILINE)
        print("✅ インポート文を追加しました")
    else:
        # パターンが見つからない場合は先頭に追加
        lines = content.split('\n')
        # docstring の後に挿入
        insert_index = 0
        for i, line in enumerate(lines):
            if '"""' in line or "'''" in line:
                # docstringの終わりを探す
                for j in range(i+1, len(lines)):
                    if '"""' in lines[j] or "'''" in lines[j]:
                        insert_index = j + 1
                        break
                break
        
        if insert_index == 0:
            insert_index = 1  # ファイルの最初の行の後
        
        lines.insert(insert_index, '\n' + new_imports.strip())
        content = '\n'.join(lines)
        print("✅ インポート文を先頭に追加しました")
    
    # ファイルに書き込み
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("✅ wp_plugin_manager.py の修正完了")
    return True


def fix_wordpress_init(base_dir: Path) -> bool:
    """wordpress/__init__.py のインポートエラーを修正"""
    file_path = base_dir / "wordpress" / "__init__.py"
    
    if not file_path.exists():
        print(f"⚠️ ファイルが見つかりません: {file_path}")
        return False
    
    print(f"\n🔧 チェック中: {file_path}")
    
    # ファイルを読み込み
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # エラーハンドリングが必要か確認
    needs_fix = False
    
    if 'from .wp_agent import WordPressAgent' in content:
        if 'try:' not in content:
            needs_fix = True
    
    if not needs_fix:
        print("✅ 修正不要です")
        return True
    
    # バックアップ作成
    create_backup(file_path)
    
    # エラーハンドリング付きインポートに変更
    new_content = '''"""
WordPress パッケージ
"""

try:
    from .wp_agent import WordPressAgent
    from .wp_utils import WordPressConfig, task_router
    __all__ = ['WordPressAgent', 'WordPressConfig', 'task_router']
except ImportError as e:
    import logging
    logger = logging.getLogger(__name__)
    logger.warning(f"⚠️ WordPress モジュールのインポート失敗: {e}")
    WordPressAgent = None
    WordPressConfig = None
    task_router = None
    __all__ = []
'''
    
    # ファイルに書き込み
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("✅ wordpress/__init__.py の修正完了")
    return True


def check_all_typing_imports(base_dir: Path) -> list:
    """全Pythonファイルの typing インポートをチェック"""
    print("\n🔍 全ファイルのチェック中...")
    
    issues = []
    
    for py_file in base_dir.rglob("*.py"):
        if 'venv' in str(py_file) or '__pycache__' in str(py_file):
            continue
        
        try:
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # List, Dict などを使っているがインポートしていない
            if ('List[' in content or 'Dict[' in content or 
                'Optional[' in content or 'Tuple[' in content):
                if 'from typing import' not in content:
                    issues.append(str(py_file))
        except Exception as e:
            print(f"⚠️ {py_file} の読み込みエラー: {e}")
    
    return issues


def fix_task_executor_imports(base_dir: Path) -> bool:
    """task_executor.py のインポートエラーを修正"""
    file_path = base_dir / "task_executor.py"
    
    if not file_path.exists():
        print(f"⚠️ ファイルが見つかりません: {file_path}")
        return False
    
    print(f"\n🔧 修正中: {file_path}")
    
    # バックアップ作成
    create_backup(file_path)
    
    # ファイルを読み込み
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 既に修正済みかチェック
    if 'from sheets_manager import GoogleSheetsManager' in content:
        print("✅ 既に修正済みです")
        return True
    
    # 正しいインポート順序
    correct_imports = '''"""
Task Executor - タスク実行コントローラー
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== 設定とユーティリティ =====
from config_utils import ErrorHandler, config

# ===== データ管理 =====
from sheets_manager import GoogleSheetsManager

# ===== エラーハンドラー（オプション） =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    import warnings
    warnings.warn("⚠️ error_handler_enhanced未検出（標準エラーハンドラー使用）")

# ===== 分離モジュール =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    import warnings
    warnings.warn("⚠️ task_executor_content/ma が見つかりません")

# ===== WordPress連携（オプション） =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None
    import warnings
    warnings.warn("⚠️ wordpress.wp_utils.task_router が見つかりません")

logger = logging.getLogger(__name__)


'''
    
    # 既存のインポート部分を探して置き換え
    # クラス定義の前までを置き換える
    class_pattern = r'class TaskExecutor:'
    class_match = re.search(class_pattern, content)
    
    if class_match:
        # クラス定義以降を保持
        class_and_rest = content[class_match.start():]
        # 新しいインポート + クラス定義以降
        new_content = correct_imports + class_and_rest
    else:
        print("⚠️ TaskExecutor クラスが見つかりません")
        return False
    
    # ファイルに書き込み
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("✅ task_executor.py のインポート修正完了")
    return True


def main():
    """メイン処理"""
    print("="*60)
    print("🔧 クイック修正スクリプト v2")
    print("="*60)
    
    # カレントディレクトリを取得
    base_dir = Path.cwd()
    print(f"\n📁 作業ディレクトリ: {base_dir}")
    
    # 修正実行
    success_count = 0
    
    # 1. wp_plugin_manager.py の修正
    if fix_wp_plugin_manager(base_dir):
        success_count += 1
    
    # 2. wordpress/__init__.py の修正
    if fix_wordpress_init(base_dir):
        success_count += 1
    
    # 3. task_executor.py の修正（新規追加）
    if fix_task_executor_imports(base_dir):
        success_count += 1
    
    # 4. その他のファイルをチェック
    issues = check_all_typing_imports(base_dir)
    
    if issues:
        print(f"\n⚠️ 追加で修正が必要な可能性のあるファイル: {len(issues)}件")
        for issue_file in issues[:10]:  # 最初の10件のみ表示
            print(f"  - {issue_file}")
        
        if len(issues) > 10:
            print(f"  ... 他 {len(issues) - 10} 件")
    
    # 結果サマリー
    print("\n" + "="*60)
    print("📊 修正完了")
    print("="*60)
    print(f"✅ 修正成功: {success_count} ファイル")
    
    if issues:
        print(f"⚠️ 要確認: {len(issues)} ファイル")
        print("\n💡 ヒント: 各ファイルで以下を追加してください:")
        print("   from typing import Dict, List, Optional, Any")
    
    print("\n🎉 修正完了！")
    print("次のコマンドで実行してください:")
    print("   python run_multi_agent.py --auto")


if __name__ == "__main__":
    main()

#review_agent.py
# review_agent.py
"""レビューAI - タスク出力を評価し、失敗原因を分析、次のアクションを提案"""
import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController
from sheets_manager import GoogleSheetsManager
from review_agent_prompts import REVIEW_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class ReviewAgent:
    """レビューAI - タスク出力を評価し、失敗原因を分析、次のアクションを提案"""
    
    def __init__(self):
        """コンストラクタ - 後でプロパティを設定する"""
        self.browser = None
        self.sheets_manager = None
        self.system_prompt = REVIEW_SYSTEM_PROMPT

    async def process_task(self, task: Dict) -> Dict:
        """レビュータスクを処理（互換性のため）"""
        return await self.review_completed_task(task, task.get('output_content', ''))

    async def review_completed_task(self, task: Dict, output_content: str) -> Dict:
        """完了したタスクをレビュー（失敗原因分析強化版）"""
        try:
            # === パート1: レビュー開始処理 ===
            logger.info("="*60)
            logger.info(f"レビューAI: タスク {task['task_id']} のレビュー開始")
            logger.info("="*60)
            
            # タスクのステータスを確認
            task_status = task.get('status', 'unknown')
            is_failed_task = task_status in ['failed', 'error', 'timeout']
            
            # 事前チェック：出力内容の構造を検証
            pre_check_result = self._pre_check_content(output_content, task['required_role'])
            if pre_check_result:
                logger.info(f"事前チェック結果: {pre_check_result}")
            
            # エラー情報を取得
            error_info = task.get('error', '')
            
            # === パート2: プロンプト構築とGemini送信 ===
            full_prompt = self._build_review_prompt(
                task, task_status, is_failed_task, 
                output_content, error_info, pre_check_result
            )
            
            logger.info("レビューをGeminiに依頼中...")
            await self.browser.send_prompt(full_prompt)
            
            # 応答待機
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                logger.warning("レビューAI: タイムアウト")
                return self._create_default_review(task, is_failed_task)
            
            # === パート3: 応答取得と結果解析 ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.warning("レビューAI: 応答取得失敗")
                return self._create_default_review(task, is_failed_task)
            
            logger.info(f"レビューAI: 応答取得完了（{len(response_text)}文字）")
            
            # JSONをパース
            review_result = self._parse_review_json(response_text)
            
            if review_result:
                # レビュー結果の妥当性を検証
                validated_review = self._validate_review_result(review_result, output_content)
                self._display_review_summary(validated_review, is_failed_task)
                return {
                    'success': True,
                    'review': validated_review,
                    'summary': validated_review.get('evaluation', {}).get('overall_assessment', ''),
                    'full_text': response_text
                }
            else:
                logger.warning("レビュー結果のJSON解析に失敗")
                return self._create_default_review(task, is_failed_task)
                
        except Exception as e:
            ErrorHandler.log_error(e, "レビューAI処理")
            return self._create_default_review(task, False)

    def _build_review_prompt(self, task: Dict, task_status: str, is_failed_task: bool,
                           output_content: str, error_info: str, pre_check_result: str) -> str:
        """レビュー用プロンプトを構築(トレーサビリティ情報付き)"""
    
        # === 🆕 新規追加: トレーサビリティ情報の抽出 ===
        traceability = task.get('_traceability', {})
        executed_by = traceability.get('executed_by_agent', '不明')
        agent_class = traceability.get('agent_class', '不明')
    
        return f"""{self.system_prompt}

    【レビュー対象タスク】
    タスクID: {task['task_id']}
    内容: {task['description']}
    担当: {task['required_role']}
    ステータス: {task_status}
    出力文字数: {len(output_content)}文字

    🆕【実行エージェント情報】(原因切り分け用)
    実行エージェント: {executed_by}
    エージェントクラス: {agent_class}
    実行タイムスタンプ: {traceability.get('execution_timestamp', 'N/A')}

    【タスクの状態】
    {'❌ このタスクは失敗しました' if is_failed_task else '✅ タスクは完了しました'}
    {f'エラー情報: {error_info}' if error_info else ''}

    【事前チェック結果】
    {pre_check_result if pre_check_result else '特記事項なし'}

    【タスクの出力】
    {output_content[:4000] if output_content else '(出力なし)'}

    上記のタスク出力をレビューし、指定されたJSON形式で評価と次のアクションを提案してください。
    {'特に失敗原因を詳細に分析し、適切な推奨アクションを提案してください。' if is_failed_task else '特に、構造的に完結しているかどうかを重点的に確認してください。'}

    🆕【レビュー時の注意】
    - コードブロックが途中で途切れている場合は必ず指摘してください
    - 実行エージェント({executed_by})の出力品質に問題がある場合、その旨を明記してください
    - 手動作業が必要な手順が含まれている場合、自動化の提案も含めてください
    """


    def _pre_check_content(self, content: str, role: str) -> str:
        """出力内容の事前チェック"""
        checks = []
        
        # === パート1: 文字数チェック ===
        if len(content) < 100:
            checks.append("⚠️ 文字数が少なすぎます（100文字未満）")
        elif len(content) > 5000:
            checks.append("✅ 文字数が十分です")
        
        # === パート2: 記事・文書系タスクの構造チェック ===
        if role in ['writer', 'content', 'wordpress', 'writer_ja', 'writer_en', 'writer_ru']:
            if '<h1' in content or '<h2' in content or '# ' in content:
                checks.append("✅ 見出し構造があります")
            
            if any(phrase in content for phrase in ['まとめ', '結論', '終わり', '以上', '最後に', 'Conclusion', 'Summary']):
                checks.append("✅ 結論・まとめがあります")
            else:
                checks.append("⚠️ 明示的な結論・まとめが見つかりません")
            
            # HTML/マークダウンの閉じ忘れチェック
            if content.count('<div') > content.count('</div'):
                checks.append("⚠️ HTMLのdivタグが閉じられていません")
            if content.count('<p>') > content.count('</p>'):
                checks.append("⚠️ HTMLのpタグが閉じられていません")
        
        # === パート3: コード系タスクの構造チェック ===
        if role in ['dev', 'programming']:
            if 'def ' in content or 'function ' in content or 'class ' in content:
                checks.append("✅ 関数/クラス定義があります")
            if 'import ' in content or 'require ' in content:
                checks.append("✅ インポート文があります")
        
        return " | ".join(checks) if checks else "✅ 基本的な構造は問題ありません"

    def _validate_review_result(self, review: Dict, original_content: str) -> Dict:
        """レビュー結果の妥当性を検証"""
        evaluation = review.get('evaluation', {})
        next_actions = review.get('next_actions', {})
        
        # === パート1: 「部分的」判定の妥当性チェック ===
        if evaluation.get('completeness') == '部分的':
            issues = evaluation.get('issues', [])
            new_issues = []
            
            for issue in issues:
                # 文字数関連の指摘を検証
                if any(word in issue for word in ['文字数', '文字', '短い', '少ない']):
                    if len(original_content) > 1000:  # 1000文字以上あれば文字数不足ではない
                        continue
                # 構造的な指摘を検証
                elif '切れて' in issue or '途切れ' in issue:
                    # 実際に文が途中で切れているかチェック
                    if self._is_content_properly_ended(original_content):
                        continue
                
                new_issues.append(issue)
            
            # 問題点を更新
            evaluation['issues'] = new_issues
            
            # 問題点がなくなった場合は「完了」に変更
            if not new_issues and len(original_content) > 500:
                evaluation['completeness'] = '完了'
                evaluation['overall_assessment'] = '再評価: 内容は完結しており、文字数も十分です'
                next_actions['required'] = False
                next_actions['suggested_tasks'] = []
        
        return review

    def _is_content_properly_ended(self, content: str) -> bool:
        """コンテンツが適切に終了しているかチェック"""
        # === パート1: 文の終了チェック ===
        sentences = re.split(r'[。！？!?\.]', content.strip())
        if sentences and sentences[-1].strip():
            return False  # 最後の文が終了記号で終わっていない
        
        # === パート2: HTMLタグの閉じチェック ===
        if content.count('<') > 0 and content.count('>') > 0:
            open_tags = len(re.findall(r'<(?!\/)[^>]+>', content))
            close_tags = len(re.findall(r'<\/[^>]+>', content))
            if open_tags != close_tags:
                return False
        
        return True

    def _parse_review_json(self, text: str) -> Optional[Dict]:
        """レビュー結果のJSONをパース"""
        try:
            import re
            
            # === パート1: ```json ... ``` 形式の抽出 ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            # === パート2: 単純なJSONオブジェクトの抽出 ===
            json_match = re.search(r'(\{.*\})', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            logger.warning("JSON形式が見つかりません")
            return None
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON解析エラー: {e}")
            return None

    def _create_default_review(self, task: Dict, is_failed: bool = False) -> Dict:
        """デフォルトのレビュー結果（失敗時）"""
        if is_failed:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': '失敗',
                        'quality_score': 3,
                        'issues': ['タスク実行に失敗しました'],
                        'good_points': [],
                        'overall_assessment': 'タスクは失敗しましたが、レビュー処理も問題が発生しました',
                        'failure_analysis': {
                            'is_failed': True,
                            'failure_category': '環境問題',
                            'root_cause': 'レビューAIの応答取得に失敗',
                            'impact': '失敗原因の詳細が不明',
                            'recommended_action': 'immediate_retry',
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': True,
                        'reasoning': 'タスクの再実行または修正が必要',
                        'suggested_tasks': []
                    }
                },
                'summary': 'レビュー処理エラー - タスク失敗',
                'full_text': ''
            }
        else:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': '完了',
                        'quality_score': 7,
                        'issues': [],
                        'good_points': ['タスク完了'],
                        'overall_assessment': 'レビュー処理に問題が発生しましたが、タスクは完了とみなします',
                        'failure_analysis': {
                            'is_failed': False,
                            'failure_category': None,
                            'root_cause': None,
                            'impact': None,
                            'recommended_action': None,
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': False,
                        'reasoning': 'レビューAIの応答取得に失敗したため、追加タスクなし',
                        'suggested_tasks': []
                    }
                },
                'summary': 'レビュー処理エラー - デフォルト評価',
                'full_text': ''
            }

    def _display_review_summary(self, review: Dict, is_failed_task: bool = False):
        """レビュー結果を表示（失敗分析強化版）"""
        
        print("\n" + "🎯" * 30)
        print("📋 レビュー結果")
        print("🎯" * 30)
        
        evaluation = review.get('evaluation', {})
        
        # === パート1: 基本情報表示 ===
        completeness = evaluation.get('completeness', 'N/A')
        completeness_icon = {
            '完了': '✅',
            '部分的': '⚠️',
            '不完全': '❌',
            '失敗': '💥'
        }.get(completeness, '❓')
        
        print(f"\n{completeness_icon} 完成度: {completeness}")
        print(f"⭐ 品質スコア: {evaluation.get('quality_score', 'N/A')}/10")
        
        # === パート2: 失敗分析表示 ===
        failure_analysis = evaluation.get('failure_analysis', {})
        if failure_analysis.get('is_failed'):
            print("\n" + "💥" * 30)
            print("🔍 失敗原因分析")
            print("💥" * 30)
            
            category = failure_analysis.get('failure_category', 'N/A')
            category_icon = {
                '要件不明瞭': '📝',
                '技術的問題': '⚙️',
                'リソース不足': '📦',
                '依存関係': '🔗',
                '環境問題': '🌐',
                'タイムアウト': '⏱️',
                '出力不完全': '✂️',
                '品質不足': '📉'
            }.get(category, '❓')
            
            print(f"\n{category_icon} 失敗カテゴリ: {category}")
            print(f"🔍 根本原因: {failure_analysis.get('root_cause', 'N/A')}")
            print(f"💡 影響: {failure_analysis.get('impact', 'N/A')}")
            
            action = failure_analysis.get('recommended_action', 'N/A')
            action_map = {
                'immediate_retry': '🔄 即座に再実行',
                'modify_task': '✏️ タスクを修正',
                'add_prerequisite': '➕ 前提タスクを追加',
                'escalate': '🚨 エスカレーション（人間の判断が必要）',
                'skip': '⏭️ スキップまたは後回し'
            }
            print(f"📌 推奨アクション: {action_map.get(action, action)}")
            
            prereqs = failure_analysis.get('prerequisites', [])
            if prereqs:
                print(f"\n📋 前提条件:")
                for prereq in prereqs:
                    print(f"   • {prereq}")
            
            print("💥" * 30)
        
        # === パート3: 良い点・問題点表示 ===
        good_points = evaluation.get('good_points', [])
        if good_points:
            print(f"\n✨ 良い点:")
            for point in good_points:
                print(f"   ✅ {point}")
        
        issues = evaluation.get('issues', [])
        if issues:
            print(f"\n⚠️ 問題点:")
            for issue in issues:
                print(f"   ❌ {issue}")
        
        # === パート4: 総合評価表示 ===
        overall = evaluation.get('overall_assessment', '')
        if overall:
            print(f"\n💎 総合評価:")
            print(f"   {overall}")
        
        # === パート5: 次のアクション表示 ===
        next_actions = review.get('next_actions', {})
        required = next_actions.get('required', False)
        
        action_icon = '🔴' if required else '🟢'
        print(f"\n🎯 次のアクション: {action_icon} {'必要' if required else '不要'}")
        
        if required:
            reasoning = next_actions.get('reasoning', '')
            if reasoning:
                print(f"   📌 理由: {reasoning}")
            
            # 提案タスク
            suggested_tasks = next_actions.get('suggested_tasks', [])
            if suggested_tasks:
                print(f"\n🚀 提案タスク ({len(suggested_tasks)}件):")
                for i, task in enumerate(suggested_tasks, 1):
                    priority_icon = {
                        'high': '🔴',
                        'medium': '🟡',
                        'low': '🟢'
                    }.get(task.get('priority', 'medium'), '⚪')
                    
                    role_icon = {
                        'design': '📐',
                        'dev': '💻',
                        'ui': '🎨',
                        'review': '✅',
                        'wordpress': '🌐',
                        'content': '✍️',
                        'writer': '📝',
                        'writer_ja': '🗾',
                        'writer_en': '🔠',
                        'writer_ru': '🇷🇺'
                    }.get(task.get('required_role', 'dev'), '📋')
                    
                    print(f"   {i}. {priority_icon} {role_icon} {task.get('description', 'N/A')}")
                    
                    deps = task.get('dependencies', [])
                    if deps:
                        print(f"      📎 依存: {', '.join(map(str, deps))}")
        
        print("🎯" * 30 + "\n")

    async def add_suggested_tasks_to_sheet(self, parent_task_id: str, suggested_tasks: List[Dict]) -> int:
        """提案されたタスクをpm_tasksシートに追加（正しい列配置版）"""
        try:
            if not suggested_tasks:
                return 0
            
            logger.info(f"提案タスク {len(suggested_tasks)} 件をスプレッドシートに追加中...")
            
            # === パート1: シート準備 ===
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            task_sheet = sheet.worksheet("pm_tasks")
            
            # 既存データを取得
            all_values = task_sheet.get_all_values()
            
            if len(all_values) < 1:
                logger.error("pm_tasksシートが空です")
                return 0
            
            # ヘッダー行を確認
            headers = all_values[0]
            logger.info(f"列ヘッダー: {headers}")
            
            # === パート2: タスクIDの決定 ===
            existing_task_ids = []
            for row in all_values[1:]:  # ヘッダーをスキップ
                if row and len(row) > 0:
                    try:
                        task_id = int(row[0])
                        existing_task_ids.append(task_id)
                    except (ValueError, IndexError):
                        continue
            
            # 次のタスクIDを決定
            if existing_task_ids:
                next_task_id = max(existing_task_ids) + 1
            else:
                next_task_id = 1
            
            logger.info(f"次のタスクID: {next_task_id}")
            
            # === パート3: タスクデータの準備 ===
            rows_to_add = []
            for task in suggested_tasks:
                row = [
                    next_task_id,  # A: task_id
                    '',  # B: parent_goal_id（空欄）
                    task.get('description', ''),  # C: task_description
                    task.get('required_role', 'dev'),  # D: required_role
                    'pending',  # E: status
                    task.get('priority', 'medium'),  # F: priority
                    task.get('estimated_time', ''),  # G: estimated_time
                    ','.join(map(str, task.get('dependencies', [parent_task_id]))),  # H: dependencies
                    datetime.now().isoformat(),  # I: created_at
                    f"Review suggested from task {parent_task_id}"  # J: notes
                ]
                rows_to_add.append(row)
                logger.info(f"追加予定タスク: ID={next_task_id}, 内容={task.get('description', '')[:50]}")
                next_task_id += 1
            
            # === パート4: データ追加処理 ===
            if rows_to_add:
                # 最終行の次の行から追加
                start_row = len(all_values) + 1
                
                # セル範囲を指定して追加
                range_notation = f'A{start_row}:J{start_row + len(rows_to_add) - 1}'
                
                logger.info(f"データを追加: {range_notation}")
                task_sheet.update(range_notation, rows_to_add)
                
                logger.info(f"✅ 提案タスク {len(rows_to_add)} 件を追加しました")
                
                # 追加されたタスクIDをログ出力
                added_ids = [row[0] for row in rows_to_add]
                logger.info(f"追加されたタスクID: {added_ids}")
            
            return len(rows_to_add)
            
        except Exception as e:
            ErrorHandler.log_error(e, "提案タスク追加")
            logger.error(f"エラー詳細: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return 0

#review_agent_prompts.py
# review_agent_prompts.py
"""レビューAIのプロンプト定義"""

REVIEW_SYSTEM_PROMPT = """あなたは経験豊富なプロジェクトレビュアーです。

【あなたの役割】
- タスクの完成度を評価する
- 出力物の品質をチェックする
- **失敗原因を特定し分類する**
- 次に必要なタスクを特定する
- 改善点や問題点を指摘する

【失敗原因の分類】
タスクが失敗した場合、以下のカテゴリで原因を特定してください：

1. **要件不明瞭** - タスクの説明が不十分、曖昧
2. **技術的問題** - 実装の難易度が高い、技術的制約
3. **リソース不足** - 必要な情報、ツール、権限が不足
4. **依存関係** - 前提タスクが未完了、必要なデータがない
5. **環境問題** - システム、ブラウザ、APIの問題
6. **タイムアウト** - 処理時間が長すぎる
7. **出力不完全** - 出力が途中で切れている、構造が不完全
8. **品質不足** - 成果物の品質が基準を満たしていない

【重要な判断基準 - 誤判断防止】
★ 以下の場合は「完了」と判断してください：
- 記事・文書が導入→本編→結論の構造になっている
- 主要なセクションが全て含まれている
- 内容的に完結している（途中で文が切れていない）
- HTML/マークダウン構造が適切に閉じられている
- 文字数が多少少なくても、内容が充実している
- 文書の最後に明確な結論やまとめがある

★ 「部分的」と判断するのは本当に明らかに未完成の場合のみ：
- 明らかに文の途中で切れている（主語だけ、動詞がないなど）
- 主要セクションが完全に欠落している
- 「続く」「後述」などの未完成を示す表現がある
- HTMLタグが閉じられていないなどの構造的問題

【評価基準】
1. 完成度: タスクが要求を満たしているか
2. 品質: 実装可能で具体的か
3. 失敗原因: なぜ失敗したのか（該当する場合）
4. 次のステップ: 何が不足しているか

【出力形式】
必ずJSON形式で出力してください：

```json
{
  "evaluation": {
    "completeness": "完了|部分的|不完全|失敗",
    "quality_score": 1-10,
    "issues": ["問題点1", "問題点2"],
    "good_points": ["良い点1", "良い点2"],
    "overall_assessment": "総合評価のサマリー（100文字程度）",
    "failure_analysis": {
      "is_failed": true|false,
      "failure_category": "要件不明瞭|技術的問題|リソース不足|依存関係|環境問題|タイムアウト|出力不完全|品質不足",
      "root_cause": "失敗の根本原因の詳細説明",
      "impact": "この失敗がプロジェクトに与える影響",
      "recommended_action": "immediate_retry|modify_task|add_prerequisite|escalate|skip",
      "prerequisites": ["前提条件1", "前提条件2"]
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "次のタスクが必要な理由",
    "suggested_tasks": [
      {
        "description": "具体的なタスク内容",
        "required_role": "design|dev|ui|review|wordpress",
        "priority": "high|medium|low",
        "reasoning": "このタスクが必要な理由",
        "dependencies": ["依存するタスクID"],
        "estimated_time": "予想時間"
      }
    ]
  }
}
【失敗時の推奨アクションの選択基準】

immediate_retry: 一時的なエラー（タイムアウト、ネットワーク）

modify_task: 要件が不明瞭、タスク内容の修正が必要

add_prerequisite: 前提タスクが不足している

escalate: 人間の判断が必要な問題

skip: このタスクは不要または後回しにすべき

【単純な判断条件】

要件定義だけで実装がない場合 → 実装タスクを提案

設計書だけでコードがない場合 → 開発タスクを提案

コードにテストがない場合 → テストタスクを提案

不完全な出力の場合 → 改善タスクを提案

十分に完成している場合 → 次のタスクは不要と判断

タスクを提案しすぎないこと。本当に必要なタスクのみを提案してください。"""

#review_agent_prompts_ACF.py
# review_agent_prompts_ACF.py
"""ACF/WordPress専用レビュープロンプト定義"""

# =============================================================================
# ACF専用レビュープロンプト
# =============================================================================

ACF_REVIEW_PROMPT = """あなたはWordPress/ACF Proの専門家レビュアーです。

【ACFコードレビューの観点】

## 1. 必須要素の確認
- [ ] `acf_add_local_field_group()` 関数が正しく使用されているか
- [ ] フィールドグループの必須キー（key, title, fields, location）が全て定義されているか
- [ ] 各フィールドに一意の `key` が設定されているか
- [ ] フィールドタイプが有効な値か（text, number, select, relationship等）

## 2. セキュリティチェック
- [ ] 出力時に `esc_html()`, `esc_attr()`, `esc_url()` などのエスケープ関数が使用されているか
- [ ] 入力値の検証に `sanitize_text_field()`, `intval()` などが使用されているか
- [ ] データベースクエリに `$wpdb->prepare()` が使用されているか
- [ ] `$_GET`, `$_POST` の直接使用時に適切なサニタイゼーションがあるか

## 3. WordPress互換性
- [ ] フック（`add_action`, `add_filter`）が適切に使用されているか
- [ ] 国際化関数（`__()`, `_e()`, `_x()`）が使用されているか
- [ ] 関数名に名前空間の衝突を防ぐプレフィックスがあるか
- [ ] `show_in_rest` が設定されているか（Gutenberg対応）

## 4. ACF固有のベストプラクティス
- [ ] フィールドグループの `location` ルールが適切に設定されているか
- [ ] 条件付きロジック（`conditional_logic`）が必要に応じて設定されているか
- [ ] フィールドの `required` 設定が適切か
- [ ] リレーションシップフィールドで `post_type` が指定されているか
- [ ] 繰り返しフィールド（`repeater`）のサブフィールドが正しく定義されているか

## 5. パフォーマンスと保守性
- [ ] 不要なフィールドやグループが含まれていないか
- [ ] フィールド取得に `get_field()` が使用され、`the_field()` が適切に使い分けられているか
- [ ] コメントが適切に記載されているか
- [ ] コードの可読性が高いか

## 6. M&A案件特有の要件（該当する場合）
- [ ] 業種、地域、価格帯などの検索用フィールドが定義されているか
- [ ] 多言語対応（Polylang）を考慮したフィールド設計か
- [ ] `meta_query` による検索フィルタリングが正しく実装されているか
- [ ] 数値フィールド（価格等）の型が `NUMERIC` に設定されているか

【評価基準】

**致命的な問題（10点満点中0-3点）**
- 必須要素の欠落
- セキュリティ脆弱性（XSS, SQLインジェクション）
- PHP構文エラー
- ACF関数の誤用

**警告レベルの問題（4-6点）**
- エスケープ関数の一部不足
- 国際化対応の欠如
- パフォーマンス上の問題
- コメント不足

**良好（7-10点）**
- すべてのチェック項目をクリア
- コードが可読性高く保守しやすい
- ベストプラクティスに完全準拠
- 拡張性を考慮した設計

【出力形式】

必ず以下のJSON形式で出力してください：

```json
{
  "evaluation": {
    "completeness": "完了|部分的|不完全",
    "quality_score": 1-10,
    "issues": [
      "問題点の詳細説明"
    ],
    "good_points": [
      "良い点の詳細説明"
    ],
    "overall_assessment": "総合評価のサマリー",
    "acf_specific_checks": {
      "field_group_structure": "OK|NG",
      "security_practices": "OK|NG",
      "wordpress_compatibility": "OK|NG",
      "performance": "OK|NG"
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "次のタスクが必要な理由",
    "suggested_tasks": [
      {
        "description": "具体的なタスク内容",
        "required_role": "dev|wordpress",
        "priority": "high|medium|low"
      }
    ]
  }
}
```

【重要な注意事項】
- ACFコードは実装可能で完全に動作する必要があります
- セキュリティは最優先事項です
- Polylang多言語対応を常に考慮してください
- M&A案件特有の要件を満たしているか確認してください
"""

# =============================================================================
# PHP構文チェック用の補助プロンプト
# =============================================================================

PHP_SYNTAX_CHECK_PROMPT = """以下のPHPコードの構文エラーをチェックしてください。

【チェック項目】
1. 括弧の対応（(), {}, []）
2. セミコロンの有無
3. 引用符の閉じ忘れ
4. 予約語の誤用
5. 関数名の重複

【PHPコード】
{php_code}

問題があれば詳細を、問題なければ "OK" と回答してください。
"""

# =============================================================================
# セキュリティチェック用の補助プロンプト
# =============================================================================

SECURITY_CHECK_PROMPT = """以下のWordPress/PHPコードのセキュリティをチェックしてください。

【重点チェック項目】
1. XSS対策（エスケープ関数の使用）
2. SQLインジェクション対策（$wpdb->prepare の使用）
3. CSRF対策（nonce の使用）
4. 入力値のサニタイゼーション
5. ファイルアップロードの検証

【コード】
{code}

セキュリティ上の問題があれば、重要度（critical/warning）と共に指摘してください。
"""

#run_multi_agent.py
# run_multi_agent.py
"""マルチエージェントシステムの統合オーケストレーター（完全修正版）"""
# ========================================
# デバッグ: TaskExecutor の確認
# ========================================
import sys
import importlib

# キャッシュクリア
if 'task_executor' in sys.modules:
    print("🔄 task_executor モジュールをリロード中...")
    importlib.reload(sys.modules['task_executor'])

from task_executor import TaskExecutor

# メソッド確認
print("\n" + "="*60)
print("🔍 TaskExecutor クラスの確認")
print("="*60)
print(f"📁 モジュール場所: {sys.modules['task_executor'].__file__}")
print("\n📋 利用可能なメソッド:")
methods = [m for m in dir(TaskExecutor) if not m.startswith('_')]
for method in methods:
    print(f"  - {method}")

if 'run_all_tasks' in methods:
    print("\n✅ run_all_tasks メソッドが見つかりました")
else:
    print("\n❌ run_all_tasks メソッドが見つかりません")
    print("\n🚨 緊急パッチを適用します...")
    
    # 緊急パッチを動的にインポート
    exec(open('task_executor.py').read())

print("="*60 + "\n")

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import asyncio
import logging
from pathlib import Path
import argparse

# ===== 最優先: ログ設定 =====
from config_utils import config, ErrorHandler, PathManager

# === パート1: エラーハンドラーのインポートと設定 ===
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        BrowserErrorHandler,
        SheetErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
    logger = logging.getLogger(__name__)
    logger.info("✅ 強化版エラーハンドラー読み込み成功")
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced.py が見つかりません（標準エラーハンドラー使用）")
    EnhancedErrorHandler = None
    BrowserErrorHandler = None

# === パート2: その他のモジュールをインポート ===
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_agent import PMAgent
from task_executor import TaskExecutor
from design_agent import DesignAgent
from dev_agent import DevAgent
from review_agent import ReviewAgent


class MultiAgentOrchestrator:
    """マルチエージェントシステムの統合オーケストレーター"""

    def __init__(self, pc_id: int = None, max_iterations: int = None):
        # === パート1: 基本パラメータの初期化 ===
        self.pc_id = pc_id or 1
        self.max_iterations = max_iterations
        
        # === パート2: コンポーネント変数の初期化 ===
        self.sheets_manager = None
        self.browser = None
        self.pm_agent = None
        self.task_executor = None
        self.design_agent = None
        self.dev_agent = None
        self.review_agent = None
        self.content_writer = None
        self.wordpress_agent = None
        self.output_folder = None
        self.initialization_success = False

    def _is_url(self, path_str: str) -> bool:
        """文字列がURLかどうかを判定"""
        # === パート1: 入力値の検証 ===
        if not path_str:
            return False
        
        # === パート2: URLパターンの判定 ===
        path_lower = path_str.lower().strip()
        return path_lower.startswith('http://') or path_lower.startswith('https://')

    async def _find_service_account_file(self) -> str:
        """サービスアカウントファイルを探す"""
        logger.info("📁 サービスアカウントファイルを検索中...")
        
        # === パート1: 検索パスの定義 ===
        possible_paths = [
            Path.cwd() / "service_account.json",
            Path.home() / "Documents" / "gemini_auto_generate" / "service_account.json",
            Path.home() / "Documents" / "AI_Agent" / "service_account.json",
            Path.home() / "Documents" / "gemini_AI_Agent" / "service_account.json",
            Path(__file__).parent / "service_account.json",
        ]
        
        # === パート2: 環境変数からのパス取得 ===
        env_path = os.environ.get('SERVICE_ACCOUNT_FILE')
        if env_path:
            possible_paths.insert(0, Path(env_path))
        
        # === パート3: バリデーション付きで検索 ===
        for path in possible_paths:
            if not path:
                continue
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                validated_path = EnhancedErrorHandler.validate_file_path(path, must_exist=True)
                if validated_path:
                    logger.info(f"✅ サービスアカウントファイル発見: {validated_path}")
                    return str(validated_path)
            else:
                if path.exists():
                    logger.info(f"✅ サービスアカウントファイル発見: {path}")
                    return str(path)
        
        # === パート4: ファイルが見つからない場合のエラー処理 ===
        raise FileNotFoundError(
            "サービスアカウントファイルが見つかりません。\n"
            "以下の場所を確認してください:\n" +
            "\n".join(f"  - {p}" for p in possible_paths if p)
        )

    async def initialize(self):
        """システムの初期化"""
        try:
            print("="*60)
            print("🚀 マルチエージェントシステム起動中...")
            print("="*60)
    
            # === パート1: サービスアカウントファイルの取得 ===
            service_account_file = await self._find_service_account_file()
        
            # === パート2: Google Sheets Managerの初期化 ===
            logger.info("📊 Google Sheets 接続を初期化中...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
    
            # === パート3: PC設定の読み込み ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} をスプレッドシートから取得")
    
            logger.info(f"⚙️ PC_ID={self.pc_id} の設定を読み込み中...")
            # ⭐ ここで settings を定義
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
        
            # === パート4: 設定の適用 ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
        
            # === パート5: 出力フォルダの設定 ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
        
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"⚠️ B14がURL形式のため、デフォルトフォルダを使用")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"📁 Agent出力先: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"📁 Agent出力先(B14から取得): {self.output_folder}")
        
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
    
            # === パート6: ブラウザの初期化(リトライ付き) ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
        
            if not browser_success:
                raise Exception("ブラウザの初期化に失敗しました")
        
            # === パート7: Geminiサイトへのナビゲーション ===
            logger.info("="*60)
            logger.info("🌐 Geminiサイトへのナビゲーション開始...")
            logger.info("="*60)
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="Geminiナビゲーション"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
    
            # === パート8: WordPress認証情報の取得 ===
            # ⭐ settings は既に定義済みなので使用可能
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
    
            # === パート9: 基本エージェントの初期化 ===
            logger.info("="*60)
            logger.info("🤖 AIエージェント初期化開始...")
            logger.info("="*60)
    
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )

            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
    
            # ReviewAgentの初期化
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)

            # エージェント登録
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
    
            logger.info("✅ 基本エージェント登録完了")
        
            # === パート10: WordPress 専用エージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("🌐 WordPress 専用エージェント初期化中...")
            logger.info("="*60)
        
            if wp_url and wp_user and wp_pass:
                # WordPress エージェントの初期化
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            
                if self.wordpress_agent:
                    logger.info("✅ WordPress エージェント初期化成功")
                else:
                    logger.warning("⚠️ WordPress エージェント初期化失敗（タスク実行に影響なし）")
            else:
                logger.info("⚠️ WordPress 認証情報が未設定です（スキップ）")
                self.wordpress_agent = None
        
            # === パート11: その他のエージェント初期化 ===
            # （content_writers, MA エージェントなど）
            # ... 既存のコードを維持 ...
        
            # === パート12: 初期化完了 ===
            logger.info("="*60)
            logger.info("✅ マルチエージェントシステム初期化完了")
            logger.info("="*60)
            logger.info(f"⚙️ 最大反復回数: {self.max_iterations}")
            logger.info(f"🆔 使用中の PC_ID: {self.pc_id}")
        
            self.initialization_success = True
        
        except Exception as e:
            logger.error("❌ システム初期化失敗")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "システム初期化")
            else:
                ErrorHandler.log_error(e, "システム初期化")
            raise

    async def validate_system_health(self) -> bool:
        """システム健全性チェック（追加）"""
        try:
            logger.info("🔍 システム健全性チェック中...")
            
            # 1. スプレッドシート接続確認
            if not self.sheets_manager or not self.sheets_manager.gc:
                logger.error("❌ Google Sheets接続が確立されていません")
                return False
            
            # 2. シート構造検証
            if not self.sheets_manager.validate_sheet_structure():
                logger.error("❌ シート構造が不正です")
                return False
            
            # 3. タスクシートの基本検証
            try:
                tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
                logger.info(f"📊 タスクシート読み込み: {len(tasks)}件")
                
                # タスクIDの重複チェック
                task_ids = [task.get('task_id') for task in tasks if task.get('task_id')]
                unique_ids = set(task_ids)
                if len(task_ids) != len(unique_ids):
                    logger.warning(f"⚠️ タスクID重複検出: {len(task_ids)} -> {len(unique_ids)}ユニーク")
                
            except Exception as e:
                logger.warning(f"⚠️ タスクシート検証エラー: {e}")
            
            logger.info("✅ システム健全性チェック完了")
            return True
            
        except Exception as e:
            logger.error(f"❌ 健全性チェックエラー: {e}")
            return False


    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """
        WordPress エージェント初期化（完全修正版）
    
        シーケンス:
        1. WordPress エージェントのインスタンス化
        2. WordPress セッション初期化（新しいタブで）
        3. タスクエグゼキュータへの登録
    
        Args:
            wp_url: WordPress サイトURL
            wp_user: ユーザー名
            wp_pass: パスワード
        
        Returns:
            WordPressAgent or None
        """
        try:
            # WordPress エージェントモジュールのインポート
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("⚠️ WordPress モジュールが見つかりません")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # 認証情報の設定
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("🌐 WordPress エージェント初期化中...")
        
            # ステップ1: インスタンス化
            wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            wordpress_agent.sheets_manager = self.sheets_manager
        
            # ステップ2: WordPress セッション初期化（新しいタブで）
            logger.info("🔐 WordPress セッション初期化中...")
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0,
                    context="WordPress セッション初期化"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # ステップ3: 初期化結果の処理
            if wp_login_success:
                # タスクエグゼキュータに登録
                self.task_executor.register_agent('wordpress', wordpress_agent)
                logger.info("✅ WordPress エージェント登録完了")
            
                # クッキー保存状態をログ出力
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file and wp_cookies_file.exists():
                    logger.info(f"🍪 WordPress クッキー: {wp_cookies_file}")
                else:
                    logger.info("🍪 WordPress クッキー: 新規作成済み")
            
                return wordpress_agent
            else:
                logger.error("❌ WordPress セッション初期化失敗")
                return None
            
        except Exception as e:
            logger.error(f"WordPress エージェント初期化エラー: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress 初期化")
            return None

    def _print_browser_troubleshooting(self):
        """ブラウザトラブルシューティングガイド"""
        # === パート1: トラブルシューティング情報の表示 ===
        logger.error("\n📋 トラブルシューティング:")
        logger.error("1. ✅ 既存のChromeプロセスを全て終了")
        logger.error("2. 📁 ブラウザデータディレクトリの権限確認")
        logger.error(f"     → {config.BROWSER_DATA_DIR}")
        logger.error("3. 🔧 Playwrightの再インストール:")
        logger.error("     → playwright install chromium")
        logger.error("4. 🗑️ ブラウザキャッシュのクリア:")
        logger.error(f"     → {config.BROWSER_DATA_DIR} を削除")
        logger.error("5. 🔄 システムの再起動")

    # === 修正開始: MultiAgentOrchestratorのWordPress初期化を強化 ===

    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """WordPressエージェント初期化（クッキー管理対応版）"""
        try:
            # インポートチェック
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("⚠️ WordPressモジュールが見つかりません")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # 認証情報の設定
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("🌐 WordPressエージェント初期化中...")
            self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            self.wordpress_agent.sheets_manager = self.sheets_manager
        
            # WordPressセッション初期化（クッキー優先）
            logger.info("🔐 WordPressセッション初期化中...")
        
            # タイムアウト付き初期化
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0,  # 90秒に延長
                    context="WordPressセッション初期化"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # 初期化結果の処理
            if wp_login_success:
                self.task_executor.register_agent('wordpress', self.wordpress_agent)
                logger.info("✅ WordPressエージェント登録完了")
            
                # クッキー保存状態をログ出力
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file.exists():
                    logger.info(f"📁 WordPressクッキー: {wp_cookies_file}")
                else:
                    logger.info("📁 WordPressクッキー: 新規作成済み")
                
                return self.wordpress_agent
            else:
                logger.error("❌ WordPressセッション初期化失敗")
                return None
            
        except Exception as e:
            logger.error(f"WordPressエージェント初期化エラー: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress初期化")
            return None


    async def initialize(self):
        """システムの初期化"""
        try:
            print("="*60)
            print("🚀 マルチエージェントシステム起動中...")
            print("="*60)
        
            # === パート1: サービスアカウントファイルの取得 ===
            service_account_file = await self._find_service_account_file()
            
            # === パート2: Google Sheets Managerの初期化 ===
            logger.info("📊 Google Sheets 接続を初期化中...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
            health_ok = await self.validate_system_health()
            if not health_ok:
                logger.warning("⚠️ システム健全性チェックで警告が検出されました")
        
            # === パート3: PC設定の読み込み ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} をスプレッドシートから取得")
        
            logger.info(f"⚙️ PC_ID={self.pc_id} の設定を読み込み中...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            
            # === パート4: 設定の適用 ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            # === パート5: 出力フォルダの設定 ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
            
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"⚠️ B14がURL形式のため、デフォルトフォルダを使用")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"📁 Agent出力先: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"📁 Agent出力先(B14から取得): {self.output_folder}")
            
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
            
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
        
            # === パート6: ブラウザの初期化（リトライ付き） ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
            
            if not browser_success:
                raise Exception("ブラウザの初期化に失敗しました")
            
            # === パート7: Geminiサイトへのナビゲーション ===
            logger.info("="*60)
            logger.info("🌐 Geminiサイトへのナビゲーション開始...")
            logger.info("="*60)
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="Geminiナビゲーション"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
        
            # === パート8: WordPress認証情報の取得 ===
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
        
            # === パート9: 基本エージェントの初期化 ===
            logger.info("="*60)
            logger.info("🤖 AIエージェント初期化開始...")
            logger.info("="*60)
        
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )
    
            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
        
            # ReviewAgentの初期化
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)
    
            # エージェント登録
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
        
            logger.info("✅ 基本エージェント登録完了")

            # === パート10: WordPress専用エージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("🌐 WordPress専用エージェントを初期化中...")
            logger.info("="*60)
            
            # WordPress認証情報の取得
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
            
            # === WordPress設計AIエージェント (wp_design) ===
            try:
                from wordpress.wp_design import WordPressDesignAgent
                wp_design_agent = WordPressDesignAgent(
                    self.browser, 
                    output_folder=self.output_folder
                )
                wp_design_agent.sheets_manager = self.sheets_manager
                self.task_executor.register_agent('wp_design', wp_design_agent)
                logger.info("✅ WordPress設計AIエージェント登録完了")
            except ImportError:
                logger.warning("⚠️ wordpress/wp_design.py が見つかりません")
            except Exception as e:
                logger.warning(f"⚠️ WordPress設計AIエージェント登録失敗: {e}")
            
            # === WordPress開発AIエージェント (wp_dev) ===
            try:
                from wordpress.wp_dev import WordPressDevAgent
                
                # WordPressDevAgent のインスタンス化
                wp_dev_agent = WordPressDevAgent(
                    self.browser,
                    wp_credentials=wp_credentials,
                    output_folder=self.output_folder
                )
                wp_dev_agent.sheets_manager = self.sheets_manager
                
                # タスクエグゼキューターに登録
                self.task_executor.register_agent('wp_dev', wp_dev_agent)
                logger.info("✅ WordPress開発AIエージェント(wp_dev)登録完了")
                
                # 標準 dev エージェントのバックアップ登録も維持
                if self.dev_agent:
                    # 既存の dev エージェントは維持（要件定義用）
                    logger.info("✅ 標準 dev エージェントも維持（要件定義タスク用）")
                
            except ImportError:
                logger.warning("⚠️ wordpress/wp_dev.py が見つかりません")
                logger.info("💡 WordPress開発タスクは標準 dev エージェントで処理されます")
                
                # フォールバック: 標準 dev エージェントを wp_dev としても登録
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("🔄 標準 dev エージェントを wp_dev としても登録しました")
                    
            except Exception as e:
                logger.warning(f"⚠️ WordPress開発AIエージェント初期化失敗: {e}")
                
                # エラー時のフォールバック
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("🔄 エラーのため標準 dev エージェントで代替")


            # === パート11: M&A専用エージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("📊 M&A専用エージェントを初期化中...")
            logger.info("="*60)
            
            try:
                from task_executor_ma import MATaskExecutor
                ma_task_executor = MATaskExecutor(self.task_executor.agents)
                self.task_executor.register_agent('ma', ma_task_executor)
                self.task_executor.register_agent('wordpress_ma', ma_task_executor)
                
                # ⭐ 重要: dev エージェントを wp_dev としても登録（バックアップ）
                # wp_dev 専用エージェントが登録されていない場合のフォールバック
                if 'wp_dev' not in self.task_executor.agents and self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("✅ dev エージェントを wp_dev フォールバックとして登録")
                
                logger.info("✅ M&A専用タスク実行エージェント登録完了")
            except ImportError:
                logger.warning("⚠️ task_executor_ma.py が見つかりません")
            except Exception as e:
                logger.warning(f"⚠️ M&A専用エージェント登録失敗: {e}")
            
            # === パート12: 多言語ライターエージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("多言語ライターエージェントを初期化中...")
            logger.info("="*60)
            
            try:
                from content_writers import (
                    JapaneseWriterAgent,
                    EnglishWriterAgent,
                    RussianWriterAgent,
                    UzbekWriterAgent,
                    ChineseWriterAgent,
                    KoreanWriterAgent,
                    TurkishWriterAgent
                )
                
                # 日本語ライター
                ja_writer = JapaneseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ja', ja_writer)
                logger.info("✅ 日本語ライターエージェント登録完了")
                
                # 英語ライター
                en_writer = EnglishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_en', en_writer)
                logger.info("✅ 英語ライターエージェント登録完了")
                
                # ロシア語ライター
                ru_writer = RussianWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ru', ru_writer)
                logger.info("✅ ロシア語ライターエージェント登録完了")
                
                # ウズベク語ライター
                uz_writer = UzbekWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_uz', uz_writer)
                logger.info("✅ ウズベク語ライターエージェント登録完了")
                
                # 中国語ライター
                zh_writer = ChineseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_zh', zh_writer)
                logger.info("✅ 中国語ライターエージェント登録完了")
                
                # 韓国語ライター
                ko_writer = KoreanWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ko', ko_writer)
                logger.info("✅ 韓国語ライターエージェント登録完了")
                
                # トルコ語ライター
                tr_writer = TurkishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_tr', tr_writer)
                logger.info("✅ トルコ語ライターエージェント登録完了")
                
            except Exception as e:
                logger.warning(f"⚠️ コンテンツライターエージェント登録失敗: {e}")
            
            # === パート13: WordPress投稿管理エージェントの初期化 ===
            if wp_url and wp_user and wp_pass:
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            else:
                logger.info("⚠️ WordPress認証情報が未設定です(スキップ)")
                self.wordpress_agent = None
        
            # === パート14: 初期化完了の確認 ===
            logger.info("="*60)
            logger.info("✅ マルチエージェントシステム初期化完了")
            logger.info("="*60)
            logger.info(f"⚙️ 最大反復回数: {self.max_iterations}")
            logger.info(f"🆔 使用中のPC_ID: {self.pc_id}")
            
            self.initialization_success = True
        
        except Exception as e:
            logger.error("❌ システム初期化失敗")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "システム初期化")
            else:
                ErrorHandler.log_error(e, "システム初期化")
            raise

    async def run_full_workflow(self, goal: str = None, auto_continue: bool = False, enable_review: bool = True):
        """完全なワークフローを実行"""
        # === パート1: 初期化状態の確認 ===
        if not self.initialization_success:
            raise Exception("システムが初期化されていません")
        
        try:
            # === パート2: PM AIによるタスク分解フェーズ ===
            print("\n" + "="*60)
            print("📋 フェーズ1: PM AIによるタスク分解")
            print("="*60)
            
            if goal:
                goal_description = goal
                logger.info(f"🎯 指定された目標: {goal_description}")
            else:
                goal_data = await self.pm_agent.load_project_goal()
                if not goal_data:
                    print("\n❌ エラー: 目標が見つかりません")
                    print("--goal オプションで目標を指定するか、")
                    print("スプレッドシートの'project_goal'シートに目標を設定してください")
                    return
                goal_description = goal_data['description']
            
            task_plan = await self.pm_agent.analyze_and_create_tasks(goal_description)
            self.pm_agent.display_task_summary(task_plan)
            
            # === パート3: タスク保存の確認 ===
            if not auto_continue:
                save = input("\n💾 タスクをスプレッドシートに保存しますか? (y/n): ")
                if save.lower() != 'y':
                    print("⏸️ 実行をキャンセルしました")
                    return
            
            await self.pm_agent.save_tasks_to_sheet(task_plan)
            
            # === パート4: タスク実行フェーズ ===
            print("\n" + "="*60)
            print("⚙️ フェーズ2: タスクの実行")
            print("="*60)
            
            if enable_review:
                print("✅ レビューAI: 有効")
            else:
                print("⏭️ レビューAI: 無効")
            
            if not auto_continue:
                execute = input("\n▶️ タスクの実行を開始しますか? (y/n): ")
                if execute.lower() != 'y':
                    print("⏸️ タスク実行をスキップしました")
                    return
            
            # === パート5: タスク実行の実行 ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === パート6: 完了メッセージの表示 ===
            print("\n" + "="*60)
            print("🎉 ワークフロー完了")
            print("="*60)
            print(f"📁 出力フォルダ: {self.output_folder}")
            print("📊 スプレッドシートで結果を確認してください")
            
        except Exception as e:
            logger.error("ワークフロー実行エラー")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ワークフロー実行")
            else:
                ErrorHandler.log_error(e, "ワークフロー実行")
            raise

    async def run_tasks_only(self, auto_continue: bool = False, enable_review: bool = True):
        """既存のタスクのみを実行"""
        # === パート1: 初期化状態の確認 ===
        if not self.initialization_success:
            raise Exception("システムが初期化されていません")
        
        try:
            # === パート2: 実行開始の表示 ===
            print("\n" + "="*60)
            print("⚙️ 既存タスクの実行")
            print("="*60)
            
            if enable_review:
                print("✅ レビューAI: 有効")
            else:
                print("⏭️ レビューAI: 無効")
            
            # === パート3: タスク実行の実行 ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === パート4: 完了メッセージの表示 ===
            print("\n" + "="*60)
            print("🎉 タスク実行完了")
            print("="*60)
            
        except Exception as e:
            logger.error("タスク実行エラー")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "タスク実行")
            else:
                ErrorHandler.log_error(e, "タスク実行")
            raise

    async def cleanup(self):
        """リソースのクリーンアップ（強化版）"""
        logger.info("🧹 クリーンアップ開始...")
        
        cleanup_tasks = []
        
        # ブラウザのクリーンアップ
        if self.browser:
            cleanup_tasks.append(self._safe_cleanup_browser())
        
        # WordPressエージェントのクリーンアップ
        if self.wordpress_agent:
            cleanup_tasks.append(self._safe_cleanup_wordpress())
        
        # その他のエージェントのクリーンアップ
        if hasattr(self, 'dev_agent') and self.dev_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.dev_agent, "dev_agent"))
        
        if hasattr(self, 'design_agent') and self.design_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.design_agent, "design_agent"))
        
        # 並行してクリーンアップ実行
        if cleanup_tasks:
            await asyncio.gather(*cleanup_tasks, return_exceptions=True)
        
        logger.info("✅ 全リソースクリーンアップ完了")

    async def _safe_cleanup_browser(self):
        """安全なブラウザクリーンアップ"""
        try:
            if self.browser:
                await self.browser.cleanup()
                logger.info("✅ ブラウザクリーンアップ完了")
        except Exception as e:
            logger.warning(f"⚠️ ブラウザクリーンアップ失敗: {e}")

    async def _safe_cleanup_wordpress(self):
        """安全なWordPressエージェントクリーンアップ"""
        try:
            if self.wordpress_agent and hasattr(self.wordpress_agent, 'cleanup'):
                await self.wordpress_agent.cleanup()
                logger.info("✅ WordPressエージェントクリーンアップ完了")
        except Exception as e:
            logger.warning(f"⚠️ WordPressエージェントクリーンアップ失敗: {e}")

    async def _safe_cleanup_agent(self, agent, agent_name: str):
        """安全なエージェントクリーンアップ"""
        try:
            if agent and hasattr(agent, 'cleanup'):
                await agent.cleanup()
                logger.info(f"✅ {agent_name} クリーンアップ完了")
        except Exception as e:
            logger.warning(f"⚠️ {agent_name} クリーンアップ失敗: {e}")


async def main():
    """メイン実行関数"""
    # === パート1: コマンドライン引数の解析 ===
    parser = argparse.ArgumentParser(description='マルチエージェントシステム')
    parser.add_argument('--goal', type=str, help='プロジェクト目標を直接指定')
    parser.add_argument('--tasks-only', action='store_true', help='既存タスクのみ実行(PM AIスキップ)')
    parser.add_argument('--auto', action='store_true', help='自動実行(確認なし)')
    parser.add_argument('--no-review', action='store_true', help='レビュー機能を無効化')
    parser.add_argument('--max-iterations', type=int, default=3, help='最大反復回数(デフォルト: 3)')
    parser.add_argument('--pc-id', type=int, help='PC_IDを指定')
    
    args = parser.parse_args()
    
    # === パート2: オーケストレーターの初期化 ===
    orchestrator = MultiAgentOrchestrator(
        pc_id=args.pc_id,
        max_iterations=args.max_iterations
    )
    
    try:
        # === パート3: システム初期化 ===
        await orchestrator.initialize()
        
        # === パート4: ワークフローの実行 ===
        if args.tasks_only:
            await orchestrator.run_tasks_only(
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        else:
            await orchestrator.run_full_workflow(
                goal=args.goal,
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        
    except KeyboardInterrupt:
        # === パート5: ユーザー中断の処理 ===
        logger.warning("\n⏸️ ユーザーによる中断")
    except Exception as e:
        # === パート6: エラー処理 ===
        logger.error(f"❌ 致命的エラー: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        # === パート7: クリーンアップ ===
        await orchestrator.cleanup()
        logger.info("\n👋 マルチエージェントシステムを終了しました")


if __name__ == "__main__":
    asyncio.run(main())

#sheets_manager.py
# sheets_manager.py
"""Google Sheets管理クラス(拡張版: Google Drive対応)"""
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from google.auth import default
from google.auth.transport.requests import Request
from pathlib import Path
from typing import List, Dict, Optional
import logging
import re

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class GoogleSheetsManager:
    """Google Sheets管理クラス(拡張版: Google Drive対応)"""
    
    # Google API スコープの定義
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]
    
    def __init__(self, spreadsheet_id: str, service_account_file: Optional[str] = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.gc: Optional[gspread.Client] = None
        self.drive_service = None  # Google Drive API用
        self.setup_client()
    
    def setup_client(self) -> None:
        """Google Sheets クライアントの設定"""
        try:
            # === パート1: サービスアカウント認証の試行 ===
            logger.info("🔐 Google Sheetsクライアント設定中...")
            
            if self.service_account_file and Path(self.service_account_file).exists():
                # サービスアカウント認証
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.service_account_file, self.GOOGLE_SHEETS_SCOPE)
                self.gc = gspread.authorize(creds)
                
                # Google Drive API用のサービスも初期化
                self._setup_drive_service(creds)
                
                logger.info("✅ サービスアカウントで Google Sheets に接続しました")
            else:
                # === パート2: デフォルト認証へのフォールバック ===
                logger.info("🔄 サービスアカウントなし、デフォルト認証を試行...")
                
                try:
                    creds, project = default(scopes=self.GOOGLE_SHEETS_SCOPE)
                    if creds.expired and creds.refresh_token:
                        creds.refresh(Request())
                    self.gc = gspread.authorize(creds)
                    
                    # Google Drive API用
                    self._setup_drive_service(creds)
                    
                    logger.info("✅ デフォルト認証で Google Sheets に接続しました")
                except Exception as e:
                    logger.warning(f"⚠️ デフォルト認証に失敗しました: {e}")
                    logger.warning("サービスアカウントファイルが必要です")
                    self.gc = None
                    
        except Exception as e:
            ErrorHandler.log_error(e, "Google Sheets クライアント設定")
            self.gc = None
    
    def _setup_drive_service(self, creds):
        """Google Drive APIサービスを初期化"""
        try:
            from googleapiclient.discovery import build
            self.drive_service = build('drive', 'v3', credentials=creds)
            logger.info("✅ Google Drive APIサービスを初期化しました")
        except Exception as e:
            logger.warning(f"⚠️ Google Drive APIサービスの初期化に失敗: {e}")
            self.drive_service = None
    
    def _ensure_client(self) -> None:
        """クライアントが初期化されているか確認"""
        if not self.gc:
            raise Exception("Google Sheets クライアントが初期化されていません。サービスアカウントファイルを設定してください。")
    
    async def update_task_status(self, task_id: int, status: str, sheet_name: str = "pm_tasks") -> bool:
        """
        タスクのステータスを更新（ロバスト性向上版 + 超詳細ログ）
        
        Args:
            task_id: タスクID
            status: 新しいステータス
            sheet_name: シート名
            
        Returns:
            bool: 更新成功フラグ
        """
        try:
            logger.info("=" * 70)
            logger.info(f"🔄 ステータス更新処理開始")
            logger.info(f"   タスクID: {task_id}")
            logger.info(f"   新ステータス: {status}")
            logger.info(f"   対象シート: {sheet_name}")
            logger.info("=" * 70)
            
            # === パート1: クライアントとシートの準備 ===
            logger.info("📋 [ステップ1] Google Sheets クライアント確認中...")
            self._ensure_client()
            logger.info("✅ クライアント確認完了")
            
            logger.info(f"📋 [ステップ2] スプレッドシート接続中 (ID: {self.spreadsheet_id[:20]}...)")
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            logger.info("✅ スプレッドシート接続成功")
            
            logger.info(f"📋 [ステップ3] シート '{sheet_name}' を開いています...")
            task_sheet = sheet.worksheet(sheet_name)
            logger.info("✅ シートを開きました")
            
            # 全データを取得
            logger.info("📋 [ステップ4] シートデータ取得中...")
            all_data = task_sheet.get_all_values()
            logger.info(f"✅ データ取得完了: {len(all_data)}行")
            
            if len(all_data) <= 1:
                logger.warning(f"⚠️ タスクシート '{sheet_name}' にデータがありません（ヘッダーのみ）")
                return False
            
            # === パート2: ヘッダー解析と列インデックスの特定 ===
            logger.info("📋 [ステップ5] ヘッダー解析中...")
            headers = all_data[0]
            logger.info(f"   ヘッダー内容: {headers}")
            
            task_id_col = None
            status_col = None
            
            for i, header in enumerate(headers):
                header_lower = header.lower().strip()
                logger.debug(f"   列{i+1}: '{header}' (小文字: '{header_lower}')")
                
                if 'task_id' in header_lower or header_lower == 'id':
                    task_id_col = i
                    logger.info(f"✅ タスクID列を検出: 列{i+1} ('{header}')")
                elif 'status' in header_lower:
                    status_col = i
                    logger.info(f"✅ ステータス列を検出: 列{i+1} ('{header}')")
            
            # タスクID列が見つからない場合のフォールバック
            if task_id_col is None:
                task_id_col = 0
                logger.warning(f"⚠️ タスクID列が見つかりません。デフォルトで列1を使用します")
            
            # ステータス列が見つからない場合は追加
            if status_col is None:
                status_col = len(headers)
                logger.warning(f"⚠️ ステータス列が見つかりません。新規追加します: 列{status_col + 1}")
                try:
                    task_sheet.update_cell(1, status_col + 1, 'status')
                    logger.info(f"✅ ステータス列を追加しました")
                except Exception as e:
                    logger.error(f"❌ ステータス列追加エラー: {e}")
                    return False
            
            # === パート3: 強化版タスク検索 ===
            logger.info(f"📋 [ステップ6] タスクID '{task_id}' を検索中...")
            logger.info(f"   検索対象列: 列{task_id_col + 1}")
            logger.info(f"   検索対象行数: {len(all_data) - 1}行（ヘッダー除く）")
            
            task_id_str = str(task_id).strip()
            task_found = False
            row_index = None
            
            # 詳細な検索実行
            available_ids = []
            for row_idx, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    
                    logger.debug(f"   行{row_idx}: ID='{cell_value}' (比較対象: '{task_id_str}')")
                    
                    if cell_value == task_id_str:
                        row_index = row_idx
                        task_found = True
                        logger.info(f"✅ タスクを発見: 行{row_idx}")
                        break
            
            if not task_found:
                # 詳細なデバッグ情報を出力
                logger.error(f"❌ タスクID '{task_id_str}' が見つかりません")
                logger.error(f"")
                logger.error(f"🔍 検索詳細:")
                logger.error(f"   検索したID: '{task_id_str}' (型: {type(task_id).__name__})")
                logger.error(f"   検索した列: 列{task_id_col + 1}")
                logger.error(f"   総タスク数: {len(all_data) - 1}")
                logger.error(f"")
                logger.error(f"📋 シート内の利用可能なタスクID:")
                for i, aid in enumerate(available_ids[:10], 1):
                    logger.error(f"   {i}. '{aid}'")
                if len(available_ids) > 10:
                    logger.error(f"   ... 他 {len(available_ids) - 10}件")
                logger.error(f"")
                logger.error(f"💡 確認事項:")
                logger.error(f"   1. タスクID '{task_id}' が pm_tasks シートに存在するか？")
                logger.error(f"   2. タスクIDの列が正しいか？（現在: 列{task_id_col + 1}）")
                logger.error(f"   3. タスクIDに余分な空白や特殊文字が含まれていないか？")
                
                return False
            
            # === パート4: ステータス更新 ===
            logger.info(f"📋 [ステップ7] ステータス更新実行中...")
            logger.info(f"   対象セル: 行{row_index}, 列{status_col + 1}")
            logger.info(f"   新しい値: '{status}'")
            
            try:
                # Google Sheets API でセルを更新
                task_sheet.update_cell(row_index, status_col + 1, status)
                logger.info(f"✅ API呼び出し成功")
                
                # 更新後の検証（オプション）
                import time
                time.sleep(0.5)  # API反映待ち
                
                updated_value = task_sheet.cell(row_index, status_col + 1).value
                logger.info(f"🔍 更新後の値: '{updated_value}'")
                
                if updated_value == status:
                    logger.info(f"✅ ステータス更新確認完了")
                    logger.info("=" * 70)
                    logger.info(f"🎉 タスク {task_id} のステータスを '{status}' に更新しました（行 {row_index}）")
                    logger.info("=" * 70)
                    return True
                else:
                    logger.warning(f"⚠️ 更新値が一致しません: 期待='{status}', 実際='{updated_value}'")
                    return False
                    
            except Exception as api_error:
                logger.error(f"❌ Google Sheets API エラー: {api_error}")
                logger.error(f"")
                logger.error(f"💡 考えられる原因:")
                logger.error(f"   1. サービスアカウントの権限不足")
                logger.error(f"   2. スプレッドシートが編集ロックされている")
                logger.error(f"   3. APIクォータ超過")
                logger.error(f"   4. ネットワーク接続の問題")
                import traceback
                logger.error(traceback.format_exc())
                return False
            
        except Exception as e:
            logger.error(f"❌ タスクステータス更新エラー: {e}")
            logger.error(f"")
            logger.error(f"🔧 エラーコンテキスト:")
            logger.error(f"   タスクID: {task_id}")
            logger.error(f"   ステータス: {status}")
            logger.error(f"   シート: {sheet_name}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def find_available_task_id(self) -> Optional[str]:
        """利用可能なタスクIDを検索（ログ削減版）"""
        try:
            # ログレベルを一時的にERRORに
            original_level = logger.level
            logger.setLevel(logging.ERROR)
            
            # タスクID検索
            task_ids = await self._search_task_ids()
            
            # ログレベルを戻す
            logger.setLevel(original_level)
            
            if task_ids:
                logger.info(f"✅ 利用可能タスク: {len(task_ids)}件")
                return task_ids[0]
            else:
                logger.warning("⚠️ 利用可能タスクなし")
                return None
        
        except Exception as e:
            logger.setLevel(original_level)
            logger.error(f"❌ タスクID検索エラー: {e}")
            return None
    
    async def _search_task_ids(self) -> List[str]:
        """内部検索（ログなし）"""
        try:
            # 既存の検索ロジック
            all_values = self.ws.get_all_values()
            
            # フィルタリング
            valid_ids = []
            for row in all_values[1:]:  # ヘッダー除外
                if len(row) >= 11:
                    task_id = row[0]
                    status = row[10]
                    
                    if task_id and task_id not in ['エージェント未登録', 'Review suggested']:
                        if status in ['pending', 'in_progress', '']:
                            valid_ids.append(task_id)
            
            return valid_ids
        
        except Exception as e:
            return []

    async def load_tasks_from_sheet(self, sheet_name: str = "pm_tasks") -> List[Dict]:
        """指定されたシートからタスクを読み込む（エラー修正版）"""
        try:
            # === パート1: シート接続と基本設定 ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            try:
                task_sheet = sheet.worksheet(sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.error(f"❌ シート '{sheet_name}' が見つかりません")
                return []
        
            # === パート2: データ取得方法の試行（複数方式） ===
            logger.info(f"📥 シート '{sheet_name}' からデータ取得中...")
            
            try:
                # 方法1: get_all_records() を試す
                records = task_sheet.get_all_records()
                logger.info(f"✅ get_all_records() でデータ取得成功: {len(records)}行")
            except Exception as e:
                logger.warning(f"⚠️ get_all_records() 失敗: {e}")
                logger.info("🔧 代替方法でデータを取得します...")
                
                # 方法2: 生データを取得して手動で処理
                all_values = task_sheet.get_all_values()
                
                if len(all_values) <= 1:
                    logger.info("📭 データ行がありません")
                    return []
                
                # ヘッダー行を取得
                headers = all_values[0]
                logger.info(f"📋 ヘッダー: {headers}")
                
                # データ行を処理
                records = []
                for i, row in enumerate(all_values[1:], start=2):
                    if not any(row):  # 空行をスキップ
                        continue
                    
                    record = {}
                    for j, header in enumerate(headers):
                        if j < len(row) and header:  # ヘッダーが空でない場合のみ
                            record[header] = row[j]
                        elif j < len(row):
                            record[f'column_{j+1}'] = row[j]  # 空ヘッダーの場合
                    
                    records.append(record)
                
                logger.info(f"✅ 代替方法でデータ取得成功: {len(records)}行")
        
            # === パート3: レコードからタスクオブジェクトへの変換 ===
            tasks = []
            for i, record in enumerate(records, start=2):
                # タスクIDの処理を改善
                task_id = str(record.get('task_id', '')).strip()
                if not task_id and 'task_id' not in record:
                    # 最初の列をタスクIDとして使用
                    first_col = list(record.values())[0] if record else ''
                    task_id = str(first_col).strip()
                
                task = {
                    'task_id': task_id,
                    'description': record.get('task_description', record.get('description', '')),
                    'required_role': record.get('required_role', ''),
                    'status': record.get('status', ''),
                    'priority': record.get('priority', 'medium'),
                    'estimated_time': record.get('estimated_time', ''),
                    'dependencies': record.get('dependencies', ''),
                    'created_at': record.get('created_at', ''),
                    'batch_id': record.get('batch_id', ''),
                    'review_target_task_id': record.get('review_target_task_id', ''),
                    'post_action': record.get('post_action', ''),
                    'language': record.get('language', ''),
                    'polylang_lang': record.get('polylang_lang', '')
                }
                
                # 基本的な検証
                if task['description'] and task['required_role']:
                    tasks.append(task)
        
            logger.info(f"📊 タスク読み込み: {len(tasks)}件（シート: {sheet_name}）")
            
            # === パート4: デバッグ情報と結果返却 ===
            # デバッグ情報
            if tasks:
                logger.info(f"📝 最初のタスク: {tasks[0].get('description', '')[:50]}...")
            else:
                logger.info("📭 読み込まれたタスクは0件です")
                
            return tasks
        
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー（シート: {sheet_name}）: {e}")
            return []

    async def save_task_output(self, output_data: Dict):
        """タスクの出力を保存"""
        try:
            # === パート1: クライアントとシートの準備 ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            # === パート2: 出力シートの存在確認と作成 ===
            # 出力シートが存在するか確認
            try:
                output_sheet = sheet.worksheet("task_outputs")
            except gspread.exceptions.WorksheetNotFound:
                # シートが存在しない場合は作成
                logger.info("'task_outputs' シートを作成します")
                output_sheet = sheet.add_worksheet(title="task_outputs", rows=1000, cols=10)
                # ヘッダーを設定
                headers = ["task_id", "summary", "full_text", "screenshot", "timestamp"]
                output_sheet.append_row(headers)
        
            # === パート3: データの保存 ===
            # データを追加
            row = [
                output_data.get('task_id', ''),
                output_data.get('summary', ''),
                output_data.get('full_text', ''),
                output_data.get('screenshot', ''),
                output_data.get('timestamp', '')
            ]
            output_sheet.append_row(row)
        
            logger.info(f"✅ タスク出力を保存: {output_data.get('task_id', '')}")
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "タスク出力保存")
            return False
    
    def save_result_to_sheet(self, results: List[Dict], mode: str = "text") -> None:
        """
        結果をスプレッドシートに保存
        
        Args:
            results: 結果のリスト
            mode: "text" または "image"
        """
        try:
            # === パート1: クライアントとシート名の準備 ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            # 結果シート名を決定
            result_sheet_name = f"result_{mode}"
            
            # === パート2: シートの存在確認と作成 ===
            # シートが存在しない場合は作成
            try:
                result_sheet = sheet.worksheet(result_sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.info(f"シート '{result_sheet_name}' を作成します")
                result_sheet = sheet.add_worksheet(title=result_sheet_name, rows=1000, cols=10)
                
                # ヘッダーを設定
                headers = ['Index', 'Prompt', 'Status', 'Filename', 'Timestamp', 'Error', 'Mode']
                result_sheet.append_row(headers)
            
            # === パート3: 結果データの保存 ===
            # 結果を追加
            for result in results:
                row = [
                    result.get('index', ''),
                    result.get('prompt', '')[:100],  # プロンプトは最初の100文字
                    result.get('status', ''),
                    result.get('filename', ''),
                    result.get('timestamp', ''),
                    result.get('error', ''),
                    result.get('mode', mode)
                ]
                result_sheet.append_row(row)
            
            logger.info(f"✅ {len(results)}件の結果を '{result_sheet_name}' に保存しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "結果保存")
            logger.warning("結果の保存に失敗しましたが、処理を続行します")
    
    def extract_file_id_from_url(self, url: str) -> Optional[str]:
        """
        Google DriveのURLからファイルIDを抽出
        
        対応形式:
        - https://drive.google.com/file/d/FILE_ID/view
        - https://drive.google.com/open?id=FILE_ID
        - https://docs.google.com/document/d/FILE_ID/edit
        """
        # === パート1: 正規表現パターンの定義 ===
        patterns = [
            r'/file/d/([a-zA-Z0-9_-]+)',
            r'id=([a-zA-Z0-9_-]+)',
            r'/d/([a-zA-Z0-9_-]+)',
        ]
        
        # === パート2: パターンマッチングの実行 ===
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                file_id = match.group(1)
                logger.info(f"✅ ファイルIDを抽出: {file_id}")
                return file_id
        
        logger.warning(f"⚠️ URLからファイルIDを抽出できませんでした: {url}")
        return None
    
    def read_file_from_drive(self, file_id_or_url: str) -> Optional[str]:
        """
        Google Driveからファイルをダウンロードして読み込む（超詳細ログ版）
        
        Args:
            file_id_or_url: ファイルID または Google DriveのURL
            
        Returns:
            ファイルの内容（テキスト）、失敗時はNone
        """
        try:
            logger.info("="*60)
            logger.info("【Google Drive読み込み開始】")
            logger.info("="*60)
            
            # === パート1: Drive APIサービスの確認 ===
            logger.info("【切り分け1】Drive APIサービスを確認")
            if not self.drive_service:
                logger.error("❌ Google Drive APIサービスが初期化されていません")
                logger.error("  → サービスアカウント認証を確認してください")
                return None
            logger.info("✅ Drive APIサービス: 正常")
            
            # === パート2: 入力値の解析とファイルIDの抽出 ===
            logger.info("【切り分け2】入力値を解析")
            logger.info(f"  入力: {file_id_or_url[:100]}")
            
            if file_id_or_url.startswith('http'):
                logger.info("  → URL形式と判定")
                file_id = self.extract_file_id_from_url(file_id_or_url)
                if not file_id:
                    logger.error("❌ URLからファイルIDを抽出できませんでした")
                    return None
                logger.info(f"✅ ファイルID抽出成功: {file_id}")
            else:
                file_id = file_id_or_url
                logger.info(f"  → ファイルID形式: {file_id}")
            
            # === パート3: ファイルメタデータの取得 ===
            logger.info("【切り分け3】ファイルメタデータを取得")
            try:
                from googleapiclient.http import MediaIoBaseDownload
                import io
                
                file_metadata = self.drive_service.files().get(
                    fileId=file_id, 
                    fields='name,mimeType,size,permissions'
                ).execute()
                
                file_name = file_metadata.get('name', 'Unknown')
                mime_type = file_metadata.get('mimeType', '')
                file_size = file_metadata.get('size', '0')
                
                logger.info("✅ ファイルメタデータ取得成功")
                logger.info(f"  ファイル名: {file_name}")
                logger.info(f"  MIME Type: {mime_type}")
                logger.info(f"  サイズ: {file_size} bytes")
                
            except Exception as e:
                logger.error(f"❌ ファイルメタデータ取得エラー: {e}")
                logger.error("  考えられる原因:")
                logger.error("  - ファイルIDが間違っている")
                logger.error("  - サービスアカウントに権限がない")
                logger.error("  - ファイルが削除されている")
                return None
            
            # === パート4: ファイルのダウンロード ===
            logger.info("【切り分け4】ファイルをダウンロード")
            try:
                request = self.drive_service.files().get_media(fileId=file_id)
                
                fh = io.BytesIO()
                downloader = MediaIoBaseDownload(fh, request)
                
                done = False
                chunk_count = 0
                while not done:
                    status, done = downloader.next_chunk()
                    chunk_count += 1
                    if status:
                        progress = int(status.progress() * 100)
                        logger.debug(f"  ⏳ チャンク{chunk_count}: {progress}%")
                
                logger.info(f"✅ ダウンロード完了: {chunk_count}チャンク")
                
            except Exception as e:
                logger.error(f"❌ ダウンロードエラー: {e}")
                return None
            
            # === パート5: バイトデータからテキストへの変換 ===
            logger.info("【切り分け5】バイトデータをテキストに変換")
            try:
                content = fh.getvalue().decode('utf-8')
                logger.info(f"✅ 変換成功: {len(content)}文字")
                logger.info(f"  先頭100文字: {content[:100]}...")
                
                # 内容の検証
                if len(content) < 10:
                    logger.warning(f"⚠️ 内容が短すぎます: {len(content)}文字")
                
                return content
                
            except UnicodeDecodeError as e:
                logger.error(f"❌ UTF-8デコードエラー: {e}")
                logger.error("  → ファイルがテキスト形式ではない可能性")
                return None
            except Exception as e:
                logger.error(f"❌ 変換エラー: {e}")
                return None
            
        except Exception as e:
            logger.error(f"❌ Google Driveファイル読み込みエラー: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def get_current_pc_id(self) -> int:
        """スプレッドシートのB12セルからPC_IDを読み取る"""
        try:
            # === パート1: シート接続とセル読み取り ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
            
            pc_id_value = setting_sheet.cell(12, 2).value
            
            # === パート2: 値の検証と変換 ===
            if pc_id_value:
                try:
                    pc_id = int(pc_id_value)
                    logger.info(f"✅ スプレッドシートからPC_ID={pc_id}を読み取りました(セルB12)")
                    return pc_id
                except ValueError:
                    logger.warning(f"⚠️ B12セルの値 '{pc_id_value}' を整数に変換できません。デフォルト値1を使用します")
                    return 1
            else:
                logger.warning("⚠️ B12セルが空です。デフォルト値1を使用します")
                return 1
                
        except Exception as e:
            ErrorHandler.log_error(e, "PC_ID読み取り")
            logger.warning("⚠️ PC_IDの読み取りに失敗しました。デフォルト値1を使用します")
            return 1
    
    def load_pc_settings(self, pc_id: int = 1) -> Dict[str, str]:
        """PC固有の設定をsettingシートから読み込み"""
        try:
            # === パート1: シート接続と基本設定 ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
        
            col_index = 1 + pc_id
        
            # === パート2: 各設定値の読み込み ===
            settings = {
                'google_id': self._get_cell_value(setting_sheet, 2, col_index),
                'google_pass': self._get_cell_value(setting_sheet, 3, col_index),
                'service_mail': self._get_cell_value(setting_sheet, 4, col_index),
                'download_image_folder': self._get_cell_value(setting_sheet, 5, col_index),
                'download_text_folder': self._get_cell_value(setting_sheet, 6, col_index),
                'browser_data_dir': self._get_cell_value(setting_sheet, 7, col_index),
                'service_account_file': self._get_cell_value(setting_sheet, 8, col_index),
                'cookies_file': self._get_cell_value(setting_sheet, 9, col_index),
                'generation_mode': self._get_cell_value(setting_sheet, 10, col_index),
                'text_format': self._get_cell_value(setting_sheet, 11, col_index),
                'service_type': self._get_cell_value(setting_sheet, 13, col_index),
                'agent_output_folder': self._get_cell_value(setting_sheet, 14, col_index),
                'max_iterations': self._get_cell_value(setting_sheet, 15, col_index),
                'wp_url': self._get_cell_value(setting_sheet, 16, col_index),
                'wp_user': self._get_cell_value(setting_sheet, 17, col_index),
                'wp_pass': self._get_cell_value(setting_sheet, 18, col_index),
            }
        
            # === パート3: 設定値の検証と正規化 ===
            # generation_modeの検証
            mode = settings.get('generation_mode', '').strip().lower()
            if mode not in ['text', 'image']:
                logger.warning(f"⚠️ 不正なgeneration_mode値: '{mode}' → デフォルト 'image' を使用")
                settings['generation_mode'] = 'image'
            else:
                settings['generation_mode'] = mode
        
            # max_iterationsの検証
            try:
                max_iter = int(settings.get('max_iterations', '3'))
                if max_iter < 1 or max_iter > 10:
                    logger.warning(f"⚠️ 不正なmax_iterations値: {max_iter} → デフォルト 3 を使用")
                    settings['max_iterations'] = 3
                else:
                    settings['max_iterations'] = max_iter
            except (ValueError, TypeError):
                logger.warning(f"⚠️ max_iterationsの変換エラー → デフォルト 3 を使用")
                settings['max_iterations'] = 3
        
            logger.info(f"✅ PC_ID={pc_id} の設定を読み込みました")
            return settings
        
        except Exception as e:
            ErrorHandler.log_error(e, f"PC_ID={pc_id} の設定読み込み")
            raise

    def _get_cell_value(self, sheet, row: int, col: int) -> str:
        """セルの値を安全に取得"""
        try:
            value = sheet.cell(row, col).value
            return value if value is not None else ""
        except Exception:
            return ""
    
    def _get_column_letter(self, col_index: int) -> str:
        """列インデックスを列文字に変換(1→A, 2→B, ...)"""
        result = ""
        while col_index > 0:
            col_index -= 1
            result = chr(col_index % 26 + ord('A')) + result
            col_index //= 26
        return result
    
    def load_credentials_from_sheet(self, pc_id: int = 1) -> Dict[str, str]:
        """認証情報を読み込み(PC_ID対応版)"""
        try:
            # === パート1: 設定読み込み ===
            settings = self.load_pc_settings(pc_id)
            
            # === パート2: 認証情報の抽出 ===
            credentials = {
                'email': settings['google_id'],
                'password': settings['google_pass'],
                'service_mail': settings.get('service_mail')
            }
            
            return credentials
            
        except Exception as e:
            ErrorHandler.log_error(e, "認証情報読み込み")
            raise
    
    # sheets_manager.py に以下のメソッドを追加

    async def verify_task_exists(self, task_id: int, sheet_name: str = "pm_tasks") -> bool:
        """タスクがシートに存在するか検証（追加）"""
        try:
            self._ensure_client()
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            task_sheet = sheet.worksheet(sheet_name)
        
            # 全データを取得
            all_data = task_sheet.get_all_values()
        
            if len(all_data) <= 1:
                logger.warning(f"タスクシートにデータがありません")
                return False
        
            # ヘッダー解析
            headers = all_data[0]
            task_id_col = None
        
            for i, header in enumerate(headers):
                header_lower = header.lower()
                if 'task_id' in header_lower or 'id' in header_lower:
                    task_id_col = i
                    break
        
            if task_id_col is None:
                task_id_col = 0
        
            # タスクID検索（型の不一致を考慮）
            task_id_str = str(task_id)
            for row in all_data[1:]:
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    if cell_value == task_id_str:
                        logger.info(f"✅ タスク {task_id} の存在を確認")
                        return True
        
            logger.warning(f"❌ タスク {task_id} はシートに存在しません")
            return False
        
        except Exception as e:
            logger.error(f"タスク存在確認エラー: {e}")
            return False

    def _enhanced_task_search(self, task_sheet, task_id: int, task_id_col: int) -> tuple:
        """強化版タスク検索（修正）"""
        try:
            all_data = task_sheet.get_all_values()
            task_id_str = str(task_id)
        
            # デバッグ情報の収集
            available_ids = []
            for i, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col and row[task_id_col]:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    if cell_value == task_id_str:
                        return (i, True)  # (行番号, 見つかったか)
        
            logger.warning(f"🔍 検索対象ID: '{task_id_str}'")
            logger.warning(f"🔍 利用可能なタスクID: {available_ids}")
            return (None, False)
        
        except Exception as e:
            logger.error(f"タスク検索エラー: {e}")
            return (None, False)
    
    def validate_sheet_structure(self) -> bool:
        """シート構造の妥当性をチェック"""
        try:
            # === パート1: クライアントとシート一覧の取得 ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            required_sheets = ["setting"]
            existing_sheets = [ws.title for ws in sheet.worksheets()]
            
            # === パート2: 必須シートの存在確認 ===
            for required_sheet in required_sheets:
                if required_sheet not in existing_sheets:
                    logger.error(f"❌ 必要なシート '{required_sheet}' が見つかりません")
                    return False
            
            # === パート3: プロンプトシートの存在確認 ===
            if "prompt_text" not in existing_sheets and "prompt" not in existing_sheets:
                logger.error("❌ プロンプトシート ('prompt_text' または 'prompt') が見つかりません")
                return False
            
            logger.info("✅ シート構造の妥当性チェック完了")
            return True
            
        except Exception as e:
            ErrorHandler.log_error(e, "シート構造チェック")
            return False

#system_cli_executor.py
"""
system_cli_executor.py - システムCLIタスク専門実行モジュール
WP-CLI、ACF、ファイル操作などのシステムタスクを担当
"""

import asyncio
import subprocess
import logging
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime

# 設定
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

# コマンド監視エージェント
try:
    from agents.command_monitor_agent import CommandMonitorAgent
    HAS_COMMAND_MONITOR = True
except ImportError:
    HAS_COMMAND_MONITOR = False
    CommandMonitorAgent = None

logger = logging.getLogger(__name__)


class SystemCLIExecutor:
    """
    システムCLIタスクの専門実行モジュール
    
    WP-CLI、ACFインポート、ファイル操作、
    インフラコマンド実行を統合管理
    """
    
    def __init__(self, sheets_manager: GoogleSheetsManager):
        """
        初期化
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
        """
        self.sheets_manager = sheets_manager
        
        # コマンド監視エージェント初期化
        if HAS_COMMAND_MONITOR and CommandMonitorAgent:
            try:
                self.command_monitor = CommandMonitorAgent()
                logger.info("✅ CommandMonitorAgent 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ CommandMonitorAgent 初期化失敗: {e}")
                self.command_monitor = None
        else:
            logger.info("ℹ️ CommandMonitorAgent は利用できません")
            self.command_monitor = None
        
        # タイムアウト設定
        self.default_timeout = 60.0
        self.long_timeout = 300.0
        
        # WP-CLI設定
        self.wp_cli_path = self._detect_wp_cli_path()
        
        logger.info("✅ SystemCLIExecutor 初期化完了")
    
    def _detect_wp_cli_path(self) -> str:
        """WP-CLIパスを検出"""
        candidates = [
            'wp',  # PATH内
            '/usr/local/bin/wp',
            '/usr/bin/wp',
            './wp-cli.phar'
        ]
        
        for candidate in candidates:
            try:
                result = subprocess.run(
                    [candidate, '--version'],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    logger.info(f"✅ WP-CLI検出: {candidate}")
                    return candidate
            except:
                continue
        
        logger.warning("⚠️ WP-CLI未検出 - 'wp'をデフォルト使用")
        return 'wp'
    
    async def execute_cli_task(self, task: Dict) -> Dict:
        """
        CLIタスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("=" * 60)
            logger.info(f"⚙️ CLIタスク実行開始: {task_id}")
            logger.info("=" * 60)
            
            # タスクタイプ判定
            cli_type = self._determine_cli_type(task)
            logger.info(f"CLIタイプ: {cli_type}")
            
            # タイプ別実行
            if cli_type == 'wp-cli':
                result = await self._execute_wp_cli_task(task)
            elif cli_type == 'acf':
                result = await self._execute_acf_task(task)
            elif cli_type == 'file':
                result = await self._execute_file_operation_task(task)
            elif cli_type == 'generic':
                result = await self._execute_generic_command_task(task)
            else:
                logger.warning(f"⚠️ 未知のCLIタイプ: {cli_type}")
                result = await self._execute_generic_command_task(task)
            
            if result.get('success'):
                logger.info(f"✅ CLIタスク {task_id} 完了")
            else:
                logger.error(f"❌ CLIタスク {task_id} 失敗")
            
            return result
        
        except Exception as e:
            logger.error(f"❌ CLIタスク {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"SystemCLIExecutor.execute_cli_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_cli_type(self, task: Dict) -> str:
        """
        CLIタスクのタイプを判定
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: タスクタイプ ('wp-cli', 'acf', 'file', 'generic')
        """
        description = task.get('description', '').lower()
        command = task.get('command', '').lower()
        
        # WP-CLIキーワード
        if any(kw in description or kw in command for kw in ['wp ', 'wp-cli', 'wordpress cli']):
            return 'wp-cli'
        
        # ACFキーワード
        if any(kw in description or kw in command for kw in ['acf', 'advanced custom fields', 'acf-json']):
            return 'acf'
        
        # ファイル操作キーワード
        if any(kw in description for kw in ['ファイル', 'コピー', '移動', '削除', 'mkdir', 'cp', 'mv', 'rm']):
            return 'file'
        
        return 'generic'
    
    async def _execute_wp_cli_task(self, task: Dict) -> Dict:
        """
        WP-CLIコマンドを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🌐 WP-CLIコマンド実行")
            
            # コマンド構築
            command = task.get('command', '')
            if not command:
                # タスク説明からコマンド抽出を試行
                description = task.get('description', '')
                if 'wp ' in description:
                    command = description[description.find('wp '):]
                else:
                    return {
                        'success': False,
                        'error': 'WP-CLIコマンドが指定されていません'
                    }
            
            # WP-CLIパス付加
            if not command.startswith(self.wp_cli_path):
                command = f"{self.wp_cli_path} {command}"
            
            # 作業ディレクトリ
            wp_path = task.get('wp_path', config.WP_PATH if hasattr(config, 'WP_PATH') else None)
            
            # コマンド監視エージェント使用
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            else:
                # 直接実行（フォールバック）
                result = await self._direct_command_execution(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"❌ WP-CLI実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_acf_task(self, task: Dict) -> Dict:
        """
        ACF関連タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📦 ACFタスク実行")
            
            # ACF操作タイプ判定
            description = task.get('description', '').lower()
            
            if 'インポート' in description or 'import' in description:
                # ACFインポート
                acf_file = task.get('acf_file', task.get('file_path', ''))
                
                if not acf_file:
                    return {
                        'success': False,
                        'error': 'ACFファイルパスが指定されていません'
                    }
                
                if self.command_monitor and hasattr(self.command_monitor, 'monitor_acf_import_process'):
                    result = await self.command_monitor.monitor_acf_import_process(acf_file)
                else:
                    # WP-CLI経由でインポート
                    command = f"{self.wp_cli_path} acf import {acf_file}"
                    result = await self._direct_command_execution(
                        command,
                        timeout=self.long_timeout
                    )
                
                return result
            
            elif 'エクスポート' in description or 'export' in description:
                # ACFエクスポート
                output_path = task.get('output_path', './acf-export.json')
                command = f"{self.wp_cli_path} acf export --path={output_path}"
                
                result = await self._direct_command_execution(
                    command,
                    timeout=self.default_timeout
                )
                
                return result
            
            else:
                return {
                    'success': False,
                    'error': 'ACF操作タイプが不明です'
                }
        
        except Exception as e:
            logger.error(f"❌ ACFタスク実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_file_operation_task(self, task: Dict) -> Dict:
        """
        ファイル操作タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📁 ファイル操作タスク実行")
            
            description = task.get('description', '').lower()
            
            # 操作タイプ判定
            if 'コピー' in description or 'copy' in description:
                return await self._file_copy(task)
            elif '移動' in description or 'move' in description:
                return await self._file_move(task)
            elif '削除' in description or 'delete' in description:
                return await self._file_delete(task)
            elif 'ディレクトリ作成' in description or 'mkdir' in description:
                return await self._directory_create(task)
            else:
                return {
                    'success': False,
                    'error': 'ファイル操作タイプが不明です'
                }
        
        except Exception as e:
            logger.error(f"❌ ファイル操作エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _file_copy(self, task: Dict) -> Dict:
        """ファイルコピー"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': 'コピー元またはコピー先が指定されていません'}
        
        try:
            shutil.copy2(source, dest)
            logger.info(f"✅ ファイルコピー成功: {source} -> {dest}")
            return {'success': True, 'message': f'コピー完了: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'コピー失敗: {e}'}
    
    async def _file_move(self, task: Dict) -> Dict:
        """ファイル移動"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': '移動元または移動先が指定されていません'}
        
        try:
            shutil.move(source, dest)
            logger.info(f"✅ ファイル移動成功: {source} -> {dest}")
            return {'success': True, 'message': f'移動完了: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'移動失敗: {e}'}
    
    async def _file_delete(self, task: Dict) -> Dict:
        """ファイル削除"""
        target = task.get('target', task.get('file_path', ''))
        
        if not target:
            return {'success': False, 'error': '削除対象が指定されていません'}
        
        try:
            path = Path(target)
            if path.is_file():
                path.unlink()
            elif path.is_dir():
                import shutil
                shutil.rmtree(path)
            else:
                return {'success': False, 'error': f'ファイルまたはディレクトリが見つかりません: {target}'}
            
            logger.info(f"✅ 削除成功: {target}")
            return {'success': True, 'message': f'削除完了: {target}'}
        except Exception as e:
            return {'success': False, 'error': f'削除失敗: {e}'}
    
    async def _directory_create(self, task: Dict) -> Dict:
        """ディレクトリ作成"""
        dir_path = task.get('directory', task.get('path', ''))
        
        if not dir_path:
            return {'success': False, 'error': 'ディレクトリパスが指定されていません'}
        
        try:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
            logger.info(f"✅ ディレクトリ作成成功: {dir_path}")
            return {'success': True, 'message': f'作成完了: {dir_path}'}
        except Exception as e:
            return {'success': False, 'error': f'作成失敗: {e}'}
    
    async def _execute_generic_command_task(self, task: Dict) -> Dict:
        """
        汎用コマンドタスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🔧 汎用コマンド実行")
            
            command = task.get('command', '')
            if not command:
                return {
                    'success': False,
                    'error': 'コマンドが指定されていません'
                }
            
            timeout = task.get('timeout', self.default_timeout)
            cwd = task.get('cwd', None)
            
            # コマンド監視エージェント使用
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            else:
                result = await self._direct_command_execution(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"❌ 汎用コマンド実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _direct_command_execution(
        self,
        command: str,
        cwd: Optional[str] = None,
        timeout: float = 60.0
    ) -> Dict:
        """
        コマンドを直接実行（フォールバック）
        
        Args:
            command: 実行するコマンド
            cwd: 作業ディレクトリ
            timeout: タイムアウト時間（秒）
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info(f"🔧 コマンド直接実行: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                return {
                    'success': False,
                    'error': f'タイムアウト ({timeout}秒)'
                }
            
            returncode = process.returncode
            stdout_text = stdout.decode('utf-8') if stdout else ''
            stderr_text = stderr.decode('utf-8') if stderr else ''
            
            if returncode == 0:
                logger.info(f"✅ コマンド実行成功")
                return {
                    'success': True,
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
            else:
                logger.error(f"❌ コマンド実行失敗 (コード: {returncode})")
                return {
                    'success': False,
                    'error': f'コマンド失敗 (コード: {returncode})',
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
        
        except Exception as e:
            logger.error(f"❌ コマンド直接実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#tas__init__.py
"""
task_executor パッケージ初期化モジュール
タスク実行の専門モジュールを統合管理

ファイル名: task_executor/tas__init__.py
使用方法: from task_executor.tas__init__ import *
"""

# 既存モジュール（変更不要）
try:
    from .task_executor_content import ContentTaskExecutor as LegacyContentExecutor
    HAS_LEGACY_CONTENT = True
except ImportError:
    HAS_LEGACY_CONTENT = False
    LegacyContentExecutor = None

try:
    from .task_executor_ma import MATaskExecutor as LegacyMAExecutor
    HAS_LEGACY_MA = True
except ImportError:
    HAS_LEGACY_MA = False
    LegacyMAExecutor = None

# 新規モジュール
try:
    from .content_task_executor import ContentTaskExecutor
    HAS_CONTENT_EXECUTOR = True
except ImportError:
    HAS_CONTENT_EXECUTOR = False
    ContentTaskExecutor = None

try:
    from .system_cli_executor import SystemCLIExecutor
    HAS_CLI_EXECUTOR = True
except ImportError:
    HAS_CLI_EXECUTOR = False
    SystemCLIExecutor = None

try:
    from .task_coordinator import TaskCoordinator
    HAS_COORDINATOR = True
except ImportError:
    HAS_COORDINATOR = False
    TaskCoordinator = None

try:
    from .workflow_executor import WorkflowExecutor
    HAS_WORKFLOW_EXECUTOR = True
except ImportError:
    HAS_WORKFLOW_EXECUTOR = False
    WorkflowExecutor = None

# パッケージ情報
__version__ = '2.0.0'
__all__ = [
    # 既存
    'LegacyContentExecutor',
    'LegacyMAExecutor',
    # 新規
    'ContentTaskExecutor',
    'SystemCLIExecutor',
    'TaskCoordinator',
    'WorkflowExecutor',
    # フラグ
    'HAS_LEGACY_CONTENT',
    'HAS_LEGACY_MA',
    'HAS_CONTENT_EXECUTOR',
    'HAS_CLI_EXECUTOR',
    'HAS_COORDINATOR',
    'HAS_WORKFLOW_EXECUTOR'
]

# 利用可能モジュールのログ出力
import logging
logger = logging.getLogger(__name__)

logger.info("=" * 60)
logger.info("📦 task_executor パッケージ初期化 (tas__init__)")
logger.info("=" * 60)

if HAS_LEGACY_CONTENT:
    logger.info("✅ 既存 task_executor_content 利用可能")
else:
    logger.info("⚠️ task_executor_content 未検出")

if HAS_LEGACY_MA:
    logger.info("✅ 既存 task_executor_ma 利用可能")
else:
    logger.info("⚠️ task_executor_ma 未検出")

if HAS_CONTENT_EXECUTOR:
    logger.info("✅ 新規 ContentTaskExecutor 利用可能")
else:
    logger.info("ℹ️ ContentTaskExecutor 未配置（オプション）")

if HAS_CLI_EXECUTOR:
    logger.info("✅ 新規 SystemCLIExecutor 利用可能")
else:
    logger.info("ℹ️ SystemCLIExecutor 未配置（オプション）")

if HAS_COORDINATOR:
    logger.info("✅ 新規 TaskCoordinator 利用可能")
else:
    logger.info("ℹ️ TaskCoordinator 未配置（オプション）")

if HAS_WORKFLOW_EXECUTOR:
    logger.info("✅ 新規 WorkflowExecutor 利用可能")
else:
    logger.info("ℹ️ WorkflowExecutor 未配置（オプション）")

logger.info("=" * 60)


# ========================================
# 便利関数: パッケージモジュールを一括インポート
# ========================================

def load_all_modules():
    """
    利用可能な全モジュールを辞書形式で返す
    
    Returns:
        Dict: モジュール名をキー、モジュールオブジェクトを値とする辞書
    """
    modules = {}
    
    if HAS_LEGACY_CONTENT:
        modules['legacy_content'] = LegacyContentExecutor
    if HAS_LEGACY_MA:
        modules['legacy_ma'] = LegacyMAExecutor
    if HAS_CONTENT_EXECUTOR:
        modules['content'] = ContentTaskExecutor
    if HAS_CLI_EXECUTOR:
        modules['cli'] = SystemCLIExecutor
    if HAS_COORDINATOR:
        modules['coordinator'] = TaskCoordinator
    if HAS_WORKFLOW_EXECUTOR:
        modules['workflow'] = WorkflowExecutor
    
    return modules


def get_available_modules():
    """
    利用可能なモジュールのリストを返す
    
    Returns:
        List[str]: 利用可能なモジュール名のリスト
    """
    available = []
    
    if HAS_LEGACY_CONTENT:
        available.append('legacy_content')
    if HAS_LEGACY_MA:
        available.append('legacy_ma')
    if HAS_CONTENT_EXECUTOR:
        available.append('content')
    if HAS_CLI_EXECUTOR:
        available.append('cli')
    if HAS_COORDINATOR:
        available.append('coordinator')
    if HAS_WORKFLOW_EXECUTOR:
        available.append('workflow')
    
    return available


def print_module_status():
    """
    モジュールの利用可能状況をコンソールに出力
    """
    print("\n" + "=" * 60)
    print("📦 task_executor パッケージモジュール状況")
    print("=" * 60)
    
    modules_status = [
        ("既存 task_executor_content", HAS_LEGACY_CONTENT),
        ("既存 task_executor_ma", HAS_LEGACY_MA),
        ("新規 ContentTaskExecutor", HAS_CONTENT_EXECUTOR),
        ("新規 SystemCLIExecutor", HAS_CLI_EXECUTOR),
        ("新規 TaskCoordinator", HAS_COORDINATOR),
        ("新規 WorkflowExecutor", HAS_WORKFLOW_EXECUTOR)
    ]
    
    for name, available in modules_status:
        status = "✅ 利用可能" if available else "❌ 未配置"
        print(f"{name}: {status}")
    
    print("=" * 60 + "\n")

#task_coordinator.py
"""
task_coordinator.py - タスク実行の統合調整レイヤー
既存のTaskExecutorを補完し、タスクの振り分けと結果集約を担当
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# 設定とユーティリティ
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

# 既存のTaskExecutor
from task_executor import TaskExecutor

# 専門実行モジュール（新規）
try:
    from content_task_executor import ContentTaskExecutor
    HAS_CONTENT_EXECUTOR = True
except ImportError:
    HAS_CONTENT_EXECUTOR = False
    ContentTaskExecutor = None

try:
    from system_cli_executor import SystemCLIExecutor
    HAS_CLI_EXECUTOR = True
except ImportError:
    HAS_CLI_EXECUTOR = False
    SystemCLIExecutor = None

try:
    from workflow_executor import WorkflowExecutor
    HAS_WORKFLOW_EXECUTOR = True
except ImportError:
    HAS_WORKFLOW_EXECUTOR = False
    WorkflowExecutor = None

logger = logging.getLogger(__name__)


class TaskCoordinator:
    """
    タスク実行の統合調整レイヤー
    
    既存のTaskExecutorを拡張し、専門実行モジュールへの
    タスク振り分けと結果集約を行う
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        初期化
        
        Args:
            task_executor: 既存のTaskExecutorインスタンス
            sheets_manager: GoogleSheetsManagerインスタンス
            browser_controller: BrowserControllerインスタンス(オプション)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # 統計情報
        self.stats = {
            'total_executed': 0,
            'content_tasks': 0,
            'cli_tasks': 0,
            'workflow_tasks': 0,
            'fallback_tasks': 0,
            'success': 0,
            'failed': 0
        }
        
        logger.info("=" * 60)
        logger.info("🎯 TaskCoordinator 初期化中...")
        logger.info("=" * 60)
        
        # 専門実行モジュールの初期化
        self._initialize_specialized_executors()
        
        logger.info("=" * 60)
        logger.info("✅ TaskCoordinator 初期化完了")
        logger.info("=" * 60)
    
    def _initialize_specialized_executors(self):
        """専門実行モジュールを初期化"""
        
        # コンテンツタスク実行モジュール
        if HAS_CONTENT_EXECUTOR and ContentTaskExecutor:
            try:
                self.content_executor = ContentTaskExecutor(
                    browser_controller=self.browser,
                    sheets_manager=self.sheets_manager
                )
                logger.info("✅ ContentTaskExecutor 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ ContentTaskExecutor 初期化失敗: {e}")
                self.content_executor = None
        else:
            logger.info("ℹ️ ContentTaskExecutor は利用できません（既存実装を使用）")
            self.content_executor = None
        
        # CLIタスク実行モジュール
        if HAS_CLI_EXECUTOR and SystemCLIExecutor:
            try:
                self.cli_executor = SystemCLIExecutor(
                    sheets_manager=self.sheets_manager
                )
                logger.info("✅ SystemCLIExecutor 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ SystemCLIExecutor 初期化失敗: {e}")
                self.cli_executor = None
        else:
            logger.info("ℹ️ SystemCLIExecutor は利用できません")
            self.cli_executor = None
        
        # ワークフロー実行モジュール
        if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
            try:
                self.workflow_executor = WorkflowExecutor(
                    task_executor=self.task_executor,
                    sheets_manager=self.sheets_manager,
                    browser_controller=self.browser
                )
                logger.info("✅ WorkflowExecutor 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ WorkflowExecutor 初期化失敗: {e}")
                self.workflow_executor = None
        else:
            logger.info("ℹ️ WorkflowExecutor は利用できません")
            self.workflow_executor = None
            
    def determine_executor_type(self, task: Dict) -> str:
        """
        タスクに最適な実行モジュールを判定
            
        Args:
            task: タスク情報辞書
                
        Returns:
            str: 実行モジュールタイプ ('content', 'cli', 'workflow', 'review', 'fallback')
        """
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
            
        # ========================================
        # 🔍 レビュータスク判定（最優先 - 新規追加）
        # ========================================
        if role == 'review' or 'レビュー' in description or 'review' in description:
            return 'review'
        # ========================================
            
        # ワークフローキーワードチェック（最優先）
        workflow_keywords = [
            '多言語', 'マルチステップ', 'レビュー→修正',
            'シーケンス', 'パイプライン', 'チェーン'
        ]
        if any(kw in description for kw in workflow_keywords):
            return 'workflow'
            
        # コンテンツ生成キーワードチェック
        content_keywords = [
            '記事', '生成', '執筆', 'ライティング', 
            'コンテンツ', 'ai', 'gemini', 'deepseek',
            'プロンプト', '抽出'
        ]
        if any(kw in description for kw in content_keywords):
            return 'content'
            
        # CLIコマンドキーワードチェック
        cli_keywords = [
            'wp-cli', 'acf', 'コマンド実行', 'インポート',
            'ファイル操作', 'システム', 'インフラ'
        ]
        if any(kw in description for kw in cli_keywords):
            return 'cli'
            
        # ロールベース判定
        if role in ['content', 'writer', 'seo']:
            return 'content'
        elif role in ['dev', 'system', 'admin']:
            return 'cli'
            
        # デフォルトは既存実装にフォールバック
        return 'fallback'
    
    async def execute_task_coordinated(self, task: Dict) -> Dict:
        """
        タスクを適切な実行モジュールに振り分けて実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        self.stats['total_executed'] += 1
        
        try:
            # 実行モジュールタイプを判定
            executor_type = self.determine_executor_type(task)
            
            logger.info("=" * 60)
            logger.info(f"📋 タスク振り分け: {task_id}")
            logger.info(f"実行タイプ: {executor_type.upper()}")
            logger.info("=" * 60)
            
            result = None
            
            # ========================================
            # 🔍 レビュータスク実行（新規追加）
            # ========================================
            if executor_type == 'review':
                logger.info("🔍 ReviewAgent で実行")
                
                # TaskExecutor経由でreview_agentを実行
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'review',
                    'message': 'レビュー実行完了' if success else 'レビュー実行失敗'
                }
            # ========================================
            
            # ワークフロー実行
            elif executor_type == 'workflow' and self.workflow_executor:
                logger.info("🔄 WorkflowExecutor で実行")
                self.stats['workflow_tasks'] += 1
                result = await self.workflow_executor.execute_workflow_task(task)
            
            # コンテンツ生成実行
            elif executor_type == 'content' and self.content_executor:
                logger.info("✍️ ContentTaskExecutor で実行")
                self.stats['content_tasks'] += 1
                result = await self.content_executor.execute_content_task(task)
            
            # CLIタスク実行
            elif executor_type == 'cli' and self.cli_executor:
                logger.info("⚙️ SystemCLIExecutor で実行")
                self.stats['cli_tasks'] += 1
                result = await self.cli_executor.execute_cli_task(task)
            
            # 既存実装へフォールバック
            else:
                logger.info("🔙 既存 TaskExecutor で実行（フォールバック）")
                self.stats['fallback_tasks'] += 1
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'fallback',
                    'message': '既存実装で実行完了'
                }
            
            # 統計更新
            if result and result.get('success'):
                self.stats['success'] += 1
            else:
                self.stats['failed'] += 1
            
            # 実行情報を結果に追加
            if result:
                result['executor_type'] = executor_type
                result['coordinated_execution'] = True
            
            return result
            
        except Exception as e:
            logger.error(f"❌ タスク調整エラー: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
            
        except Exception as e:
            logger.error(f"❌ タスク調整エラー: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
    
    async def run_all_tasks_coordinated(
        self,
        auto_continue: bool = False,
        enable_review: bool = True
    ):
        """
        全タスクを調整レイヤー経由で実行
        
        Args:
            auto_continue: 自動継続フラグ
            enable_review: レビュー有効化フラグ
        """
        logger.info("\n" + "=" * 60)
        logger.info("🚀 タスク調整実行開始")
        logger.info("=" * 60)
        
        try:
            iteration = 0
            max_iterations = self.task_executor.max_iterations
            
            while iteration < max_iterations:
                iteration += 1
                
                logger.info(f"\n{'=' * 60}")
                logger.info(f"反復 {iteration}/{max_iterations}")
                logger.info(f"{'=' * 60}")
                
                # 保留中タスクの読み込み
                pending_tasks = await self.task_executor.load_pending_tasks()
                
                if not pending_tasks:
                    logger.info("✅ 全タスク完了または保留タスクなし")
                    break
                
                logger.info(f"📋 実行予定タスク: {len(pending_tasks)}件")
                
                # タスク実行ループ
                for task in pending_tasks:
                    task_id = task.get('task_id', 'UNKNOWN')
                    
                    try:
                        logger.info(f"\n{'─' * 60}")
                        logger.info(f"タスク実行: {task_id}")
                        logger.info(f"{'─' * 60}")
                        
                        # 調整レイヤー経由で実行
                        result = await self.execute_task_coordinated(task)
                        
                        if result and result.get('success'):
                            logger.info(f"✅ タスク {task_id} 成功")
                        else:
                            logger.error(f"❌ タスク {task_id} 失敗")
                        
                        # ユーザー確認（自動継続でない場合）
                        if not auto_continue:
                            continue_task = input(
                                f"\n次のタスクに進みますか? "
                                f"(y/n/a=以降全て実行): "
                            ).lower()
                            
                            if continue_task == 'n':
                                logger.info("ユーザーによる中断")
                                return
                            elif continue_task == 'a':
                                auto_continue = True
                                logger.info("自動実行モードに切り替え")
                        
                        await asyncio.sleep(2)
                        
                    except KeyboardInterrupt:
                        logger.warning("⏸️ ユーザーによる中断")
                        raise
                    
                    except Exception as e:
                        logger.error(f"❌ タスク {task_id} で予期しないエラー")
                        ErrorHandler.log_error(e, f"タスク {task_id} 実行中")
                        
                        if not auto_continue:
                            cont = input(
                                f"\n⚠️ エラーが発生しました。続行しますか? (y/n): "
                            ).lower()
                            if cont != 'y':
                                logger.info("ユーザーによる中断")
                                break
            
            # 最終統計レポート
            self._print_coordination_report()
            
        except KeyboardInterrupt:
            logger.warning("\n⏸️ ユーザーによる中断")
            self._print_coordination_report()
            raise
        
        except Exception as e:
            logger.error("❌ タスク調整実行全体で重大エラー")
            ErrorHandler.log_error(e, "TaskCoordinator.run_all_tasks_coordinated")
            self._print_coordination_report()
            raise
    
    def _print_coordination_report(self):
        """タスク調整の統計レポートを出力"""
        logger.info("\n" + "=" * 60)
        logger.info("📊 タスク調整実行レポート")
        logger.info("=" * 60)
        logger.info(f"総実行数: {self.stats['total_executed']}")
        logger.info(f"  - コンテンツタスク: {self.stats['content_tasks']}")
        logger.info(f"  - CLIタスク: {self.stats['cli_tasks']}")
        logger.info(f"  - ワークフロータスク: {self.stats['workflow_tasks']}")
        logger.info(f"  - フォールバック: {self.stats['fallback_tasks']}")
        logger.info(f"成功: {self.stats['success']}")
        logger.info(f"失敗: {self.stats['failed']}")
        logger.info("=" * 60)
        
        # コンソール出力
        print("\n" + "=" * 60)
        print("📊 タスク調整実行レポート")
        print("=" * 60)
        print(f"総実行数: {self.stats['total_executed']}")
        print(f"  - コンテンツタスク: {self.stats['content_tasks']}")
        print(f"  - CLIタスク: {self.stats['cli_tasks']}")
        print(f"  - ワークフロータスク: {self.stats['workflow_tasks']}")
        print(f"  - フォールバック: {self.stats['fallback_tasks']}")
        print(f"成功: {self.stats['success']}")
        print(f"失敗: {self.stats['failed']}")
        print("=" * 60 + "\n")
    
    def get_stats(self) -> Dict:
        """統計情報を取得"""
        return self.stats.copy()

#task_executor - コピー.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== 設定とユーティリティ =====
from config_utils import ErrorHandler, config

# ===== データ管理 =====
from sheets_manager import GoogleSheetsManager

# ===== エラーハンドラー（オプション） =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced未検出（標準エラーハンドラー使用）")

# ===== 分離モジュール =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPress連携（オプション） =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """タスク実行コントローラー(エラーハンドリング強化版)"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        初期化
        
        Args:
            sheets_manager: GoogleSheetsManager インスタンス
            browser_controller: BrowserController インスタンス(オプション)
            max_iterations: 最大反復回数
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: 最大反復回数 = {self.max_iterations}")
        
        # エージェントを自動初期化
        self._initialize_agents()
        
        # === 分離モジュール初期化 ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # 記事生成専用エグゼキュータ
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("✅ ContentTaskExecutor 初期化完了")
                
                # M&A専用エグゼキュータ
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("✅ MATaskExecutor 初期化完了")
                
                logger.info("="*60)
                logger.info("分離モジュール初期化完了")
                logger.info("  - ContentTaskExecutor (記事生成専用)")
                logger.info("  - MATaskExecutor (M&A/企業検索専用)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"⚠️ 分離モジュール初期化失敗: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("⚠️ 分離モジュールが利用できません")
            self.content_executor = None
            self.ma_executor = None
        
        # === WordPress開発専用エージェント初期化 ===
        logger.info("\n" + "="*60)
        logger.info("🔧 WordPress開発エージェント初期化中...")
        logger.info("="*60)
        
        # WordPress開発エージェント (wp_dev) の初期化
        self.wp_dev_agent = None
        try:
            from wordpress.wp_dev import WordPressDevAgent
            
            if self.browser:
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_dev'] = self.wp_dev_agent
                logger.info("✅ WordPressDevAgent (wp_dev) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラー未初期化のため wp_dev スキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ wordpress/wp_dev.py のインポート失敗: {e}")
            logger.info("💡 WordPress開発タスクは標準 dev エージェントで処理されます")
        except Exception as e:
            logger.warning(f"⚠️ wp_dev エージェント初期化エラー: {e}")
        
        # WordPress設計エージェント (wp_design) の初期化
        self.wp_design_agent = None
        try:
            from wordpress.wp_design import WordPressDesignAgent
            
            if self.browser:
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_design'] = self.wp_design_agent
                logger.info("✅ WordPressDesignAgent (wp_design) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラー未初期化のため wp_design スキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ wordpress/wp_design.py のインポート失敗: {e}")
            logger.info("💡 WordPress設計タスクは標準 design エージェントで処理されます")
        except Exception as e:
            logger.warning(f"⚠️ wp_design エージェント初期化エラー: {e}")
        
        logger.info("="*60)
        logger.info("WordPress専用エージェント初期化完了")
        if self.wp_dev_agent:
            logger.info("  - WordPressDevAgent (カスタム開発)")
        if self.wp_design_agent:
            logger.info("  - WordPressDesignAgent (テーマ/CSS)")
        logger.info("="*60)

        # ========================================
        # 📦 新規モジュール統合（__init__メソッド内に追加）
        # ========================================

        logger.info("\n" + "="*60)
        logger.info("📦 拡張モジュール統合チェック")
        logger.info("="*60)

        # task_executor.tas__init__ から新規モジュールをインポート
        try:
            from task_executor.tas__init__ import (
                TaskCoordinator,
                ContentTaskExecutor as NewContentExecutor,
                SystemCLIExecutor,
                WorkflowExecutor,
                HAS_COORDINATOR,
                HAS_CONTENT_EXECUTOR,
                HAS_CLI_EXECUTOR,
                HAS_WORKFLOW_EXECUTOR,
                print_module_status
            )
            
            # TaskCoordinator の初期化（オプション）
            if HAS_COORDINATOR:
                try:
                    logger.info("✅ TaskCoordinator 利用可能")
                    self._has_coordinator = True
                except Exception as e:
                    logger.warning(f"⚠️ TaskCoordinator 初期化スキップ: {e}")
                    self._has_coordinator = False
            else:
                logger.info("ℹ️ TaskCoordinator は配置されていません（オプション）")
                self._has_coordinator = False
            
            # 新規 ContentTaskExecutor の初期化（オプション）
            if HAS_CONTENT_EXECUTOR and NewContentExecutor:
                try:
                    self.new_content_executor = NewContentExecutor(
                        browser_controller=self.browser,
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("✅ 新規 ContentTaskExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ 新規 ContentTaskExecutor 初期化失敗: {e}")
                    self.new_content_executor = None
            else:
                logger.info("ℹ️ 新規 ContentTaskExecutor は配置されていません")
                self.new_content_executor = None
            
            # SystemCLIExecutor の初期化（オプション）
            if HAS_CLI_EXECUTOR and SystemCLIExecutor:
                try:
                    self.cli_executor = SystemCLIExecutor(
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("✅ SystemCLIExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ SystemCLIExecutor 初期化失敗: {e}")
                    self.cli_executor = None
            else:
                logger.info("ℹ️ SystemCLIExecutor は配置されていません")
                self.cli_executor = None
            
            # WorkflowExecutor の初期化（オプション）
            if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
                try:
                    self.workflow_executor = WorkflowExecutor(
                        task_executor=self,
                        sheets_manager=self.sheets_manager,
                        browser_controller=self.browser
                    )
                    logger.info("✅ WorkflowExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ WorkflowExecutor 初期化失敗: {e}")
                    self.workflow_executor = None
            else:
                logger.info("ℹ️ WorkflowExecutor は配置されていません")
                self.workflow_executor = None
            
            logger.info("="*60)
            logger.info("拡張モジュール統合完了")
            logger.info("="*60)

        except ImportError as e:
            logger.info("="*60)
            logger.info("ℹ️ 拡張モジュール未配置（既存機能のみ使用）")
            logger.info(f"詳細: {e}")
            logger.info("="*60)
            self._has_coordinator = False
            self.new_content_executor = None
            self.cli_executor = None
            self.workflow_executor = None

    def _initialize_agents(self):
        """エージェントの自動初期化"""
        logger.info("エージェントを初期化中...")
        # エージェントは外部から register_agent() で登録される
        logger.info("エージェント初期化完了")

    def register_agent(self, role: str, agent):
        """エージェントを登録"""
        self.agents[role] = agent
        logger.info(f"エージェント '{role}' を登録しました")

    def register_review_agent(self, review_agent):
        """レビューエージェントを登録"""
        self.review_agent = review_agent
        logger.info("レビューエージェントを登録しました")
    
    def register_review_agent(self, review_agent):
        """レビューエージェントを登録"""
        self.review_agent = review_agent
        logger.info("レビューエージェントを登録しました")

    async def execute_task_with_extensions(self, task: Dict) -> bool:
        """
        拡張モジュールを考慮したタスク実行
        
        新規モジュールが利用可能な場合は優先的に使用し、
        そうでなければ既存実装にフォールバック
        
        Args:
            task: タスク情報辞書
            
        Returns:
            bool: 実行成功フラグ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            # CLIタスク判定
            if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'コマンド実行']):
                logger.info(f"🔧 SystemCLIExecutor でタスク {task_id} を実行")
                result = await self.cli_executor.execute_cli_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # ワークフロータスク判定
            if self.workflow_executor and any(kw in description for kw in ['多言語', 'レビュー→修正', 'マルチステップ']):
                logger.info(f"🔄 WorkflowExecutor でタスク {task_id} を実行")
                result = await self.workflow_executor.execute_workflow_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # 既存実装にフォールバック
            logger.info(f"🔙 既存実装でタスク {task_id} を実行")
            return await self.execute_task(task)
        
        except Exception as e:
            logger.error(f"❌ 拡張実行エラー: {e}")
            ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
            # エラー時も既存実装にフォールバック
            return await self.execute_task(task)

    async def load_pending_tasks(self) -> List[Dict]:
        """保留中のタスクを読み込む（エラーハンドリング強化版）"""
        try:
            logger.info("📋 保留中のタスクを読み込み中...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("📭 pm_tasksシートにタスクがありません")
                return []
            
            # statusが'pending'のタスクのみをフィルタ
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"📊 保留中のタスク: {len(pending_tasks)}件")
            
            # デバッグ情報
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... 他 {len(pending_tasks)-3}件")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー: {e}")
            return []

    async def update_task_status(self, task: Dict, status: str, error_message: str = None) -> bool:
        """タスクステータスを更新（非同期エラー修正版）"""
        try:
            task_id = task.get('task_id')
            
            if error_message:
                logger.info(f"タスク {task_id} ステータス更新: {status} - エラー: {error_message}")
            else:
                logger.info(f"タスク {task_id} ステータス更新: {status}")
            
            # 非同期関数かどうかを確認して適切に呼び出す
            update_method = self.sheets_manager.update_task_status
            
            import inspect
            if inspect.iscoroutinefunction(update_method):
                result = await update_method(task_id, status)
            else:
                result = update_method(task_id, status)
            
            if result is None:
                logger.warning(f"⚠️ ステータス更新の結果がNoneです - タスク {task_id}")
                return True
                
            return bool(result)
            
        except Exception as e:
            logger.warning(f"⚠️ ステータス更新失敗（続行）: {e}")
            return False

# ========================================
# 🎯 タスク実行メソッド（追加部分）
# ========================================


async def run_all_tasks(self) -> Dict[str, Any]:
    """
    全タスクを一括実行（エラーハンドリング強化版）
        
    スプレッドシートからペンディングタスクを取得し、
    順次実行していきます。
        
    Returns:
        Dict: 実行結果サマリー
            {
                'total': 総タスク数,
                'success': 成功数,
                'failed': 失敗数,
                'skipped': スキップ数,
                'results': 各タスクの結果リスト
            }
    """
    logger.info("\n" + "="*80)
    logger.info("🚀 全タスク実行を開始します")
    logger.info("="*80 + "\n")
        
    # 実行結果を格納
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'skipped': 0,
        'results': [],
        'start_time': datetime.now(),
        'end_time': None
    }
        
    try:
        # 1. ペンディングタスクを取得
        logger.info("📋 ペンディングタスクを読み込み中...")
        pending_tasks = await self.load_pending_tasks()
            
        if not pending_tasks:
            logger.info("📭 実行すべきタスクがありません")
            logger.info("💡 スプレッドシートの 'pm_tasks' シートを確認してください")
            logger.info("   - タスクが存在するか")
            logger.info("   - status列が 'pending' になっているか")
            summary['end_time'] = datetime.now()
            return summary
            
        summary['total'] = len(pending_tasks)
        logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            
        # 登録されているエージェントを表示
        logger.info(f"👥 登録済みエージェント: {list(self.agents.keys())}")
        logger.info("")
            
        # 2. 各タスクを順次実行
        for index, task in enumerate(pending_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
                
            # 反復回数チェック
            self.current_iteration += 1
            if self.current_iteration > self.max_iterations:
                logger.warning(f"⚠️ 最大反復回数 ({self.max_iterations}) に到達")
                logger.warning(f"残り {summary['total'] - index + 1} タスクをスキップします")
                summary['skipped'] = summary['total'] - index + 1
                break
                
            logger.info(f"\n{'─'*80}")
            logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
            logger.info(f"{'─'*80}")
                
            try:
                # 拡張機能を使用してタスクを実行
                if hasattr(self, 'execute_task_with_extensions'):
                    success = await self.execute_task_with_extensions(task)
                else:
                    # 拡張機能がない場合は標準メソッドを使用
                    success = await self.execute_task(task)
                    
                # 結果を記録
                task_result = {
                    'task_id': task_id,
                    'success': success,
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                if success:
                    summary['success'] += 1
                    logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                else:
                    summary['failed'] += 1
                    logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                    
                # タスク間に少し待機（負荷軽減）
                await asyncio.sleep(1)
                    
            except Exception as e:
                summary['failed'] += 1
                error_msg = f"タスク {task_id} 実行中のエラー: {str(e)}"
                logger.error(f"❌ {error_msg}")
                ErrorHandler.log_error(e, f"run_all_tasks - task {task_id}")
                    
                # エラーでもタスク結果を記録
                task_result = {
                    'task_id': task_id,
                    'success': False,
                    'error': str(e),
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                # 継続するか判断（重大エラーの場合は中断）
                if "critical" in str(e).lower():
                    logger.error("🚨 重大エラーのため処理を中断します")
                    summary['skipped'] = summary['total'] - index
                    break
            
        # 3. 実行結果サマリーを表示
        summary['end_time'] = datetime.now()
        elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
        logger.info("\n" + "="*80)
        logger.info("📊 全タスク実行完了 - 実行結果サマリー")
        logger.info("="*80)
        logger.info(f"  総タスク数:   {summary['total']:>3}件")
        logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
        logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
        logger.info(f"  ⏭️  スキップ:  {summary['skipped']:>3}件")
        logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
        logger.info("="*80 + "\n")
            
        # 成功率を計算
        if summary['total'] > 0:
            success_rate = (summary['success'] / summary['total']) * 100
            logger.info(f"📈 成功率: {success_rate:.1f}%")
                
            if success_rate >= 80:
                logger.info("🎉 良好な実行結果です！")
            elif success_rate >= 50:
                logger.info("⚠️ いくつかのタスクで問題が発生しています")
            else:
                logger.warning("🚨 多くのタスクが失敗しています。設定を確認してください")
            
        return summary
            
    except Exception as e:
        logger.error(f"❌ 全タスク実行中に予期しないエラー: {e}")
        ErrorHandler.log_error(e, "run_all_tasks")
        summary['end_time'] = datetime.now()
        return summary
        
    finally:
        # 最終的なクリーンアップ処理
        logger.info("\n🧹 タスク実行後のクリーンアップ...")
        self.current_iteration = 0  # 反復カウンターをリセット
        logger.info("✅ クリーンアップ完了\n")

async def run_tasks_by_agent(self, agent_role: str) -> Dict[str, Any]:
    """
    特定のエージェント担当のタスクのみを実行
        
    Args:
        agent_role: エージェントロール名（例: 'dev', 'design', 'review'）
            
    Returns:
        Dict: 実行結果サマリー
    """
    logger.info(f"\n🎯 エージェント '{agent_role}' のタスクを実行します\n")
        
    summary = {
        'agent': agent_role,
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # 全ペンディングタスクを取得
        all_tasks = await self.load_pending_tasks()
            
        # 指定エージェント担当のタスクのみフィルタ
        agent_tasks = [
            task for task in all_tasks 
            if task.get('required_role', task.get('assigned_to', '')).lower() == agent_role.lower()
        ]
            
        if not agent_tasks:
            logger.info(f"📭 エージェント '{agent_role}' のタスクがありません")
            return summary
            
        summary['total'] = len(agent_tasks)
        logger.info(f"📊 実行対象: {summary['total']}件\n")
            
        # タスクを順次実行
        for index, task in enumerate(agent_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
            logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                
            if hasattr(self, 'execute_task_with_extensions'):
                success = await self.execute_task_with_extensions(task)
            else:
                success = await self.execute_task(task)
                
            task_result = {
                'task_id': task_id,
                'success': success
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
            else:
                summary['failed'] += 1
                
            await asyncio.sleep(1)
            
        logger.info(f"\n✅ エージェント '{agent_role}' のタスク実行完了")
        logger.info(f"成功: {summary['success']}/{summary['total']}\n")
            
        return summary
            
    except Exception as e:
        logger.error(f"❌ エージェントタスク実行エラー: {e}")
        ErrorHandler.log_error(e, f"run_tasks_by_agent({agent_role})")
        return summary

async def retry_failed_tasks(self, max_retries: int = 3) -> Dict[str, Any]:
    """
    失敗したタスクを再試行
        
    Args:
        max_retries: 最大再試行回数
            
    Returns:
        Dict: 再試行結果サマリー
    """
    logger.info(f"\n🔄 失敗タスクの再試行を開始（最大{max_retries}回）\n")
        
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # 失敗ステータスのタスクを取得
        all_tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
        failed_tasks = [
            task for task in all_tasks 
            if task.get('status', '').lower() == 'failed'
        ]
            
        if not failed_tasks:
            logger.info("📭 再試行すべき失敗タスクがありません")
            return summary
            
        summary['total'] = len(failed_tasks)
        logger.info(f"📊 再試行対象: {summary['total']}件\n")
            
        for task in failed_tasks:
            task_id = task.get('task_id', 'UNKNOWN')
            retry_count = 0
            success = False
                
            while retry_count < max_retries and not success:
                retry_count += 1
                logger.info(f"🔄 タスク {task_id} - 再試行 {retry_count}/{max_retries}")
                    
                if hasattr(self, 'execute_task_with_extensions'):
                    success = await self.execute_task_with_extensions(task)
                else:
                    success = await self.execute_task(task)
                    
                if not success and retry_count < max_retries:
                    wait_time = retry_count * 2  # 指数バックオフ
                    logger.info(f"⏳ {wait_time}秒待機してから再試行...")
                    await asyncio.sleep(wait_time)
                
            task_result = {
                'task_id': task_id,
                'success': success,
                'retries': retry_count
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
                logger.info(f"✅ タスク {task_id} 再試行成功")
            else:
                summary['failed'] += 1
                logger.warning(f"❌ タスク {task_id} {max_retries}回の再試行後も失敗")
            
        logger.info(f"\n📊 再試行完了: 成功 {summary['success']}/{summary['total']}\n")
        return summary
            
    except Exception as e:
        logger.error(f"❌ 再試行処理エラー: {e}")
        ErrorHandler.log_error(e, "retry_failed_tasks")
        return summary

async def execute_task(self, task: Dict) -> bool:
    """
    個別タスクを実行（エラーハンドリング強化版）
        
    Args:
        task: タスク情報辞書
            
    Returns:
        bool: 実行成功フラグ
    """
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '')
    assigned_to = task.get('assigned_to', '')
        
    try:
        logger.info(f"\n{'='*60}")
        logger.info(f"🎯 タスク実行開始: {task_id}")
        logger.info(f"📝 内容: {description}")
        logger.info(f"👤 担当: {assigned_to}")
        logger.info(f"{'='*60}\n")
            
        # ステータスを'in_progress'に更新
        await self.update_task_status(task, 'in_progress')
            
        # エージェントが登録されているか確認
        if assigned_to not in self.agents:
            error_msg = f"エージェント '{assigned_to}' が登録されていません"
            logger.error(f"❌ {error_msg}")
            await self.update_task_status(task, 'failed', error_msg)
            return False
            
        # 担当エージェントを取得
        agent = self.agents[assigned_to]
            
        # エージェントにタスクを実行させる
        result = await agent.execute(task)
            
        # 結果を判定
        if result and result.get('success'):
            logger.info(f"✅ タスク {task_id} 完了")
            await self.update_task_status(task, 'completed')
            return True
        else:
            error_msg = result.get('error', '実行失敗') if result else '実行失敗'
            logger.warning(f"⚠️ タスク {task_id} 失敗: {error_msg}")
            await self.update_task_status(task, 'failed', error_msg)
            return False
                
    except Exception as e:
        error_msg = f"タスク実行中にエラー: {str(e)}"
        logger.error(f"❌ {error_msg}")
        ErrorHandler.log_error(e, f"execute_task({task_id})")
        await self.update_task_status(task, 'failed', error_msg)
        return False

async def run_all_tasks(self) -> Dict[str, Any]:
    """
    全タスクを一括実行（エラーハンドリング強化版）
        
    スプレッドシートからペンディングタスクを取得し、
    順次実行していきます。
        
    Returns:
        Dict: 実行結果サマリー
            {
                'total': 総タスク数,
                'success': 成功数,
                'failed': 失敗数,
                'skipped': スキップ数,
                'results': 各タスクの結果リスト
            }
    """
    logger.info("\n" + "="*80)
    logger.info("🚀 全タスク実行を開始します")
    logger.info("="*80 + "\n")
        
    # 実行結果を格納
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'skipped': 0,
        'results': [],
        'start_time': datetime.now(),
        'end_time': None
    }
        
    try:
        # 1. ペンディングタスクを取得
        pending_tasks = await self.load_pending_tasks()
            
        if not pending_tasks:
            logger.info("📭 実行すべきタスクがありません")
            summary['end_time'] = datetime.now()
            return summary
            
        summary['total'] = len(pending_tasks)
        logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            
        # 2. 各タスクを順次実行
        for index, task in enumerate(pending_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
                
            # 反復回数チェック
            self.current_iteration += 1
            if self.current_iteration > self.max_iterations:
                logger.warning(f"⚠️ 最大反復回数 ({self.max_iterations}) に到達")
                logger.warning(f"残り {summary['total'] - index + 1} タスクをスキップします")
                summary['skipped'] = summary['total'] - index + 1
                break
                
            logger.info(f"\n{'─'*80}")
            logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
            logger.info(f"{'─'*80}")
                
            try:
                # 拡張機能を使用してタスクを実行
                success = await self.execute_task_with_extensions(task)
                    
                # 結果を記録
                task_result = {
                    'task_id': task_id,
                    'success': success,
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                if success:
                    summary['success'] += 1
                    logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                else:
                    summary['failed'] += 1
                    logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                    
                # タスク間に少し待機（負荷軽減）
                await asyncio.sleep(1)
                    
            except Exception as e:
                summary['failed'] += 1
                error_msg = f"タスク {task_id} 実行中のエラー: {str(e)}"
                logger.error(f"❌ {error_msg}")
                ErrorHandler.log_error(e, f"run_all_tasks - task {task_id}")
                    
                # エラーでもタスク結果を記録
                task_result = {
                    'task_id': task_id,
                    'success': False,
                    'error': str(e),
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                # 継続するか判断（重大エラーの場合は中断）
                if "critical" in str(e).lower():
                    logger.error("🚨 重大エラーのため処理を中断します")
                    summary['skipped'] = summary['total'] - index
                    break
            
        # 3. 実行結果サマリーを表示
        summary['end_time'] = datetime.now()
        elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
        logger.info("\n" + "="*80)
        logger.info("📊 全タスク実行完了 - 実行結果サマリー")
        logger.info("="*80)
        logger.info(f"  総タスク数:   {summary['total']:>3}件")
        logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
        logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
        logger.info(f"  ⏭️  スキップ:  {summary['skipped']:>3}件")
        logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
        logger.info("="*80 + "\n")
            
        # 成功率を計算
        if summary['total'] > 0:
            success_rate = (summary['success'] / summary['total']) * 100
            logger.info(f"📈 成功率: {success_rate:.1f}%")
                
            if success_rate >= 80:
                logger.info("🎉 良好な実行結果です！")
            elif success_rate >= 50:
                logger.info("⚠️ いくつかのタスクで問題が発生しています")
            else:
                logger.warning("🚨 多くのタスクが失敗しています。設定を確認してください")
            
        return summary
            
    except Exception as e:
        logger.error(f"❌ 全タスク実行中に予期しないエラー: {e}")
        ErrorHandler.log_error(e, "run_all_tasks")
        summary['end_time'] = datetime.now()
        return summary
        
    finally:
        # 最終的なクリーンアップ処理
        logger.info("\n🧹 タスク実行後のクリーンアップ...")
        self.current_iteration = 0  # 反復カウンターをリセット
        logger.info("✅ クリーンアップ完了\n")

async def run_tasks_by_agent(self, agent_role: str) -> Dict[str, Any]:
    """
    特定のエージェント担当のタスクのみを実行
        
    Args:
        agent_role: エージェントロール名（例: 'dev', 'design', 'review'）
            
    Returns:
        Dict: 実行結果サマリー
    """
    logger.info(f"\n🎯 エージェント '{agent_role}' のタスクを実行します\n")
        
    summary = {
        'agent': agent_role,
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # 全ペンディングタスクを取得
        all_tasks = await self.load_pending_tasks()
            
        # 指定エージェント担当のタスクのみフィルタ
        agent_tasks = [
            task for task in all_tasks 
            if task.get('assigned_to', '').lower() == agent_role.lower()
        ]
            
        if not agent_tasks:
            logger.info(f"📭 エージェント '{agent_role}' のタスクがありません")
            return summary
            
        summary['total'] = len(agent_tasks)
        logger.info(f"📊 実行対象: {summary['total']}件\n")
            
        # タスクを順次実行
        for index, task in enumerate(agent_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
            logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                
            success = await self.execute_task_with_extensions(task)
                
            task_result = {
                'task_id': task_id,
                'success': success
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
            else:
                summary['failed'] += 1
                
            await asyncio.sleep(1)
            
        logger.info(f"\n✅ エージェント '{agent_role}' のタスク実行完了")
        logger.info(f"成功: {summary['success']}/{summary['total']}\n")
            
        return summary
            
    except Exception as e:
        logger.error(f"❌ エージェントタスク実行エラー: {e}")
        ErrorHandler.log_error(e, f"run_tasks_by_agent({agent_role})")
        return summary

async def retry_failed_tasks(self, max_retries: int = 3) -> Dict[str, Any]:
    """
    失敗したタスクを再試行
        
    Args:
        max_retries: 最大再試行回数
            
    Returns:
        Dict: 再試行結果サマリー
    """
    logger.info(f"\n🔄 失敗タスクの再試行を開始（最大{max_retries}回）\n")
        
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # 失敗ステータスのタスクを取得
        all_tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
        failed_tasks = [
            task for task in all_tasks 
            if task.get('status', '').lower() == 'failed'
        ]
            
        if not failed_tasks:
            logger.info("📭 再試行すべき失敗タスクがありません")
            return summary
            
        summary['total'] = len(failed_tasks)
        logger.info(f"📊 再試行対象: {summary['total']}件\n")
            
        for task in failed_tasks:
            task_id = task.get('task_id', 'UNKNOWN')
            retry_count = 0
            success = False
                
            while retry_count < max_retries and not success:
                retry_count += 1
                logger.info(f"🔄 タスク {task_id} - 再試行 {retry_count}/{max_retries}")
                    
                success = await self.execute_task_with_extensions(task)
                    
                if not success and retry_count < max_retries:
                    wait_time = retry_count * 2  # 指数バックオフ
                    logger.info(f"⏳ {wait_time}秒待機してから再試行...")
                    await asyncio.sleep(wait_time)
                
            task_result = {
                'task_id': task_id,
                'success': success,
                'retries': retry_count
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
                logger.info(f"✅ タスク {task_id} 再試行成功")
            else:
                summary['failed'] += 1
                logger.warning(f"❌ タスク {task_id} {max_retries}回の再試行後も失敗")
            
        logger.info(f"\n📊 再試行完了: 成功 {summary['success']}/{summary['total']}\n")
        return summary
            
    except Exception as e:
        logger.error(f"❌ 再試行処理エラー: {e}")
        ErrorHandler.log_error(e, "retry_failed_tasks")
        return summary

# ========================================
# 📦 拡張実行メソッド（オプション追加）
# ========================================

def execute_task_with_extensions(self, task: Dict) -> bool:
    """
    拡張モジュールを考慮したタスク実行
    
    新規モジュールが利用可能な場合は優先的に使用し、
    そうでなければ既存実装にフォールバック
    
    Args:
        task: タスク情報辞書
        
    Returns:
        bool: 実行成功フラグ
    """
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '').lower()
    
    try:
        # CLIタスク判定
        if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'コマンド実行']):
            logger.info(f"🔧 SystemCLIExecutor でタスク {task_id} を実行")
            import asyncio
            result = asyncio.run(self.cli_executor.execute_cli_task(task))
            return result.get('success', False) if isinstance(result, dict) else bool(result)
        
        # ワークフロータスク判定
        if self.workflow_executor and any(kw in description for kw in ['多言語', 'レビュー→修正', 'マルチステップ']):
            logger.info(f"🔄 WorkflowExecutor でタスク {task_id} を実行")
            import asyncio
            result = asyncio.run(self.workflow_executor.execute_workflow_task(task))
            return result.get('success', False) if isinstance(result, dict) else bool(result)
        
        # 既存実装にフォールバック
        logger.info(f"🔙 既存実装でタスク {task_id} を実行")
        import asyncio
        return asyncio.run(self.execute_task(task))
    
    except Exception as e:
        logger.error(f"❌ 拡張実行エラー: {e}")
        ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
        # エラー時も既存実装にフォールバック
        import asyncio
        return asyncio.run(self.execute_task(task))

# このメソッドをTaskExecutorクラスに追加
# TaskExecutor.execute_task_with_extensions = execute_task_with_extensions


# ========================================
# 使用例（main.py や起動スクリプト）
# ========================================

"""
# 既存の使い方（変更不要）
executor = TaskExecutor(sheets_manager, browser_controller)
await executor.execute_task(task)

# 拡張機能を使う場合（オプション）
if hasattr(executor, '_has_coordinator') and executor._has_coordinator:
    from task_executor.tas__init__ import TaskCoordinator
    
    coordinator = TaskCoordinator(
        task_executor=executor,
        sheets_manager=sheets_manager,
        browser_controller=browser_controller
    )
    
    await coordinator.run_all_tasks_coordinated()
else:
    # 既存実装
    await executor.run_all_tasks()
"""
# ========================================
# 🚨 緊急パッチ: run_all_tasks の追加
# ========================================

# TaskExecutor クラスの定義が終わった後、ファイルの末尾に以下を追加

def patch_task_executor():
    """TaskExecutor に run_all_tasks メソッドを動的に追加"""
    import inspect
    from datetime import datetime
    
    async def run_all_tasks(self) -> Dict[str, Any]:
        """全タスクを一括実行（動的パッチ版）"""
        logger.info("\n" + "="*80)
        logger.info("🚀 全タスク実行を開始します（動的パッチ版）")
        logger.info("="*80 + "\n")
        
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
        
        try:
            # ペンディングタスクを取得
            logger.info("📋 ペンディングタスクを読み込み中...")
            
            # load_pending_tasks メソッドを呼び出す
            if hasattr(self, 'load_pending_tasks'):
                pending_tasks = await self.load_pending_tasks()
            else:
                logger.error("❌ load_pending_tasks メソッドが見つかりません")
                return summary
            
            if not pending_tasks:
                logger.info("📭 実行すべきタスクがありません")
                logger.info("💡 スプレッドシートの 'pm_tasks' シートを確認してください")
                summary['end_time'] = datetime.now()
                return summary
            
            summary['total'] = len(pending_tasks)
            logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            
            # 各タスクを実行
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                logger.info(f"\n{'─'*80}")
                logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                logger.info(f"{'─'*80}")
                
                try:
                    # execute_task メソッドを呼び出す
                    if hasattr(self, 'execute_task'):
                        success = await self.execute_task(task)
                    elif hasattr(self, 'execute_task_with_extensions'):
                        success = await self.execute_task_with_extensions(task)
                    else:
                        logger.error(f"❌ タスク実行メソッドが見つかりません")
                        success = False
                    
                    if success:
                        summary['success'] += 1
                        logger.info(f"✅ タスク {task_id} 成功")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"⚠️ タスク {task_id} 失敗")
                    
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"❌ タスク {task_id} エラー: {e}")
            
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
            logger.info("\n" + "="*80)
            logger.info("📊 全タスク実行完了")
            logger.info("="*80)
            logger.info(f"  総タスク数:   {summary['total']:>3}件")
            logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
            logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
            logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
            logger.info("="*80 + "\n")
            
            return summary
            
        except Exception as e:
            logger.error(f"❌ 全タスク実行エラー: {e}")
            summary['end_time'] = datetime.now()
            return summary
    
    # TaskExecutor クラスにメソッドを動的に追加
    TaskExecutor.run_all_tasks = run_all_tasks
    logger.info("✅ TaskExecutor に run_all_tasks メソッドを動的に追加しました")

# パッチを適用
try:
    patch_task_executor()
except Exception as e:
    logger.error(f"❌ パッチ適用エラー: {e}")

#task_executor.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== 設定とユーティリティ =====
from config_utils import ErrorHandler, config

# ===== データ管理 =====
from sheets_manager import GoogleSheetsManager

# ===== エラーハンドラー（オプション） =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced未検出（標準エラーハンドラー使用）")

# ===== 分離モジュール =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPress連携（オプション） =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """タスク実行コントローラー(エラーハンドリング強化版)"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        初期化
        
        Args:
            sheets_manager: GoogleSheetsManager インスタンス
            browser_controller: BrowserController インスタンス(オプション)
            max_iterations: 最大反復回数
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: 最大反復回数 = {self.max_iterations}")
        
        # エージェントを自動初期化
        self._initialize_agents()
        
        # === 分離モジュール初期化 ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # 記事生成専用エグゼキュータ
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("✅ ContentTaskExecutor 初期化完了")
                
                # M&A専用エグゼキュータ
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("✅ MATaskExecutor 初期化完了")
                
                logger.info("="*60)
                logger.info("分離モジュール初期化完了")
                logger.info("  - ContentTaskExecutor (記事生成専用)")
                logger.info("  - MATaskExecutor (M&A/企業検索専用)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"⚠️ 分離モジュール初期化失敗: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("⚠️ 分離モジュールが利用できません")
            self.content_executor = None
            self.ma_executor = None
        
        # === WordPress開発専用エージェント初期化 ===
        logger.info("\n" + "="*60)
        logger.info("🔧 WordPress開発エージェント初期化中...")
        logger.info("="*60)
        
        # WordPress開発エージェント (wp_dev) の初期化
        self.wp_dev_agent = None
        try:
            from wordpress.wp_dev import WordPressDevAgent
            
            if self.browser:
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_dev'] = self.wp_dev_agent
                logger.info("✅ WordPressDevAgent (wp_dev) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラー未初期化のため wp_dev スキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ wordpress/wp_dev.py のインポート失敗: {e}")
            logger.info("💡 WordPress開発タスクは標準 dev エージェントで処理されます")
        except Exception as e:
            logger.warning(f"⚠️ wp_dev エージェント初期化エラー: {e}")
        
        # WordPress設計エージェント (wp_design) の初期化
        self.wp_design_agent = None
        try:
            from wordpress.wp_design import WordPressDesignAgent
            
            if self.browser:
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_design'] = self.wp_design_agent
                logger.info("✅ WordPressDesignAgent (wp_design) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラー未初期化のため wp_design スキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ wordpress/wp_design.py のインポート失敗: {e}")
            logger.info("💡 WordPress設計タスクは標準 design エージェントで処理されます")
        except Exception as e:
            logger.warning(f"⚠️ wp_design エージェント初期化エラー: {e}")
        
        logger.info("="*60)
        logger.info("WordPress専用エージェント初期化完了")
        if self.wp_dev_agent:
            logger.info("  - WordPressDevAgent (カスタム開発)")
        if self.wp_design_agent:
            logger.info("  - WordPressDesignAgent (テーマ/CSS)")
        logger.info("="*60)
        

        # ========================================
        # 🔍 レビューエージェント初期化（新規追加）
        # ========================================
        
        logger.info("\n" + "="*60)
        logger.info("🔍 レビューエージェント初期化中...")
        logger.info("="*60)
        
        # レビューエージェント (review) の初期化
        self.review_agent_instance = None
        try:
            from review_agent import ReviewAgent
            
            if self.browser:
                self.review_agent_instance = ReviewAgent(self.browser)
                if hasattr(self.review_agent_instance, 'sheets_manager'):
                    self.review_agent_instance.sheets_manager = self.sheets_manager
                
                self.agents['review'] = self.review_agent_instance
                logger.info("✅ ReviewAgent (review) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラ未初期化のため review エージェントスキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ review_agent.py のインポート失敗: {e}")
            logger.info("💡 レビュータスクは標準処理でスキップされます")
        except Exception as e:
            logger.warning(f"⚠️ review エージェント初期化エラー: {e}")
        
        logger.info("="*60)
        if self.review_agent_instance:
            logger.info("レビューエージェント初期化完了")
            logger.info("  - ReviewAgent (品質チェック・仕様確認)")
        else:
            logger.info("レビューエージェントは利用できません")
        logger.info("="*60)

        # ========================================
        # 📦 新規モジュール統合（__init__メソッド内に追加）
        # ========================================

        logger.info("\n" + "="*60)
        logger.info("📦 拡張モジュール統合チェック")
        logger.info("="*60)

        # task_executor.tas__init__ から新規モジュールをインポート
        try:
            from task_executor.tas__init__ import (
                TaskCoordinator,
                ContentTaskExecutor as NewContentExecutor,
                SystemCLIExecutor,
                WorkflowExecutor,
                HAS_COORDINATOR,
                HAS_CONTENT_EXECUTOR,
                HAS_CLI_EXECUTOR,
                HAS_WORKFLOW_EXECUTOR,
                print_module_status
            )
            
            # TaskCoordinator の初期化（オプション）
            if HAS_COORDINATOR:
                try:
                    logger.info("✅ TaskCoordinator 利用可能")
                    self._has_coordinator = True
                except Exception as e:
                    logger.warning(f"⚠️ TaskCoordinator 初期化スキップ: {e}")
                    self._has_coordinator = False
            else:
                logger.info("ℹ️ TaskCoordinator は配置されていません（オプション）")
                self._has_coordinator = False
            
            # 新規 ContentTaskExecutor の初期化（オプション）
            if HAS_CONTENT_EXECUTOR and NewContentExecutor:
                try:
                    self.new_content_executor = NewContentExecutor(
                        browser_controller=self.browser,
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("✅ 新規 ContentTaskExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ 新規 ContentTaskExecutor 初期化失敗: {e}")
                    self.new_content_executor = None
            else:
                logger.info("ℹ️ 新規 ContentTaskExecutor は配置されていません")
                self.new_content_executor = None
            
            # SystemCLIExecutor の初期化（オプション）
            if HAS_CLI_EXECUTOR and SystemCLIExecutor:
                try:
                    self.cli_executor = SystemCLIExecutor(
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("✅ SystemCLIExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ SystemCLIExecutor 初期化失敗: {e}")
                    self.cli_executor = None
            else:
                logger.info("ℹ️ SystemCLIExecutor は配置されていません")
                self.cli_executor = None
            
            # WorkflowExecutor の初期化（オプション）
            if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
                try:
                    self.workflow_executor = WorkflowExecutor(
                        task_executor=self,
                        sheets_manager=self.sheets_manager,
                        browser_controller=self.browser
                    )
                    logger.info("✅ WorkflowExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ WorkflowExecutor 初期化失敗: {e}")
                    self.workflow_executor = None
            else:
                logger.info("ℹ️ WorkflowExecutor は配置されていません")
                self.workflow_executor = None
            
            logger.info("="*60)
            logger.info("拡張モジュール統合完了")
            logger.info("="*60)

        except ImportError as e:
            logger.info("="*60)
            logger.info("ℹ️ 拡張モジュール未配置（既存機能のみ使用）")
            logger.info(f"詳細: {e}")
            logger.info("="*60)
            self._has_coordinator = False
            self.new_content_executor = None
            self.cli_executor = None
            self.workflow_executor = None

    def _initialize_agents(self):
        """エージェントの自動初期化"""
        logger.info("エージェントを初期化中...")
        # エージェントは外部から register_agent() で登録される
        logger.info("エージェント初期化完了")

    def register_agent(self, role: str, agent):
        """エージェントを登録"""
        self.agents[role] = agent
        logger.info(f"エージェント '{role}' を登録しました")

    def register_review_agent(self, review_agent):
        """レビューエージェントを登録"""
        self.review_agent = review_agent
        logger.info("レビューエージェントを登録しました")

    async def execute_task_with_extensions(self, task: Dict) -> bool:
        """
        拡張モジュールを考慮したタスク実行
        
        新規モジュールが利用可能な場合は優先的に使用し、
        そうでなければ既存実装にフォールバック
        
        Args:
            task: タスク情報辞書
            
        Returns:
            bool: 実行成功フラグ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            # CLIタスク判定
            if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'コマンド実行']):
                logger.info(f"🔧 SystemCLIExecutor でタスク {task_id} を実行")
                result = await self.cli_executor.execute_cli_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # ワークフロータスク判定
            if self.workflow_executor and any(kw in description for kw in ['多言語', 'レビュー→修正', 'マルチステップ']):
                logger.info(f"🔄 WorkflowExecutor でタスク {task_id} を実行")
                result = await self.workflow_executor.execute_workflow_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # 既存実装にフォールバック
            logger.info(f"🔙 既存実装でタスク {task_id} を実行")
            return await self.execute_task(task)
        
        except Exception as e:
            logger.error(f"❌ 拡張実行エラー: {e}")
            ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
            # エラー時も既存実装にフォールバック
            return await self.execute_task(task)

    async def load_pending_tasks(self) -> List[Dict]:
        """保留中のタスクを読み込む（エラーハンドリング強化版）"""
        try:
            logger.info("📋 保留中のタスクを読み込み中...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("📭 pm_tasksシートにタスクがありません")
                return []
            
            # statusが'pending'のタスクのみをフィルタ
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"📊 保留中のタスク: {len(pending_tasks)}件")
            
            # デバッグ情報
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... 他 {len(pending_tasks)-3}件")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー: {e}")
            return []

    async def update_task_status(self, task: Dict, status: str, **kwargs):
        """
        タスクステータス更新（引数統一版）
        
        Args:
            task: タスク辞書
            status: ステータス ('completed', 'failed', など)
            **kwargs: その他の引数（errorなど）
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # エラーメッセージの取得
            error_msg = kwargs.get('error', '')
            
            logger.info(f"💬 タスク {task_id} ステータス更新: {status}")
            if error_msg:
                logger.info(f"   エラー: {error_msg}")
            
            # シートマネージャーがある場合のみ更新
            if self.sheets_manager:
                try:
                    # ステータス列に書き込み
                    row = task.get('_row_index')
                    if row:
                        self.sheets_manager.ws.update_cell(row, 11, status)
                        
                        # エラーがある場合はメモ列に書き込み
                        if error_msg and status == 'failed':
                            self.sheets_manager.ws.update_cell(row, 12, f"エラー: {error_msg}")
                except Exception as e:
                    logger.warning(f"⚠️ シート更新失敗: {e}")
            
        except Exception as e:
            logger.warning(f"⚠️ ステータス更新エラー: {e}")
    
    async def execute_task(self, task: Dict) -> bool:
        """タスク実行（完全修正版）"""
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            print(f"\n{'='*70}")
            print(f"🎯 タスク: {task_id}")
            print(f"説明: {task.get('description', 'N/A')[:50]}...")
            print(f"{'='*70}\n")
            
            # ステータス更新
            await self.update_task_status(task, 'in_progress')
            
            role = task['required_role'].lower()
            
            # タイムアウト設定
            task_timeout = 180.0
            
            # エージェント取得
            agent = self.agents.get(role)
            
            if not agent:
                logger.error(f"❌ エージェント '{role}' が登録されていません")
                await self.update_task_status(task, 'failed', error=f'エージェント未登録: {role}')
                return False
            
            # タスク実行（execute または process_task）
            result = None
            
            try:
                if hasattr(agent, 'execute'):
                    logger.info(f"実行: {role}.execute()")
                    result = await asyncio.wait_for(
                        agent.execute(task),
                        timeout=task_timeout
                    )
                elif hasattr(agent, 'process_task'):
                    logger.info(f"実行: {role}.process_task()")
                    result = await asyncio.wait_for(
                        agent.process_task(task),
                        timeout=task_timeout
                    )
                else:
                    logger.error(f"❌ エージェント '{role}' にexecute/process_taskメソッドがありません")
                    await self.update_task_status(task, 'failed', error='メソッド不在')
                    return False
                
            except asyncio.TimeoutError:
                logger.error(f"⏱️ タイムアウト: {task_id}")
                await self.update_task_status(task, 'failed', error='タイムアウト')
                return False
            
            # 結果判定
            if result and result.get('success'):
                logger.info(f"✅ タスク完了: {task_id}")
                await self.update_task_status(task, 'completed')
                
                # 結果保存
                try:
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"⚠️ 結果保存失敗: {e}")
                
                
                # ========================================
                # 🔍 レビュータスク自動生成（新規追加）
                # ========================================
                try:
                    await self._generate_review_task_if_needed(task, result)
                except Exception as e:
                    logger.warning(f"⚠️ レビュータスク生成エラー: {e}")
                # ========================================
                                
                return True
            else:
                error = result.get('error', '不明') if result else '結果なし'
                logger.error(f"❌ タスク失敗: {error}")
                await self.update_task_status(task, 'failed', error=error)
                return False
        
        except Exception as e:
            logger.error(f"❌ タスク実行エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            try:
                await self.update_task_status(task, 'failed', error=str(e))
            except:
                pass
            
            return False
    
    def _determine_task_type_safe(self, task: Dict) -> str:
        """タスクタイプ判定（セーフ版）"""
        try:
            if HAS_TASK_ROUTER and task_router:
                return task_router.determine_task_type(task)
        except:
            pass
        
        # フォールバック判定
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
        
        if any(kw in description for kw in ['要件定義', 'requirements', 'wordpress']):
            return 'requirements'
        elif role in ['ma', 'content', 'review']:
            return role
        else:
            return 'default'
    
    async def _fallback_generic_task(self, task: Dict) -> Dict:
        """汎用フォールバック処理"""
        logger.warning(f"⚠️ エージェント不在 - 汎用処理")
        
        return {
            'success': True,
            'message': 'フォールバック処理完了',
            'summary': f'タスク {task.get("task_id")} を汎用処理で完了'
        }

    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """全タスクを一括実行"""
        logger.info("\n" + "="*80)
        logger.info("🚀 全タスク実行を開始します")
        logger.info("="*80 + "\n")
            
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
            
        try:
            logger.info("📋 ペンディングタスクを読み込み中...")
            pending_tasks = await self.load_pending_tasks()
                
            if not pending_tasks:
                logger.info("📭 実行すべきタスクがありません")
                summary['end_time'] = datetime.now()
                return summary
                
            summary['total'] = len(pending_tasks)
            logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            logger.info(f"👥 登録済みエージェント: {list(self.agents.keys())}\n")
                
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                    
                self.current_iteration += 1
                if self.current_iteration > self.max_iterations:
                    logger.warning(f"⚠️ 最大反復回数 ({self.max_iterations}) に到達")
                    summary['skipped'] = summary['total'] - index + 1
                    break
                    
                logger.info(f"\n{'─'*80}")
                logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                logger.info(f"{'─'*80}")
                    
                try:
                    success = await self.execute_task(task)
                        
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                        
                    if success:
                        summary['success'] += 1
                        logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                        
                    await asyncio.sleep(1)
                        
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"❌ タスク {task_id} エラー: {e}")
                
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
                
            logger.info("\n" + "="*80)
            logger.info("📊 全タスク実行完了")
            logger.info("="*80)
            logger.info(f"  総タスク数:   {summary['total']:>3}件")
            logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
            logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
            logger.info(f"  ⏭️  スキップ:  {summary['skipped']:>3}件")
            logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
            logger.info("="*80 + "\n")
                
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"📈 成功率: {success_rate:.1f}%")
                
            return summary
                
        except Exception as e:
            logger.error(f"❌ 全タスク実行エラー: {e}")
            ErrorHandler.log_error(e, "run_all_tasks")
            summary['end_time'] = datetime.now()
            return summary
            
        finally:
            logger.info("\n🧹 クリーンアップ...")
            self.current_iteration = 0
            logger.info("✅ 完了\n")
    
    async def _generate_review_task_if_needed(self, completed_task: Dict, result: Dict):
        """
        完了タスクに対してレビューが必要な場合、自動的にレビュータスクを生成
                
        Args:
            completed_task: 完了したタスク情報
            result: タスク実行結果
        """
        task_id = completed_task.get('task_id', 'UNKNOWN')
        role = completed_task.get('required_role', '').lower()
        description = completed_task.get('description', '').lower()
                
        # レビューが必要なタスクのキーワード
        review_trigger_keywords = [
            '要件定義', '詳細設計', 'カスタム投稿タイプ', 'acf設計',
            'テンプレート作成', 'テーマカスタマイズ', 'プラグイン開発',
            'requirements', 'design', 'template', 'custom post type'
        ]
                
        # レビューが必要なロール
        review_trigger_roles = ['dev', 'wp_dev', 'design', 'wp_design']
                
        # レビュータスク生成条件チェック
        should_create_review = False
                
        # キーワードベースのチェック
        if any(keyword in description for keyword in review_trigger_keywords):
            should_create_review = True
            logger.info(f"📋 タスク {task_id} はレビュー対象キーワードを含んでいます")
                
        # ロールベースのチェック
        if role in review_trigger_roles:
            should_create_review = True
            logger.info(f"📋 タスク {task_id} のロール '{role}' はレビュー対象です")
                
        # タスク結果に重要なアウトプットがある場合
        if result.get('output_path') or result.get('created_files'):
            should_create_review = True
            logger.info(f"📋 タスク {task_id} は成果物を生成しました")
                
        if not should_create_review:
            logger.debug(f"タスク {task_id} はレビュー不要と判断")
            return
                
        # レビュータスクの生成
        try:
            logger.info(f"🔍 タスク {task_id} のレビュータスクを生成中...")
                    
            # レビュータスクの説明文生成
            review_description = f"【レビュー】ID:{task_id} ({completed_task.get('description', '')[:30]}...) の成果物レビュー"
                    
            # 新しいタスクIDの生成
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            review_task_id = f"REVIEW_{task_id}_{timestamp}"
                    
            # レビュータスクデータ
            review_task_data = {
                'task_id': review_task_id,
                'description': review_description,
                'required_role': 'review',  # ← 重要: レビューエージェントを指定
                'status': 'pending',
                'priority': 'high',
                'parent_task_id': task_id,  # 元タスクへの参照
                'target_output': result.get('output_path', ''),
                'created_at': timestamp
            }
                    
            # Google Sheetsに追加
            if self.sheets_manager:
                try:
                    # pm_tasksシートに新規行を追加
                    new_row = [
                        review_task_id,
                        review_description,
                        'review',  # required_role
                        'high',    # priority
                        'pending', # status
                        '',        # assigned_to
                        '',        # started_at
                        '',        # completed_at
                        task_id,   # parent_task_id
                        result.get('output_path', ''),  # target_output
                        '',        # result
                        f'元タスク: {task_id}'  # memo
                    ]
                            
                    # シートに追加
                    ws = self.sheets_manager.ws
                    ws.append_row(new_row)
                            
                    logger.info(f"✅ レビュータスク {review_task_id} を生成しました")
                    logger.info(f"   対象: {task_id}")
                    logger.info(f"   説明: {review_description}")
                            
                except Exception as e:
                    logger.error(f"❌ レビュータスクのシート追加エラー: {e}")
            else:
                logger.warning("⚠️ sheets_manager が利用できません")
                        
        except Exception as e:
            logger.error(f"❌ レビュータスク生成エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
    
    

#task_executor_content.py
"""
task_executor_content.py
記事生成専用のタスク実行モジュール
task_executor.pyから分離
"""
import logging
from typing import Dict, List
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """記事生成タスク専用の実行クラス"""
    
    def __init__(self, agents: Dict):
        self.agents = agents
    
    async def execute_writer_task(self, task: Dict, role: str) -> Dict:
        """言語別ライタータスクを実行"""
        # === パート1: タスク情報の抽出 ===
        task_language = task.get('language')
        polylang_lang = task.get('polylang_lang')
        
        # === パート2: 実行開始ヘッダー ===
        logger.info("┌" + "─"*58 + "┐")
        logger.info(f"│ ✏️ ライターAIエージェント実行中 ({role})")
        logger.info("├" + "─"*58 + "┤")
        logger.info(f"│ 言語: {task_language}")
        logger.info(f"│ Polylang: {polylang_lang}")
        logger.info("└" + "─"*58 + "┘")
        
        # === パート3: エージェントの選択と実行 ===
        if role == 'writer' or role == 'content':
            # === パート3-1: 汎用ライターの処理 ===
            logger.info("📝 汎用ライターを使用(後方互換性モード)")
            agent = self.agents.get('writer')
            if not agent:
                logger.error("❌ writerエージェントが登録されていません")
                return {
                    'success': False,
                    'error': 'writer エージェントが登録されていません'
                }
            result = await agent.process_task(task)
        else:
            # === パート3-2: 言語別ライターの処理 ===
            agent = self.agents.get(role)
            if not agent:
                logger.error(f"❌ {role}エージェントが登録されていません")
                return {
                    'success': False,
                    'error': f'未対応の言語ライター: {role}'
                }
            
            # === パート3-3: 言語確認 ===
            if task_language and hasattr(agent, 'get_language_code'):
                if agent.get_language_code() != task_language:
                    logger.warning(f"⚠️ 言語不一致: タスク={task_language}, ライター={agent.get_language_code()}")
            
            result = await agent.process_task(task)
        
        # === パート4: 結果の処理 ===
        if result.get('success'):
            logger.info(f"✅ ライターAI ({role}): タスク完了")
            # 言語情報を追加
            if hasattr(agent, 'get_language_code'):
                result['language'] = agent.get_language_code()
                result['polylang_lang'] = polylang_lang or agent.get_language_code()
        else:
            logger.error(f"❌ ライターAI ({role}): 失敗 - {result.get('error', '不明')}")
        
        return result
    
    def display_suggested_tasks(self, suggested_tasks: List[Dict]):
        """提案タスクの詳細を表示"""
        # === パート1: ヘッダー表示 ===
        print("\n" + "="*60)
        print("提案タスク詳細")
        print("="*60)

        # === パート2: 各タスクの詳細表示 ===
        for i, task in enumerate(suggested_tasks, 1):
            # === パート2-1: 優先度マークの設定 ===
            priority_mark = {
                'high': '🔴[高]',
                'medium': '🟡[中]', 
                'low': '🟢[低]'
            }.get(task.get('priority', 'medium'), '⚪[中]')
        
            # === パート2-2: 役割ラベルの設定 ===
            role_label = {
                'design': '📐[設計]',
                'dev': '💻[開発]',
                'ui': '🎨[UI]',
                'review': '✅[レビュー]',
                'wordpress': '🌐[WordPress]',
                'writer': '✏️[ライター]',
                'writer_ja': '🇯🇵[日本語]',
                'writer_en': '🇬🇧[英語]',
                'writer_ru': '🇷🇺[ロシア語]',
                'content': '📄[コンテンツ]'
            }.get(task.get('required_role', 'dev'), '📋[タスク]')
        
            # === パート2-3: タスク情報の表示 ===
            print(f"\n{i}. {priority_mark} {role_label} {task.get('description', 'N/A')}")
            print(f"   理由: {task.get('reasoning', 'N/A')}")
            print(f"   担当: {task.get('required_role', 'dev')}")
            print(f"   優先度: {task.get('priority', 'medium')}")

        # === パート3: フッター表示 ===
        print("="*60)
    
    async def edit_suggested_tasks(self, suggested_tasks: List[Dict]) -> List[Dict]:
        """提案タスクを編集"""
        try:
            # === パート1: 変数初期化 ===
            edited_tasks = []
        
            # === パート2: 各タスクの編集ループ ===
            for i, task in enumerate(suggested_tasks, 1):
                # === パート2-1: 現在のタスク情報表示 ===
                print(f"\n--- タスク {i}/{len(suggested_tasks)} の編集 ---")
                print(f"現在の内容:")
                print(f"  説明: {task.get('description', '')}")
                print(f"  担当: {task.get('required_role', 'dev')}")
                print(f"  優先度: {task.get('priority', 'medium')}")
                print(f"  理由: {task.get('reasoning', '')}")
            
                # === パート2-2: 編集オプション表示 ===
                print(f"\n編集オプション:")
                print("  (d)説明を変更 / (r)担当を変更 / (p)優先度を変更 / (e)理由を変更")
                print("  (s)このタスクをスキップ / (k)このタスクを保持 / (q)編集を終了")
            
                # === パート2-3: ユーザー入力の取得 ===
                edit_choice = input("選択: ").lower()
            
                # === パート2-4: 各選択肢の処理 ===
                if edit_choice == 'd':
                    # 説明変更
                    new_desc = input("新しい説明: ").strip()
                    if new_desc:
                        task['description'] = new_desc
                    edited_tasks.append(task)
                
                elif edit_choice == 'r':
                    # 担当変更
                    print("利用可能な担当:")
                    print("  design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                    new_role = input("新しい担当: ").strip()
                    valid_roles = ['design', 'dev', 'ui', 'review', 'wordpress', 'writer', 
                                'writer_ja', 'writer_en', 'writer_ru', 'writer_uz', 
                                'writer_zh', 'writer_ko', 'writer_tr', 'plugin', 'content']
                    if new_role in valid_roles:
                        task['required_role'] = new_role
                    else:
                        print("無効な担当です。変更しません。")
                    edited_tasks.append(task)
                
                elif edit_choice == 'p':
                    # 優先度変更
                    print("優先度: high, medium, low")
                    new_priority = input("新しい優先度: ").strip()
                    if new_priority in ['high', 'medium', 'low']:
                        task['priority'] = new_priority
                    else:
                        print("無効な優先度です。変更しません。")
                    edited_tasks.append(task)
                
                elif edit_choice == 'e':
                    # 理由変更
                    new_reason = input("新しい理由: ").strip()
                    if new_reason:
                        task['reasoning'] = new_reason
                    edited_tasks.append(task)
                
                elif edit_choice == 's':
                    # スキップ
                    print(f"タスク {i} をスキップしました")
                    continue
                
                elif edit_choice == 'k':
                    # 保持
                    edited_tasks.append(task)
                    print(f"タスク {i} をそのまま保持しました")
                
                elif edit_choice == 'q':
                    # 編集終了
                    print("編集を終了します")
                    break
                
                else:
                    # 不正な入力
                    print("不正な入力です。タスクをそのまま保持します。")
                    edited_tasks.append(task)
        
            # === パート3: 編集結果の表示 ===
            if edited_tasks:
                print(f"\n編集後のタスク ({len(edited_tasks)}件):")
                self.display_suggested_tasks(edited_tasks)
            
            return edited_tasks
        
        except Exception as e:
            # === パート4: 例外処理 ===
            ErrorHandler.log_error(e, "タスク編集")
            return suggested_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """手動でタスクを作成"""
        try:
            # === パート1: 変数初期化 ===
            manual_tasks = []
            
            # === パート2: 作成開始ヘッダー ===
            print("\n" + "="*60)
            print("手動タスク作成")
            print("="*60)
            print("新しいタスクを手動で作成します。")
            print("空の説明で終了します。")
            
            # === パート3: タスク作成ループ ===
            while True:
                # === パート3-1: タスクヘッダー表示 ===
                print(f"\n--- タスク {len(manual_tasks) + 1} ---")
                
                # === パート3-2: タスク説明の入力 ===
                description = input("タスク説明: ").strip()
                if not description:
                    break
                    
                # === パート3-3: 担当の入力 ===
                print("利用可能な担当: design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                role = input("担当 (デフォルト: dev): ").strip() or "dev"
                
                # === パート3-4: 優先度の入力 ===
                print("優先度: high, medium, low")
                priority = input("優先度 (デフォルト: medium): ").strip() or "medium"
                
                # === パート3-5: 理由の入力 ===
                reasoning = input("理由: ").strip()
                
                # === パート3-6: タスクオブジェクトの作成 ===
                task = {
                    'description': description,
                    'required_role': role,
                    'priority': priority,
                    'reasoning': reasoning
                }
                
                # === パート3-7: タスクリストへの追加 ===
                manual_tasks.append(task)
                print(f"タスクを追加しました (合計: {len(manual_tasks)}件)")
                
                # === パート3-8: 継続確認 ===
                more = input("さらにタスクを追加しますか? (y/n): ").lower()
                if more != 'y':
                    break
            
            # === パート4: 作成結果の表示 ===
            if manual_tasks:
                print(f"\n作成したタスク ({len(manual_tasks)}件):")
                self.display_suggested_tasks(manual_tasks)
                
            return manual_tasks
            
        except Exception as e:
            # === パート5: 例外処理 ===
            ErrorHandler.log_error(e, "手動タスク作成")
            return []

#task_executor_ma.py
"""
task_executor_ma.py
M&A/企業検索専用のタスク実行モジュール（完全版）
task_executor.pyから分離
"""
import asyncio
import logging
from typing import Dict, Optional, Any, List
from datetime import datetime
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class MATaskExecutor:
    """M&A/企業検索タスク専用の実行クラス"""

    def __init__(self, sheets_manager, browser, max_iterations: int = 30):
        """
        MATaskExecutorの初期化
    
        Args:
            sheets_manager: Google Sheetsマネージャー
            browser: ブラウザコントローラー
            max_iterations: 最大イテレーション数（デフォルト30）
        """
        # === パート1: 基本プロパティの設定 ===
        self.sheets_manager = sheets_manager
        self.browser = browser
        self.max_iterations = max_iterations
        self.agents = {}  # エージェント辞書を空で初期化
        self.review_agent = None  # レビューエージェント用の属性
    
        logger.info(f"MATaskExecutor initialized (max_iterations={max_iterations})")
    
    # === 追加メソッド: エージェント登録機能 ===
    def register_agent(self, agent_name: str, agent):
        """
        エージェントを登録
        
        Args:
            agent_name: エージェント名（例: 'wordpress', 'plugin'）
            agent: エージェントインスタンス
        """
        self.agents[agent_name] = agent
        logger.info(f"✅ エージェント '{agent_name}' を登録しました")
    
    # ========================================
    # ✅ ここに追加: レビューエージェント登録メソッド
    # ========================================
    def register_review_agent(self, review_agent):
        """
        レビューエージェントを登録
        
        Args:
            review_agent: ReviewAgentインスタンス
        """
        self.review_agent = review_agent
        self.agents['review'] = review_agent  # agentsディクショナリにも登録
        logger.info("✅ レビューエージェントを登録しました")
    
    # ========================================
    # ✅ ここに追加: タスク読み込みメソッド（互換性のため）
    # ========================================
    async def load_pending_tasks(self):
        """
        保留中のタスクを読み込む
        
        Returns:
            List[Dict]: pendingステータスのタスクリスト
        """
        try:
            logger.info("📋 保留中のタスクを読み込み中...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("🔭 pm_tasksシートにタスクがありません")
                return []
            
            # statusが'pending'のタスクのみをフィルタ
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"📊 保留中のタスク: {len(pending_tasks)}件")
            return pending_tasks
            
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー: {e}")
            return []
    
    # ========================================
    # ✅ ここに追加: タスク実行メソッド（互換性のため）
    # ========================================
    async def execute_task(self, task: Dict) -> bool:
        """
        タスクを実行（基本的な実装）
        
        Args:
            task: タスク情報辞書
            
        Returns:
            bool: 実行成功フラグ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info(f"🎯 タスク実行開始: {task_id}")
            
            # M&Aタスクとして実行
            result = await self.execute_ma_task(task)
            
            if result and result.get('success'):
                logger.info(f"✅ タスク完了: {task_id}")
                return True
            else:
                error = result.get('error', '不明') if result else '結果なし'
                logger.error(f"❌ タスク失敗: {error}")
                return False
                
        except Exception as e:
            logger.error(f"❌ タスク実行エラー: {e}")
            return False
    
    # ========================================
    # ✅ ここに追加: 全タスク実行メソッド（互換性のため）
    # ========================================
    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """
        全タスクを一括実行
        
        Args:
            auto_continue: 自動継続フラグ
            enable_review: レビュー有効化フラグ
            
        Returns:
            Dict: 実行結果サマリー
        """
        from datetime import datetime
        
        logger.info("\n" + "="*80)
        logger.info("🚀 全タスク実行を開始します")
        logger.info("="*80 + "\n")
        
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
        
        try:
            # 保留中のタスクを読み込み
            pending_tasks = await self.load_pending_tasks()
            
            if not pending_tasks:
                logger.info("🔭 実行すべきタスクがありません")
                summary['end_time'] = datetime.now()
                return summary
            
            summary['total'] = len(pending_tasks)
            logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            
            # タスクを順番に実行
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                
                logger.info(f"\n{'─'*80}")
                logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                logger.info(f"{'─'*80}")
                
                try:
                    success = await self.execute_task(task)
                    
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                    
                    if success:
                        summary['success'] += 1
                        logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                    
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"❌ タスク {task_id} エラー: {e}")
            
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
            logger.info("\n" + "="*80)
            logger.info("📊 全タスク実行完了")
            logger.info("="*80)
            logger.info(f"  総タスク数:   {summary['total']:>3}件")
            logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
            logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
            logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
            logger.info("="*80 + "\n")
            
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"📈 成功率: {success_rate:.1f}%")
            
            return summary
            
        except Exception as e:
            logger.error(f"❌ 全タスク実行エラー: {e}")
            summary['end_time'] = datetime.now()
            return summary

    async def execute_ma_task(self, task: Dict) -> Dict:
        """
        M&A関連タスクを実行
    
        タスクの内容を解析して、適切なメソッドに振り分ける
        """
        try:
            # === パート1: 実行開始ヘッダー ===
            logger.info("="*60)
            logger.info("📊 M&A案件処理タスク実行")
            logger.info("="*60)
        
            # === パート2: タスク内容の解析 ===
            description = task.get('description', '').lower()
            parameters = task.get('parameters', {})
        
            # === パート3: パラメータベースの判定（最も確実）===
            if 'cpt_slug' in parameters or 'cpt_labels' in parameters:
                logger.info("→ Custom Post Type作成タスクと判定")
                return await self._execute_cpt_creation(task)
        
            elif 'acf_field_group_name' in parameters or 'acf_fields' in parameters:
                logger.info("→ ACF設定タスクと判定")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy_slug' in parameters or 'taxonomy_labels' in parameters:
                logger.info("→ タクソノミー作成タスクと判定")
                return await self._execute_taxonomy_creation(task)
        
            elif 'facets' in parameters or 'facetwp' in description:
                logger.info("→ 検索機能設定タスクと判定")
                return await self._execute_search_setup(task)
        
            elif 'role_slug' in parameters or 'role_name' in parameters:
                logger.info("→ ユーザーロール設定タスクと判定")
                return await self._execute_user_role_setup(task)
        
            # === パート4: キーワードベースの判定 ===
            elif 'custom post type' in description or 'カスタム投稿タイプ' in description:
                logger.info("→ Custom Post Type作成タスクと判定（キーワード）")
                return await self._execute_cpt_creation(task)
        
            elif 'acf' in description or 'カスタムフィールド' in description:
                logger.info("→ ACF設定タスクと判定（キーワード）")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy' in description or 'タクソノミー' in description:
                logger.info("→ タクソノミー作成タスクと判定（キーワード）")
                return await self._execute_taxonomy_creation(task)
        
            elif 'm&a案件' in description or 'ma_case' in description:
                logger.info("→ M&A案件投稿タスクと判定")
                return await self._execute_ma_case_post(task)
        
            elif '検索' in description or 'search' in description:
                logger.info("→ 検索機能設定タスクと判定")
                return await self._execute_search_setup(task)
        
            elif 'user role' in description or 'ユーザーロール' in description:
                logger.info("→ ユーザーロール設定タスクと判定")
                return await self._execute_user_role_setup(task)
        
            else:
                # === パート5: デフォルト処理 ===
                logger.info("→ 汎用WordPressタスクとして処理")
                wp_agent = self.agents.get('wordpress')
                if wp_agent:
                    return await wp_agent.process_task(task)
                else:
                    return {
                        'success': False,
                        'error': 'WordPressエージェントが登録されていません'
                    }
    
        except Exception as e:
            # === パート6: 例外処理 ===
            ErrorHandler.log_error(e, "M&Aタスク実行")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_cpt_creation(self, task: Dict) -> Dict:
        """Custom Post Type作成タスクを実行"""
        logger.info("【Custom Post Type作成】")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'cpt_slug': parameters.get('cpt_slug', 'ma_case'),
            'cpt_labels': parameters.get('cpt_labels', {
                'singular': 'M&A案件',
                'plural': 'M&A案件一覧'
            }),
            'cpt_supports': parameters.get('cpt_supports', ['title', 'editor', 'thumbnail', 'custom-fields']),
            'cpt_settings': parameters.get('cpt_settings', {
                'public': True,
                'has_archive': True,
                'show_in_rest': True,
                'menu_icon': 'dashicons-portfolio'
            })
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'configure_custom_post_type'):
            result = await wp_agent.configure_custom_post_type(task_params)
        else:
            logger.warning("configure_custom_post_type メソッドが見つかりません")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_acf_setup(self, task: Dict) -> Dict:
        """ACFフィールド設定タスクを実行"""
        logger.info("【ACFフィールド設定】")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'acf_field_group_name': parameters.get('acf_field_group_name', 'M&A案件基本情報'),
            'acf_fields': parameters.get('acf_fields', [
                {'name': 'case_id', 'type': 'text', 'label': '案件ID'},
                {'name': 'ma_scheme', 'type': 'select', 'label': 'M&Aスキーム'},
                {'name': 'desired_price', 'type': 'number', 'label': '希望価格'},
                {'name': 'industry_category', 'type': 'taxonomy', 'label': '業種'},
                {'name': 'region', 'type': 'taxonomy', 'label': '地域'},
                {'name': 'established_year', 'type': 'number', 'label': '設立年'},
                {'name': 'employees', 'type': 'number', 'label': '従業員数'},
            ]),
            'acf_location_rules': parameters.get('acf_location_rules', {
                'post_type': 'ma_case'
            })
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'configure_acf_fields'):
            result = await wp_agent.configure_acf_fields(task_params)
        else:
            logger.warning("configure_acf_fields メソッドが見つかりません")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_taxonomy_creation(self, task: Dict) -> Dict:
        """カスタムタクソノミー作成タスクを実行"""
        logger.info("【カスタムタクソノミー作成】")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'taxonomy_slug': parameters.get('taxonomy_slug', 'industry_category'),
            'taxonomy_labels': parameters.get('taxonomy_labels', {
                'singular': '業種',
                'plural': '業種一覧'
            }),
            'taxonomy_post_types': parameters.get('taxonomy_post_types', ['ma_case']),
            'taxonomy_hierarchical': parameters.get('taxonomy_hierarchical', True)
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'configure_custom_taxonomy'):
            result = await wp_agent.configure_custom_taxonomy(task_params)
        else:
            logger.warning("configure_custom_taxonomy メソッドが見つかりません")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_ma_case_post(self, task: Dict) -> Dict:
        """M&A案件投稿タスクを実行"""
        logger.info("【M&A案件投稿】")

        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            # === パート1: WordPressエージェント未登録エラー ===
            logger.error("❌ WordPressエージェントが登録されていません")
            logger.error("登録済みエージェント一覧:")
            for agent_name in self.agents.keys():
                logger.error(f"  - {agent_name}")
        
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません。test_tasks.pyでエージェント登録を確認してください。'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'post_type': 'ma_case',
            'post_title': parameters.get('post_title', '新規M&A案件'),
            'post_content': parameters.get('post_content', ''),
            'acf_fields': parameters.get('acf_fields', {}),
            'polylang_lang': parameters.get('polylang_lang', 'ja'),
            'post_status': parameters.get('post_status', 'draft')
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'create_ma_case_post'):
            result = await wp_agent.create_ma_case_post(task_params)
        else:
            logger.warning("create_ma_case_post メソッドが見つかりません")
            # フォールバック: 通常の投稿作成
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_search_setup(self, task: Dict) -> Dict:
        """検索機能設定タスクを実行"""
        logger.info("【検索機能設定】")

        # === パート1: プラグインエージェント取得（フォールバック付き） ===
        plugin_agent = self.agents.get('plugin')

        # プラグインエージェントがない場合、WordPressエージェントから取得を試みる
        if not plugin_agent:
            logger.warning("⚠️ plugin エージェントが直接登録されていません")
        
            wp_agent = self.agents.get('wordpress')
            if wp_agent and hasattr(wp_agent, 'plugin_manager'):
                plugin_agent = wp_agent.plugin_manager
                logger.info("✅ WordPressエージェントからplugin_managerを取得しました")
            else:
                logger.error("❌ プラグインエージェントが見つかりません")
                return {
                    'success': False,
                    'error': 'プラグインエージェントが登録されていません。WordPressエージェントを確認してください。'
                }
        
        parameters = task.get('parameters', {})
        
        # FacetWP設定タスクとして実行
        task_params = {
            'plugin_name': 'facetwp',
            'action': 'configure',
            'facets': parameters.get('facets', [
                {
                    'name': '業種フィルター',
                    'type': 'checkboxes',
                    'source': 'tax/industry_category'
                },
                {
                    'name': '価格帯フィルター',
                    'type': 'slider',
                    'source': 'cf/desired_price',
                    'min': 0,
                    'max': 1000000000,
                    'step': 10000000
                },
                {
                    'name': '地域フィルター',
                    'type': 'dropdown',
                    'source': 'tax/region'
                }
            ])
        }
        
        # プラグインエージェントで実行
        if hasattr(plugin_agent, 'configure_facetwp'):
            result = await plugin_agent.configure_facetwp(task_params)
        else:
            logger.warning("configure_facetwp メソッドが見つかりません")
            result = await plugin_agent.change_plugin_settings(None, task)
        
        return result
    
    async def _execute_user_role_setup(self, task: Dict) -> Dict:
        """ユーザーロール設定タスクを実行"""
        logger.info("【ユーザーロール設定】")
    
        # === パート1: プラグインエージェント取得（フォールバック付き） ===
        plugin_agent = self.agents.get('plugin')
    
        # プラグインエージェントがない場合、WordPressエージェントから取得を試みる
        if not plugin_agent:
            logger.warning("⚠️ plugin エージェントが直接登録されていません")
        
            wp_agent = self.agents.get('wordpress')
            if wp_agent and hasattr(wp_agent, 'plugin_manager'):
                plugin_agent = wp_agent.plugin_manager
                logger.info("✅ WordPressエージェントからplugin_managerを取得しました")
            else:
                logger.error("❌ プラグインエージェントが見つかりません")
                return {
                    'success': False,
                    'error': 'プラグインエージェントが登録されていません。WordPressエージェントを確認してください。'
                }
        
        parameters = task.get('parameters', {})
        
        # User Role Editor設定タスクとして実行
        task_params = {
            'plugin_name': 'user-role-editor',
            'action': 'configure',
            'role_slug': parameters.get('role_slug', 'ma_partner'),
            'role_name': parameters.get('role_name', '提携パートナー'),
            'capabilities': parameters.get('capabilities', {
                'read': True,
                'edit_posts': True,
                'delete_posts': True,
                'edit_published_posts': True,
                'publish_posts': False
            })
        }
        
        # プラグインエージェントで実行
        if hasattr(plugin_agent, 'configure_user_roles'):
            result = await plugin_agent.configure_user_roles(None, task_params)
        else:
            logger.warning("configure_user_roles メソッドが見つかりません")
            result = await plugin_agent.change_plugin_settings(None, task)
        
        return result
    
def validate_ma_task(self, task: Dict) -> tuple[bool, Optional[str]]:
    """
    M&Aタスクのパラメータを検証
        
    Returns:
        (valid: bool, error_message: Optional[str])
    """
    try:
        parameters = task.get('parameters', {})
            
        # === パート1: Custom Post Type作成の検証 ===
        if 'cpt_slug' in parameters:
            if not parameters['cpt_slug']:
                return False, "cpt_slugが空です"
            if not parameters['cpt_slug'].replace('_', '').isalnum():
                return False, "cpt_slugは英数字とアンダースコアのみ使用可能です"
            
        # === パート2: ACF設定の検証 ===
        if 'acf_field_group_name' in parameters:
            if not parameters['acf_field_group_name']:
                return False, "acf_field_group_nameが空です"
                
            acf_fields = parameters.get('acf_fields', [])
            if not isinstance(acf_fields, list):
                return False, "acf_fieldsはリスト形式である必要があります"
                
            for field in acf_fields:
                if 'name' not in field or 'type' not in field:
                    return False, "ACFフィールドにはnameとtypeが必要です"
            
        # === パート3: タクソノミー作成の検証 ===
        if 'taxonomy_slug' in parameters:
            if not parameters['taxonomy_slug']:
                return False, "taxonomy_slugが空です"
            if not parameters['taxonomy_slug'].replace('_', '').isalnum():
                return False, "taxonomy_slugは英数字とアンダースコアのみ使用可能です"
            
        # === パート4: 検証成功 ===
        return True, None
            
    except Exception as e:
        # === パート5: 検証中の例外処理 ===
        return False, f"検証エラー: {str(e)}"

#test_tasks - コピー.py
# test_tasks.py
"""
pm_tasksシートの既存タスクをテスト実行するデバッグスクリプト

使い方:
  python test_tasks.py                    # 全pending タスクを実行
  python test_tasks.py --task-id 5        # 特定のタスクIDのみ実行
  python test_tasks.py --role writer      # 特定の役割のタスクのみ実行
  python test_tasks.py --auto             # 自動実行（確認なし）
"""
import asyncio
import logging
import argparse
from pathlib import Path

from config_utils import config, ErrorHandler, PathManager
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from task_executor import TaskExecutor

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)


class TaskTester:
    """既存タスクのテスト実行用クラス"""
    
    def __init__(self, spreadsheet_id: str, service_account_file: str = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.sheets_manager = None
        self.browser = None
        self.task_executor = None
    
    async def initialize(self):
        """システム初期化"""
        try:
            logger.info("="*60)
            logger.info("タスクテスターを初期化中...")
            logger.info("="*60)
            
            # === パート1: Google Sheets接続と基本設定読み込み ===
            logger.info("📊 Google Sheets接続中...")
            
            # Google Sheets接続
            self.sheets_manager = GoogleSheetsManager(
                self.spreadsheet_id, 
                self.service_account_file
            )
            
            # PC_IDを取得して設定を読み込み
            pc_id = self.sheets_manager.get_current_pc_id()
            settings = self.sheets_manager.load_pc_settings(pc_id)
            
            # === パート2: 出力フォルダとブラウザ設定 ===
            logger.info("📁 出力フォルダ設定中...")
            
            # 出力フォルダの設定
            agent_output = settings.get('agent_output_folder')
            if not agent_output or agent_output.startswith('http'):
                download_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                download_folder.mkdir(exist_ok=True, parents=True)
            else:
                download_folder = PathManager.get_safe_path(agent_output)
            
            logger.info(f"出力フォルダ: {download_folder}")
            
            # === パート3: BrowserController初期化 ===
            logger.info("🌐 ブラウザ初期化中...")
            
            # BrowserControllerを初期化
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            self.browser = BrowserController(
                download_folder, 
                mode='text', 
                service='google'
            )
            await self.browser.setup_browser()
            await self.browser.navigate_to_gemini()
            
            # === パート4: TaskExecutor初期化 ===
            logger.info("⚙️ タスク実行エンジン初期化中...")
            
            # TaskExecutorを初期化
            self.task_executor = TaskExecutor(
                self.sheets_manager,
                self.browser,
                max_iterations=1  # テストモードは1回のみ
            )
            
            # === パート5: 各エージェントの登録 ===
            logger.info("🤖 エージェント登録中...")
            
            # ★★★ 各種エージェントの初期化と登録 ★★★
            
            # 1. Design Agent
            try:
                from design_agent import DesignAgent
                design_agent = DesignAgent(self.browser)
                self.task_executor.register_agent('design', design_agent)
                logger.info("✅ Design Agent登録完了")
            except ImportError:
                logger.warning("⚠️ design_agent が見つかりません")
            
            # 2. Dev Agent
            try:
                from dev_agent import DevAgent
                dev_agent = DevAgent(self.browser)
                self.task_executor.register_agent('dev', dev_agent)
                logger.info("✅ Dev Agent登録完了")
            except ImportError:
                logger.warning("⚠️ dev_agent が見つかりません")
            
            # 3. Review Agent
            try:
                from review_agent import ReviewAgent
                review_agent = ReviewAgent()
                review_agent.browser = self.browser
                review_agent.sheets_manager = self.sheets_manager
                self.task_executor.register_review_agent(review_agent)
                logger.info("✅ Review Agent登録完了")
            except ImportError:
                logger.warning("⚠️ review_agent が見つかりません")
            
            # 4. Content Writer Agents
            try:
                from content_writer_agent import ContentWriterAgent
                content_writer = ContentWriterAgent(self.browser)
                self.task_executor.register_agent('writer', content_writer)
                self.task_executor.register_agent('content', content_writer)
                logger.info("✅ Content Writer Agent登録完了")
            except ImportError:
                logger.warning("⚠️ content_writer_agent が見つかりません")
            
            # 5. WordPress Agent（重要！）
            logger.info("🗄️ WordPress Agent設定中...")
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
            
            if wp_url and wp_user and wp_pass:
                try:
                    from wordpress.wp_agent import WordPressAgent
                    
                    wp_credentials = {
                        'wp_url': wp_url,
                        'wp_user': wp_user,
                        'wp_pass': wp_pass
                    }
                    
                    wordpress_agent = WordPressAgent(self.browser, wp_credentials)
                    wordpress_agent.sheets_manager = self.sheets_manager
                    
                    logger.info("WordPressへのログインを試行中...")
                    wp_login_success = await wordpress_agent.initialize_wp_session()
                    
                    if wp_login_success:
                        self.task_executor.register_agent('wordpress', wordpress_agent)
                        logger.info("✅ WordPress Agent登録完了")
                    else:
                        logger.warning("⚠️ WordPressログイン失敗")
                        
                except Exception as e:
                    logger.error(f"WordPress Agent初期化エラー: {e}")
            else:
                logger.warning("⚠️ WordPress認証情報が未設定です")
            
            logger.info("="*60)
            logger.info("✅ システム初期化完了")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "システム初期化")
            raise
    
    async def test_specific_task(self, task_id: str):
        """特定のタスクIDをテスト実行"""
        try:
            # === パート1: タスク検索 ===
            logger.info(f"\n{'='*60}")
            logger.info(f"タスクID {task_id} のテスト実行")
            logger.info(f"{'='*60}\n")
            
            # pm_tasksから該当タスクを取得
            tasks = await self.task_executor.load_pending_tasks()
            target_task = None
            
            for task in tasks:
                if str(task['task_id']) == str(task_id):
                    target_task = task
                    break
            
            if not target_task:
                logger.error(f"❌ タスクID {task_id} が見つかりません（statusがpendingか確認してください）")
                return False
            
            # === パート2: タスク情報表示と確認 ===
            # タスク情報を表示
            self._display_task_info(target_task)
            
            # 実行確認
            confirm = input("\nこのタスクを実行しますか？ (y/n): ")
            if confirm.lower() != 'y':
                logger.info("実行をキャンセルしました")
                return False
            
            # === パート3: タスク実行と結果処理 ===
            # タスク実行
            success = await self.task_executor.execute_task(target_task)
            
            if success:
                logger.info(f"\n✅ タスク {task_id} のテスト実行完了")
            else:
                logger.error(f"\n❌ タスク {task_id} のテスト実行失敗")
            
            return success
            
        except Exception as e:
            ErrorHandler.log_error(e, f"タスク {task_id} テスト実行")
            return False
    
    async def test_tasks_by_role(self, role: str, auto: bool = False):
        """特定の役割のタスクをテスト実行"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info(f"役割 '{role}' のタスクをテスト実行")
            logger.info(f"{'='*60}\n")
            
            # pm_tasksから該当タスクを取得
            all_tasks = await self.task_executor.load_pending_tasks()
            filtered_tasks = [t for t in all_tasks if t['required_role'].lower() == role.lower()]
            
            if not filtered_tasks:
                logger.error(f"❌ 役割 '{role}' のpendingタスクが見つかりません")
                return
            
            logger.info(f"対象タスク: {len(filtered_tasks)}件\n")
            
            for i, task in enumerate(filtered_tasks, 1):
                logger.info(f"{i}. [{task['task_id']}] {task['description'][:80]}")
            
            if not auto:
                confirm = input(f"\nこれらのタスクを実行しますか？ (y/n): ")
                if confirm.lower() != 'y':
                    logger.info("実行をキャンセルしました")
                    return
            
            # タスクを順番に実行
            completed = 0
            failed = 0
            
            for task in filtered_tasks:
                logger.info(f"\n{'='*60}")
                logger.info(f"タスク {task['task_id']} を実行中...")
                logger.info(f"{'='*60}")
                
                success = await self.task_executor.execute_task(task)
                
                if success:
                    completed += 1
                else:
                    failed += 1
                
                # 次のタスクへの確認
                if not auto and task != filtered_tasks[-1]:
                    choice = input("\n次のアクション: (c)続行 / (q)終了: ").lower()
                    if choice == 'q':
                        break
            
            # サマリー表示
            logger.info(f"\n{'='*60}")
            logger.info("テスト実行完了")
            logger.info(f"{'='*60}")
            logger.info(f"完了: {completed}件")
            logger.info(f"失敗: {failed}件")
            logger.info(f"{'='*60}")
            
        except Exception as e:
            ErrorHandler.log_error(e, f"役割 '{role}' のテスト実行")
    
    async def test_all_pending_tasks(self, auto: bool = False):
        """全てのpendingタスクをテスト実行"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info("全pendingタスクをテスト実行")
            logger.info(f"{'='*60}\n")
            
            # TaskExecutorの通常実行を使用
            await self.task_executor.run_all_tasks(
                auto_continue=auto,
                enable_review=False  # テストモードではレビューなし
            )
            
        except Exception as e:
            ErrorHandler.log_error(e, "全タスクテスト実行")
    
    def _display_task_info(self, task: dict):
        """タスク情報を表示"""
        print("\n" + "="*60)
        print("タスク詳細")
        print("="*60)
        print(f"タスクID: {task['task_id']}")
        print(f"説明: {task['description']}")
        print(f"担当: {task['required_role']}")
        print(f"優先度: {task['priority']}")
        print(f"ステータス: {task['status']}")
        
        if 'language' in task:
            print(f"言語: {task['language']}")
        if 'polylang_lang' in task:
            print(f"Polylang: {task['polylang_lang']}")
        if 'source_task_id' in task:
            print(f"元記事タスクID: {task['source_task_id']}")
        if 'post_action' in task:
            print(f"投稿アクション: {task['post_action']}")
        if 'post_status' in task:
            print(f"投稿ステータス: {task['post_status']}")
        
        print("="*60)
    
    async def cleanup(self):
        """クリーンアップ"""
        if self.browser:
            await self.browser.cleanup()

async def run_all_tasks(
    self, 
    auto_continue: bool = True, 
    enable_review: bool = True
) -> Dict[str, Any]:
    """
    全タスクを一括実行
        
    Args:
        auto_continue: 自動継続フラグ（Falseの場合、各タスク後に確認）
        enable_review: レビュー有効化フラグ
            
    Returns:
        Dict: 実行結果サマリー
    """
    logger.info("\n" + "="*80)
    logger.info("🚀 全タスク実行を開始します")
    logger.info("="*80 + "\n")
        
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'skipped': 0,
        'results': [],
        'start_time': datetime.now(),
        'end_time': None
    }
        
    try:
        # ペンディングタスクを取得
        logger.info("📋 ペンディングタスクを読み込み中...")
        pending_tasks = await self.load_pending_tasks()
            
        if not pending_tasks:
            logger.info("📭 実行すべきタスクがありません")
            logger.info("💡 スプレッドシートの 'pm_tasks' シートを確認してください")
            logger.info("   - タスクが存在するか")
            logger.info("   - status列が 'pending' になっているか")
            summary['end_time'] = datetime.now()
            return summary
            
        summary['total'] = len(pending_tasks)
        logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            
        # 登録されているエージェントを表示
        logger.info(f"👥 登録済みエージェント: {list(self.agents.keys())}")
        logger.info("")
            
        # 各タスクを順次実行
        for index, task in enumerate(pending_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
                
            # 反復回数チェック
            self.current_iteration += 1
            if self.current_iteration > self.max_iterations:
                logger.warning(f"⚠️ 最大反復回数 ({self.max_iterations}) に到達")
                logger.warning(f"残り {summary['total'] - index + 1} タスクをスキップします")
                summary['skipped'] = summary['total'] - index + 1
                break
                
            logger.info(f"\n{'─'*80}")
            logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
            logger.info(f"{'─'*80}")
                
            try:
                success = await self.execute_task(task)
                    
                task_result = {
                    'task_id': task_id,
                    'success': success,
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                if success:
                    summary['success'] += 1
                    logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                        
                    # レビュー実行（有効な場合）
                    if enable_review and self.review_agent and hasattr(self.review_agent, 'review_task'):
                        logger.info(f"🔍 タスク {task_id} をレビュー中...")
                        try:
                            review_result = await self.review_agent.review_task(task)
                            if review_result and not review_result.get('approved', True):
                                logger.warning(f"⚠️ タスク {task_id} レビュー不合格")
                        except Exception as e:
                            logger.warning(f"⚠️ レビュー実行エラー: {e}")
                else:
                    summary['failed'] += 1
                    logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                    
                # 自動継続でない場合、次のタスクへの確認
                if not auto_continue and index < summary['total']:
                    user_choice = input("\n次のアクション: (c)続行 / (s)スキップ / (q)終了: ").lower()
                    if user_choice == 'q':
                        logger.info("ユーザーによる中断")
                        summary['skipped'] = summary['total'] - index
                        break
                    elif user_choice == 's':
                        logger.info("このタスクをスキップ")
                        continue
                    
                await asyncio.sleep(1)
                    
            except Exception as e:
                summary['failed'] += 1
                error_msg = f"タスク {task_id} 実行中のエラー: {str(e)}"
                logger.error(f"❌ {error_msg}")
                ErrorHandler.log_error(e, f"run_all_tasks - task {task_id}")
                    
                task_result = {
                    'task_id': task_id,
                    'success': False,
                    'error': str(e),
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                # エラー時の継続確認
                if not auto_continue:
                    user_choice = input("\nエラーが発生しました。続行しますか？ (y/n): ").lower()
                    if user_choice != 'y':
                        summary['skipped'] = summary['total'] - index
                        break
            
        # 実行結果サマリーを表示
        summary['end_time'] = datetime.now()
        elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
        logger.info("\n" + "="*80)
        logger.info("📊 全タスク実行完了 - 実行結果サマリー")
        logger.info("="*80)
        logger.info(f"  総タスク数:   {summary['total']:>3}件")
        logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
        logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
        logger.info(f"  ⏭️  スキップ:  {summary['skipped']:>3}件")
        logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
        logger.info("="*80 + "\n")
            
        if summary['total'] > 0:
            success_rate = (summary['success'] / summary['total']) * 100
            logger.info(f"📈 成功率: {success_rate:.1f}%")
                
            if success_rate >= 80:
                logger.info("🎉 良好な実行結果です！")
            elif success_rate >= 50:
                logger.info("⚠️ いくつかのタスクで問題が発生しています")
            else:
                logger.warning("🚨 多くのタスクが失敗しています。設定を確認してください")
            
        return summary
            
    except Exception as e:
        logger.error(f"❌ 全タスク実行中に予期しないエラー: {e}")
        ErrorHandler.log_error(e, "run_all_tasks")
        summary['end_time'] = datetime.now()
        return summary
        
    finally:
        logger.info("\n🧹 タスク実行後のクリーンアップ...")
        self.current_iteration = 0
        logger.info("✅ クリーンアップ完了\n")

async def main():
    parser = argparse.ArgumentParser(
        description='pm_tasksの既存タスクをテスト実行（デバッグ用）',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使用例:
  python test_tasks.py                    # 全pendingタスクを実行
  python test_tasks.py --task-id 5        # タスクID 5のみ実行
  python test_tasks.py --role writer      # writer タスクのみ実行
  python test_tasks.py --role wordpress --auto  # wordpress タスクを自動実行
        """
    )
    
    parser.add_argument('--task-id', type=str, help='特定のタスクIDのみ実行')
    parser.add_argument('--role', type=str, help='特定の役割のタスクのみ実行 (design, dev, writer, wordpress, etc.)')
    parser.add_argument('--auto', action='store_true', help='自動実行（確認なし）')
    parser.add_argument('--spreadsheet-id', type=str, help='スプレッドシートID（config.pyのデフォルトを上書き）')
    
    args = parser.parse_args()
    
    # スプレッドシートID
    spreadsheet_id = args.spreadsheet_id or config.SPREADSHEET_ID
    
    # service_account.json のパス
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
    
    # TaskTesterを初期化
    tester = TaskTester(spreadsheet_id, service_account_file)
    
    try:
        await tester.initialize()
        
        # モードに応じて実行
        if args.task_id:
            # 特定のタスクIDをテスト
            await tester.test_specific_task(args.task_id)
        
        elif args.role:
            # 特定の役割のタスクをテスト
            await tester.test_tasks_by_role(args.role, auto=args.auto)
        
        else:
            # 全てのpendingタスクをテスト
            await tester.test_all_pending_tasks(auto=args.auto)
        
    except KeyboardInterrupt:
        logger.info("\n\n⚠️ ユーザーによる中断")
    
    except Exception as e:
        logger.error(f"❌ エラー発生: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        await tester.cleanup()
        logger.info("\n👋 タスクテスターを終了しました")


if __name__ == "__main__":
    asyncio.run(main())

#test_tasks.py
# test_tasks.py
"""
pm_tasksシートの既存タスクをテスト実行するデバッグスクリプト

使い方:
  python test_tasks.py                    # 全pending タスクを実行
  python test_tasks.py --task-id 5        # 特定のタスクIDのみ実行
  python test_tasks.py --role writer      # 特定の役割のタスクのみ実行
  python test_tasks.py --auto             # 自動実行（確認なし）
"""

import logging
import asyncio
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Any 

from config_utils import config, ErrorHandler, PathManager
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

# ロガー設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# TaskExecutor インポートの簡素化
try:
    # まずメインのTaskExecutorを試す
    from task_executor.task_executor import TaskExecutor
    logger.info("✅ メイン TaskExecutor をインポート")
except ImportError as e:
    logger.warning(f"⚠️ メイン TaskExecutor インポート失敗: {e}")
    try:
        # フォールバック: MATaskExecutor
        from task_executor.task_executor_ma import MATaskExecutor as TaskExecutor
        logger.info("✅ MATaskExecutor を TaskExecutor として使用")
    except ImportError as e:
        logger.warning(f"⚠️ MATaskExecutor インポート失敗: {e}")
        try:
            # 最終フォールバック: ContentTaskExecutor
            from task_executor.content_task_executor import ContentTaskExecutor as TaskExecutor
            logger.info("✅ ContentTaskExecutor を TaskExecutor として使用")
        except ImportError as e:
            logger.error(f"❌ 利用可能なTaskExecutorが見つかりません: {e}")
            TaskExecutor = None

class TaskTester:
    """既存タスクのテスト実行用クラス"""
    
    def __init__(self, spreadsheet_id: str, service_account_file: str = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.sheets_manager = None
        self.browser = None
        self.task_executor = None
    
    def safe_import_task_executor():
        """安全なTaskExecutorインポート関数"""
        import logging
        temp_logger = logging.getLogger(__name__)
        
        candidates = [
            # 優先順位1: メインTaskExecutor
            ('task_executor', 'TaskExecutor', 'メイン'),
            # 優先順位2: MATaskExecutor
            ('task_executor.task_executor_ma', 'MATaskExecutor', 'M&A'),
            # 優先順位3: ContentTaskExecutor
            ('task_executor.content_task_executor', 'ContentTaskExecutor', 'コンテンツ'),
        ]
        
        for module_path, class_name, executor_type in candidates:
            try:
                module = __import__(module_path, fromlist=[class_name])
                executor_class = getattr(module, class_name)
                temp_logger.info(f"✅ {executor_type} Executor をインポート: {class_name}")
                return executor_class
            except ImportError as e:
                temp_logger.debug(f"⚠️ {module_path}.{class_name} インポート失敗: {e}")
            except AttributeError as e:
                temp_logger.debug(f"⚠️ {module_path} に {class_name} がありません: {e}")
        
        temp_logger.error("❌ 利用可能なTaskExecutorクラスが見つかりません")
        return None
    
    async def initialize(self):
        """システム初期化"""
        try:
            logger.info("="*60)
            logger.info("タスクテスターを初期化中...")
            logger.info("="*60)
    
            # === パート1: Google Sheets接続と基本設定読み込み ===
            logger.info("📊 Google Sheets接続中...")
    
            # Google Sheets接続
            self.sheets_manager = GoogleSheetsManager(
                self.spreadsheet_id, 
                self.service_account_file
            )
    
            # PC_IDを取得して設定を読み込み
            pc_id = self.sheets_manager.get_current_pc_id()
            settings = self.sheets_manager.load_pc_settings(pc_id)
    
            # === パート2: 出力フォルダとブラウザ設定 ===
            logger.info("📁 出力フォルダ設定中...")
    
            # 出力フォルダの設定
            agent_output = settings.get('agent_output_folder')
            if not agent_output or agent_output.startswith('http'):
                download_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                download_folder.mkdir(exist_ok=True, parents=True)
            else:
                download_folder = PathManager.get_safe_path(agent_output)
    
            logger.info(f"出力フォルダ: {download_folder}")
            
            # === パート3: BrowserController初期化 ===
            logger.info("🌐 ブラウザ初期化中...")
            
            # BrowserControllerを初期化
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
        
            self.browser = BrowserController(
                download_folder, 
                mode='text', 
                service='google'
            )
            await self.browser.setup_browser()
            await self.browser.navigate_to_gemini()
            
            def resolve_task_executor():
                """利用可能なTaskExecutorを動的に解決"""
                available_executors = []

                # MATaskExecutorの確認
                try:
                    from task_executor.task_executor_ma import MATaskExecutor
                    available_executors.append(('ma', MATaskExecutor))
                except ImportError:
                    pass

                # ContentTaskExecutorの確認
                try:
                    from task_executor.content_task_executor import ContentTaskExecutor
                    available_executors.append(('content', ContentTaskExecutor))
                except ImportError:
                    pass

                # TaskCoordinatorの確認
                try:
                    from task_executor.task_coordinator import TaskCoordinator
                    available_executors.append(('coordinator', TaskCoordinator))
                except ImportError:
                    pass

                if available_executors:
                    executor_type, executor_class = available_executors[0]
                    logger.info(f"✅ {executor_type} Executor を使用: {executor_class.__name__}")
                    return executor_class
                else:
                    logger.error("❌ 利用可能なTaskExecutorが見つかりません")
                    return None

            # ========================================
            # === パート4: TaskExecutor初期化（統一版） ===
            # ========================================
            logger.info("⚙️ タスク実行エンジン初期化中...")

            # ステップ1: 利用可能なExecutorを解決
            executor_class = resolve_task_executor()

            # ステップ2: フォールバック処理
            if executor_class is None:
                # resolve_task_executorで見つからなかった場合、TaskExecutorを試す
                if TaskExecutor is None:
                    logger.error("❌ TaskExecutor のインポートに失敗しました")
                    return False
                executor_class = TaskExecutor
                logger.info("⚙️ デフォルトのTaskExecutorを使用します")

            # ステップ3: Executorの初期化
            logger.info(f"🚀 {executor_class.__name__} を初期化中...")
            self.task_executor = executor_class(
                self.sheets_manager,
                self.browser,
                max_iterations=30
            )

            # ステップ4: Executor種別の判定フラグ
            is_ma_executor = 'MATaskExecutor' in executor_class.__name__
            is_standard_executor = 'TaskExecutor' in executor_class.__name__ and not is_ma_executor

            logger.info(f"📝 使用するExecutor: {executor_class.__name__}")
            logger.info(f"   - MATaskExecutor: {is_ma_executor}")
            logger.info(f"   - 標準TaskExecutor: {is_standard_executor}")
        
            # === パート5: 各エージェントの登録 ===
            logger.info("🤖 エージェント登録中...")
                
            # ★★★ 各種エージェントの初期化と登録 ★★★
                
            # 1. Design Agent
            try:
                from design_agent import DesignAgent
                self.design_agent = DesignAgent(self.browser)
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('design', self.design_agent)
                logger.info("✅ Design Agent初期化完了")
            except ImportError:
                logger.warning("⚠️ design_agent が見つかりません")
                self.design_agent = None

            # 2. Dev Agent
            try:
                from dev_agent import DevAgent
                self.dev_agent = DevAgent(self.browser)
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('dev', self.dev_agent)
                logger.info("✅ Dev Agent初期化完了")
            except ImportError:
                logger.warning("⚠️ dev_agent が見つかりません")
                self.dev_agent = None

            # 3. Review Agent
            try:
                from review_agent import ReviewAgent
                self.review_agent = ReviewAgent()
                self.review_agent.browser = self.browser
                self.review_agent.sheets_manager = self.sheets_manager
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_review_agent(self.review_agent)
                logger.info("✅ Review Agent初期化完了")
            except ImportError:
                logger.warning("⚠️ review_agent が見つかりません")
                self.review_agent = None

            # 4. Content Writer Agents
            try:
                from content_writer_agent import ContentWriterAgent
                self.content_writer = ContentWriterAgent(self.browser)
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('writer', self.content_writer)
                    self.task_executor.register_agent('content', self.content_writer)
                logger.info("✅ Content Writer Agent初期化完了")
            except ImportError:
                logger.warning("⚠️ content_writer_agent が見つかりません")
                self.content_writer = None
                
            # ========================================
            # 5. WordPress Agent（重要！）
            # ========================================
            logger.info("🗄️ WordPress Agent設定中...")
            
            # 認証情報の取得とログ出力
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
            
            # ✅ デバッグ：認証情報の状態を確認
            logger.info("="*60)
            logger.info("📋 WordPress認証情報チェック:")
            logger.info("="*60)
            logger.info(f"   - wp_url: {'✅ 設定済み' if wp_url else '❌ 未設定'} ({len(wp_url)} chars)")
            logger.info(f"   - wp_user: {'✅ 設定済み' if wp_user else '❌ 未設定'}")
            logger.info(f"   - wp_pass: {'✅ 設定済み' if wp_pass else '❌ 未設定'}")
            logger.info("="*60)

            # インスタンス変数として初期化（重要！）
            self.wordpress_agent = None

            if wp_url and wp_user and wp_pass:
                try:
                    logger.info("📦 WordPressAgentクラスをインポート中...")
                    from wordpress.wp_agent import WordPressAgent
            
                    wp_credentials = {
                        'wp_url': wp_url,
                        'wp_user': wp_user,
                        'wp_pass': wp_pass
                    }
            
                    # ✅ self.wordpress_agent として保存
                    logger.info("🔧 WordPressAgentインスタンスを作成中...")
                    self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
                    logger.info("✅ WordPressAgentインスタンス作成完了")
                    
                    self.wordpress_agent.sheets_manager = self.sheets_manager
                    logger.info("✅ sheets_manager を設定")
            
                    logger.info("🔐 WordPressへのログインを試行中...")
                    wp_login_success = await self.wordpress_agent.initialize_wp_session()
            
                    if wp_login_success:
                        logger.info("✅ WordPressログイン成功")
                        # ✅ 一旦登録（後で再登録される）
                        if hasattr(self, 'task_executor') and self.task_executor:
                            self.task_executor.register_agent('wordpress', self.wordpress_agent)
                            logger.info("✅ WordPressAgent 一時登録完了")
                        logger.info("✅ WordPress Agent初期化完了")
                    else:
                        logger.warning("⚠️ WordPressログイン失敗")
                        logger.warning("⚠️ ログイン失敗でもエージェントは保持します")
                        # ✅ ログイン失敗でもエージェントは保持（重要！）
                        # self.wordpress_agent = None  # ← コメントアウト
            
                except Exception as e:
                    logger.error("="*60)
                    logger.error(f"❌ WordPress Agent初期化エラー: {e}")
                    logger.error("="*60)
                    import traceback
                    logger.error(traceback.format_exc())
                    logger.error("⚠️ エージェントをNoneに設定します")
                    self.wordpress_agent = None
            else:
                logger.warning("="*60)
                logger.warning("⚠️ WordPress認証情報が未設定です")
                logger.warning(f"   - wp_url: {bool(wp_url)}")
                logger.warning(f"   - wp_user: {bool(wp_user)}")
                logger.warning(f"   - wp_pass: {bool(wp_pass)}")
                logger.warning("="*60)
                
            # ========================================
            # 6. WordPress Dev Agent
            # ========================================
            logger.info("🔧 WordPress Dev Agent設定中...")
            self.wp_dev_agent = None
                
            try:
                from wordpress.wp_dev import WordPressDevAgent
                    
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                    
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('wp_dev', self.wp_dev_agent)
                logger.info("✅ WordPress Dev Agent (wp_dev) 初期化完了")
            except ImportError as e:
                logger.warning(f"⚠️ wordpress/wp_dev.py のインポート失敗: {e}")
                logger.info("💡 wp_dev タスクは標準 dev エージェントで処理されます")
            except Exception as e:
                logger.warning(f"⚠️ wp_dev エージェント初期化エラー: {e}")
                
            # ========================================
            # 7. WordPress Design Agent
            # ========================================
            logger.info("🎨 WordPress Design Agent設定中...")
            self.wp_design_agent = None
                
            try:
                from wordpress.wp_design import WordPressDesignAgent
                    
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                    
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('wp_design', self.wp_design_agent)
                logger.info("✅ WordPress Design Agent (wp_design) 初期化完了")
            except ImportError as e:
                logger.warning(f"⚠️ wordpress/wp_design.py のインポート失敗: {e}")
                logger.info("💡 wp_design タスクは標準 design エージェントで処理されます")
            except Exception as e:
                logger.warning(f"⚠️ wp_design エージェント初期化エラー: {e}")
                
            # ========================================
            # ✅ システム初期化完了（全エージェント初期化後）
            # ========================================
            logger.info("="*60)
            logger.info("✅ システム初期化完了")
            logger.info("="*60)
            
            # ========================================
            # ✅ デバッグ：is_ma_executor フラグの確認
            # ========================================
            logger.info("\n" + "="*60)
            logger.info("🔍 デバッグ情報")
            logger.info("="*60)
            logger.info(f"Executor種別: {executor_class.__name__}")
            logger.info(f"is_ma_executor フラグ: {is_ma_executor}")
            logger.info(f"wordpress_agent 存在: {hasattr(self, 'wordpress_agent')}")
            if hasattr(self, 'wordpress_agent'):
                logger.info(f"wordpress_agent 値: {self.wordpress_agent}")
                if self.wordpress_agent:
                    logger.info(f"plugin_manager 存在: {hasattr(self.wordpress_agent, 'plugin_manager')}")
                    if hasattr(self.wordpress_agent, 'plugin_manager'):
                        logger.info(f"plugin_manager 値: {self.wordpress_agent.plugin_manager}")
            logger.info("="*60)

            # ========================================
            # ✅ 重要：MATaskExecutor用のエージェント再登録
            # ========================================

            if is_ma_executor:
                logger.info("\n" + "="*60)
                logger.info("🔄 MATaskExecutor用エージェント再登録中...")
                logger.info("="*60)
        
                # インスタンス変数から初期化済みエージェントを収集
                agents_to_register = {}
        
                # design_agentの登録
                if hasattr(self, 'design_agent') and self.design_agent:
                    agents_to_register['design'] = self.design_agent
        
                # dev_agentの登録
                if hasattr(self, 'dev_agent') and self.dev_agent:
                    agents_to_register['dev'] = self.dev_agent
        
                # review_agentの登録
                if hasattr(self, 'review_agent') and self.review_agent:
                    agents_to_register['review'] = self.review_agent
        
                # content_writerの登録
                if hasattr(self, 'content_writer') and self.content_writer:
                    agents_to_register['writer'] = self.content_writer
                    agents_to_register['content'] = self.content_writer
        
                # ========================================
                # ✅ 重要：wordpress_agentの登録（デバッグ強化）
                # ========================================
                logger.info("\n📋 wordpress_agent 登録チェック:")
                logger.info(f"   - hasattr: {hasattr(self, 'wordpress_agent')}")
                if hasattr(self, 'wordpress_agent'):
                    logger.info(f"   - value: {self.wordpress_agent}")
                    logger.info(f"   - is None: {self.wordpress_agent is None}")
                
                if hasattr(self, 'wordpress_agent') and self.wordpress_agent:
                    agents_to_register['wordpress'] = self.wordpress_agent
                    logger.info("  ✅ wordpress_agent を取得")
            
                    # wordpressから派生するサブエージェントも登録
                    if hasattr(self.wordpress_agent, 'plugin_manager'):
                        logger.info(f"  📦 plugin_manager 存在確認: {self.wordpress_agent.plugin_manager is not None}")
                        if self.wordpress_agent.plugin_manager:
                            agents_to_register['plugin'] = self.wordpress_agent.plugin_manager
                            logger.info("  ✅ plugin_manager を取得")
                        else:
                            logger.error("  ❌ plugin_manager is None!")
                    else:
                        logger.error("  ❌ plugin_manager 属性が存在しません!")
                else:
                    logger.error("  ❌ wordpress_agent が見つかりません！")
                    if hasattr(self, 'wordpress_agent'):
                        logger.error(f"     wordpress_agent is None: {self.wordpress_agent is None}")
        
                # wp_dev_agentの登録
                if hasattr(self, 'wp_dev_agent') and self.wp_dev_agent:
                    agents_to_register['wp_dev'] = self.wp_dev_agent
                elif hasattr(self, 'dev_agent') and self.dev_agent:
                    agents_to_register['wp_dev'] = self.dev_agent
                    logger.info("  🔄 wp_dev → dev でフォールバック")
        
                # wp_design_agentの登録
                if hasattr(self, 'wp_design_agent') and self.wp_design_agent:
                    agents_to_register['wp_design'] = self.wp_design_agent
                elif hasattr(self, 'design_agent') and self.design_agent:
                    agents_to_register['wp_design'] = self.design_agent
                    logger.info("  🔄 wp_design → design でフォールバック")
        
                # エージェントを一括登録
                logger.info("\n📝 エージェント登録処理:")
                for agent_name, agent_instance in agents_to_register.items():
                    try:
                        self.task_executor.register_agent(agent_name, agent_instance)
                        logger.info(f"  ✅ {agent_name:15s} 登録完了")
                    except Exception as e:
                        logger.error(f"  ❌ {agent_name:15s} 登録失敗: {e}")
        
                # レビューエージェントの特別登録
                if hasattr(self, 'review_agent') and self.review_agent:
                    try:
                        self.task_executor.register_review_agent(self.review_agent)
                        logger.info(f"  ✅ {'review (専用)':15s} 登録完了")
                    except Exception as e:
                        logger.error(f"  ❌ review (専用) 登録失敗: {e}")
        
                logger.info("="*60)
                logger.info(f"MATaskExecutor エージェント登録完了: {len(agents_to_register)}個")
                logger.info("="*60)
        
                # デバッグ：登録済みエージェント一覧を表示
                logger.info("\n📋 登録済みエージェント一覧:")
                for agent_name in self.task_executor.agents.keys():
                    logger.info(f"  - {agent_name}")
                logger.info("")
            else:
                logger.warning("\n⚠️ MATaskExecutorではないため、再登録処理をスキップします")
                logger.warning(f"   Executor種別: {executor_class.__name__}")
                logger.warning(f"   is_ma_executor: {is_ma_executor}")
                    
            # ========================================
            # ✅ 最後にreturn
            # ========================================
            return True
                
        except Exception as e:
            ErrorHandler.log_error(e, "システム初期化")
            raise
    
    async def test_tasks_by_role(self, role: str, auto: bool = False):
        """特定の役割のタスクをテスト実行"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info(f"役割 '{role}' のタスクをテスト実行")
            logger.info(f"{'='*60}\n")
            
            # pm_tasksから該当タスクを取得
            all_tasks = await self.task_executor.load_pending_tasks()
            filtered_tasks = [t for t in all_tasks if t['required_role'].lower() == role.lower()]
            
            if not filtered_tasks:
                logger.error(f"❌ 役割 '{role}' のpendingタスクが見つかりません")
                return
            
            logger.info(f"対象タスク: {len(filtered_tasks)}件\n")
            
            for i, task in enumerate(filtered_tasks, 1):
                logger.info(f"{i}. [{task['task_id']}] {task['description'][:80]}")
            
            if not auto:
                confirm = input(f"\nこれらのタスクを実行しますか？ (y/n): ")
                if confirm.lower() != 'y':
                    logger.info("実行をキャンセルしました")
                    return
            
            # タスクを順番に実行
            completed = 0
            failed = 0
            
            for task in filtered_tasks:
                logger.info(f"\n{'='*60}")
                logger.info(f"タスク {task['task_id']} を実行中...")
                logger.info(f"{'='*60}")
                
                success = await self.task_executor.execute_task(task)
                
                if success:
                    completed += 1
                else:
                    failed += 1
                
                # 次のタスクへの確認
                if not auto and task != filtered_tasks[-1]:
                    choice = input("\n次のアクション: (c)続行 / (q)終了: ").lower()
                    if choice == 'q':
                        break
            
            # サマリー表示
            logger.info(f"\n{'='*60}")
            logger.info("テスト実行完了")
            logger.info(f"{'='*60}")
            logger.info(f"完了: {completed}件")
            logger.info(f"失敗: {failed}件")
            logger.info(f"{'='*60}")
            
        except Exception as e:
            ErrorHandler.log_error(e, f"役割 '{role}' のテスト実行")
    
    async def test_all_pending_tasks(self, auto: bool = False):
        """全てのpendingタスクをテスト実行"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info("全pendingタスクをテスト実行")
            logger.info(f"{'='*60}\n")
            
            # TaskExecutorの通常実行を使用
            await self.task_executor.run_all_tasks(
                auto_continue=auto,
                enable_review=False  # テストモードではレビューなし
            )
            
        except Exception as e:
            ErrorHandler.log_error(e, "全タスクテスト実行")
    
    def _display_task_info(self, task: dict):
        """タスク情報を表示"""
        print("\n" + "="*60)
        print("タスク詳細")
        print("="*60)
        print(f"タスクID: {task['task_id']}")
        print(f"説明: {task['description']}")
        print(f"担当: {task['required_role']}")
        print(f"優先度: {task['priority']}")
        print(f"ステータス: {task['status']}")
        
        if 'language' in task:
            print(f"言語: {task['language']}")
        if 'polylang_lang' in task:
            print(f"Polylang: {task['polylang_lang']}")
        if 'source_task_id' in task:
            print(f"元記事タスクID: {task['source_task_id']}")
        if 'post_action' in task:
            print(f"投稿アクション: {task['post_action']}")
        if 'post_status' in task:
            print(f"投稿ステータス: {task['post_status']}")
        
        print("="*60)
    
    async def cleanup(self):
        """クリーンアップ"""
        if self.browser:
            await self.browser.cleanup()

async def main():
    parser = argparse.ArgumentParser(
        description='pm_tasksの既存タスクをテスト実行（デバッグ用）',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
使用例:
  python test_tasks.py                    # 全pendingタスクを実行
  python test_tasks.py --task-id 5        # タスクID 5のみ実行
  python test_tasks.py --role writer      # writer タスクのみ実行
  python test_tasks.py --role wordpress --auto  # wordpress タスクを自動実行
        """
    )
    
    parser.add_argument('--task-id', type=str, help='特定のタスクIDのみ実行')
    parser.add_argument('--role', type=str, help='特定の役割のタスクのみ実行 (design, dev, writer, wordpress, etc.)')
    parser.add_argument('--auto', action='store_true', help='自動実行（確認なし）')
    parser.add_argument('--spreadsheet-id', type=str, help='スプレッドシートID（config.pyのデフォルトを上書き）')
    
    args = parser.parse_args()
    
    # スプレッドシートID
    spreadsheet_id = args.spreadsheet_id or config.SPREADSHEET_ID
    
    # service_account.json のパス
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
    
    # TaskTesterを初期化
    tester = TaskTester(spreadsheet_id, service_account_file)
    
    try:
        await tester.initialize()
        
        # モードに応じて実行
        if args.task_id:
            # 特定のタスクIDをテスト
            await tester.test_specific_task(args.task_id)
        
        elif args.role:
            # 特定の役割のタスクをテスト
            await tester.test_tasks_by_role(args.role, auto=args.auto)
        
        else:
            # 全てのpendingタスクをテスト
            await tester.test_all_pending_tasks(auto=args.auto)
        
    except KeyboardInterrupt:
        logger.info("\n\n⚠️ ユーザーによる中断")
    
    except Exception as e:
        logger.error(f"❌ エラー発生: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        await tester.cleanup()
        logger.info("\n👋 タスクテスターを終了しました")


if __name__ == "__main__":
    asyncio.run(main())

#workflow_executor.py
"""
workflow_executor.py - 複雑なワークフロー実行モジュール
マルチステップ・マルチエージェント連携タスクを統合管理
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# 設定
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

# 既存のTaskExecutor
from task_executor import TaskExecutor

logger = logging.getLogger(__name__)


class WorkflowExecutor:
    """
    複雑なワークフロー実行モジュール
    
    複数ステップ、マルチエージェント連携、
    レビュー→修正サイクル、多言語展開などを統合管理
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        初期化
        
        Args:
            task_executor: 既存のTaskExecutorインスタンス
            sheets_manager: GoogleSheetsManagerインスタンス
            browser_controller: BrowserControllerインスタンス(オプション)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # ワークフロー統計
        self.workflow_stats = {
            'total_workflows': 0,
            'completed': 0,
            'failed': 0,
            'partial_success': 0
        }
        
        logger.info("✅ WorkflowExecutor 初期化完了")
    
    async def execute_workflow_task(self, task: Dict) -> Dict:
        """
        ワークフローのメインエントリポイント
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        workflow_type = self._determine_workflow_type(task)
        
        self.workflow_stats['total_workflows'] += 1
        
        try:
            logger.info("=" * 60)
            logger.info(f"🔄 ワークフロー実行開始: {task_id}")
            logger.info(f"ワークフロータイプ: {workflow_type}")
            logger.info("=" * 60)
            
            result = None
            
            # ワークフロータイプ別実行
            if workflow_type == 'multilingual':
                result = await self._execute_multilingual_workflow(task)
            elif workflow_type == 'review_cycle':
                result = await self._execute_review_cycle_workflow(task)
            elif workflow_type == 'sequential':
                result = await self._execute_sequential_workflow(task)
            elif workflow_type == 'parallel':
                result = await self._execute_parallel_workflow(task)
            elif workflow_type == 'conditional':
                result = await self._execute_conditional_workflow(task)
            else:
                # デフォルトシーケンシャル実行
                result = await self._execute_sequential_workflow(task)
            
            # 統計更新
            if result and result.get('success'):
                self.workflow_stats['completed'] += 1
            elif result and result.get('partial_success'):
                self.workflow_stats['partial_success'] += 1
            else:
                self.workflow_stats['failed'] += 1
            
            return result
        
        except Exception as e:
            logger.error(f"❌ ワークフロー {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"WorkflowExecutor.execute_workflow_task({task_id})")
            self.workflow_stats['failed'] += 1
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_workflow_type(self, task: Dict) -> str:
        """
        ワークフロータイプを判定
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: ワークフロータイプ
        """
        description = task.get('description', '').lower()
        
        # 多言語ワークフロー
        if any(kw in description for kw in ['多言語', '翻訳', 'multilingual', 'translation']):
            return 'multilingual'
        
        # レビューサイクルワークフロー
        if any(kw in description for kw in ['レビュー→修正', 'review cycle', 'iterative review']):
            return 'review_cycle'
        
        # 並列ワークフロー
        if any(kw in description for kw in ['並列', '同時', 'parallel', 'concurrent']):
            return 'parallel'
        
        # 条件分岐ワークフロー
        if any(kw in description for kw in ['条件', '分岐', 'conditional', 'if-then']):
            return 'conditional'
        
        # デフォルトはシーケンシャル
        return 'sequential'
    
    async def _execute_multilingual_workflow(self, task: Dict) -> Dict:
        """
        多言語コンテンツ生成ワークフロー（Polylang連携強化版）
            
        1. 日本語記事生成
        2. 英語翻訳
        3. その他言語翻訳（オプション）
        4. WordPress多言語投稿（Polylang連携）
            
        Args:
            task: タスク情報辞書
                
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("🌍 多言語ワークフロー実行（Polylang連携版）")
                
            # ターゲット言語リスト
            target_languages = task.get('target_languages', ['ja', 'en'])
            base_language = task.get('base_language', 'ja')
                
            # Polylang言語コードマッピング
            polylang_lang_codes = {
                'ja': 'ja',
                'en': 'en',
                'uz': 'uz_UZ',  # ウズベク語
                'ru': 'ru_RU',  # ロシア語
                'tr': 'tr_TR',  # トルコ語
                'zh': 'zh_CN',  # 中国語
                'ko': 'ko_KR'   # 韓国語
            }
                
            results = {}
            contents = {}
            post_ids = {}  # 投稿IDを保存（Polylang連携用）
                
            # ========================================
            # ステップ1: 基本言語でコンテンツ生成
            # ========================================
            logger.info(f"--- ステップ1: {base_language} コンテンツ生成 ---")
                
            base_task = {
                **task,
                'task_id': f"{task_id}_base_{base_language}",
                'language': base_language,
                'required_role': 'content'
            }
                
            base_result = await self.task_executor.execute_task(base_task)
                
            if not base_result:
                return {
                    'success': False,
                    'error': f'{base_language} コンテンツ生成失敗'
                }
                
            results[base_language] = base_result
                
            # 基本コンテンツ取得
            base_content = ""
            if hasattr(base_result, 'get'):
                base_content = base_result.get('full_text', base_result.get('content', ''))
                
            contents[base_language] = base_content
                
            # ========================================
            # ステップ2: 他言語への翻訳
            # ========================================
            for lang in target_languages:
                if lang == base_language:
                    continue
                    
                logger.info(f"--- ステップ2-{lang}: {lang} 翻訳 ---")
                    
                translation_task = {
                    'task_id': f"{task_id}_translate_{lang}",
                    'description': f'{base_language}から{lang}に翻訳',
                    'prompt': f'以下のコンテンツを{lang}に翻訳してください:\n\n{base_content}',
                    'required_role': 'content',
                    'language': lang,
                    'source_language': base_language,
                    'target_language': lang,
                    'source_text': base_content
                }
                    
                translate_result = await self.task_executor.execute_task(translation_task)
                    
                results[lang] = translate_result
                    
                if translate_result and hasattr(translate_result, 'get'):
                    translated_content = translate_result.get('full_text', translate_result.get('content', ''))
                    contents[lang] = translated_content
                else:
                    logger.warning(f"⚠️ {lang} 翻訳失敗")
                    
                await asyncio.sleep(2)
                
            # ========================================
            # ステップ3: WordPress多言語投稿（Polylang連携強化版）
            # ========================================
            if task.get('auto_publish', False):
                logger.info("--- ステップ3: WordPress多言語投稿（Polylang連携） ---")
                    
                # 3-1: 基本言語の投稿を作成
                base_lang_code = polylang_lang_codes.get(base_language, base_language)
                base_wp_task = {
                    'task_id': f"{task_id}_publish_{base_language}",
                    'description': f'{base_language} コンテンツをWordPressに投稿',
                    'required_role': 'wordpress',
                    'language': base_language,
                    'polylang_lang': base_lang_code,
                    'post_action': 'create',
                    'post_title': task.get('post_title', f'記事_{base_language}'),
                    'post_content': contents.get(base_language, ''),
                    'post_status': 'draft'  # 下書きで作成
                }
                    
                base_publish_result = await self.task_executor.execute_task(base_wp_task)
                results[f'{base_language}_publish'] = base_publish_result
                    
                # 投稿IDを取得
                if base_publish_result and hasattr(base_publish_result, 'get'):
                    base_post_id = base_publish_result.get('post_id')
                    if base_post_id:
                        post_ids[base_language] = base_post_id
                        logger.info(f"✅ {base_language} 投稿ID: {base_post_id}")
                    
                await asyncio.sleep(2)
                    
                # 3-2: 翻訳投稿を作成し、Polylangで連携
                for lang, content in contents.items():
                    if lang == base_language or not content:
                        continue
                        
                    lang_code = polylang_lang_codes.get(lang, lang)
                        
                    wp_task = {
                        'task_id': f"{task_id}_publish_{lang}",
                        'description': f'{lang} コンテンツをWordPressに投稿（Polylang連携）',
                        'required_role': 'wordpress',
                        'language': lang,
                        'polylang_lang': lang_code,
                        'post_action': 'create',
                        'post_title': task.get('post_title', f'記事_{lang}'),
                        'post_content': content,
                        'post_status': 'draft',
                        # ========================================
                        # 🆕 Polylang連携パラメータ（新規追加）
                        # ========================================
                        'polylang_link_to': post_ids.get(base_language),  # 基本言語の投稿IDとリンク
                        'polylang_translation_group': task_id  # 翻訳グループID
                    }
                        
                    publish_result = await self.task_executor.execute_task(wp_task)
                    results[f'{lang}_publish'] = publish_result
                        
                    # 投稿IDを取得
                    if publish_result and hasattr(publish_result, 'get'):
                        post_id = publish_result.get('post_id')
                        if post_id:
                            post_ids[lang] = post_id
                            logger.info(f"✅ {lang} 投稿ID: {post_id}")
                        
                    await asyncio.sleep(2)
                    
                # ========================================
                # 🆕 ステップ3-3: Polylang翻訳リンクの設定（新規追加）
                # ========================================
                if len(post_ids) > 1:
                    logger.info("--- ステップ3-3: Polylang翻訳リンク設定 ---")
                        
                    polylang_link_task = {
                        'task_id': f"{task_id}_polylang_link",
                        'description': 'Polylang翻訳リンクを設定',
                        'required_role': 'wordpress',
                        'action': 'polylang_link_translations',
                        'post_ids': post_ids,  # {'ja': 123, 'en': 124, ...}
                        'translation_group': task_id
                    }
                        
                    link_result = await self.task_executor.execute_task(polylang_link_task)
                    results['polylang_link'] = link_result
                        
                    if link_result and hasattr(link_result, 'get') and link_result.get('success'):
                        logger.info("✅ Polylang翻訳リンク設定完了")
                    else:
                        logger.warning("⚠️ Polylang翻訳リンク設定失敗（手動で設定が必要）")
                
            # ========================================
            # 結果集約
            # ========================================
            success_count = sum(1 for r in results.values() if r and (r is True or (hasattr(r, 'get') and r.get('success'))))
            total_count = len(results)
                
            logger.info(f"✅ 多言語ワークフロー完了: {success_count}/{total_count} 成功")
                
            return {
                'success': success_count == total_count,
                'partial_success': success_count > 0 and success_count < total_count,
                'results': results,
                'contents': contents,
                'post_ids': post_ids,  # 投稿ID情報を追加
                'summary': f'{success_count}/{total_count} 言語で成功（投稿数: {len(post_ids)}）',
                'full_text': '\n\n---\n\n'.join([f'[{lang}]\n{content}' for lang, content in contents.items()])
            }
            
        except Exception as e:
            logger.error(f"❌ 多言語ワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_multilingual_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_review_cycle_workflow(self, task: Dict) -> Dict:
        """
        レビュー→修正サイクルワークフロー
        
        1. コンテンツ生成
        2. レビュー実行
        3. 修正指示に基づいて再生成
        4. 最終承認まで繰り返し
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        max_iterations = task.get('max_review_iterations', 3)
        
        try:
            logger.info("🔄 レビューサイクルワークフロー実行")
            
            iteration = 0
            current_content = None
            review_history = []
            
            while iteration < max_iterations:
                iteration += 1
                logger.info(f"--- レビューサイクル {iteration}/{max_iterations} ---")
                
                # ステップ1: コンテンツ生成（初回）または修正（2回目以降）
                if iteration == 1:
                    logger.info("初回コンテンツ生成")
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'required_role': 'content'
                    }
                else:
                    logger.info("レビューフィードバックに基づく修正")
                    last_review = review_history[-1]
                    feedback = last_review.get('feedback', '')
                    
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'prompt': f'{task.get("prompt", "")}\n\n前回のレビューフィードバック:\n{feedback}\n\n上記フィードバックを反映して修正してください。',
                        'required_role': 'content'
                    }
                
                content_result = await self.task_executor.execute_task(content_task)
                
                if not content_result:
                    logger.error("コンテンツ生成失敗")
                    break
                
                if hasattr(content_result, 'get'):
                    current_content = content_result.get('full_text', content_result.get('content', ''))
                else:
                    current_content = str(content_result)
                
                # ステップ2: レビュー実行
                logger.info("レビュー実行")
                review_task = {
                    'task_id': f"{task_id}_review_v{iteration}",
                    'description': 'コンテンツレビュー',
                    'required_role': 'review',
                    'review_target_task_id': f"{task_id}_content_v{iteration}",
                    'content_to_review': current_content
                }
                
                review_result = await self.task_executor.execute_task(review_task)
                
                if not review_result or not hasattr(review_result, 'get'):
                    logger.warning("レビュー実行失敗 - サイクル終了")
                    break
                
                review_history.append(review_result)
                
                # ステップ3: 承認判定
                approved = review_result.get('approved', False)
                
                if approved:
                    logger.info(f"✅ レビュー承認 (反復{iteration}回)")
                    return {
                        'success': True,
                        'content': current_content,
                        'iterations': iteration,
                        'review_history': review_history,
                        'full_text': current_content,
                        'summary': f'{iteration}回の反復で承認'
                    }
                else:
                    logger.info(f"🔄 修正が必要 - 次の反復へ")
                    await asyncio.sleep(2)
            
            # 最大反復回数到達
            logger.warning(f"⚠️ 最大反復回数({max_iterations})到達 - 最終版を返却")
            
            return {
                'success': False,
                'partial_success': True,
                'content': current_content,
                'iterations': iteration,
                'review_history': review_history,
                'full_text': current_content,
                'summary': f'{iteration}回反復したが承認されず',
                'error': '最大反復回数到達'
            }
        
        except Exception as e:
            logger.error(f"❌ レビューサイクルワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_review_cycle_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_sequential_workflow(self, task: Dict) -> Dict:
        """
        シーケンシャルワークフロー（順次実行）
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("ステップ定義なし - 単一タスクとして実行")
            result = await self.task_executor.execute_task(task)
            return {'success': bool(result), 'result': result}
        
        try:
            logger.info(f"📋 シーケンシャルワークフロー実行 ({len(steps)}ステップ)")
            
            results = []
            accumulated_output = {}
            
            for i, step in enumerate(steps, 1):
                logger.info(f"--- ステップ {i}/{len(steps)}: {step.get('description', 'N/A')} ---")
                
                # ステップタスク構築
                step_task = {
                    **task,
                    **step,  # ステップ設定で上書き
                    'task_id': f"{task_id}_step{i}",
                }
                
                # 前ステップの出力を参照
                if step.get('use_previous_output') and accumulated_output:
                    prev_output = accumulated_output.get(f'step{i-1}', '')
                    if 'prompt' in step_task:
                        step_task['prompt'] = step_task['prompt'].replace(
                            '{previous_output}',
                            str(prev_output)
                        )
                
                # ステップ実行
                step_result = await self.task_executor.execute_task(step_task)
                
                results.append(step_result)
                accumulated_output[f'step{i}'] = step_result
                
                # 失敗時の処理
                if not step_result or (hasattr(step_result, 'get') and not step_result.get('success')):
                    if step.get('continue_on_failure', False):
                        logger.warning(f"⚠️ ステップ {i} 失敗したが継続")
                    else:
                        logger.error(f"❌ ステップ {i} 失敗 - ワークフロー中断")
                        return {
                            'success': False,
                            'error': f'ステップ {i} 失敗',
                            'completed_steps': i - 1,
                            'results': results
                        }
                
                logger.info(f"✅ ステップ {i} 完了")
                await asyncio.sleep(1)
            
            logger.info(f"✅ 全 {len(steps)} ステップ完了")
            
            return {
                'success': True,
                'steps_completed': len(steps),
                'results': results,
                'accumulated_output': accumulated_output,
                'full_text': str(accumulated_output)
            }
        
        except Exception as e:
            logger.error(f"❌ シーケンシャルワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_sequential_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_parallel_workflow(self, task: Dict) -> Dict:
        """
        並列ワークフロー（複数タスク同時実行）
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        parallel_tasks = task.get('parallel_tasks', [])
        
        if not parallel_tasks:
            logger.warning("並列タスク定義なし")
            return {'success': False, 'error': '並列タスクが定義されていません'}
        
        try:
            logger.info(f"⚡ 並列ワークフロー実行 ({len(parallel_tasks)}タスク)")
            
            # 並列タスクリスト構築
            coroutines = []
            for i, parallel_task in enumerate(parallel_tasks, 1):
                parallel_task_config = {
                    **task,
                    **parallel_task,
                    'task_id': f"{task_id}_parallel{i}"
                }
                coroutines.append(
                    self.task_executor.execute_task(parallel_task_config)
                )
            
            # 並列実行
            results = await asyncio.gather(*coroutines, return_exceptions=True)
            
            # 結果分析
            success_count = sum(
                1 for r in results 
                if r and not isinstance(r, Exception) and (r is True or (hasattr(r, 'get') and r.get('success')))
            )
            
            logger.info(f"✅ 並列ワークフロー完了: {success_count}/{len(results)} 成功")
            
            return {
                'success': success_count == len(results),
                'partial_success': success_count > 0 and success_count < len(results),
                'results': results,
                'summary': f'{success_count}/{len(results)} タスク成功'
            }
        
        except Exception as e:
            logger.error(f"❌ 並列ワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_parallel_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_conditional_workflow(self, task: Dict) -> Dict:
        """
        条件分岐ワークフロー
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("🔀 条件分岐ワークフロー実行")
            
            # 条件評価タスク実行
            condition_task = task.get('condition_task')
            if not condition_task:
                return {'success': False, 'error': '条件タスクが定義されていません'}
            
            condition_result = await self.task_executor.execute_task(condition_task)
            
            # 条件評価
            condition_met = self._evaluate_condition(condition_result, task.get('condition'))
            
            # 分岐実行
            if condition_met:
                logger.info("✅ 条件成立 - then分岐実行")
                then_task = task.get('then_task')
                if then_task:
                    result = await self.task_executor.execute_task(then_task)
                    return {'success': True, 'branch': 'then', 'result': result}
            else:
                logger.info("❌ 条件不成立 - else分岐実行")
                else_task = task.get('else_task')
                if else_task:
                    result = await self.task_executor.execute_task(else_task)
                    return {'success': True, 'branch': 'else', 'result': result}
            
            return {'success': True, 'branch': 'none'}
        
        except Exception as e:
            logger.error(f"❌ 条件分岐ワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_conditional_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _evaluate_condition(self, result: Any, condition: Dict) -> bool:
        """
        条件を評価
        
        Args:
            result: 評価対象の結果
            condition: 条件定義辞書
            
        Returns:
            bool: 条件成立フラグ
        """
        if not condition:
            return True
        
        condition_type = condition.get('type', 'success')
        
        if condition_type == 'success':
            return result and (result is True or (hasattr(result, 'get') and result.get('success')))
        elif condition_type == 'contains':
            target_text = condition.get('text', '')
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return target_text.lower() in content.lower()
        elif condition_type == 'length':
            min_length = condition.get('min_length', 0)
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return len(content) >= min_length
        
        return False
    
    def get_workflow_stats(self) -> Dict:
        """ワークフロー統計情報を取得"""
        return self.workflow_stats.copy()

#wp_acf_agent.py
"""
WordPress ACF設計・設定エージェント
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressACFAgent:
    """ACF設計・設定専門エージェント"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """ACFタスクを実行"""
        # 実装（wp_cpt_agent.py と同様のパターン）
        return {
            'success': True,
            'message': 'ACF設定完了（実装中）',
            'task_id': task.get('task_id')
        }
        
"""
専門エージェントの修正パターン例
（wp_acf_agent.py, wp_cpt_agent.py などに適用）

❌ エラーが発生するパターン（修正前）
✅ 安全なパターン（修正後）
"""

# ========================================
# ❌ エラーパターン1: 条件分岐外での変数参照
# ========================================

# --- 修正前（エラーが発生） ---
async def save_generated_code_BAD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """❌ このパターンはエラーが発生します"""
    
    # 条件分岐内でのみ変数を定義
    if output_type == 'php':
        php_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        json_filename = f"acf_{task_id}.json"
    
    # ここで変数を参照すると、条件に合致しなかった場合にエラー！
    # UnboundLocalError: cannot access local variable 'php_filename' where it is not associated with a value
    await self.browser.save_text_to_file(content, php_filename)  # ❌ エラー発生箇所


# --- 修正後（安全） ---
async def save_generated_code_GOOD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """✅ このパターンは安全です"""
    
    # === 方法1: 最初に変数を初期化 ===
    final_filename = None  # 最初に初期化（重要！）
    
    if output_type == 'php':
        final_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        final_filename = f"acf_{task_id}.json"
    else:
        # デフォルト値を設定（どの条件にも合致しない場合）
        final_filename = f"output_{task_id}.txt"
    
    # 安全に参照可能
    if final_filename:
        await self.browser.save_text_to_file(content, final_filename)
    else:
        logger.error("❌ ファイル名が決定できませんでした")


# ========================================
# ❌ エラーパターン2: 複雑な条件分岐
# ========================================

# --- 修正前（エラーリスク高） ---
async def process_and_save_BAD(self, task: dict, generated_content: str):
    """❌ 複雑な条件でエラーリスクが高い"""
    
    task_type = task.get('type')
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = 'ma_case_template.php'
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = 'acf_fields.json'
    
    # 上記の条件に合致しない場合、output_filenameが未定義！
    save_result = await self._save_file(output_filename, generated_content)  # ❌ エラー


# --- 修正後（安全） ---
async def process_and_save_GOOD(self, task: dict, generated_content: str):
    """✅ デフォルト値で安全に処理"""
    
    task_type = task.get('type')
    task_id = task.get('task_id', 'unknown')
    
    # === デフォルト値を最初に設定 ===
    output_filename = f"output_{task_id}.txt"  # デフォルト
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = f"ma_case_template_{task_id}.php"
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = f"acf_fields_{task_id}.json"
    
    # 常にoutput_filenameが定義されているので安全
    save_result = await self._save_file(output_filename, generated_content)  # ✅ 安全


# ========================================
# ✅ 推奨パターン: 親クラスのヘルパーメソッド使用
# ========================================

class WordPressACFAgent:
    """ACF設計エージェント（修正例）"""
    
    def __init__(self, browser, output_folder, parent_agent=None):
        self.browser = browser
        self.output_folder = output_folder
        self.parent_agent = parent_agent  # 親のWordPressDevAgentへの参照
    
    async def execute(self, task: dict):
        """タスク実行"""
        task_id = task.get('task_id', 'unknown')
        
        try:
            # AIでコンテンツ生成
            generated_content = await self._generate_acf_fields(task)
            
            # === 推奨: 親エージェントの安全なヘルパーを使用 ===
            if self.parent_agent and hasattr(self.parent_agent, 'safe_save_code_file'):
                save_result = await self.parent_agent.safe_save_code_file(
                    content=generated_content,
                    task_id=task_id,
                    file_type='json',  # or 'php'
                    custom_filename=None  # 自動生成
                )
                
                if save_result['success']:
                    logger.info(f"✅ 保存成功: {save_result['filepath']}")
                    return {
                        'success': True,
                        'output_file': save_result['filepath']
                    }
                else:
                    logger.error(f"❌ 保存失敗: {save_result['error']}")
                    return {
                        'success': False,
                        'error': save_result['error']
                    }
            else:
                # === フォールバック: 自前で安全に処理 ===
                return await self._safe_save_fallback(task_id, generated_content)
        
        except Exception as e:
            logger.error(f"❌ 実行エラー: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _safe_save_fallback(self, task_id: str, content: str):
        """安全なフォールバック保存"""
        # 変数を最初に初期化
        filename = None
        saved_path = None
        
        try:
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # ファイル名決定
            filename = f"acf_output_{task_id}_{timestamp}.json"
            output_path = self.output_folder / filename
            
            # 保存実行
            if hasattr(self.browser, 'save_text_to_file'):
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
            else:
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                saved_path = str(output_path)
            
            return {
                'success': True,
                'output_file': saved_path
            }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"保存エラー: {e}"
            }


# ========================================
# 🔧 実際の修正手順（各専門エージェントファイルで実行）
# ========================================

"""
1. wordpress/wp_dev/__init__.py を確認し、親エージェントの参照を渡す:

   from .wp_acf_agent import WordPressACFAgent
   
   # 初期化時に親エージェントを渡す
   def create_agents(browser, output_folder, parent):
       acf_agent = WordPressACFAgent(
           browser, 
           output_folder,
           parent_agent=parent  # 追加
       )
       return acf_agent

2. 各専門エージェント（wp_acf_agent.py など）内のファイル保存ロジックを探す:
   
   検索キーワード:
   - "filename" + "if" または "elif"
   - "save" + "file"
   - ".php" または ".json"

3. 上記のパターンに従って修正:
   
   修正前:
   ```python
   if condition:
       php_filename = "something.php"
   
   await save(php_filename)  # ❌ エラー
   ```
   
   修正後:
   ```python
   php_filename = None  # 最初に初期化
   
   if condition:
       php_filename = "something.php"
   else:
       php_filename = "default.txt"  # デフォルト値
   
   if php_filename:
       await save(php_filename)  # ✅ 安全
   ```

4. または、親のヘルパーメソッドを使用:
   
   ```python
   result = await self.parent_agent.safe_save_code_file(
       content=generated_code,
       task_id=task_id,
       file_type='php'
   )
   ```
"""

#wp_agent.py
""" wp_agent.py WordPressエージェント - メインオーケストレーター"""
import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path
from playwright.async_api import Page

from config_utils import ErrorHandler
from browser_controller import BrowserController

from .wp_auth import WordPressAuth
from .wp_post_editor import WordPressPostEditor
from .wp_post_creator import WordPressPostCreator
from .wp_plugin_manager import WordPressPluginManager
from .wp_settings_manager import WordPressSettingsManager
from .wp_tester import WordPressTester
from .wp_utils import TaskTypeAnalyzer

logger = logging.getLogger(__name__)


    # === 修正開始: WordPressAgentクラスに自動ログイン機能を追加 ===

class WordPressAgent:
    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        初期化
        
        Args:
            browser_controller: BrowserController インスタンス
            wp_credentials: WordPress 認証情報
                - wp_url: サイトURL
                - wp_user: ユーザー名
                - wp_pass: パスワード
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.is_logged_in = False
        
        # WordPress 専用ページ（新しいタブ）
        self.wp_page = None
        
        # 認証情報の取得
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        self.wp_user = self.wp_credentials.get('wp_user', '')
        self.wp_pass = self.wp_credentials.get('wp_pass', '')
        
        # WordPress 認証モジュール
        if self.wp_url and self.wp_user and self.wp_pass:
            self.auth = WordPressAuth(
                browser_controller=self.browser,
                wp_url=self.wp_url,
                wp_user=self.wp_user,
                wp_pass=self.wp_pass
            )
        else:
            logger.warning("⚠️ WordPress 認証情報が不完全です")
            self.auth = None
        
        # ========================================
        # ✅ ここに追加：サブエージェントの初期化
        # ========================================
        
        # シートマネージャー（後で外部から設定される）
        self.sheets_manager = None
        
        # 投稿編集エージェント
        self.post_editor = WordPressPostEditor(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressPostEditor 初期化完了")
        
        # 投稿作成エージェント
        self.post_creator = WordPressPostCreator(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressPostCreator 初期化完了")
        
        # プラグインマネージャー
        self.plugin_manager = WordPressPluginManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressPluginManager 初期化完了")
        
        # 設定マネージャー
        self.settings_manager = WordPressSettingsManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressSettingsManager 初期化完了")
        
        # テスター
        self.tester = WordPressTester(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressTester 初期化完了")
        
        logger.info("="*60)
        logger.info("WordPressAgent 全サブエージェント初期化完了")
        logger.info("="*60)
    async def initialize_wp_session(self) -> bool:
        """
        WordPress セッション初期化（完全修正版 - クッキー強制ナビゲーション対応）
            
        改善点:
        1. 新しいタブ作成（Gemini セッションとは完全独立）
        2. クッキー適用 + 管理画面への強制ナビゲーション
        3. ログイン状態の厳格な検証
        4. 失敗時の手動ログインフォールバック
            
        Returns:
            bool: 初期化成功時 True
        """
        try:
            logger.info("="*60)
            logger.info("🔐 WordPress セッション初期化中...")
            logger.info("="*60)
                
            # ✅ Phase 1: 新しいタブを作成
            if not self.browser.context:
                logger.error("❌ ブラウザコンテキストが初期化されていません")
                return False
                
            self.wp_page = await self.browser.context.new_page()
            logger.info("✅ WordPress 専用タブを作成しました")
                
            # ✅ Phase 2: 認証情報の検証
            if not self.auth:
                logger.error("❌ WordPress 認証モジュールが初期化されていません")
                return False
                
            # ✅ Phase 3: ログイン実行（クッキー優先 + 強制ナビゲーション）
            logger.info("🔄 WordPress認証を実行中...")
            login_success = await self.auth.login(self.wp_page)
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("✅ WordPress セッション初期化完了")
                logger.info("  認証方法: クッキー or 手動ログイン")
                logger.info("  ページURL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("❌ WordPress ログイン失敗")
                logger.error("  原因: 認証情報またはネットワークの問題")
                logger.error("  対策: 認証情報を確認してください")
                logger.error("="*60)
                    
                # デバッグ用: 失敗時のスクリーンショット
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("📸 デバッグ用スクリーンショット: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"❌ WordPress セッション初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def ensure_logged_in(self) -> bool:
        """
        ログイン状態を保証
    
        Returns:
            bool: ログイン済みまたはログイン成功時 True
        """
        if self.is_logged_in and self.wp_page:
            # 定期的にログイン状態を確認
            if await self.auth._verify_login_status(self.wp_page):
                return True
    
        # ログインしていない場合は再初期化
        logger.info("🔄 WordPress 再ログインを試行します")
        return await self.initialize_wp_session()
    
    async def _try_cookie_login(self, wp_url: str) -> bool:
        """クッキーを使用したログイン試行"""
        try:
            if not wp_url:
                logger.warning("⚠️ WordPress URLが設定されていません")
                return False
        
            # WordPressクッキーをロード
            cookie_loaded = await self.browser.load_wordpress_cookies(wp_url)
            if not cookie_loaded:
                return False
        
            # 管理画面にアクセスしてログイン状態を確認
            admin_url = f"{wp_url.rstrip('/')}/wp-admin/"
            await self.browser.page.goto(admin_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ログイン状態を詳細チェック
            return await self._verify_wordpress_login_status()
        
        except Exception as e:
            logger.warning(f"⚠️ クッキーログイン試行エラー: {e}")
            return False

    async def _verify_wordpress_login_status(self) -> bool:
        """WordPressログイン状態を詳細検証"""
        try:
            page = self.browser.page
        
            # 複数の方法でログイン状態を確認
            checks = []
        
            # 1. 管理バーの存在チェック
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('管理バー', bool(admin_bar)))
        
            # 2. ダッシュボード要素チェック
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ダッシュボード', bool(dashboard)))
        
            # 3. ログインフォームの不在チェック
            login_form = await page.query_selector('#loginform')
            checks.append(('ログインフォーム不在', not bool(login_form)))
        
            # 4. URLチェック（リダイレクトされていないか）
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('管理ページURL', is_admin_page))
        
            # 結果の集計
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
        
            logger.info(f"🔍 ログイン状態検証: {total_passed}/4 合格")
            if total_passed >= 3:  # 4つのうち3つ以上合格ならログイン成功
                logger.info(f"  合格項目: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  不合格項目が多すぎます")
                return False
            
        except Exception as e:
            logger.warning(f"⚠️ ログイン状態検証エラー: {e}")
            return False

    async def _manual_wordpress_login(self) -> bool:
        """手動WordPressログイン"""
        try:
            wp_url = self.wp_credentials.get('wp_url', '')
            wp_user = self.wp_credentials.get('wp_user', '')
            wp_pass = self.wp_credentials.get('wp_pass', '')
        
            if not all([wp_url, wp_user, wp_pass]):
                logger.error("❌ WordPress認証情報が不足しています")
                return False
        
            # ログインページに移動
            login_url = f"{wp_url.rstrip('/')}/wp-login.php"
            await self.browser.page.goto(login_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ユーザー名入力
            user_field = await self.browser.page.query_selector('#user_login')
            if user_field:
                await user_field.fill(wp_user)
                logger.info("✅ ユーザー名入力完了")
            else:
                logger.error("❌ ユーザー名入力フィールドが見つかりません")
                return False
        
            # パスワード入力
            pass_field = await self.browser.page.query_selector('#user_pass')
            if pass_field:
                await pass_field.fill(wp_pass)
                logger.info("✅ パスワード入力完了")
            else:
                logger.error("❌ パスワード入力フィールドが見つかりません")
                return False
        
            # ログインボタンクリック
            login_button = await self.browser.page.query_selector('#wp-submit')
            if login_button:
                await login_button.click()
                logger.info("✅ ログインボタンクリック")
            else:
                logger.error("❌ ログインボタンが見つかりません")
                return False
        
            # ログイン完了待機
            await self.browser.page.wait_for_load_state('networkidle')
            await asyncio.sleep(3)
        
            # ログイン成功確認
            if await self._verify_wordpress_login_status():
                logger.info("✅ 手動ログイン成功")
                return True
            else:
                logger.error("❌ 手動ログイン失敗 - 認証情報またはネットワークの問題")
                return False
            
        except Exception as e:
            logger.error(f"❌ 手動ログインエラー: {e}")
            return False

    async def ensure_logged_in(self) -> bool:
        """ログイン状態を保証"""
        if self.is_logged_in:
            return True
    
        # 定期的にログイン状態を確認
        if await self._verify_wordpress_login_status():
            self.is_logged_in = True
            return True
    
        # ログインしていない場合は再初期化
        return await self.initialize_wp_session()
       
    async def process_task(self, task: Dict) -> Dict:
        """WordPressタスクを処理"""
        try:
            # ログイン状態を確認
            if not await self.ensure_logged_in():
                return {
                    'success': False,
                    'error': 'WordPress にログインできませんでした'
                }
            # === パート1: タスク実行開始 ===
            logger.info("="*60)
            logger.info("WordPressエージェント: タスク実行開始")
            logger.info(f"タスク: {task['description']}")
            logger.info("="*60)
            
            # === パート2: シートマネージャー設定 ===
            self.post_editor.sheets_manager = self.sheets_manager
            self.post_creator.sheets_manager = self.sheets_manager
            
            # === パート3: タスクタイプ解析 ===
            task_type = TaskTypeAnalyzer.analyze(task['description'])
            logger.info(f"解析されたタスクタイプ: {task_type}")
            
            # === パート4: タスクタイプに応じた処理実行 ===
            result = await self._execute_task_by_type(task, task_type)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressタスク処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_task_by_type(self, task: Dict, task_type: str) -> Dict:
        """タスクタイプに応じて適切なモジュールに処理を委譲"""
        try:
            # === パート1: プラグイン関連タスク ===
            if task_type == 'plugin_install':
                result = await self.plugin_manager.install_plugin(self.wp_page, task)
            elif task_type == 'plugin_settings':
                result = await self.plugin_manager.change_plugin_settings(self.wp_page, task)
            
            # === パート2: 投稿関連タスク ===
            elif task_type == 'edit_post':
                result = await self.post_editor.edit_post(self.wp_page, task)
            elif task_type == 'content_create':
                result = await self.post_creator.create_post(self.wp_page, task)
            
            # === パート3: 設定関連タスク ===
            elif task_type == 'theme_change':
                result = await self.settings_manager.change_theme(self.wp_page, task)
            elif task_type == 'setting_change':
                result = await self.settings_manager.change_settings(self.wp_page, task)
            
            # === パート4: テストタスク ===
            elif task_type == 'test_functionality':
                result = await self.tester.test_functionality(self.wp_page, task)
            
            # === パート5: その他のタスク ===
            else:
                result = await self._generic_execution(task)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "タスクタイプ別実行")
            return {
                'success': False,
                'error': str(e)
            }

    async def create_post(self, page: Page, task: Dict) -> Dict:
        """新規投稿を作成（post_status対応版）"""
        try:
            # === パート1: タスクパラメータ取得 ===
            post_status = task.get('post_status', 'draft')
            post_action = task.get('post_action', 'create')
        
            logger.info(f"WordPress投稿作成:")
            logger.info(f"  アクション: {post_action}")
            logger.info(f"  ステータス: {post_status}")
        
            # === パート2: 記事コンテンツ設定 ===
            # （既存の記事取得・タイトル・本文設定処理）
            article_title = "デフォルトタイトル"  # 実際の実装では適切な値を設定
            polylang_lang = "ja"
            language = "日本語"
            article_body = ""
            screenshot_path = None
        
            # === パート3: 投稿ステータスに応じた処理 ===
            status_result = await self._handle_post_status(page, post_status, post_action)
            
            # === パート4: 結果サマリー構築 ===
            summary = self._build_create_summary(
                article_title, polylang_lang, language, 
                len(article_body), post_status, status_result['message']
            )
        
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'action': post_action,
                'screenshot': screenshot_path
            }
        
        except Exception as e:
            logger.error(f"❌ WordPress投稿作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _handle_post_status(self, page: Page, post_status: str, post_action: str) -> Dict:
        """投稿ステータスに応じた保存/公開処理"""
        try:
            # === パート1: 下書き保存の場合 ===
            if post_status == 'draft' or post_action == 'create':
                logger.info("\n【下書き保存中...】")
                saved = await self._save_draft(page)
            
                if saved:
                    logger.info("✅ 下書き保存完了")
                    return {'success': True, 'message': '下書き保存'}
                else:
                    logger.warning("⚠️ 下書き保存ボタンが見つかりませんでした")
                    return {'success': False, 'message': '保存確認推奨'}
        
            # === パート2: 公開の場合 ===
            elif post_status == 'publish' or post_action == 'publish':
                logger.info("\n【記事を公開中...】")
                published = await self._publish_post(page)
            
                if published:
                    logger.info("✅ 記事公開完了")
                    return {'success': True, 'message': '公開完了'}
                else:
                    logger.warning("⚠️ 公開ボタンが見つかりませんでした")
                    return {'success': False, 'message': '公開確認推奨'}
        
            # === パート3: その他のステータスの場合 ===
            else:
                logger.info(f"\n【カスタムステータス: {post_status}】")
                saved = await self._save_draft(page)
                return {
                    'success': saved, 
                    'message': f'保存完了（ステータス: {post_status}）'
                }
        
        except Exception as e:
            logger.error(f"投稿ステータス処理エラー: {e}")
            return {'success': False, 'message': f'エラー: {str(e)}'}


    async def _publish_post(self, page: Page) -> bool:
        """投稿を公開"""
        # === パート1: 公開ボタンセレクタ定義 ===
        publish_selectors = [
            'button:has-text("公開")',
            'button[aria-label="公開"]',
            '.editor-post-publish-button',
            'button.editor-post-publish-button__button'
        ]
    
        logger.debug("公開ボタンを探索中...")
    
        # === パート2: 公開ボタン探索ループ ===
        for i, selector in enumerate(publish_selectors, 1):
            logger.debug(f"  試行 {i}/{len(publish_selectors)}: {selector}")
            try:
                publish_button = await page.query_selector(selector)
                if not publish_button:
                    continue
                    
                # === パート3: ボタン状態チェック ===
                is_visible = await publish_button.is_visible()
                is_disabled = await publish_button.is_disabled() if is_visible else True
            
                logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === パート4: 公開ボタンクリック ===
                    await publish_button.click()
                    await page.wait_for_timeout(2000)
                
                    # === パート5: 確認ダイアログ処理 ===
                    try:
                        confirm_button = await page.query_selector('button:has-text("公開")')
                        if confirm_button and await confirm_button.is_visible():
                            await confirm_button.click()
                            await page.wait_for_timeout(3000)
                    except:
                        pass
                
                    logger.info("✅ 公開ボタンクリック成功")
                    return True
                    
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
    
        logger.warning("❌ 公開ボタンが見つかりませんでした")
        return False


    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        # === パート1: 保存ボタンセレクタ定義 ===
        save_selectors = [
            'button:has-text("下書き保存")',
            'button[aria-label="下書き保存"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
    
        logger.debug("下書き保存ボタンを探索中...")
    
        # === パート2: 保存ボタン探索ループ ===
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  試行 {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if not save_button:
                    continue
                    
                # === パート3: ボタン状態チェック ===
                is_visible = await save_button.is_visible()
                is_disabled = await save_button.is_disabled() if is_visible else True
            
                logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === パート4: 保存ボタンクリック ===
                    await save_button.click()
                    await page.wait_for_timeout(4000)
                    logger.info("✅ 下書き保存ボタンクリック成功")
                    return True
                    
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
    
        logger.warning("❌ 下書き保存ボタンが見つかりませんでした")
        return False


    def _build_create_summary(self, title: str, polylang_lang: str, 
                             language: str, content_length: int, 
                             post_status: str, status_message: str) -> str:
        """新規投稿作成のサマリーを構築"""
        # === パート1: サマリー行の構築 ===
        summary_lines = []
        summary_lines.append("【WordPress投稿完了】")
        summary_lines.append(f"タイトル: {title}")
        summary_lines.append(f"言語: {language}")
        summary_lines.append(f"Polylang設定: {polylang_lang}")
        summary_lines.append(f"本文: {content_length}文字（HTML形式）")
        summary_lines.append(f"投稿ステータス: {post_status}")
        summary_lines.append(f"✅ {status_message}")
    
        # === パート2: サマリー文字列の結合 ===
        return '\n'.join(summary_lines)
    
    
    async def _generic_execution(self, task: Dict) -> Dict:
        """汎用的なタスク実行(Geminiに確認しながら実行)"""
        try:
            # === パート1: 実行開始 ===
            logger.info("汎用タスクを実行中...")
            
            # === パート2: Geminiプロンプト作成 ===
            gemini_prompt = self._build_gemini_prompt(task)
            
            # === パート3: Geminiに送信 ===
            await self.browser.send_prompt(gemini_prompt)
            await self.browser.wait_for_text_generation(max_wait=120)
            response = await self.browser.extract_latest_text_response()
            
            logger.info("Geminiから実行手順を取得しました")
            logger.info(f"手順:\n{response[:500]}...")
            
            # === パート4: 結果返却 ===
            return self._build_generic_result(task, response)
            
        except Exception as e:
            ErrorHandler.log_error(e, "汎用タスク実行")
            return {
                'success': False,
                'error': str(e)
            }

    def _build_gemini_prompt(self, task: Dict) -> str:
        """Gemini用プロンプトを構築"""
        return f"""
        WordPressで以下のタスクを実行したいです:

        【タスク】
        {task['description']}

        【WordPress情報】
        - URL: {self.wp_url}
        - 管理画面にログイン済み

        【質問】
        このタスクを実行するための具体的な手順を、WordPress管理画面の操作として教えてください。

        以下の形式で回答してください:
        1. 移動するページのURL(相対パス)
        2. クリックまたは入力する要素のセレクタ
        3. 入力する値
        4. 確認すべきポイント

        セレクタはできるだけ具体的に(id, class, name属性など)。
        """

    def _build_generic_result(self, task: Dict, response: str) -> Dict:
        """汎用実行の結果を構築"""
        logger.info("⚠️ 実際の実行は手動で確認してください")
        
        return {
            'success': True,
            'summary': 'Geminiから実行手順を取得しました。手順を確認して実行してください。',
            'full_text': f'【タスク】\n{task["description"]}\n\n【実行手順】\n{response}'
        }
    
    async def cleanup(self):
        """WordPressセッションをクリーンアップ"""
        # === パート1: ページクローズ ===
        if self.wp_page:
            await self.wp_page.close()
            logger.info("WordPressセッションを終了しました")


# === 追加機能メソッド（分割済み） ===

    async def configure_acf_fields(self, task_params: Dict) -> Dict:
        """Advanced Custom Fieldsのフィールドグループを設定"""
        try:
            # === パート1: パラメータ取得 ===
            field_group_name = task_params.get('acf_field_group_name')
            fields = task_params.get('acf_fields', [])
            location_rules = task_params.get('acf_location_rules', {})
            
            logger.info(f"ACFフィールドグループ '{field_group_name}' を設定中...")
            
            # === パート2: ACF画面移動 ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/edit.php?post_type=acf-field-group")
            await self.wp_page.wait_for_timeout(2000)
            
            # === パート3: 新規フィールドグループ追加 ===
            await self._click_acf_add_new_button()
            
            # === パート4: フィールドグループ名入力 ===
            await self._input_acf_field_group_name(field_group_name)
            
            # === パート5: スクリーンショットと結果返却 ===
            return await self._build_acf_result(field_group_name, fields, location_rules)
            
        except Exception as e:
            logger.error(f"ACF設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _click_acf_add_new_button(self):
        """ACF新規追加ボタンをクリック"""
        add_button_selectors = [
            'a.page-title-action:has-text("新規追加")',
            'a:has-text("Add New")',
            '.page-title-action'
        ]
        
        for selector in add_button_selectors:
            try:
                add_button = await self.wp_page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await self.wp_page.wait_for_timeout(3000)
                    break
            except:
                continue

    async def _input_acf_field_group_name(self, field_group_name: str):
        """ACFフィールドグループ名を入力"""
        title_input = await self.wp_page.query_selector('#title')
        if title_input:
            await title_input.fill(field_group_name)
            logger.info(f"フィールドグループ名を入力: {field_group_name}")

    async def _build_acf_result(self, field_group_name: str, fields: list, location_rules: dict) -> Dict:
        """ACF設定結果を構築"""
        # スクリーンショット
        screenshot_path = f"acf_setup_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("⚠️ ACFフィールドの詳細設定は手動で確認してください")
        
        return {
            'success': True,
            'summary': f'ACFフィールドグループ "{field_group_name}" の設定画面を開きました。',
            'field_group_name': field_group_name,
            'fields_count': len(fields),
            'screenshot': screenshot_path,
            'full_text': f'ACFフィールドグループ設定\n名前: {field_group_name}\nフィールド数: {len(fields)}\n※フィールド追加は手動で実施してください'
        }

    # （他の追加機能メソッドも同様に分割。以下は一部のみ表示）

    async def configure_custom_post_type(self, task_params: Dict) -> Dict:
        """Custom Post Type UIでカスタム投稿タイプを作成"""
        try:
            # === パート1: パラメータ取得 ===
            cpt_slug = task_params.get('cpt_slug')
            cpt_labels = task_params.get('cpt_labels', {})
            cpt_supports = task_params.get('cpt_supports', [])
            cpt_settings = task_params.get('cpt_settings', {})
            
            logger.info(f"カスタム投稿タイプ '{cpt_slug}' を作成中...")
            
            # === パート2: CPT UI画面移動 ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_post_types")
            await self.wp_page.wait_for_timeout(3000)
            
            # === パート3: 基本情報入力 ===
            await self._input_cpt_basic_info(cpt_slug, cpt_labels)
            
            # === パート4: 結果構築 ===
            return await self._build_cpt_result(cpt_slug, cpt_labels)
            
        except Exception as e:
            logger.error(f"Custom Post Type作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _input_cpt_basic_info(self, cpt_slug: str, cpt_labels: dict):
        """CPT基本情報を入力"""
        # Post Type Slug入力
        slug_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[name]"]')
        if slug_input:
            await slug_input.fill(cpt_slug)
            logger.info(f"スラッグを入力: {cpt_slug}")
        
        # Plural Label入力
        plural_label = cpt_labels.get('plural', cpt_slug)
        plural_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[label]"]')
        if plural_input:
            await plural_input.fill(plural_label)
            logger.info(f"複数形ラベルを入力: {plural_label}")
        
        # Singular Label入力
        singular_label = cpt_labels.get('singular', cpt_slug)
        singular_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[singular_label]"]')
        if singular_input:
            await singular_input.fill(singular_label)
            logger.info(f"単数形ラベルを入力: {singular_label}")

    async def _build_cpt_result(self, cpt_slug: str, cpt_labels: dict) -> Dict:
        """CPT作成結果を構築"""
        screenshot_path = f"cpt_creation_{cpt_slug}_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("⚠️ 詳細設定とSupports設定は手動で確認してください")
        
        return {
            'success': True,
            'summary': f'カスタム投稿タイプ "{cpt_slug}" の設定画面を開きました。',
            'cpt_slug': cpt_slug,
            'cpt_labels': cpt_labels,
            'screenshot': screenshot_path,
            'full_text': f'Custom Post Type作成\nスラッグ: {cpt_slug}\nラベル: {cpt_labels}\n※Supports設定等は手動で実施してください'
        }


    # === 3. カスタムタクソノミー作成機能 ===
    async def configure_custom_taxonomy(self, task_params: Dict) -> Dict:
        """
        Custom Post Type UIでカスタムタクソノミーを作成
        
        Parameters:
            taxonomy_slug: str - タクソノミースラッグ
            taxonomy_labels: dict - ラベル設定
            taxonomy_post_types: list - 紐づける投稿タイプ
            taxonomy_hierarchical: bool - 階層構造の有無
        """
        try:
            taxonomy_slug = task_params.get('taxonomy_slug')
            taxonomy_labels = task_params.get('taxonomy_labels', {})
            taxonomy_post_types = task_params.get('taxonomy_post_types', [])
            taxonomy_hierarchical = task_params.get('taxonomy_hierarchical', True)
            
            logger.info(f"カスタムタクソノミー '{taxonomy_slug}' を作成中...")
            
            # 1 Custom Post Type UI - Taxonomies画面に移動
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_taxonomies")
            await self.wp_page.wait_for_timeout(3000)
            
            # 2 Taxonomy Slug入力
            slug_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[name]"]')
            if slug_input:
                await slug_input.fill(taxonomy_slug)
                logger.info(f"タクソノミースラッグを入力: {taxonomy_slug}")
            
            # 3 Plural Label入力
            plural_label = taxonomy_labels.get('plural', taxonomy_slug)
            plural_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[label]"]')
            if plural_input:
                await plural_input.fill(plural_label)
                logger.info(f"複数形ラベルを入力: {plural_label}")
            
            # 4 Singular Label入力
            singular_label = taxonomy_labels.get('singular', taxonomy_slug)
            singular_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[singular_label]"]')
            if singular_input:
                await singular_input.fill(singular_label)
                logger.info(f"単数形ラベルを入力: {singular_label}")
            
            # 5 スクリーンショット
            screenshot_path = f"taxonomy_creation_{taxonomy_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("⚠️ Attach to Post Typesと階層設定は手動で確認してください")
            
            return {
                'success': True,
                'summary': f'カスタムタクソノミー "{taxonomy_slug}" の設定画面を開きました。',
                'taxonomy_slug': taxonomy_slug,
                'taxonomy_labels': taxonomy_labels,
                'screenshot': screenshot_path,
                'full_text': f'Custom Taxonomy作成\nスラッグ: {taxonomy_slug}\nラベル: {taxonomy_labels}\n※投稿タイプ紐付けは手動で実施してください'
            }
            
        except Exception as e:
            logger.error(f"カスタムタクソノミー作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 4. M&A案件投稿機能（ACFフィールド付き） ===
    async def create_ma_case_post(self, task_params: Dict) -> Dict:
        """
        M&A案件をACFカスタムフィールド付きで投稿
        
        Parameters:
            post_title: str - 投稿タイトル
            post_content: str - 本文
            acf_fields: dict - ACFカスタムフィールドの値
            polylang_lang: str - 言語設定
            post_status: str - 投稿ステータス
        """
        try:
            post_title = task_params.get('post_title')
            post_content = task_params.get('post_content', '')
            acf_fields = task_params.get('acf_fields', {})
            polylang_lang = task_params.get('polylang_lang', 'ja')
            post_status = task_params.get('post_status', 'draft')
            
            logger.info(f"M&A案件投稿: {post_title}")
            
            # 1 新規投稿画面に移動（ma_case投稿タイプ）
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post-new.php?post_type=ma_case")
            await self.wp_page.wait_for_timeout(5000)
            
            # 2 タイトル入力
            await self._input_title(self.wp_page, post_title)
            
            # 3 本文入力（ある場合）
            if post_content:
                await self._input_content(self.wp_page, post_content)
            
            # 4 ACFフィールドに値を入力
            logger.info("ACFフィールドに値を入力中...")
            for field_name, field_value in acf_fields.items():
                try:
                    # フィールド名からセレクタを推測
                    field_selector = f'input[name="acf[{field_name}]"]'
                    field_input = await self.wp_page.query_selector(field_selector)
                    
                    if field_input:
                        await field_input.fill(str(field_value))
                        logger.info(f"  {field_name}: {field_value}")
                    else:
                        logger.warning(f"  フィールド '{field_name}' が見つかりません")
                except Exception as e:
                    logger.warning(f"  フィールド '{field_name}' 入力エラー: {e}")
            
            # 5 Polylang言語設定
            await self._set_polylang_language(self.wp_page, polylang_lang)
            
            # 6 スクリーンショット
            screenshot_path = f"ma_case_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            # 7 保存または公開
            if post_status == 'draft':
                saved = await self._save_draft(self.wp_page)
                status_message = "下書き保存完了" if saved else "保存確認推奨"
            elif post_status == 'publish':
                published = await self._publish_post(self.wp_page)
                status_message = "公開完了" if published else "公開確認推奨"
            else:
                saved = await self._save_draft(self.wp_page)
                status_message = f"保存完了（ステータス: {post_status}）"
            
            summary = f"""【M&A案件投稿完了】
    タイトル: {post_title}
    言語: {polylang_lang}
    ACFフィールド: {len(acf_fields)}件
    投稿ステータス: {post_status}
    ✅ {status_message}"""
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'acf_fields_count': len(acf_fields),
                'screenshot': screenshot_path,
                'full_text': summary
            }
            
        except Exception as e:
            logger.error(f"M&A案件投稿エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 5. Polylang翻訳連携機能 ===
    async def link_polylang_translations(self, original_post_id: int, translated_post_id: int, lang_code: str) -> Dict:
        """
        Polylangで投稿同士を翻訳関係として連携
        
        Parameters:
            original_post_id: int - 元の投稿ID
            translated_post_id: int - 翻訳先の投稿ID
            lang_code: str - 翻訳先の言語コード
        """
        try:
            logger.info(f"Polylang翻訳連携: {original_post_id} → {translated_post_id} ({lang_code})")
            
            # 元の投稿の編集画面を開く
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post.php?post={original_post_id}&action=edit")
            await self.wp_page.wait_for_timeout(3000)
            
            # Polylang言語メタボックスで+ボタンをクリック
            logger.info("Polylang言語設定メタボックスを操作中...")
            
            # スクリーンショット
            screenshot_path = f"polylang_link_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("⚠️ Polylang翻訳連携は手動で確認してください")
            
            return {
                'success': True,
                'summary': f'投稿ID {original_post_id} の編集画面を開きました。Polylang設定で投稿ID {translated_post_id} を連携してください。',
                'original_post_id': original_post_id,
                'translated_post_id': translated_post_id,
                'lang_code': lang_code,
                'screenshot': screenshot_path,
                'full_text': f'Polylang翻訳連携\n元投稿ID: {original_post_id}\n翻訳先ID: {translated_post_id}\n言語: {lang_code}\n※手動で連携を完了してください'
            }
            
        except Exception as e:
            logger.error(f"Polylang翻訳連携エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _calculate_dynamic_timeout(self, text_content: str) -> int:
        """動的タイムアウト計算 - WP処理対応"""
        base_timeout = 120
            
        # 既存のキーワード
        long_task_keywords = [
            '要件定義', '設計書', 'コード生成', '実装'
        ]
            
        # === 新規追加: WordPress専用キーワード ===
        wp_long_task_keywords = [
            'FacetWP', 'Relevanssi', 'インデックス再構築',
            'WP-CLI', 'データベース移行', 'プラグイン一括',
            'ACF Pro ライセンス', 'カスタムフィールド同期'
        ]
            
        # 通常の長時間タスク
        if any(kw in text_content for kw in long_task_keywords):
            base_timeout = 300
            
        # === WP特化の超長時間タスク ===
        if any(kw in text_content for kw in wp_long_task_keywords):
            base_timeout = 600  # 10分
            logger.info(f"⏱️ config WP長時間処理を検出 - タイムアウト: {base_timeout}秒")
        
        async def cleanup(self):
            """WordPress セッションをクリーンアップ"""
            if self.wp_page:
                try:
                    await self.wp_page.close()
                    logger.info("WordPress セッションを終了しました")
                except Exception as e:
                    logger.warning(f"⚠️ WordPress ページクローズエラー: {e}")
            
        return base_timeout
            

#wp_auth.py
"""WordPress認証・ログイン管理（完全修正版 - クッキー強制ナビゲーション対応）"""
import asyncio
import logging
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressAuth:
    """WordPress認証管理（BrowserController統合版 + クッキー強制ナビゲーション対応）"""
    
    def __init__(self, browser_controller, wp_url: str, wp_user: str, wp_pass: str):
        """
        初期化
        
        Args:
            browser_controller: BrowserController インスタンス
            wp_url: WordPress サイトURL
            wp_user: ユーザー名
            wp_pass: パスワード
        """
        self.browser = browser_controller
        self.wp_url = wp_url.rstrip('/')
        self.wp_user = wp_user
        self.wp_pass = wp_pass
    
    async def login(self, page: Page) -> bool:
        """
        WordPressにログイン（クッキー優先 + 強制ナビゲーション版）
        
        改善点:
        1. クッキー適用後に必ず管理画面URLへナビゲーション
        2. ログイン状態検証の厳格化
        3. 失敗時のフォールバック強化
        
        Args:
            page: Playwright Page オブジェクト
            
        Returns:
            bool: ログイン成功時 True
        """
        try:
            logger.info("="*60)
            logger.info("WordPress: ログイン開始（クッキー優先 + 強制ナビゲーション）")
            logger.info(f"URL: {self.wp_url}")
            logger.info("="*60)
            
            # ✅ Phase 1: クッキーでのログインを試行
            cookies_loaded = await self.browser.load_wordpress_cookies(self.wp_url)
            
            if cookies_loaded:
                logger.info("✅ WordPress クッキーを読み込みました")
                
                # ✅ 重要: クッキー適用後に管理画面に強制ナビゲーション
                admin_url = f"{self.wp_url}/wp-admin/"
                logger.info(f"🔄 管理画面にナビゲーション中: {admin_url}")
                
                try:
                    await page.goto(admin_url, timeout=30000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)  # セッション確立を待機
                    
                    # ✅ Phase 2: ログイン状態を厳格に検証
                    if await self._verify_login_status(page):
                        logger.info("✅ クッキー認証成功 - 既にログイン済み")
                        
                        # スクリーンショット保存
                        screenshot_path = f"wp_cookie_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                        await page.screenshot(path=screenshot_path)
                        logger.info(f"📸 クッキーログイン成功: {screenshot_path}")
                        
                        return True
                    else:
                        logger.warning("⚠️ クッキー認証失敗 - 手動ログインを実行します")
                        
                except Exception as nav_error:
                    logger.warning(f"⚠️ 管理画面ナビゲーションエラー: {nav_error}")
            
            # ✅ Phase 3: クッキー認証が失敗した場合は手動ログイン
            return await self.manual_login(page)
                
        except Exception as e:
            logger.error(f"❌ ログインエラー: {e}")
            # フォールバック: 手動ログイン
            return await self.manual_login(page)
    
    async def manual_login(self, page: Page) -> bool:
        """
        手動ログイン（ユーザー名/パスワード方式）
        
        Args:
            page: Playwright Page オブジェクト
            
        Returns:
            bool: ログイン成功時 True
        """
        try:
            logger.info("🔐 手動ログインを実行します")
            
            # ログインページに移動
            login_url = f"{self.wp_url}/wp-login.php"
            await page.goto(login_url, timeout=30000, wait_until="domcontentloaded")
            await asyncio.sleep(2)
            
            # ユーザー名入力
            user_field = await page.query_selector('#user_login')
            if not user_field:
                logger.error("❌ ユーザー名入力フィールドが見つかりません")
                return False
            
            await user_field.fill(self.wp_user)
            await asyncio.sleep(0.5)
            logger.info("✅ ユーザー名入力完了")
            
            # パスワード入力
            pass_field = await page.query_selector('#user_pass')
            if not pass_field:
                logger.error("❌ パスワード入力フィールドが見つかりません")
                return False
            
            await pass_field.fill(self.wp_pass)
            await asyncio.sleep(0.5)
            logger.info("✅ パスワード入力完了")
            
            # ログインボタンをクリック
            login_button = await page.query_selector('#wp-submit')
            if not login_button:
                logger.error("❌ ログインボタンが見つかりません")
                return False
            
            await login_button.click()
            await asyncio.sleep(5)
            logger.info("✅ ログインボタンをクリックしました")
            
            # ログイン成功確認
            if await self._verify_login_status(page):
                logger.info("✅ WordPress手動ログイン成功")
                
                # ✅ ログイン成功時にクッキーを保存
                await self.browser.save_wordpress_cookies(self.wp_url)
                
                # スクリーンショット保存
                screenshot_path = f"wp_manual_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                logger.info(f"📸 手動ログイン成功: {screenshot_path}")
                
                return True
            else:
                logger.error("❌ WordPressログイン失敗")
                
                # 失敗時のスクリーンショット
                await page.screenshot(path="wp_login_failed.png")
                
                # エラーメッセージの確認
                error_element = await page.query_selector('#login_error')
                if error_element:
                    error_text = await error_element.text_content()
                    logger.error(f"ログインエラーメッセージ: {error_text}")
                
                return False
                
        except Exception as e:
            logger.error(f"❌ 手動ログインエラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _verify_login_status(self, page: Page) -> bool:
        """
        WordPressログイン状態を詳細検証（厳格版）
        
        改善点:
        1. URL確認を最優先
        2. 4つのチェックのうち3つ以上で合格判定
        3. 各チェック結果を詳細にログ出力
        
        Args:
            page: Playwright Page オブジェクト
            
        Returns:
            bool: ログイン済みの場合 True
        """
        try:
            checks = []
            
            # ✅ 1. URL確認（最優先）
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('管理ページURL', is_admin_page))
            
            # ✅ 2. 管理バーの存在チェック
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('管理バー', bool(admin_bar)))
            
            # ✅ 3. ダッシュボード要素チェック
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ダッシュボード', bool(dashboard)))
            
            # ✅ 4. ログインフォームの不在チェック
            login_form = await page.query_selector('#loginform')
            checks.append(('ログインフォーム不在', not bool(login_form)))
            
            # 結果の集計
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
            
            logger.info(f"🔍 ログイン状態検証: {total_passed}/4 合格")
            
            # ✅ 詳細ログ出力
            for name, passed in checks:
                status = "✅" if passed else "❌"
                logger.info(f"  {status} {name}")
            
            if total_passed >= 3:  # 4つのうち3つ以上合格ならログイン成功
                logger.info(f"  ✅ 合格項目: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  ❌ 不合格が多すぎます（合格: {total_passed}/4）")
                logger.warning(f"  現在URL: {current_url}")
                return False
                
        except Exception as e:
            logger.warning(f"⚠️ ログイン状態検証エラー: {e}")
            return False

#wp_cpt_agent.py
"""
WordPressカスタム投稿タイプ作成エージェント
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """カスタム投稿タイプ作成専門エージェント"""
    
    PROMPT_TEMPLATE = """あなたはWordPress開発の専門家です。

【タスク】
以下の仕様でカスタム投稿タイプを作成するPHPコードを生成してください：

{cpt_spec}

【出力要件】
1. 完全に動作するPHPコード
2. register_post_type() を使用
3. 多言語対応（Polylang互換）
4. エラーハンドリング付き
5. コメント付き

【出力形式】
```php
<?php
/**
 * カスタム投稿タイプ: {cpt_name}
 * 作成日: {date}
 */

function register_cpt_{cpt_slug}() {{
    // コード実装
}}
add_action('init', 'register_cpt_{cpt_slug}', 0);
完全なPHPコードを出力してください。
"""
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder

    async def execute(self, task: Dict) -> Dict:
        """CPT作成タスクを実行"""
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '')
        
        try:
            logger.info("🔧 カスタム投稿タイプ作成開始")
            
            # CPT仕様を抽出
            cpt_spec = self._extract_cpt_spec(description)
            
            # プロンプト構築
            prompt = self.PROMPT_TEMPLATE.format(
                cpt_spec=cpt_spec,
                cpt_name=cpt_spec.get('name', 'N/A'),
                cpt_slug=cpt_spec.get('slug', 'custom_post'),
                date=datetime.now().strftime('%Y-%m-%d')
            )
            
            # プロンプト送信
            await self.browser.send_prompt(prompt)
            
            # 応答待機
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                return {'success': False, 'error': 'タイムアウト'}
            
            # 応答取得
            response_text = await self.browser.extract_latest_text_response()
            
            # PHP保存
            output_file = await self._save_php_code(response_text, cpt_spec['slug'], task_id)
            
            return {
                'success': True,
                'message': f'CPT作成完了: {cpt_spec["slug"]}',
                'output_file': str(output_file),
                'cpt_slug': cpt_spec['slug'],
                'task_id': task_id
            }
            
        except Exception as e:
            logger.error(f"❌ CPT作成エラー: {e}")
            return {'success': False, 'error': str(e), 'task_id': task_id}

    def _extract_cpt_spec(self, description: str) -> Dict:
        """説明からCPT仕様を抽出"""
        # M&A案件の場合
        if 'ma_case' in description.lower() or 'm&a案件' in description:
            return {
                'slug': 'ma_case',
                'name': 'M&A案件',
                'singular': 'M&A案件',
                'plural': 'M&A案件一覧'
            }
        
        # デフォルト
        return {
            'slug': 'custom_post',
            'name': 'カスタム投稿',
            'singular': 'カスタム投稿',
            'plural': 'カスタム投稿一覧'
        }

    async def _save_php_code(self, code: str, slug: str, task_id: str) -> Path:
        """PHPコードを保存"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"cpt_{slug}_{task_id}_{timestamp}.php"
        output_path = self.output_folder / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        logger.info(f"✅ PHP保存: {filename}")
        return output_path

#### 3-3. `wordpress/wp_dev/wp_taxonomy_agent.py`
"""
WordPressタクソノミー作成エージェント
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressTaxonomyAgent:
    """タクソノミー作成専門エージェント"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """タクソノミー作成タスクを実行"""
        # 実装（wp_cpt_agent.py と同様のパターン）
        return {
            'success': True,
            'message': 'タクソノミー作成完了（実装中）',
            'task_id': task.get('task_id')
        }

#wp_design.py
# task_executor.py の execute_task メソッド内に追加

async def execute_task(self, task: Dict) -> bool:
    """単一タスクを実行（WordPress専用エージェント対応版）"""
    task_id = task.get('task_id', 'UNKNOWN')
    
    try:
        # ============================================================
        # === パート1: タスク開始ヘッダー表示 ===
        # ============================================================
        print("\n" + "📷"*40)
        print("=" * 80)
        print(f"🎯 タスク開始: {task_id}")
        print("=" * 80)
        print(f"📝 内容: {task['description'][:70]}...")
        print(f"👤 担当エージェント: {task['required_role'].upper()}")
        
        # ... タスクタイプ判定の既存コード ...
        
        print("=" * 80)
        print("📷"*40 + "\n")
        
        logger.info(f"タスク {task_id} 実行開始")
        
        # タスクのステータスを'in_progress'に更新
        try:
            await self.update_task_status(task, 'in_progress')
        except Exception as e:
            logger.warning(f"⚠️ ステータス更新失敗（続行）: {e}")
        
        # ============================================================
        # === パート2: タスクタイプ判定とタイムアウト設定 ===
        # ============================================================
        role = task['required_role'].lower()
        
        # タイムアウトマップ
        timeout_map = {
            'ma': 300.0,
            'content': 240.0,
            'review': 180.0,
            'wordpress': 300.0,
            'wp_design': 300.0,  # WordPress設計
            'wp_dev': 300.0,     # WordPress開発
            'default': 180.0
        }
        
        # タスクタイプを取得
        task_type = 'default'
        if HAS_TASK_ROUTER and task_router:
            try:
                task_type = task_router.determine_task_type(task)
                logger.info(f"📊 タスクタイプ判定: {task_type}")
            except Exception as e:
                logger.warning(f"⚠️ タスクタイプ判定失敗、デフォルト処理: {e}")
        
        task_timeout = timeout_map.get(task_type, timeout_map.get(role, 180.0))
        
        # ============================================================
        # === パート3: タスク実行（エージェント振り分け） ===
        # ============================================================
        result = None
        
        try:
            # --- 3-1: WordPress専用エージェント判定（最優先） ---
            if role == 'wp_design':
                logger.info("="*60)
                logger.info("🎨 WordPress設計AIエージェント実行中")
                logger.info("="*60)
                task_coro = self._execute_wp_design_task(task)
            
            elif role == 'wp_dev':
                logger.info("="*60)
                logger.info("💻 WordPress開発AIエージェント実行中")
                logger.info("="*60)
                task_coro = self._execute_wp_dev_task(task)
            
            # --- 3-2: タスクタイプベースの分岐 ---
            elif task_type == 'ma' and self.ma_executor:
                logger.info("="*60)
                logger.info("📊 M&A/企業検索タスクとして処理")
                logger.info("="*60)
                task_coro = self.ma_executor.execute_ma_task(task)
            
            elif task_type == 'content' and self.content_executor:
                logger.info("="*60)
                logger.info("✏️ 記事生成タスクとして処理")
                logger.info("="*60)
                task_coro = self.content_executor.execute_writer_task(task, role)
            
            elif task_type == 'review':
                logger.info("="*60)
                logger.info("✅ レビュータスクとして処理")
                logger.info("="*60)
                task_coro = self._execute_review_task(task)
            
            # --- 3-3: デフォルトのロール分岐 ---
            else:
                logger.info("="*60)
                logger.info(f"📋 デフォルトタスク ({role}) として処理")
                logger.info("="*60)
                
                if role == 'design':
                    task_coro = self._execute_design_task(task)
                elif role == 'dev':
                    task_coro = self._execute_dev_task(task)
                elif role == 'ui':
                    task_coro = self._execute_ui_task(task)
                elif role == 'wordpress':
                    task_coro = self._execute_wordpress_task(task)
                elif role == 'plugin':
                    task_coro = self._execute_plugin_task(task)
                else:
                    # 未登録エージェント
                    agent = self.agents.get(role)
                    if not agent:
                        logger.warning(f"担当エージェント '{role}' が見つかりません - スキップします")
                        await self.update_task_status(task, 'skipped', error=f"エージェント未登録")
                        return False
                    task_coro = agent.process_task(task)
            
            # --- 3-4: タイムアウト付きで実行 ---
            if HAS_ENHANCED_HANDLER:
                result = await EnhancedErrorHandler.timeout_wrapper(
                    task_coro,
                    timeout=task_timeout,
                    context=f"タスク {task_id} 実行"
                )
            else:
                result = await asyncio.wait_for(task_coro, timeout=task_timeout)
        
        # ============================================================
        # === パート4: タイムアウトエラーハンドリング ===
        # ============================================================
        except asyncio.TimeoutError:
            logger.error("="*60)
            logger.error(f"⏱️ タスク {task_id} タイムアウト（{task_timeout}秒）")
            logger.error("="*60)
            
            await self.update_task_status(
                task, 
                'failed', 
                error=f'タイムアウト（{task_timeout}秒）'
            )
            
            print("\n" + "📷"*40)
            print("=" * 80)
            print(f"⏱️ タスクタイムアウト: {task_id}")
            print(f"制限時間: {task_timeout}秒")
            print("=" * 80)
            print("📷"*40 + "\n")
            
            return False
        
        # ============================================================
        # === パート5: 一般的な例外ハンドリング ===
        # ============================================================
        except Exception as e:
            logger.error("="*60)
            logger.error(f"❌ タスク {task_id} 実行中に例外発生")
            logger.error(f"エラー: {str(e)}")
            logger.error("="*60)
            
            if HAS_ENHANCED_HANDLER:
                EnhancedErrorHandler.log_error_with_context(
                    e, 
                    f"タスク {task_id} 実行"
                )
            
            await self.update_task_status(task, 'failed', error=str(e))
            
            print("\n" + "📷"*40)
            print("=" * 80)
            print(f"💥 タスク例外: {task_id}")
            print(f"例外: {str(e)}")
            print("=" * 80)
            print("📷"*40 + "\n")
            
            return False
        
        # ============================================================
        # === パート6: 実行結果の処理（成功時） ===
        # ============================================================
        if result and result.get('success'):
            logger.info("="*60)
            logger.info(f"✅ タスク {task_id} 実行成功")
            logger.info("="*60)
            
            # --- 6-1: 結果保存 ---
            try:
                await self.update_task_status(task, 'completed')
                await self.save_task_output(task, result)
            except Exception as e:
                logger.warning(f"⚠️ 結果保存失敗（タスク自体は成功）: {e}")
            
            # --- 6-2: レビューAIでチェック ---
            if self.review_agent and role != 'review' and task_type != 'review':
                try:
                    logger.info("="*60)
                    logger.info("✅ レビューAIでチェックを開始")
                    logger.info("="*60)
                    
                    if HAS_ENHANCED_HANDLER:
                        await EnhancedErrorHandler.timeout_wrapper(
                            self.perform_review_and_add_tasks(task, result),
                            timeout=120.0,
                            context=f"レビュー（タスク {task_id}）"
                        )
                    else:
                        await asyncio.wait_for(
                            self.perform_review_and_add_tasks(task, result),
                            timeout=120.0
                        )
                except Exception as e:
                    logger.warning(f"⚠️ レビュー失敗（無視）: {e}")
            
            # --- 6-3: 成功メッセージ表示 ---
            print("\n" + "📷"*40)
            print("=" * 80)
            print(f"✅ タスク完了: {task_id}")
            print(f"タイプ: {task_type.upper()}")
            print(f"ステータス: 成功")
            print("=" * 80)
            print("📷"*40 + "\n")
            
            return True
        
        # ============================================================
        # === パート7: 実行結果の処理（失敗時） ===
        # ============================================================
        else:
            error_msg = result.get('error', '不明') if result else '結果なし'
            logger.error("="*60)
            logger.error(f"❌ タスク {task_id} 実行失敗")
            logger.error(f"エラー: {error_msg}")
            logger.error("="*60)
            
            await self.update_task_status(task, 'failed', error=error_msg)
            
            print("\n" + "📷"*40)
            print("=" * 80)
            print(f"❌ タスク失敗: {task_id}")
            print(f"タイプ: {task_type.upper()}")
            print(f"エラー: {error_msg}")
            print("=" * 80)
            print("📷"*40 + "\n")
            
            return False
    
    # ============================================================
    # === パート8: 最外層の例外ハンドリング ===
    # ============================================================
    except Exception as e:
        logger.error(f"❌ タスク {task_id} 処理全体で予期しないエラー")
        
        if HAS_ENHANCED_HANDLER:
            EnhancedErrorHandler.log_error_with_context(
                e, 
                f"タスク {task_id} 全体処理"
            )
        else:
            ErrorHandler.log_error(e, f"タスク {task_id} 実行")
        
        try:
            await self.update_task_status(task, 'failed', error=str(e))
        except:
            pass
        
        print("\n" + "📷"*40)
        print("=" * 80)
        print(f"💥 タスク重大エラー: {task_id}")
        print(f"例外: {str(e)}")
        print("=" * 80)
        print("📷"*40 + "\n")
        
        return False


async def _execute_wp_design_task(self, task: Dict) -> Dict:
    """WordPress設計タスクを実行"""
    logger.info("┌" + "─"*58 + "┐")
    logger.info("│ 🎨 WordPress設計AIエージェント実行中")
    logger.info("├" + "─"*58 + "┤")
    logger.info(f"│ タスク: {task.get('description', 'N/A')[:50]}")
    logger.info("└" + "─"*58 + "┘")
    
    try:
        # === パート1: エージェント取得 ===
        agent = self.agents.get('wp_design')
        if not agent:
            logger.error("❌ WordPress設計AIエージェントが登録されていません")
            return {
                'success': False,
                'error': 'wp_design エージェントが登録されていません'
            }

        # === パート2: タスク実行 ===
        result = await agent.process_task(task)
        
        # === パート3: 結果ログ出力 ===
        if result.get('success'):
            logger.info("✅ WordPress設計AI: タスク完了")
        else:
            logger.error(f"❌ WordPress設計AI: 失敗 - {result.get('error', '不明')}")
        
        return result
        
    except Exception as e:
        ErrorHandler.log_error(e, "WordPress設計タスク実行")
        logger.error(f"❌ WordPress設計AIエージェント: 例外発生 - {str(e)}")
        return {
            'success': False,
            'error': f'WordPress設計タスク実行エラー: {str(e)}'
        }


async def _execute_wp_dev_task(self, task: Dict) -> Dict:
    """WordPress開発タスクを実行"""
    logger.info("┌" + "─"*58 + "┐")
    logger.info("│ 💻 WordPress開発AIエージェント実行中")
    logger.info("├" + "─"*58 + "┤")
    logger.info(f"│ タスク: {task.get('description', 'N/A')[:50]}")
    logger.info("└" + "─"*58 + "┘")
    
    try:
        # === パート1: エージェント取得 ===
        agent = self.agents.get('wp_dev')
        if not agent:
            logger.error("❌ WordPress開発AIエージェントが登録されていません")
            return {
                'success': False,
                'error': 'wp_dev エージェントが登録されていません'
            }
        
        # === パート2: タスク実行 ===
        result = await agent.process_task(task)
        
        # === パート3: 結果ログ出力 ===
        if result.get('success'):
            logger.info("✅ WordPress開発AI: タスク完了")
        else:
            logger.error(f"❌ WordPress開発AI: 失敗 - {result.get('error', '不明')}")
        
        return result
        
    except Exception as e:
        ErrorHandler.log_error(e, "WordPress開発タスク実行")
        logger.error(f"❌ WordPress開発AIエージェント: 例外発生 - {str(e)}")
        return {
            'success': False,
            'error': f'WordPress開発タスク実行エラー: {str(e)}'
        }

#wp_dev.py
"""
WordPress開発タスクルーター（完全動作版）
"""

import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class WordPressDevAgent:
    """WordPress開発タスクルーター（完全動作版）"""
    
    def __init__(self, browser, output_folder: Path = None):
        self.browser = browser
        self.output_folder = output_folder or Path('./outputs/wordpress')
        self.output_folder.mkdir(parents=True, exist_ok=True)
        
        # 専門エージェントの初期化
        self._init_specialized_agents()
        
        logger.info("✅ WordPressDevAgent 初期化完了")
    
    def _init_specialized_agents(self):
        """専門エージェントを初期化"""
        try:
            from wordpress.wp_dev import (
                WordPressRequirementsAgent,
                WordPressCPTAgent,
                WordPressTaxonomyAgent,
                WordPressACFAgent
            )
            
            self.requirements_agent = WordPressRequirementsAgent(
                self.browser, 
                self.output_folder
            )
            self.cpt_agent = WordPressCPTAgent(self.browser, self.output_folder)
            self.taxonomy_agent = WordPressTaxonomyAgent(self.browser, self.output_folder)
            self.acf_agent = WordPressACFAgent(self.browser, self.output_folder)
            
            logger.info("✅ 専門エージェント初期化完了")
            
        except ImportError as e:
            logger.warning(f"⚠️ インポートエラー: {e}")
            self.requirements_agent = None
            self.cpt_agent = None
            self.taxonomy_agent = None
            self.acf_agent = None
    
    async def execute(self, task: Dict) -> Dict:
        """
        execute メソッド（必須）
        他のエージェントとの互換性のため
        """
        return await self.process_task(task)
    
    async def process_task(self, task: Dict) -> Dict:
        """
        process_task メソッド（必須）
        実際のタスク処理
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            logger.info(f"🔧 WordPress開発タスク: {task_id}")
            
            # タスクタイプを判定
            task_type = self._determine_task_type(description)
            logger.info(f"📊 タスクタイプ: {task_type}")
            
            # エージェントに振り分け
            if task_type == 'requirements':
                if self.requirements_agent:
                    return await self.requirements_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'cpt':
                if self.cpt_agent:
                    return await self.cpt_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'taxonomy':
                if self.taxonomy_agent:
                    return await self.taxonomy_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'acf':
                if self.acf_agent:
                    return await self.acf_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            else:
                # フォールバック
                return await self._fallback_execution(task)
        
        except Exception as e:
            logger.error(f"❌ エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return {
                'success': False,
                'error': str(e),
                'task_id': task_id
            }
    
    def _determine_task_type(self, description: str) -> str:
        """タスクタイプ判定（柔軟版）"""
        # 要件定義（デフォルト）
        requirements_patterns = [
            '要件定義', 'requirements', '仕様書', '設計書',
            'ポータル', 'cocoon', 'polylang', '多言語',
            'm&a', 'ウズベキスタン', 'wordpress'
        ]
        
        if any(kw in description for kw in requirements_patterns):
            return 'requirements'
        
        # CPT
        if any(kw in description for kw in ['cpt', 'custom post type', 'カスタム投稿', 'ma_case']):
            return 'cpt'
        
        # タクソノミー
        if any(kw in description for kw in ['taxonomy', 'タクソノミー', 'カテゴリ', 'industry']):
            return 'taxonomy'
        
        # ACF
        if any(kw in description for kw in ['acf', 'advanced custom fields', 'カスタムフィールド']):
            return 'acf'
        
        # デフォルト
        return 'requirements'
    
    async def _fallback_execution(self, task: Dict) -> Dict:
        """フォールバック実行"""
        logger.warning("⚠️ エージェント不在 - Geminiで直接実行")
        
        try:
            prompt = f"""WordPressタスクを実行してください：

{task.get('description', '')}

簡潔に実装方法を説明してください。"""
            
            await self.browser.send_prompt(prompt)
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if success:
                response = await self.browser.extract_latest_text_response()
                return {
                    'success': True,
                    'message': 'フォールバック実行完了',
                    'summary': response[:300] if response else 'N/A',
                    'full_text': response or ''
                }
            else:
                return {
                    'success': False,
                    'error': 'タイムアウト'
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

#wp_plugin_manager.py
"""wp_plugin_manager.py_WordPressプラグイン管理"""
import logging
import asyncio
from typing import Dict, List, Optional, Any
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

from .wp_utils import PluginNameExtractor

logger = logging.getLogger(__name__)


class WordPressPluginManager:
    """WordPressプラグイン管理機能"""

    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        初期化
        
        Args:
            browser_controller: BrowserController インスタンス
            wp_credentials: WordPress 認証情報
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        
        logger.info(f"WordPressPluginManager 初期化: {self.wp_url}")

        # ========================================
        # ✅ サブエージェントの初期化
        # ========================================
            
        # シートマネージャー（後で外部から設定される）
        self.sheets_manager = None
            
        # 投稿編集エージェント
        try:
            self.post_editor = WordPressPostEditor(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("✅ WordPressPostEditor 初期化完了")
        except Exception as e:
            logger.error(f"❌ WordPressPostEditor 初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.post_editor = None
            
        # 投稿作成エージェント
        try:
            self.post_creator = WordPressPostCreator(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("✅ WordPressPostCreator 初期化完了")
        except Exception as e:
            logger.error(f"❌ WordPressPostCreator 初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.post_creator = None
            
        # ========================================
        # ✅ 重要：プラグインマネージャー（修正版）
        # ========================================
        try:
            self.plugin_manager = WordPressPluginManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("✅ WordPressPluginManager 初期化完了")
        except Exception as e:
            logger.error(f"❌ WordPressPluginManager 初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.plugin_manager = None
            
        # 設定マネージャー
        try:
            self.settings_manager = WordPressSettingsManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("✅ WordPressSettingsManager 初期化完了")
        except Exception as e:
            logger.error(f"❌ WordPressSettingsManager 初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.settings_manager = None
            
        # テスター
        try:
            self.tester = WordPressTester(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("✅ WordPressTester 初期化完了")
        except Exception as e:
            logger.error(f"❌ WordPressTester 初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.tester = None
            
        logger.info("="*60)
        logger.info("WordPressAgent 全サブエージェント初期化完了")
        logger.info("="*60)
        
    async def install_plugin(self, page: Page, task: Dict) -> Dict:
        """プラグインをインストール"""
        try:
            logger.info("プラグインインストールを実行中...")
            
            # プラグインページに移動
            await page.goto(f"{self.wp_url}/wp-admin/plugin-install.php")
            await page.wait_for_timeout(2000)
            
            # タスクからプラグイン名を抽出
            plugin_name = PluginNameExtractor.extract(task['description'])
            
            # プラグイン検索
            search_box = await page.query_selector('#search-plugins')
            if search_box:
                await search_box.fill(plugin_name)
                await page.keyboard.press('Enter')
                await page.wait_for_timeout(4000)
                
                logger.info(f"プラグイン検索完了: {plugin_name}")
                
                # インストールと有効化
                installed, status = await self._install_and_activate(page)
                
                # スクリーンショット
                screenshot_path = f"wp_plugin_{datetime.now().strftime('%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                
                if installed:
                    return {
                        'success': True,
                        'summary': f'プラグイン "{plugin_name}" を{status}',
                        'screenshot': screenshot_path,
                        'full_text': f'プラグイン処理完了\n名前: {plugin_name}\nステータス: {status}\nスクリーンショット: {screenshot_path}'
                    }
                else:
                    return {
                        'success': True,
                        'summary': f'プラグイン "{plugin_name}" を検索しました。手動でインストールを確認してください。',
                        'screenshot': screenshot_path,
                        'full_text': f'プラグイン検索: {plugin_name}\nスクリーンショット: {screenshot_path}\n※インストールボタンが見つからなかったため手動で実施してください'
                    }
            else:
                return {
                    'success': False,
                    'error': '検索ボックスが見つかりません'
                }
                
        except Exception as e:
            logger.error(f"プラグインインストールエラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _install_and_activate(self, page: Page) -> tuple[bool, str]:
        """プラグインをインストール・有効化"""
        install_selectors = [
            'a.install-now:has-text("今すぐインストール")',
            '.plugin-card-top a.install-now',
            'a[data-slug]:has-text("今すぐインストール")',
        ]
        
        for selector in install_selectors:
            try:
                install_button = await page.query_selector(selector)
                if install_button and await install_button.is_visible():
                    logger.info(f"インストールボタンをクリック: {selector}")
                    await install_button.click()
                    
                    # インストール完了を待つ
                    await page.wait_for_timeout(5000)
                    
                    # 有効化ボタンを探す
                    activate_button = await page.query_selector('a:has-text("有効化")')
                    if activate_button:
                        logger.info("有効化ボタンをクリック")
                        await activate_button.click()
                        await page.wait_for_timeout(3000)
                        logger.info("✅ プラグインのインストールと有効化が完了しました")
                        return True, "インストール・有効化完了"
                    else:
                        logger.info("✅ プラグインのインストールが完了しました(有効化は手動)")
                        return True, "インストール完了(有効化は手動で実施してください)"
            except Exception as e:
                logger.warning(f"インストール試行エラー ({selector}): {e}")
                continue
        
        return False, "インストール失敗"
    
    async def change_plugin_settings(self, page: Page, task: Dict) -> Dict:
        """プラグイン設定を変更"""
        try:
            logger.info("プラグイン設定変更を実行中...")
            
            # タスクからプラグイン名を抽出
            plugin_name = PluginNameExtractor.extract(task['description'])
            logger.info(f"対象プラグイン: {plugin_name}")
            
            # プラグイン一覧ページに移動
            await page.goto(f"{self.wp_url}/wp-admin/plugins.php")
            await page.wait_for_timeout(3000)
            
            # プラグインの設定リンクを探す
            settings_found = await self._navigate_to_settings(page, plugin_name)
            
            # スクリーンショット
            screenshot_path = f"wp_plugin_settings_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            if settings_found:
                return {
                    'success': True,
                    'summary': f'プラグイン「{plugin_name}」の設定画面を開きました。手動で設定を確認してください。',
                    'screenshot': screenshot_path,
                    'full_text': f'プラグイン設定画面表示\nプラグイン: {plugin_name}\nスクリーンショット: {screenshot_path}\n※設定変更は手動で実施してください'
                }
            else:
                return {
                    'success': False,
                    'error': f'プラグイン「{plugin_name}」の設定画面が見つかりませんでした',
                    'screenshot': screenshot_path
                }
                
        except Exception as e:
            logger.error(f"プラグイン設定変更エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    # wp_plugin_manager.py の WordPressPluginManager クラスに以下のメソッドを追加

    # === 1. FacetWP設定機能 ===
    async def configure_facetwp(self, page: Page, task_params: Dict) -> Dict:
        """
        FacetWP 絞り込み検索の設定（実行ロジック強化版）
            
        Parameters:
            facets: list - ファセット設定のリスト
                - name: ファセット名
                - type: フィルタータイプ (checkboxes, slider, dropdownなど)
                - source: データソース (tax/カテゴリ名, cf/カスタムフィールド名)
        """
        try:
            facets = task_params.get('facets', [])
                
            logger.info("FacetWP設定を開始...")
            logger.info(f"設定するファセット数: {len(facets)}件")
                
            # FacetWP設定画面に移動
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=facetwp-settings")
            await page.wait_for_timeout(3000)
                
            # ========================================
            # 🆕 ファセット自動追加ロジック（新規実装）
            # ========================================
            created_facets = []
                
            for i, facet in enumerate(facets, 1):
                try:
                    logger.info(f"ファセット {i}/{len(facets)}: {facet.get('name')} を作成中...")
                        
                    # "Add New" ボタンをクリック
                    add_new_selectors = [
                        'a.facetwp-add:has-text("Add New")',
                        'button:has-text("Add New")',
                        '.facetwp-add-facet'
                    ]
                        
                    for selector in add_new_selectors:
                        try:
                            add_button = await page.query_selector(selector)
                            if add_button and await add_button.is_visible():
                                await add_button.click()
                                await page.wait_for_timeout(1500)
                                logger.info("✅ Add Newボタンをクリック")
                                break
                        except:
                            continue
                        
                    # ファセット名を入力
                    name_input = await page.query_selector('input[name="facet_label"]')
                    if name_input:
                        await name_input.fill(facet.get('name', ''))
                        logger.info(f"  ファセット名: {facet.get('name')}")
                        
                    # ファセットタイプを選択
                    type_select = await page.query_selector('select[name="facet_type"]')
                    if type_select:
                        await type_select.select_option(facet.get('type', 'checkboxes'))
                        logger.info(f"  タイプ: {facet.get('type')}")
                        
                    # データソースを設定
                    source = facet.get('source', '')
                    if source.startswith('tax/'):
                        # タクソノミーソース
                        taxonomy_name = source.replace('tax/', '')
                        source_select = await page.query_selector('select[name="facet_source"]')
                        if source_select:
                            await source_select.select_option('tax')
                            await page.wait_for_timeout(500)
                            
                        # タクソノミーを選択
                        taxonomy_select = await page.query_selector('select[name="facet_source_taxonomy"]')
                        if taxonomy_select:
                            await taxonomy_select.select_option(taxonomy_name)
                            logger.info(f"  ソース: Taxonomy - {taxonomy_name}")
                        
                    elif source.startswith('cf/'):
                        # カスタムフィールドソース
                        field_name = source.replace('cf/', '')
                        source_select = await page.query_selector('select[name="facet_source"]')
                        if source_select:
                            await source_select.select_option('cf')
                            await page.wait_for_timeout(500)
                            
                        # フィールド名を入力
                        field_input = await page.query_selector('input[name="facet_source_custom_field"]')
                        if field_input:
                            await field_input.fill(field_name)
                            logger.info(f"  ソース: Custom Field - {field_name}")
                        
                    # 保存ボタンをクリック
                    save_selectors = [
                        'button.facetwp-save:has-text("Save")',
                        'button:has-text("Save Changes")',
                        'input[type="submit"][value="Save"]'
                    ]
                        
                    for selector in save_selectors:
                        try:
                            save_button = await page.query_selector(selector)
                            if save_button and await save_button.is_visible():
                                await save_button.click()
                                await page.wait_for_timeout(2000)
                                logger.info(f"✅ ファセット '{facet.get('name')}' を保存")
                                created_facets.append(facet.get('name'))
                                break
                        except:
                            continue
                        
                    await page.wait_for_timeout(1000)
                        
                except Exception as e:
                    logger.warning(f"⚠️ ファセット {i} 作成エラー: {e}")
                    continue
                
            # スクリーンショット
            from datetime import datetime
            screenshot_path = f"facetwp_setup_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
                
            # 結果サマリー
            summary_lines = ["【FacetWP設定完了】"]
            summary_lines.append(f"作成成功: {len(created_facets)}/{len(facets)}件")
            for name in created_facets:
                summary_lines.append(f"  ✓ {name}")
                
            if len(created_facets) < len(facets):
                summary_lines.append("\n⚠️ 一部のファセットは手動で確認が必要です")
                
            summary = '\n'.join(summary_lines)
                
            return {
                'success': len(created_facets) > 0,
                'summary': summary,
                'facets_created': created_facets,
                'facets_count': len(facets),
                'screenshot': screenshot_path,
                'full_text': f'{summary}\nスクリーンショット: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"FacetWP設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    # === 2. User Role Editor設定機能 ===
    async def configure_user_roles(self, page: Page, task_params: Dict) -> Dict:
        """
        User Role Editorでカスタムロールを作成
    
        Parameters:
            role_slug: str - ロールスラッグ
            role_name: str - ロール表示名
            capabilities: dict - 権限設定
        """
        try:
            role_slug = task_params.get('role_slug')
            role_name = task_params.get('role_name')
            capabilities = task_params.get('capabilities', {})
        
            logger.info(f"ユーザーロール '{role_name}' を作成中...")
        
            # User Role Editor画面に移動
            await page.goto(f"{self.wp_url}/wp-admin/users.php?page=users-user-role-editor-php")
            await page.wait_for_timeout(3000)
        
            # Add Roleボタンをクリック
            add_role_selectors = [
                'button:has-text("Add Role")',
                'input[value="Add Role"]',
                '#ure_add_role_button'
            ]
        
            for selector in add_role_selectors:
                try:
                    add_button = await page.query_selector(selector)
                    if add_button and await add_button.is_visible():
                        await add_button.click()
                        await page.wait_for_timeout(2000)
                        break
                except:
                    continue
        
            # Role slug入力
            slug_input = await page.query_selector('#user_role_id')
            if slug_input:
                await slug_input.fill(role_slug)
                logger.info(f"ロールスラッグを入力: {role_slug}")
        
            # Role name入力
            name_input = await page.query_selector('#user_role_name')
            if name_input:
                await name_input.fill(role_name)
                logger.info(f"ロール名を入力: {role_name}")
        
            # スクリーンショット
            from datetime import datetime
            screenshot_path = f"user_role_{role_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("⚠️ 権限（Capabilities）の設定は手動で確認してください")
        
            return {
                'success': True,
                'summary': f'ユーザーロール "{role_name}" の作成画面を開きました。',
                'role_slug': role_slug,
                'role_name': role_name,
                'screenshot': screenshot_path,
                'full_text': f'User Role作成\nスラッグ: {role_slug}\n表示名: {role_name}\n※権限設定は手動で実施してください'
            }
        
        except Exception as e:
            logger.error(f"ユーザーロール作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 3. Wordfence Security設定機能 ===
    async def configure_wordfence(self, page: Page, task_params: Dict) -> Dict:
        """
        Wordfence Security の基本設定
    
        Parameters:
            firewall_mode: str - ファイアウォールモード（learning, enabled）
            scan_schedule: str - スキャンスケジュール
            two_factor_auth: bool - 2FA有効化
        """
        try:
            firewall_mode = task_params.get('firewall_mode', 'enabled')
            scan_schedule = task_params.get('scan_schedule', 'daily')
            two_factor_auth = task_params.get('two_factor_auth', True)
        
            logger.info("Wordfence Security設定を開始...")
        
            # Wordfence画面に移動
            await page.goto(f"{self.wp_url}/wp-admin/admin.php?page=Wordfence")
            await page.wait_for_timeout(3000)
        
            # スクリーンショット
            from datetime import datetime
            screenshot_path = f"wordfence_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("⚠️ Wordfenceの詳細設定は手動で確認してください")
        
            summary = f"""【Wordfence Security設定】
    ファイアウォールモード: {firewall_mode}
    スキャンスケジュール: {scan_schedule}
    2FA: {'有効' if two_factor_auth else '無効'}
    ※手動で設定を完了してください"""
        
            return {
                'success': True,
                'summary': 'Wordfence設定画面を開きました。',
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"Wordfence設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 4. WP Rocket設定機能 ===
    async def configure_wp_rocket(self, page: Page, task_params: Dict) -> Dict:
        """
        WP Rocket キャッシュプラグインの設定
    
        Parameters:
            cache_options: dict - キャッシュ設定
            optimization: dict - 最適化設定
        """
        try:
            cache_options = task_params.get('cache_options', {})
            optimization = task_params.get('optimization', {})
        
            logger.info("WP Rocket設定を開始...")
        
            # WP Rocket設定画面に移動
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=wprocket")
            await page.wait_for_timeout(3000)
        
            # スクリーンショット
            from datetime import datetime
            screenshot_path = f"wp_rocket_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("⚠️ WP Rocketの詳細設定は手動で確認してください")
        
            summary = """【WP Rocket設定】
    推奨設定:
    - Mobile Cache: 有効
    - User Cache: 有効
    - Minify CSS/JS: 有効
    - Combine CSS/JS: 有効
    ※手動で設定を完了してください"""
        
            return {
                'success': True,
                'summary': 'WP Rocket設定画面を開きました。',
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"WP Rocket設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 5. Relevanssi設定機能 ===
    async def configure_relevanssi(self, page: Page, task_params: Dict) -> Dict:
        """
        Relevanssi 高度な検索プラグインの設定
    
        Parameters:
            index_fields: list - インデックス対象フィールド
            search_settings: dict - 検索設定
        """
        try:
            index_fields = task_params.get('index_fields', [])
            search_settings = task_params.get('search_settings', {})
        
            logger.info("Relevanssi設定を開始...")
        
            # Relevanssi設定画面に移動
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=relevanssi/relevanssi.php")
            await page.wait_for_timeout(3000)
        
            # スクリーンショット
            from datetime import datetime
            screenshot_path = f"relevanssi_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("⚠️ Relevanssiの詳細設定は手動で確認してください")
        
            summary = f"""【Relevanssi設定】
    インデックス対象フィールド: {len(index_fields)}件
    推奨設定:
    - Custom fields: ACFフィールド名を追加
    - Build Index: インデックス構築実行
    - Weight設定: Title=高, Content=中, Custom fields=中
    ※手動で設定を完了してください"""
        
            return {
                'success': True,
                'summary': 'Relevanssi設定画面を開きました。',
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"Relevanssi設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 6. プラグイン一括設定機能 ===
    async def bulk_configure_plugins(self, page: Page, plugin_configs: List[Dict]) -> Dict:
        """
        複数のプラグインを一括で設定
    
        Parameters:
            plugin_configs: list - プラグイン設定のリスト
        """
        try:
            results = []
        
            for i, config in enumerate(plugin_configs, 1):
                plugin_name = config.get('plugin_name')
                logger.info(f"プラグイン設定 {i}/{len(plugin_configs)}: {plugin_name}")
            
                if plugin_name == 'facetwp':
                    result = await self.configure_facetwp(page, config)
                elif plugin_name == 'user-role-editor':
                    result = await self.configure_user_roles(page, config)
                elif plugin_name == 'wordfence':
                    result = await self.configure_wordfence(page, config)
                elif plugin_name == 'wp-rocket':
                    result = await self.configure_wp_rocket(page, config)
                elif plugin_name == 'relevanssi':
                    result = await self.configure_relevanssi(page, config)
                else:
                    result = {'success': False, 'error': f'未対応のプラグイン: {plugin_name}'}
            
                results.append({'plugin': plugin_name, 'result': result})
        
            successful = sum(1 for r in results if r['result'].get('success'))
        
            return {
                'success': successful > 0,
                'summary': f'{successful}/{len(plugin_configs)}件のプラグイン設定を完了',
                'results': results
            }
        
        except Exception as e:
            logger.error(f"プラグイン一括設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _navigate_to_settings(self, page: Page, plugin_name: str) -> bool:
        """プラグイン設定画面へ移動"""
        settings_selectors = [
            f'tr:has-text("{plugin_name}") .settings a',
            f'a:has-text("{plugin_name}設定")',
            '.plugin-action-buttons a:has-text("設定")'
        ]
        
        for selector in settings_selectors:
            try:
                settings_link = await page.query_selector(selector)
                if settings_link and await settings_link.is_visible():
                    await settings_link.click()
                    await page.wait_for_timeout(3000)
                    logger.info(f"✅ {plugin_name}の設定画面を開きました")
                    return True
            except:
                continue
        
        return False

#wp_post_creator.py
"""WordPress投稿作成"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostCreator:
    """WordPress投稿作成機能"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
    
    async def create_post(self, page: Page, task: Dict) -> Dict:
        """コンテンツ(投稿/ページ)を作成"""
        try:
            logger.info("コンテンツ作成を実行中...")
            
            # task_idを抽出
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            post_content = None
            post_title = f"AI投稿_{datetime.now().strftime('%Y%m%d_%H%M')}"
            
            if target_task_id:
                logger.info(f"task_id {target_task_id} の記事内容を使用")
                post_content = await TaskContentFetcher.get_task_content(
                    self.sheets_manager, target_task_id
                )
                
                if post_content:
                    # タイトルを抽出(最初の行をタイトルとする)
                    lines = post_content.split('\n')
                    if lines:
                        post_title = lines[0].strip()[:100]
                        # 本文は2行目以降
                        post_content = '\n'.join(lines[1:]).strip()
            
            if not post_content:
                # タスクからタイトルと本文を直接抽出
                title_match = re.search(r'タイトル[　\s]*(.+?)[\n本文]', task['description'])
                content_match = re.search(r'本文[　\s]*(.+?)[\n」]', task['description'])
                
                post_title = title_match.group(1).strip() if title_match else post_title
                post_content = content_match.group(1).strip() if content_match else "自動生成されたコンテンツ"
            
            logger.info(f"投稿内容: タイトル='{post_title}', 本文='{post_content[:50]}...'")
            
            # 新規投稿ページに移動
            await page.goto(f"{self.wp_url}/wp-admin/post-new.php")
            await page.wait_for_timeout(4000)
            
            # タイトル入力
            title_filled = await self._fill_title(page, post_title)
            
            # 本文入力
            content_filled = await self._fill_content(page, post_content)
            
            # Polylangの言語を日本語に設定
            await self._set_polylang_language(page)
            
            # 下書き保存
            saved = await self._save_draft(page)
            
            # スクリーンショット
            screenshot_path = f"wp_post_saved_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            
            if saved:
                return {
                    'success': True,
                    'summary': f'投稿を下書き保存しました。タイトル: {post_title}',
                    'screenshot': screenshot_path,
                    'full_text': f'投稿作成完了\nタイトル: {post_title}\n本文: {post_content[:200]}...\nスクリーンショット: {screenshot_path}'
                }
            else:
                return {
                    'success': True,
                    'summary': f'投稿を作成しました(保存ボタンが見つからなかったため手動確認が必要)',
                    'screenshot': screenshot_path,
                    'full_text': f'投稿作成\nタイトル: {post_title}\n本文: {post_content[:200]}...\nスクリーンショット: {screenshot_path}'
                }
                
        except Exception as e:
            logger.error(f"コンテンツ作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _fill_title(self, page: Page, title: str) -> bool:
        """タイトル入力"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="タイトルを追加"]',
            'textarea[placeholder*="タイトル"]',
            '#post-title-0'
        ]
        
        for selector in title_selectors:
            try:
                title_input = await page.query_selector(selector)
                if title_input and await title_input.is_visible():
                    await title_input.click()
                    await page.wait_for_timeout(500)
                    await title_input.fill(title)
                    await page.wait_for_timeout(1000)
                    logger.info(f"✅ タイトル入力完了: {title}")
                    return True
            except:
                continue
        
        logger.warning("タイトル入力欄が見つかりません")
        return False
    
    # wp_post_creator.py に追加するメソッド
    async def _fill_html_content(self, page: Page, html_content: str) -> bool:
        """HTMLコンテンツをGutenbergエディタに挿入"""
        try:
            logger.info("HTMLコンテンツを挿入中...")
        
            # カスタムHTMLブロックを追加
            await page.keyboard.press('/')
            await page.wait_for_timeout(1000)
            await page.keyboard.type('html')
            await page.wait_for_timeout(1000)
            await page.keyboard.press('Enter')
            await page.wait_for_timeout(2000)
        
            # HTML入力エリアを見つける
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]'
            ]
        
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input and await html_input.is_visible():
                        await html_input.click()
                        await page.wait_for_timeout(500)
                        await html_input.fill(html_content)
                        await page.wait_for_timeout(1000)
                        logger.info("✅ HTMLコンテンツ挿入完了")
                        return True
                except Exception as e:
                    logger.debug(f"HTML入力試行エラー ({selector}): {e}")
                    continue
        
            return False
        
        except Exception as e:
            logger.error(f"HTMLコンテンツ挿入エラー: {e}")
            return False
    
    async def _fill_content(self, page: Page, content: str) -> bool:
        """本文入力"""
        # Tabキーで本文エリアに移動
        await page.keyboard.press('Tab')
        await page.wait_for_timeout(500)
        
        content_selectors = [
            'p[data-title="段落"]',
            '.block-editor-default-block-appender__content',
            '[aria-label="ブロックを追加"]',
            '.wp-block-paragraph'
        ]
        
        for selector in content_selectors:
            try:
                content_area = await page.query_selector(selector)
                if content_area:
                    await content_area.click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content)
                    await page.wait_for_timeout(1000)
                    logger.info("✅ 本文入力完了")
                    return True
            except:
                continue
        
        # フォールバック: 単純にTabキー後に入力
        await page.keyboard.type(content)
        await page.wait_for_timeout(1000)
        logger.info("✅ 本文入力完了(フォールバック)")
        return True
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangの言語を日本語に設定（wp_post_editor.pyと同じロジック）"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylang言語設定セレクタを探索中...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  試行 {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        # 日本語オプションを探す
                        options = await lang_select.inner_text()
                        logger.debug(f"  → 利用可能な言語: {options[:100]}")
                        
                        # 複数の日本語表記を試す
                        japanese_labels = ['日本語', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"✅ Polylang言語設定成功: {label}")
                                
                                # 確認ダイアログ処理
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ Polylang言語設定要素が見つかりませんでした")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """確認ダイアログを処理（wp_post_editor.pyと同じ）"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("はい")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("✅ 確認ダイアログでOKをクリック")
                        return
            except:
                continue
    
    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        save_selectors = [
            'button[aria-label="下書き保存"]',
            'button:has-text("下書き保存")',
            '.editor-post-save-draft'
        ]
        
        for selector in save_selectors:
            try:
                save_button = await page.query_selector(selector)
                if save_button and await save_button.is_visible():
                    is_disabled = await save_button.is_disabled()
                    if not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(3000)
                        logger.info("✅ 下書き保存完了")
                        return True
            except:
                continue
        
        return False

#wp_post_editor.py
"""WordPress投稿編集（超堅牢版・詳細ログ付き）"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostEditor:
    """WordPress投稿編集機能（超堅牢版）"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
        self.debug_screenshots = []  # デバッグ用スクリーンショット一覧
    
    async def edit_post(self, page: Page, task: Dict) -> Dict:
        """既存の投稿を編集（タイトル抽出改善版）"""
        try:
            logger.info("="*80)
            logger.info("【ステップ1/10】投稿編集タスク開始")
            logger.info("="*80)
            
            # ステップ1: タスク内容の解析 - 改善版
            logger.info("\n【ステップ2/10】タスク内容を解析中...")
            
            # 複数のパターンでタイトルを抽出
            search_title = ""
            description = task['description']
            
            # パターン1: 「」で囲まれたタイトル
            title_patterns = [
                r'[「『](.+?)[」』].*の下書き保存',
                r'タイトル[　\s]*[「『](.+?)[」』]',
                r'投稿[　\s]*[「『](.+?)[」』]',
                r'[「『](AI投稿)[」』]'  # 明示的に「AI投稿」を探す
            ]
            
            for pattern in title_patterns:
                match = re.search(pattern, description)
                if match:
                    search_title = match.group(1)
                    logger.info(f"✅ タイトル抽出成功（パターン: {pattern}）: {search_title}")
                    break
            
            # パターン2: 特定のキーワードから判断
            if not search_title:
                if 'AI投稿' in description:
                    search_title = 'AI投稿'
                    logger.info(f"✅ キーワードからタイトル推測: {search_title}")
            
            if not search_title:
                logger.warning("⚠️ タイトルが見つかりませんでした。デフォルトを使用します。")
                search_title = "AI投稿"
            
            logger.info(f"🔍 検索タイトル: {search_title}")
            
            # ステップ2: task_idの抽出
            logger.info("\n【ステップ3/10】書き換え元記事のtask_idを抽出中...")
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            
            if target_task_id:
                logger.info(f"✅ task_id抽出成功: {target_task_id}")
            else:
                logger.error("❌ task_idが見つかりません")
                return {
                    'success': False,
                    'error': 'task_idが見つかりません。タスク説明にtask_idを含めてください。'
                }
            
            # ステップ3: 記事内容の取得
            logger.info("\n【ステップ4/10】Google Drive/スプレッドシートから記事内容を取得中...")
            logger.info(f"対象: task_id={target_task_id}")
            
            replacement_content = await TaskContentFetcher.get_task_content(
                self.sheets_manager, target_task_id
            )
            
            if not replacement_content:
                logger.error(f"❌ task_id {target_task_id} の記事内容が取得できませんでした")
                return {
                    'success': False,
                    'error': f'task_id {target_task_id} の記事内容が見つかりません'
                }
            
            logger.info(f"✅ 記事内容取得成功: {len(replacement_content)}文字")
            logger.info(f"先頭200文字:\n{replacement_content[:200]}...")
            
            # ステップ3.5: タイトルと本文を分離
            logger.info("\n【ステップ4.5/10】記事からタイトルと本文を分離中...")
            article_title, article_body = self._extract_title_and_body(replacement_content)
            
            logger.info(f"✅ タイトル: {article_title}")
            logger.info(f"✅ 本文: {len(article_body)}文字")
            
            # ステップ4: 投稿一覧ページへ移動
            logger.info("\n【ステップ5/10】WordPress投稿一覧ページへ移動中...")
            await page.goto(f"{self.wp_url}/wp-admin/edit.php", timeout=30000)
            await page.wait_for_timeout(3000)
            
            screenshot_path = await self._save_screenshot(page, "01_post_list")
            logger.info(f"✅ 投稿一覧ページ到達: {screenshot_path}")
            
            # ステップ5: タイトル検索
            if search_title:
                logger.info(f"\n【ステップ6/10】タイトル '{search_title}' で検索中...")
                search_success = await self._search_post(page, search_title)
                
                if search_success:
                    logger.info("✅ 検索実行成功")
                    screenshot_path = await self._save_screenshot(page, "02_search_result")
                else:
                    logger.warning("⚠️ 検索ボックスが見つかりませんでした")
            
            # ステップ6: 投稿編集ページへ移動
            logger.info(f"\n【ステップ7/10】投稿 '{search_title}' の編集ページへ移動中...")
            post_found, post_id = await self._navigate_to_edit_page(page, search_title)
            
            if not post_found:
                logger.error(f"❌ 投稿が見つかりませんでした: {search_title}")
                screenshot_path = await self._save_screenshot(page, "03_post_not_found")
                return {
                    'success': False,
                    'error': f'タイトル「{search_title}」の投稿が見つかりませんでした',
                    'screenshot': screenshot_path,
                    'debug_screenshots': self.debug_screenshots
                }
            
            logger.info(f"✅ 投稿編集ページ到達: 投稿ID={post_id}")
            screenshot_path = await self._save_screenshot(page, "04_edit_page")
            
            # ステップ7.5: タイトルを変更
            if article_title != search_title:
                logger.info(f"\n【ステップ7.5/10】投稿タイトルを '{article_title}' に変更中...")
                title_changed = await self._change_title(page, article_title)
                
                if title_changed:
                    logger.info("✅ タイトル変更完了")
                else:
                    logger.warning("⚠️ タイトル変更に失敗しました")
                
                screenshot_path = await self._save_screenshot(page, "04b_after_title_change")
            
            # ステップ7: Polylang言語設定
            logger.info("\n【ステップ8/10】Polylangの言語を日本語に変更中...")
            language_changed = await self._set_polylang_language(page)
            
            if language_changed:
                logger.info("✅ Polylang言語設定完了: 日本語")
            else:
                logger.warning("⚠️ Polylang設定が見つかりませんでした")
            
            screenshot_path = await self._save_screenshot(page, "05_after_language")
            
            # ステップ8: 記事内容の書き換え
            logger.info(f"\n【ステップ9/10】記事内容を書き換え中... ({len(article_body)}文字)")
            
            # マークダウンをHTMLに変換
            article_html = self._convert_markdown_to_html(article_body)
            logger.info(f"  マークダウン→HTML変換: {len(article_html)}文字")
            
            content_replaced = await self._replace_content(page, article_html)
            
            if content_replaced:
                logger.info("✅ 記事内容の書き換え完了")
            else:
                logger.error("❌ 記事内容の書き換えに失敗しました")
            
            screenshot_path = await self._save_screenshot(page, "06_after_content")
            
            # ステップ9: 下書き保存
            logger.info("\n【ステップ10/10】下書き保存中...")
            saved = await self._save_draft(page)
            
            if saved:
                logger.info("✅ 下書き保存完了")
            else:
                logger.warning("⚠️ 下書き保存ボタンが見つかりませんでした")
            
            # 最終スクリーンショット
            screenshot_path = await self._save_screenshot(page, "07_final")
            
            # 結果サマリー
            logger.info("\n" + "="*80)
            logger.info("【完了】投稿編集タスク終了")
            logger.info("="*80)
            
            result_summary = self._build_summary(
                search_title, post_id, article_title, language_changed, 
                len(article_body), saved
            )
            summary_text = '\n'.join(result_summary)
            
            logger.info("\n【最終結果】")
            logger.info(summary_text)
            
            return {
                'success': True,
                'summary': summary_text,
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots,
                'full_text': f'{summary_text}\n\n【デバッグ情報】\n' + '\n'.join([f'- {s}' for s in self.debug_screenshots])
            }
                
        except Exception as e:
            logger.error(f"❌ 投稿編集エラー: {e}")
            import traceback
            traceback.print_exc()
            
            screenshot_path = await self._save_screenshot(page, "ERROR")
            
            return {
                'success': False,
                'error': str(e),
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots
            }
    
    async def _save_screenshot(self, page: Page, name: str) -> str:
        """デバッグ用スクリーンショット保存"""
        try:
            timestamp = datetime.now().strftime('%H%M%S')
            screenshot_path = f"wp_debug_{name}_{timestamp}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            self.debug_screenshots.append(screenshot_path)
            logger.debug(f"📸 スクリーンショット保存: {screenshot_path}")
            return screenshot_path
        except Exception as e:
            logger.warning(f"スクリーンショット保存失敗: {e}")
            return ""
    
    async def _search_post(self, page: Page, search_title: str) -> bool:
        """投稿を検索"""
        search_box_selectors = [
            '#post-search-input',
            'input[name="s"]',
            'input[type="search"]',
            '.search-box input'
        ]
        
        for i, selector in enumerate(search_box_selectors, 1):
            try:
                logger.debug(f"検索ボックス試行 {i}/{len(search_box_selectors)}: {selector}")
                search_box = await page.query_selector(selector)
                
                if search_box:
                    is_visible = await search_box.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        await search_box.fill(search_title)
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Enter')
                        await page.wait_for_timeout(3000)
                        logger.info(f"✅ 検索実行成功: セレクタ={selector}")
                        return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
    
    # wp_post_editor.py の _extract_title_and_body メソッドを修正

    def _extract_title_and_body(self, content: str) -> tuple[str, str]:
        """
        記事からタイトルと本文を抽出（HTML対応強化版）
        """
        try:
            logger.info(f"【記事内容解析開始】文字数: {len(content)}")
                
            # HTML形式の場合はHTMLCleanerを使用
            if '<h1' in content or '<div' in content or '<p>' in content:
                logger.info("✅ HTML形式の記事を検出 - HTMLCleanerを使用")
                    
                # HTMLCleanerでタイトルと本文を抽出
                from .wp_utils import HTMLCleaner
                title, body = HTMLCleaner.prepare_html_for_wordpress(content)
                    
                logger.info(f"✅ HTML処理完了: タイトル='{title}', 本文={len(body)}文字")
                return title, body
                
            # Markdown形式の処理（既存のロジック）
            lines = content.split('\n')
            title = ""
            body_lines = []
                
            for i, line in enumerate(lines):
                line_stripped = line.strip()
                    
                # 最初の # で始まる行をタイトルとする
                if line_stripped.startswith('# ') and not title:
                    title = line_stripped[2:].strip()
                    logger.info(f"✅ Markdownタイトル抽出: {title}")
                    continue
                    
                # タイトルが見つかった後の行を本文とする
                if title:
                    body_lines.append(line)
                # タイトルが見つかる前の非空行をタイトル候補とする
                elif line_stripped and not title:
                    title = line_stripped[:100]
                    logger.info(f"✅ 最初の行をタイトルとして使用: {title}")

            if title:
                body = '\n'.join(body_lines).strip() if body_lines else content
                logger.info(f"✅ タイトル・本文分離完了: タイトル={title[:30]}..., 本文={len(body)}文字")
                return title, body

            # フォールバック
            logger.warning("❌ タイトルを抽出できませんでした")
            return "AI投稿_自動生成", content

        except Exception as e:
            logger.error(f"❌ タイトル抽出エラー: {e}")
            import traceback
            traceback.print_exc()
            return "AI投稿_エラー", content
    
    async def _change_title(self, page: Page, new_title: str) -> bool:
        """投稿のタイトルを変更"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="タイトルを追加"]',
            'textarea[placeholder*="タイトル"]',
            '#post-title-0',
            '.wp-block-post-title'
        ]
        
        logger.debug("タイトル入力欄を探索中...")
        
        for i, selector in enumerate(title_selectors, 1):
            logger.debug(f"  試行 {i}/{len(title_selectors)}: {selector}")
            try:
                title_input = await page.query_selector(selector)
                if title_input:
                    is_visible = await title_input.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        # 既存のタイトルをクリア
                        await title_input.click()
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Control+A')
                        await page.wait_for_timeout(300)
                        
                        # 新しいタイトルを入力
                        await page.keyboard.type(new_title)
                        await page.wait_for_timeout(1000)
                        
                        logger.info(f"✅ タイトル変更成功: {new_title}")
                        return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ タイトル入力欄が見つかりませんでした")
        return False
    
    def _convert_markdown_to_html(self, markdown_text: str) -> str:
        """
        マークダウンをHTMLに変換
        
        対応：
        - ## 見出し → <h2>見出し</h2>
        - ### 見出し → <h3>見出し</h3>
        - **太字** → <strong>太字</strong>
        - *斜体* → <em>斜体</em>
        """
        try:
            import re
            
            html_lines = []
            lines = markdown_text.split('\n')
            
            for line in lines:
                # 見出しの変換
                if line.strip().startswith('### '):
                    # H3
                    text = line.strip()[4:]
                    html_lines.append(f'<h3>{text}</h3>')
                elif line.strip().startswith('## '):
                    # H2
                    text = line.strip()[3:]
                    html_lines.append(f'<h2>{text}</h2>')
                elif line.strip().startswith('# '):
                    # H1（通常はタイトルなのでスキップ）
                    text = line.strip()[2:]
                    html_lines.append(f'<h1>{text}</h1>')
                else:
                    # 本文の変換
                    converted_line = line
                    
                    # **太字** → <strong>太字</strong>
                    converted_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', converted_line)
                    
                    # *斜体* → <em>斜体</em>
                    converted_line = re.sub(r'\*(.+?)\*', r'<em>\1</em>', converted_line)
                    
                    # 段落タグで囲む（空行でない場合）
                    if converted_line.strip():
                        html_lines.append(f'<p>{converted_line}</p>')
                    else:
                        html_lines.append('')
            
            html_content = '\n'.join(html_lines)
            
            logger.info(f"【マークダウン→HTML変換完了】")
            logger.info(f"  元: {len(markdown_text)}文字")
            logger.info(f"  変換後: {len(html_content)}文字")
            
            return html_content
            
        except Exception as e:
            logger.warning(f"マークダウン変換エラー: {e}")
            return markdown_text
    
    async def _replace_content(self, page: Page, content: str, is_html: bool = False) -> bool:
        """記事内容を置換（Gutenbergブロック対応版）"""
        logger.info("記事エディタを探索中...")
        
        if is_html:
            logger.info("HTML形式のため、Gutenbergブロックとして挿入します")
            return await self._insert_as_gutenberg_blocks(page, content)
        
        # 通常のテキストの場合
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  試行 {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  → {len(content_blocks)}個の要素発見")
                    
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"✅ 記事内容書き換え成功: {len(content)}文字")
                    return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.error("❌ すべてのエディタセレクタで失敗")
        return False
    
    async def _insert_as_gutenberg_blocks(self, page: Page, html_content: str) -> bool:
        """HTMLをカスタムHTMLブロックとして挿入（簡易版）"""
        try:
            logger.info("【カスタムHTMLブロック挿入開始】")
            
            # 既存のコンテンツを削除
            logger.info("  ステップ1: 既存コンテンツを削除")
            await self._clear_all_blocks_simple(page)
            
            # カスタムHTMLブロックを追加
            logger.info("  ステップ2: カスタムHTMLブロックを追加")
            
            # 方法1: /html で検索
            try:
                await page.keyboard.press('/')
                await page.wait_for_timeout(500)
                await page.keyboard.type('html')
                await page.wait_for_timeout(1000)
                await page.keyboard.press('Enter')
                await page.wait_for_timeout(1000)
                logger.info("  → /html で検索成功")
            except Exception as e:
                logger.debug(f"  方法1失敗: {e}")
                
                # 方法2: ブロック追加ボタンから
                try:
                    await page.click('button[aria-label="ブロックを追加"]', timeout=3000)
                    await page.wait_for_timeout(500)
                    await page.type('input[placeholder*="検索"]', 'html')
                    await page.wait_for_timeout(1000)
                    await page.click('button:has-text("カスタムHTML")', timeout=3000)
                    await page.wait_for_timeout(1000)
                    logger.info("  → ブロック追加ボタンから成功")
                except Exception as e2:
                    logger.debug(f"  方法2失敗: {e2}")
            
            # HTMLコードエリアを見つけて貼り付け
            logger.info("  ステップ3: HTMLコードを貼り付け")
            
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]',
                'textarea.components-textarea-control__input'
            ]
            
            pasted = False
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input:
                        is_visible = await html_input.is_visible()
                        if is_visible:
                            await html_input.click()
                            await page.wait_for_timeout(500)
                            
                            # HTMLを貼り付け
                            await html_input.fill(html_content)
                            await page.wait_for_timeout(1000)
                            
                            logger.info(f"  ✅ HTML貼り付け成功: {len(html_content)}文字")
                            pasted = True
                            break
                except Exception as e:
                    logger.debug(f"  {selector} エラー: {e}")
                    continue
            
            if not pasted:
                logger.warning("  ⚠️ HTML入力欄が見つかりませんでした")
                return False
            
            # プレビューモードに切り替え（見た目を確認）
            logger.info("  ステップ4: プレビューモードに切り替え")
            try:
                # 「プレビュー」ボタンを探す
                preview_button = await page.query_selector('button:has-text("プレビュー")')
                if preview_button:
                    await preview_button.click()
                    await page.wait_for_timeout(1000)
                    logger.info("  ✅ プレビューモード表示")
            except Exception as e:
                logger.debug(f"  プレビュー切り替えエラー: {e}")
            
            logger.info(f"✅ カスタムHTMLブロック挿入完了")
            return True
            
        except Exception as e:
            logger.error(f"❌ カスタムHTMLブロック挿入エラー: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def _clear_all_blocks_simple(self, page: Page) -> bool:
        """既存のブロックを簡易的に削除"""
        try:
            # Ctrl+A で全選択 → Backspace で削除
            await page.keyboard.press('Control+A')
            await page.wait_for_timeout(500)
            await page.keyboard.press('Backspace')
            await page.wait_for_timeout(1000)
            
            logger.info("  ✅ 既存コンテンツ削除完了")
            return True
            
        except Exception as e:
            logger.debug(f"  既存コンテンツ削除エラー: {e}")
            return False
        
        logger.warning("❌ すべての検索ボックスセレクタで失敗")
        return False
    
    async def _navigate_to_edit_page(self, page: Page, search_title: str) -> tuple[bool, Optional[str]]:
        """投稿編集ページへ移動"""
        logger.info("投稿リンクを探索中...")
        
        # 方法1: タイトルリンクから直接編集URL
        logger.debug("【方法1】タイトルリンクから編集URLを取得")
        try:
            # 複数のセレクタを試行
            title_selectors = [
                f'a.row-title:has-text("{search_title}")',
                f'td.title a:has-text("{search_title}")',
                f'.row-title:has-text("{search_title}")'
            ]
            
            for i, selector in enumerate(title_selectors, 1):
                logger.debug(f"  試行 {i}/{len(title_selectors)}: {selector}")
                try:
                    title_link = await page.query_selector(selector)
                    if title_link:
                        href = await title_link.get_attribute('href')
                        if href:
                            post_id_match = re.search(r'post=(\d+)', href)
                            if post_id_match:
                                post_id = post_id_match.group(1)
                                edit_url = f"{self.wp_url}/wp-admin/post.php?post={post_id}&action=edit"
                                logger.info(f"✅ 編集URL構築成功: 投稿ID={post_id}")
                                
                                await page.goto(edit_url, timeout=30000)
                                await page.wait_for_timeout(4000)
                                
                                return True, post_id
                except Exception as e:
                    logger.debug(f"  → エラー: {e}")
                    continue
        except Exception as e:
            logger.debug(f"方法1失敗: {e}")
        
        # 方法2: 編集リンクをクリック
        logger.debug("【方法2】編集リンクをクリック")
        edit_link_selectors = [
            f'tr:has-text("{search_title}") .row-actions .edit a',
            f'a.row-title:has-text("{search_title}")',
            '.row-actions .edit a',
            f'tr:has(a:has-text("{search_title}")) .edit a'
        ]
        
        for i, selector in enumerate(edit_link_selectors, 1):
            logger.debug(f"  試行 {i}/{len(edit_link_selectors)}: {selector}")
            try:
                edit_link = await page.query_selector(selector)
                if edit_link:
                    is_visible = await edit_link.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        await edit_link.click()
                        await page.wait_for_timeout(5000)
                        
                        # URLから投稿IDを取得
                        current_url = page.url
                        post_id_match = re.search(r'post=(\d+)', current_url)
                        post_id = post_id_match.group(1) if post_id_match else "不明"
                        
                        logger.info(f"✅ 編集リンククリック成功: 投稿ID={post_id}")
                        return True, post_id
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        # 方法3: 最初の投稿を開く（フォールバック）
        logger.debug("【方法3】最初の投稿を開く（フォールバック）")
        try:
            first_edit_link = await page.query_selector('.row-actions .edit a')
            if first_edit_link:
                await first_edit_link.click()
                await page.wait_for_timeout(4000)
                logger.warning("⚠️ 最初の投稿を開きました（フォールバック）")
                return True, "不明"
        except Exception as e:
            logger.debug(f"方法3失敗: {e}")
        
        logger.error("❌ すべての方法で投稿編集ページへの移動に失敗")
        return False, None
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangの言語を日本語に設定"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylang言語設定セレクタを探索中...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  試行 {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        # 日本語オプションを探す
                        options = await lang_select.inner_text()
                        logger.debug(f"  → 利用可能な言語: {options[:100]}")
                        
                        # 複数の日本語表記を試す
                        japanese_labels = ['日本語', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"✅ Polylang言語設定成功: {label}")
                                
                                # 確認ダイアログ処理
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ Polylang言語設定要素が見つかりませんでした")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """確認ダイアログを処理"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("はい")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("✅ 確認ダイアログでOKをクリック")
                        return
            except:
                continue
    
    async def _replace_content(self, page: Page, content: str) -> bool:
        """記事内容を置換"""
        logger.info("記事エディタを探索中...")
        
        # Gutenbergエディタのセレクタ
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
            '.editor-post-text-editor',
            'textarea.editor-post-text-editor',
            '#content'  # クラシックエディタ
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  試行 {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  → {len(content_blocks)}個の要素発見")
                    
                    # 最初のブロックをクリック
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    logger.debug("  → クリック完了")
                    
                    # 全選択して削除
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    logger.debug("  → 既存内容削除完了")
                    
                    # 新しい内容を入力
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"✅ 記事内容書き換え成功: {len(content)}文字")
                    return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.error("❌ すべてのエディタセレクタで失敗")
        return False
    
    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        save_selectors = [
            'button:has-text("下書き保存")',
            'button[aria-label="下書き保存"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
        
        logger.debug("下書き保存ボタンを探索中...")
        
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  試行 {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if save_button:
                    is_visible = await save_button.is_visible()
                    is_disabled = await save_button.is_disabled() if is_visible else True
                    
                    logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
                    
                    if is_visible and not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(4000)
                        logger.info("✅ 下書き保存ボタンクリック成功")
                        return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ 下書き保存ボタンが見つかりませんでした")
        return False
    
    def _build_summary(self, old_title: str, post_id: str, new_title: str, 
                      lang_changed: bool, content_length: int, saved: bool) -> list:
        """結果サマリーを構築"""
        result_summary = []
        result_summary.append(f"【投稿編集完了】")
        result_summary.append(f"元のタイトル: {old_title}")
        
        if new_title != old_title:
            result_summary.append(f"新しいタイトル: {new_title}")
        
        result_summary.append(f"投稿ID: {post_id}")
        result_summary.append("")
        
        if lang_changed:
            result_summary.append("✅ Polylang言語設定: 日本語")
        else:
            result_summary.append("⚠️ Polylang言語設定: スキップ")
        
        result_summary.append(f"✅ 記事内容書き換え: {content_length}文字（HTML変換済み）")
        
        if saved:
            result_summary.append("✅ 下書き保存: 完了")
        else:
            result_summary.append("⚠️ 下書き保存: スキップ（手動確認推奨）")
        
        return result_summary

#wp_requirements_agent.py
"""
WordPress要件定義書作成エージェント（完全版）
エラー処理・検証・フォールバック完備
"""

import asyncio
import logging
from typing import Dict, Optional, List
from pathlib import Path
from datetime import datetime
import json
import re

logger = logging.getLogger(__name__)


class WordPressRequirementsAgent:
    """WordPress要件定義書作成専門エージェント（完全版）"""
    
    # プロンプトは長いので簡潔版に変更
    PROMPT_TEMPLATE = """あなたはWordPress開発の専門家で、要件定義のプロフェッショナルです。

【あなたの役割】
ウズベキスタンのM&Aポータルサイトの完全な要件定義書を作成してください。

【プロジェクト情報】
- **サイト名**: ウズベキスタンM&Aポータル
- **WordPressテーマ**: Cocoon（日本製高機能テーマ）
- **多言語**: Polylang（日英露ウズ中韓トルコ語の7言語）
- **主要プラグイン**: ACF PRO, FacetWP, Relevanssi, Wordfence, WP Rocket

【要件定義書の構成】
以下の構造で**詳細な要件定義書**を出力してください：

# 1.0 プロジェクト概要
## 1.1 プロジェクト名
## 1.2 目的・背景
## 1.3 対象ユーザー
## 1.4 成功指標（KPI）

# 2.0 システム構成
## 2.1 技術スタック
- WordPress 6.4+、Cocoon、Polylang Pro、ACF PRO、FacetWP、Relevanssi
## 2.2 サーバー要件
- PHP 8.0+、MySQL 8.0+、メモリ 512MB+
## 2.3 開発・本番環境

# 3.0 機能要件
## 3.1 カスタム投稿タイプ
### 3.1.1 M&A案件（ma_case）
- supports: title, editor, thumbnail, custom-fields, excerpt
- taxonomies: industry_category, region, deal_type
### 3.1.2 企業情報（company）
### 3.1.3 ニュース（news）

## 3.2 カスタムタクソノミー
### 3.2.1 業種分類（industry_category） - 階層型
### 3.2.2 地域（region） - 階層型
### 3.2.3 案件タイプ（deal_type） - 非階層型

## 3.3 ACFカスタムフィールド
### M&A案件用フィールド（20個定義）
1. case_id（案件ID） - テキスト、必須
2. ma_scheme（M&Aスキーム） - セレクト、必須
3. desired_price（希望価格） - 数値
4. established_year（設立年） - 数値
5. employees（従業員数） - 数値
6. annual_revenue（年商） - 数値
7. reason_for_sale（売却理由） - テキストエリア
8. confidential_level（機密レベル） - セレクト
9-20. その他フィールド（具体的に記載）

## 3.4 検索・フィルター（FacetWP）
- 業種別検索（チェックボックス）
- 地域別検索（ドロップダウン）
- 価格帯検索（スライダー）
- 案件タイプ検索（チェックボックス）
- キーワード検索（Relevanssi）

## 3.5 多言語機能（Polylang）
### 言語設定
- デフォルト: 日本語（ja）
- 翻訳言語: en, ru, uz, zh, ko, tr
### URLマッピング
日本語: https://example.com/ma-cases/
英語: https://example.com/en/ma-cases/
ロシア語: https://example.com/ru/ma-cases/

## 3.6 ユーザー管理
### カスタムロール: ma_partner
- 自身の作成した ma_case のみ編集可能
- 他ユーザーの案件は閲覧・編集不可

## 3.7 問い合わせ機能
- Contact Form 7
- 多言語対応フォーム

## 3.8 SEO対策（Cocoon活用）
- 構造化データ自動生成
- OGPタグ設定
- パンくずリスト

## 3.9 セキュリティ（Wordfence）
- ファイアウォール: enabled
- スキャン: 週1回

## 3.10 パフォーマンス（WP Rocket + Cocoon）
- モバイルキャッシュ: 有効
- CSS/JS縮小化: 有効

# 4.0 非機能要件
## 4.1 パフォーマンス
- ページ読み込み: 3秒以内
- PageSpeed Insights: 80点以上
## 4.2 可用性
- サーバー稼働率: 99.9%以上
## 4.3 Pydanticモデル移行計画

# 5.0 画面設計
## 5.1 トップページ
## 5.2 M&A案件一覧
## 5.3 M&A案件詳細

# 6.0 データ構造
## 6.1 カスタム投稿タイプ定義（JSON）
```json
{
  "ma_case": {
    "labels": {
      "ja": "M&A案件",
      "en": "M&A Cases"
    },
    "supports": ["title", "editor", "thumbnail"],
    "taxonomies": ["industry_category", "region"],
    "has_archive": true
  }
}
6.2 ACFフィールドグループ定義（JSON）
json{
  "ma_case_fields": {
    "title": "M&A案件基本情報",
    "fields": [
      {
        "name": "case_id",
        "type": "text",
        "required": true
      }
    ]
  }
}
7.0 実装計画
フェーズ1: 基本構築（1-2週間）
フェーズ2: 機能実装（2-3週間）
フェーズ3: コンテンツ登録（1週間）
フェーズ4: テスト・調整（1週間）
フェーズ5: 本番公開（1週間）
8.0 運用保守
定期作業

WordPress/プラグイン更新（月1回）
バックアップ確認（週1回）

9.0 コスト見積もり
初期費用
月額費用
10.0 リスクと対策
技術的リスク
対策

【出力要件】

すべての章立て（1.0～10.0）を完全に記載
JSONコードブロックは必ず閉じる（```で終了）
具体的な数値・名称を記載
Cocoon、Polylangの機能を明記
15,000文字以上を目標

それでは、完全な要件定義書を出力してください。
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # 統計情報
    self.stats = {
        'total_attempts': 0,
        'successful': 0,
        'failed': 0
    }
    
    logger.info("✅ WordPressRequirementsAgent 初期化完了")
    logger.info(f"📁 出力フォルダ: {self.output_folder}")

async def execute(self, task: Dict) -> Dict:
    """要件定義書作成タスクを実行（完全版）"""
    task_id = task.get('task_id', 'UNKNOWN')
    self.stats['total_attempts'] += 1
    
    try:
        logger.info("\n" + "="*70)
        logger.info("📋 WordPress要件定義書作成開始")
        logger.info(f"タスクID: {task_id}")
        logger.info("="*70 + "\n")
        
        # ステップ1: ブラウザ確認
        if not self._verify_browser():
            return self._create_error_result(task_id, 'ブラウザが利用できません')
        
        # ステップ2: プロンプト送信
        logger.info("📤 ステップ1: Geminiにプロンプト送信")
        if not await self._send_prompt():
            return self._create_error_result(task_id, 'プロンプト送信失敗')
        
        # ステップ3: 応答待機
        logger.info("⏱️ ステップ2: 応答待機（最大300秒）")
        if not await self._wait_for_response():
            return self._create_error_result(task_id, 'タイムアウト（300秒）')
        
        # ステップ4: 応答取得
        logger.info("📥 ステップ3: 応答取得")
        response_text = await self._extract_response()
        
        if not response_text:
            return self._create_error_result(task_id, '応答取得失敗')
        
        # ステップ5: 品質検証
        logger.info("🔍 ステップ4: 品質検証")
        validation_result = self._validate_response(response_text)
        
        if not validation_result['valid']:
            logger.warning(f"⚠️ 品質警告: {validation_result['warnings']}")
        
        # ステップ6: ファイル保存
        logger.info("💾 ステップ5: ファイル保存")
        output_files = await self._save_requirements(response_text, task_id)
        
        # ステップ7: 成功結果の作成
        self.stats['successful'] += 1
        
        logger.info("\n" + "="*70)
        logger.info("✅ WordPress要件定義書作成完了")
        logger.info(f"📄 文字数: {len(response_text):,}文字")
        logger.info(f"📁 保存ファイル: {len(output_files)}件")
        logger.info("="*70 + "\n")
        
        return {
            'success': True,
            'message': '要件定義書作成完了',
            'task_id': task_id,
            'content_length': len(response_text),
            'output_files': [str(f['path']) for f in output_files],
            'validation': validation_result,
            'summary': f'要件定義書作成完了（{len(response_text):,}文字、{len(output_files)}ファイル）',
            'full_text': response_text[:1000] + '...' if len(response_text) > 1000 else response_text
        }
        
    except Exception as e:
        self.stats['failed'] += 1
        logger.error(f"❌ 要件定義書作成エラー: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return self._create_error_result(task_id, str(e))

def _verify_browser(self) -> bool:
    """ブラウザの状態を確認"""
    if not self.browser:
        logger.error("❌ ブラウザコントローラーが初期化されていません")
        return False
    
    if not hasattr(self.browser, 'send_prompt'):
        logger.error("❌ ブラウザに send_prompt メソッドがありません")
        return False
    
    logger.info("✅ ブラウザ確認: OK")
    return True

async def _send_prompt(self) -> bool:
    """プロンプトを送信"""
    try:
        await self.browser.send_prompt(self.PROMPT_TEMPLATE)
        logger.info("✅ プロンプト送信完了")
        return True
    except Exception as e:
        logger.error(f"❌ プロンプト送信エラー: {e}")
        return False

async def _wait_for_response(self, max_wait: int = 300) -> bool:
    """応答を待機"""
    try:
        success = await self.browser.wait_for_text_generation(max_wait=max_wait)
        if success:
            logger.info(f"✅ 応答待機完了（{max_wait}秒以内）")
        else:
            logger.error(f"❌ タイムアウト（{max_wait}秒）")
        return success
    except Exception as e:
        logger.error(f"❌ 応答待機エラー: {e}")
        return False

async def _extract_response(self) -> Optional[str]:
    """応答テキストを抽出"""
    try:
        response_text = await self.browser.extract_latest_text_response()
        
        if response_text:
            logger.info(f"✅ 応答取得: {len(response_text):,}文字")
        else:
            logger.error("❌ 応答が空です")
        
        return response_text
    except Exception as e:
        logger.error(f"❌ 応答抽出エラー: {e}")
        return None

def _validate_response(self, text: str) -> Dict:
    """応答の品質を検証"""
    warnings = []
    
    # 長さチェック
    if len(text) < 10000:
        warnings.append(f'文字数が少ない（{len(text):,}文字）')
    
    # 章立てチェック
    required_sections = [
        '1.0 プロジェクト概要',
        '2.0 システム構成',
        '3.0 機能要件',
        '4.0 非機能要件',
        '5.0 画面設計',
        '6.0 データ構造',
        '7.0 実装計画',
        '8.0 運用保守',
        '9.0 コスト見積もり',
        '10.0 リスクと対策'
    ]
    
    missing_sections = [s for s in required_sections if s not in text]
    if missing_sections:
        warnings.append(f'欠落セクション: {", ".join(missing_sections)}')
    
    # JSONブロックチェック
    json_blocks = re.findall(r'```json', text)
    if len(json_blocks) < 2:
        warnings.append(f'JSONブロックが少ない（{len(json_blocks)}個）')
    
    # Cocoonキーワードチェック
    if 'Cocoon' not in text and 'cocoon' not in text:
        warnings.append('Cocoonテーマの記述が見つかりません')
    
    # Polylangキーワードチェック
    if 'Polylang' not in text and 'polylang' not in text:
        warnings.append('Polylangプラグインの記述が見つかりません')
    
    valid = len(warnings) == 0
    
    if valid:
        logger.info("✅ 品質検証: 合格")
    else:
        logger.warning(f"⚠️ 品質検証: 警告あり（{len(warnings)}件）")
        for w in warnings:
            logger.warning(f"  - {w}")
    
    return {
        'valid': valid,
        'warnings': warnings,
        'length': len(text),
        'sections_found': len(required_sections) - len(missing_sections),
        'sections_total': len(required_sections)
    }

async def _save_requirements(self, text: str, task_id: str) -> List[Dict]:
    """要件定義書を保存"""
    output_files = []
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    try:
        # 1. メイン要件定義書（Markdown）
        doc_filename = f"requirements_wordpress_{task_id}_{timestamp}.md"
        doc_path = self.output_folder / doc_filename
        
        with open(doc_path, 'w', encoding='utf-8') as f:
            f.write(f"# WordPress要件定義書 - ウズベキスタンM&Aポータル\n\n")
            f.write(f"**作成日時**: {datetime.now().strftime('%Y年%m月%d日 %H:%M:%S')}\n")
            f.write(f"**タスクID**: {task_id}\n")
            f.write(f"**文字数**: {len(text):,}文字\n\n")
            f.write("---\n\n")
            f.write(text)
        
        output_files.append({
            'type': '要件定義書（Markdown）',
            'path': doc_path,
            'size': len(text)
        })
        logger.info(f"✅ 保存: {doc_filename} ({len(text):,}文字)")
        
        # 2. JSON構造（もし抽出できれば）
        json_data = self._extract_json_structures(text)
        if json_data:
            json_filename = f"data_structures_{task_id}_{timestamp}.json"
            json_path = self.output_folder / json_filename
            
            with open(json_path, 'w', encoding='utf-8') as f:
                json.dump(json_data, f, ensure_ascii=False, indent=2)
            
            output_files.append({
                'type': 'データ構造（JSON）',
                'path': json_path,
                'size': json_path.stat().st_size
            })
            logger.info(f"✅ 保存: {json_filename}")
        
        # 3. 実装チェックリスト
        checklist_filename = f"checklist_{task_id}_{timestamp}.md"
        checklist_path = self.output_folder / checklist_filename
        
        checklist_content = self._generate_checklist()
        with open(checklist_path, 'w', encoding='utf-8') as f:
            f.write(checklist_content)
        
        output_files.append({
            'type': '実装チェックリスト',
            'path': checklist_path,
            'size': len(checklist_content)
        })
        logger.info(f"✅ 保存: {checklist_filename}")
        
        logger.info(f"✅ 合計 {len(output_files)} ファイル保存完了")
        return output_files
        
    except Exception as e:
        logger.error(f"❌ ファイル保存エラー: {e}")
        return output_files

def _extract_json_structures(self, text: str) -> Optional[Dict]:
    """JSONブロックを抽出"""
    try:
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        
        if not json_blocks:
            return None
        
        combined_data = {}
        for i, json_str in enumerate(json_blocks, 1):
            try:
                data = json.loads(json_str)
                combined_data[f"block_{i}"] = data
            except json.JSONDecodeError:
                logger.warning(f"⚠️ JSONブロック {i} のパースに失敗")
                continue
        
        return combined_data if combined_data else None
        
    except Exception as e:
        logger.warning(f"⚠️ JSON抽出エラー: {e}")
        return None

def _generate_checklist(self) -> str:
    """実装チェックリストを生成"""
    return """# WordPress M&Aポータル 実装チェックリスト
フェーズ1: 基本構築 ✅

 WordPress 6.4+ インストール
 Cocoonテーマ インストール・有効化
 Polylang Pro インストール・設定（7言語）
 必須プラグイン インストール

 Advanced Custom Fields PRO
 Custom Post Type UI
 FacetWP
 Relevanssi
 Wordfence Security
 WP Rocket
 Contact Form 7
 User Role Editor



フェーズ2: カスタム投稿タイプ 🔧

 M&A案件（ma_case）作成

 ラベル設定（7言語）
 サポート機能設定
 パーマリンク設定


 企業情報（company）作成
 ニュース（news）作成

フェーズ3: タクソノミー 🏷️

 業種分類（industry_category）作成 - 階層型
 地域（region）作成 - 階層型
 案件タイプ（deal_type）作成 - 非階層型
 Polylang翻訳設定

フェーズ4: ACFフィールド 📝

 M&A案件フィールドグループ作成

 基本情報（case_id, ma_scheme, etc.）
 財務情報（desired_price, revenue, etc.）
 連絡先情報


 企業情報フィールドグループ作成
 Polylang連携設定

フェーズ5: 検索・フィルター 🔍

 FacetWP設定

 業種別ファセット
 地域別ファセット
 価格帯スライダー
 案件タイプファセット


 Relevanssi設定

 インデックス構築
 カスタムフィールド検索設定

フェーズ6: セキュリティ・最適化 🔒

 Wordfence Security設定

 ファイアウォール有効化
 スキャンスケジュール設定


 WP Rocket設定

 モバイルキャッシュ有効化
 CSS/JS縮小化


 Cocoon高速化設定

フェーズ7: ユーザー管理 👥

 カスタムロール（ma_partner）作成
 権限設定
 テストユーザー作成・検証

フェーズ8: コンテンツ登録 📄

 サンプルM&A案件登録（各言語）
 サンプル企業情報登録
 固定ページ作成
 メニュー設定

フェーズ9: テスト 🧪

 多言語表示確認
 検索機能テスト
 フィルター機能テスト
 フォーム送信テスト
 パフォーマンステスト
 セキュリティスキャン

フェーズ10: 本番公開 🚀

 DNS設定
 SSL証明書設定
 本番環境移行
 最終確認


作成日: {datetime}
バージョン: 1.0
""".format(datetime=datetime.now().strftime('%Y-%m-%d %H:%M'))
def _create_error_result(self, task_id: str, error: str) -> Dict:
    """エラー結果を作成"""
    logger.error(f"❌ エラー: {error}")
    
    return {
        'success': False,
        'error': error,
        'task_id': task_id,
        'stats': self.stats.copy()
    }

def get_stats(self) -> Dict:
    """統計情報を取得"""
    return self.stats.copy()



### 3. `wordpress/wp_dev/wp_cpt_agent.py`（完全版）

"""
WordPressカスタム投稿タイプ作成エージェント（完全版）
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """CPT作成専門エージェント（完全版）"""
    
    PROMPT_TEMPLATE = """あなたはWordPress開発の専門家です。

【タスク】
以下のカスタム投稿タイプを作成するPHPコードを生成してください：

**投稿タイプ情報**:
- スラッグ: {cpt_slug}
- 表示名（単数）: {cpt_singular}
- 表示名（複数）: {cpt_plural}
- サポート機能: {supports}
- タクソノミー: {taxonomies}

【要件】
1. `register_post_type()` を使用した完全なPHPコード
2. Polylang多言語対応
3. REST API対応（show_in_rest: true）
4. has_archive: true
5. エラーハンドリング付き
6. 詳細なコメント付き

【出力形式】
```php
<?php
/**
 * カスタム投稿タイプ: {cpt_name}
 * 作成日: {date}
 * Polylang対応
 */

function register_cpt_{cpt_slug_clean}() {{
    $labels = array(
        'name' => __( '{cpt_plural}', 'textdomain' ),
        'singular_name' => __( '{cpt_singular}', 'textdomain' ),
        // ... その他のラベル
    );
    
    $args = array(
        'labels' => $labels,
        'public' => true,
        'has_archive' => true,
        'show_in_rest' => true,
        'supports' => {supports_array},
        'taxonomies' => {taxonomies_array},
        // ... その他の設定
    );
    
    register_post_type( '{cpt_slug}', $args );
}}
add_action( 'init', 'register_cpt_{cpt_slug_clean}', 0 );
?>
完全に動作するPHPコードを出力してください。
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    logger.info("✅ WordPressCPTAgent 初期化")

async def execute(self, task: Dict) -> Dict:
    """CPT作成タスクを実行"""
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '')
    
    try:
        logger.info("=" * 70)
        logger.info("🔧 カスタム投稿タイプ作成開始")
        logger.info("=" * 70)
        
        # CPT仕様を抽出
        cpt_spec = self._extract_cpt_spec(description)
        logger.info(f"📊 CPT仕様: {cpt_spec['slug']}")
        
        # プロンプト構築
        prompt = self._build_prompt(cpt_spec)
        
        # Geminiに送信
        await self.browser.send_prompt(prompt)
        
        # 応答待機
        success = await self.browser.wait_for_text_generation(max_wait=180)
        
        if not success:
            return {'success': False, 'error': 'タイムアウト', 'task_id': task_id}
        
        # 応答取得
        response_text = await self.browser.extract_latest_text_response()
        
        if not response_text:
            return {'success': False, 'error': '応答取得失敗', 'task_id': task_id}
        
        # PHP保存
        output_file = await self._save_php_code(response_text, cpt_spec, task_id)
        
        logger.info("=" * 70)
        logger.info("✅ CPT作成完了")
        logger.info("=" * 70)
        
        return {
            'success': True,
            'message': f'CPT作成完了: {cpt_spec["slug"]}',
            'output_file': str(output_file),
            'cpt_slug': cpt_spec['slug'],
            'task_id': task_id,
            'summary': f'カスタム投稿タイプ {cpt_spec["slug"]} 作成完了'
        }
        
    except Exception as e:
        logger.error(f"❌ CPT作成エラー: {e}")
        return {'success': False, 'error': str(e), 'task_id': task_id}

def _extract_cpt_spec(self, description: str) -> Dict:
    """説明からCPT仕様を抽出"""
    desc_lower = description.lower()
    
    # M&A案件
    if 'ma_case' in desc_lower or 'm&a案件' in desc_lower:
        return {
            'slug': 'ma_case',
            'singular': 'M&A案件',
            'plural': 'M&A案件一覧',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields', 'excerpt'],
            'taxonomies': ['industry_category', 'region', 'deal_type']
        }
    
    # 企業情報
    elif 'company' in desc_lower or '企業情報' in desc_lower:
        return {
            'slug': 'company',
            'singular': '企業情報',
            'plural': '企業情報一覧',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields'],
            'taxonomies': ['industry_category', 'region']
        }
    
    # ニュース
    elif 'news' in desc_lower or 'ニュース' in desc_lower:
        return {
            'slug': 'news',
            'singular': 'ニュース',
            'plural': 'ニュース一覧',
            'supports': ['title', 'editor', 'thumbnail', 'excerpt'],
            'taxonomies': []
        }
    
    # デフォルト
    return {
        'slug': 'custom_post',
        'singular': 'カスタム投稿',
        'plural': 'カスタム投稿一覧',
        'supports': ['title', 'editor', 'thumbnail'],
        'taxonomies': []
    }

def _build_prompt(self, cpt_spec: Dict) -> str:
    """プロンプトを構築"""
    slug_clean = cpt_spec['slug'].replace('-', '_')
    
    return self.PROMPT_TEMPLATE.format(
        cpt_slug=cpt_spec['slug'],
        cpt_singular=cpt_spec['singular'],
        cpt_plural=cpt_spec['plural'],
        cpt_name=cpt_spec['singular'],
        cpt_slug_clean=slug_clean,
        supports=', '.join(cpt_spec['supports']),
        taxonomies=', '.join(cpt_spec['taxonomies']) if cpt_spec['taxonomies'] else 'なし',
        supports_array=str(cpt_spec['supports']).replace("'", '"'),
        taxonomies_array=str(cpt_spec['taxonomies']).replace("'", '"'),
        date=datetime.now().strftime('%Y-%m-%d')
    )

async def _save_php_code(self, code: str, cpt_spec: Dict, task_id: str) -> Path:
    """PHPコードを保存"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"cpt_{cpt_spec['slug']}_{task_id}_{timestamp}.php"
    output_path = self.output_folder / filename
    
    with open(output_path, 'w', encoding='utf-8') as f:
        # ヘッダーコメント追加
        f.write(f"<?php\n")
        f.write(f"/**\n")
        f.write(f" * カスタム投稿タイプ: {cpt_spec['singular']}\n")
        f.write(f" * スラッグ: {cpt_spec['slug']}\n")
        f.write(f" * 作成日: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f" */\n\n")
        
        # コード本体
        if '<?php' in code:
            # 既にPHPタグがある場合はそのまま
            f.write(code)
        else:
            # PHPタグがない場合は追加
            f.write(code)
    
    logger.info(f"✅ PHP保存: {filename}")
    return output_path



#wp_settings_manager.py
"""WordPress設定管理"""
import logging
from datetime import datetime
from typing import Dict
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressSettingsManager:
    """WordPress設定管理機能"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
    
    async def change_settings(self, page: Page, task: Dict) -> Dict:
        """WordPress設定を変更"""
        try:
            logger.info("設定変更を実行中...")
            
            # 設定ページに移動
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php")
            await page.wait_for_timeout(2000)
            
            # 現在の設定をスクリーンショット
            screenshot_path = f"wp_settings_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("✅ 設定画面を確認しました")
            logger.info("⚠️ 実際の設定変更は手動で確認してください")
            
            return {
                'success': True,
                'summary': '設定画面を表示しました。変更内容を確認して手動で適用してください。',
                'screenshot': screenshot_path,
                'full_text': f'設定確認完了\nスクリーンショット: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"設定変更エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def change_theme(self, page: Page, task: Dict) -> Dict:
        """テーマを変更"""
        try:
            logger.info("テーマ変更を実行中...")
            
            # テーマページに移動
            await page.goto(f"{self.wp_url}/wp-admin/themes.php")
            await page.wait_for_timeout(3000)
            
            # 現在のテーマを確認
            screenshot_path = f"wp_themes_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("✅ テーマ画面を表示しました")
            logger.info("⚠️ 実際のテーマ変更は手動で確認してください")
            
            return {
                'success': True,
                'summary': 'テーマ画面を表示しました。変更内容を確認して手動で適用してください。',
                'screenshot': screenshot_path,
                'full_text': f'テーマ確認完了\nスクリーンショット: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"テーマ変更エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#wp_tester.py
"""WordPressテスト機能（品質管理強化版）"""
import logging
import re
from datetime import datetime
from typing import Dict, List, Tuple
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressTester:
    """WordPressテスト機能（品質管理強化版）"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
        self.test_frameworks = {
            'php': ['PHPUnit', 'Codeception', 'WP_UnitTestCase'],
            'javascript': ['Jest', 'Mocha', 'Chai', 'Cypress'],
            'wordpress': ['WP_UnitTestCase', 'WordPress PHPUnit']
        }
    
    async def test_functionality(self, page: Page, task: Dict) -> Dict:
        """機能をテスト（品質検証強化版）"""
        try:
            logger.info("🔍 機能テストを実行中（品質検証付き）...")
            
            test_results = []
            quality_issues = []
            
            # 1. サイトの表示テスト
            site_test_result = await self._test_site_accessibility(page)
            test_results.extend(site_test_result['results'])
            quality_issues.extend(site_test_result['quality_issues'])
            
            # 2. 管理画面テスト
            admin_test_result = await self._test_admin_access(page)
            test_results.extend(admin_test_result['results'])
            quality_issues.extend(admin_test_result['quality_issues'])
            
            # 3. プラグインステータス確認
            plugin_test_result = await self._test_plugins_status(page)
            test_results.extend(plugin_test_result['results'])
            quality_issues.extend(plugin_test_result['quality_issues'])
            
            # 4. コード品質検証（タスクにテストコードが含まれる場合）
            if self._has_test_code(task):
                code_quality_result = await self._validate_test_code_quality(task)
                test_results.extend(code_quality_result['results'])
                quality_issues.extend(code_quality_result['quality_issues'])
            
            # テスト結果の集計
            summary = self._generate_test_summary(test_results, quality_issues)
            
            logger.info("\n" + "="*60)
            logger.info("📊 テスト結果サマリー")
            logger.info("="*60)
            logger.info(summary)
            
            return {
                'success': len(quality_issues) == 0,
                'summary': summary[:500],
                'full_text': summary,
                'quality_issues': quality_issues,
                'test_results': test_results
            }
            
        except Exception as e:
            logger.error(f"❌ 機能テストエラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _test_site_accessibility(self, page: Page) -> Dict:
        """サイトアクセシビリティテスト"""
        results = []
        quality_issues = []
        
        try:
            # サイトにアクセス
            await page.goto(self.wp_url, wait_until='networkidle')
            await page.wait_for_timeout(3000)
            
            # ページタイトル取得
            page_title = await page.title()
            results.append(f"✅ サイト表示OK: {page_title}")
            
            # HTTPステータスチェック
            response = await page.goto(self.wp_url)
            if response and response.status == 200:
                results.append("✅ HTTPステータス: 200 OK")
            else:
                quality_issues.append("❌ HTTPステータスが200ではありません")
                results.append("❌ HTTPステータスエラー")
            
            # スクリーンショット
            timestamp = datetime.now().strftime('%H%M%S')
            site_screenshot = f"wp_site_{timestamp}.png"
            await page.screenshot(path=site_screenshot, full_page=True)
            results.append(f"📸 サイト全体: {site_screenshot}")
            
            # ページ読み込み速度チェック
            load_time = await self._measure_page_load_time(page, self.wp_url)
            if load_time < 5000:  # 5秒以内
                results.append(f"✅ ページ読み込み速度: {load_time}ms")
            else:
                quality_issues.append(f"⚠️ ページ読み込みが遅い: {load_time}ms")
                results.append(f"⚠️ ページ読み込み速度: {load_time}ms")
            
        except Exception as e:
            quality_issues.append(f"❌ サイトアクセステスト失敗: {str(e)}")
            results.append(f"❌ サイトアクセステスト失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_admin_access(self, page: Page) -> Dict:
        """管理画面アクセステスト"""
        results = []
        quality_issues = []
        
        try:
            # 管理画面にアクセス
            admin_url = f"{self.wp_url}/wp-admin/"
            await page.goto(admin_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ログインフォームの存在確認
            login_form = await page.query_selector('#loginform')
            if login_form:
                results.append("✅ 管理画面ログインフォーム確認")
            else:
                # 既にログイン済みかチェック
                admin_bar = await page.query_selector('#wpadminbar')
                if admin_bar:
                    results.append("✅ 管理画面: 既にログイン済み")
                else:
                    quality_issues.append("❌ 管理画面にアクセスできません")
                    results.append("❌ 管理画面アクセス失敗")
            
            # スクリーンショット
            timestamp = datetime.now().strftime('%H%M%S')
            admin_screenshot = f"wp_admin_{timestamp}.png"
            await page.screenshot(path=admin_screenshot)
            results.append(f"📸 管理画面: {admin_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"❌ 管理画面テスト失敗: {str(e)}")
            results.append(f"❌ 管理画面テスト失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_plugins_status(self, page: Page) -> Dict:
        """プラグインステータステスト"""
        results = []
        quality_issues = []
        
        try:
            # プラグインページにアクセス（ログインが必要な場合）
            plugins_url = f"{self.wp_url}/wp-admin/plugins.php"
            await page.goto(plugins_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ページタイトルでプラグインページか確認
            page_title = await page.title()
            if 'プラグイン' in page_title or 'Plugins' in page_title:
                results.append("✅ プラグイン一覧ページ確認")
                
                # アクティブなプラグイン数をチェック
                active_plugins = await page.query_selector_all('.plugins .active')
                if len(active_plugins) > 0:
                    results.append(f"✅ アクティブプラグイン: {len(active_plugins)}個")
                else:
                    quality_issues.append("⚠️ アクティブなプラグインがありません")
                    results.append("⚠️ アクティブプラグイン: 0個")
            else:
                quality_issues.append("❌ プラグインページにアクセスできません")
                results.append("❌ プラグインページアクセス失敗")
            
            # スクリーンショット
            timestamp = datetime.now().strftime('%H%M%S')
            plugins_screenshot = f"wp_plugins_{timestamp}.png"
            await page.screenshot(path=plugins_screenshot)
            results.append(f"📸 プラグイン: {plugins_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"❌ プラグインテスト失敗: {str(e)}")
            results.append(f"❌ プラグインテスト失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _validate_test_code_quality(self, task: Dict) -> Dict:
        """テストコードの品質検証"""
        results = []
        quality_issues = []
        
        try:
            # タスクからテストコードを抽出
            test_code = self._extract_test_code(task)
            
            if not test_code:
                results.append("ℹ️ 検証対象のテストコードなし")
                return {'results': results, 'quality_issues': quality_issues}
            
            # 言語別の品質検証
            if self._is_php_code(test_code):
                php_validation = self._validate_php_test_code(test_code)
                results.extend(php_validation['results'])
                quality_issues.extend(php_validation['quality_issues'])
            
            elif self._is_javascript_code(test_code):
                js_validation = self._validate_javascript_test_code(test_code)
                results.extend(js_validation['results'])
                quality_issues.extend(js_validation['quality_issues'])
            
            else:
                # 一般的なテストコード検証
                general_validation = self._validate_general_test_code(test_code)
                results.extend(general_validation['results'])
                quality_issues.extend(general_validation['quality_issues'])
            
        except Exception as e:
            quality_issues.append(f"❌ テストコード検証エラー: {str(e)}")
            results.append(f"❌ テストコード検証失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_php_test_code(self, code: str) -> Dict:
        """PHPテストコードの検証"""
        results = []
        quality_issues = []
        
        # PHPUnitの基本構造チェック
        if 'class' not in code and 'function' not in code:
            quality_issues.append("❌ PHPテスト: クラスまたは関数が定義されていません")
            results.append("❌ PHPテスト構造: 不完全")
        
        # テストメソッドの存在チェック
        test_method_patterns = [
            r'function\s+test\w+',
            r'public\s+function\s+test\w+',
            r'public\s+function\s+test_\w+'
        ]
        
        has_test_methods = any(re.search(pattern, code) for pattern in test_method_patterns)
        if not has_test_methods:
            quality_issues.append("❌ PHPテスト: テストメソッドが定義されていません")
            results.append("❌ PHPテストメソッド: 未定義")
        else:
            results.append("✅ PHPテストメソッド: 定義済み")
        
        # アサーションの存在チェック
        assertion_patterns = [
            r'\$this->assert',
            r'assertEquals',
            r'assertTrue',
            r'assertFalse',
            r'expectException'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("❌ PHPテスト: アサーションがありません")
            results.append("❌ PHPテストアサーション: 未定義")
        else:
            results.append("✅ PHPテストアサーション: 定義済み")
        
        # PHPUnitのインポートチェック
        if 'PHPUnit' in code or 'use PHPUnit' in code:
            results.append("✅ PHPUnitフレームワーク: 検出")
        else:
            quality_issues.append("⚠️ PHPテスト: PHPUnitフレームワークが明示されていません")
            results.append("⚠️ PHPUnitフレームワーク: 未検出")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_javascript_test_code(self, code: str) -> Dict:
        """JavaScriptテストコードの検証"""
        results = []
        quality_issues = []
        
        # テストフレームワークのチェック
        frameworks = ['describe', 'it', 'test', 'expect']
        has_framework = any(framework in code for framework in frameworks)
        
        if not has_framework:
            quality_issues.append("❌ JSテスト: テストフレームワークが検出されません")
            results.append("❌ JSテストフレームワーク: 未検出")
        else:
            results.append("✅ JSテストフレームワーク: 検出")
        
        # アサーションの存在チェック
        assertion_patterns = [
            'expect',
            'assert',
            'should',
            'toBe',
            'toEqual'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("❌ JSテスト: アサーションがありません")
            results.append("❌ JSテストアサーション: 未定義")
        else:
            results.append("✅ JSテストアサーション: 定義済み")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_general_test_code(self, code: str) -> Dict:
        """一般的なテストコードの検証"""
        results = []
        quality_issues = []
        
        # テスト関連キーワードのチェック
        test_keywords = [
            'test', 'assert', 'expect', 'verify',
            'should', 'check', 'validate'
        ]
        
        has_test_keywords = any(keyword in code.lower() for keyword in test_keywords)
        if not has_test_keywords:
            quality_issues.append("❌ テストコード: テスト関連キーワードが不足しています")
            results.append("❌ テストキーワード: 不足")
        else:
            results.append("✅ テストキーワード: 検出")
        
        # 実行可能なコードかチェック（コメントのみでないか）
        lines = code.split('\n')
        code_lines = [line for line in lines if line.strip() and not line.strip().startswith(('//', '#'))]
        
        if len(code_lines) < 3:
            quality_issues.append("❌ テストコード: 実行可能なコードが不足しています")
            results.append("❌ 実行可能コード: 不足")
        else:
            results.append("✅ 実行可能コード: 十分")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _has_test_code(self, task: Dict) -> bool:
        """タスクにテストコードが含まれているかチェック"""
        description = task.get('description', '').lower()
        if any(keyword in description for keyword in ['test', 'テスト', 'testing']):
            return True
        
        # 出力やパラメータからテストコードを探す
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        test_indicators = ['function test', 'class Test', '@Test', 'describe(', 'it(']
        combined_text = f"{output} {parameters}".lower()
        
        return any(indicator in combined_text for indicator in test_indicators)
    
    def _extract_test_code(self, task: Dict) -> str:
        """タスクからテストコードを抽出"""
        # 出力からコードブロックを抽出
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        # コードブロックを検索
        code_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', output, re.DOTALL)
        if code_blocks:
            return '\n'.join(code_blocks)
        
        # パラメータからコードを抽出
        if '```' in parameters:
            param_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', parameters, re.DOTALL)
            if param_blocks:
                return '\n'.join(param_blocks)
        
        return output  # フォールバック
    
    def _is_php_code(self, code: str) -> bool:
        """PHPコードか判定"""
        php_indicators = ['<?php', 'function', 'class', '$this', '->']
        return any(indicator in code for indicator in php_indicators)
    
    def _is_javascript_code(self, code: str) -> bool:
        """JavaScriptコードか判定"""
        js_indicators = ['function', 'const', 'let', 'var', '=>', 'describe', 'it']
        return any(indicator in code for indicator in js_indicators)
    
    async def _measure_page_load_time(self, page: Page, url: str) -> float:
        """ページ読み込み時間を計測"""
        try:
            start_time = datetime.now()
            await page.goto(url, wait_until='networkidle')
            end_time = datetime.now()
            return (end_time - start_time).total_seconds() * 1000  # ミリ秒
        except:
            return 0
    
    def _generate_test_summary(self, test_results: List[str], quality_issues: List[str]) -> str:
        """テスト結果サマリーを生成"""
        summary = []
        
        summary.append("📊 テスト結果サマリー")
        summary.append("=" * 50)
        
        # テスト結果
        summary.append("\n✅ 成功テスト:")
        success_tests = [r for r in test_results if '✅' in r or 'OK' in r]
        for test in success_tests:
            summary.append(f"  • {test}")
        
        # 品質問題
        if quality_issues:
            summary.append("\n❌ 品質問題:")
            for issue in quality_issues:
                summary.append(f"  • {issue}")
        else:
            summary.append("\n🎉 品質問題: なし")
        
        # 統計
        total_tests = len(test_results)
        success_count = len(success_tests)
        issue_count = len(quality_issues)
        
        summary.append("\n📈 統計:")
        summary.append(f"  総テスト数: {total_tests}")
        summary.append(f"  成功テスト: {success_count}")
        summary.append(f"  品質問題: {issue_count}")
        
        if total_tests > 0:
            success_rate = (success_count / total_tests) * 100
            summary.append(f"  成功率: {success_rate:.1f}%")
        
        return '\n'.join(summary)

#wp_utils.py
"""WordPressユーティリティ (Google Drive対応版)
このモジュールは、WordPressタスクの処理に必要な各種ユーティリティクラスを提供します。
主な機能:
- タスク内容の取得（Google Drive、JSON、ローカルファイル対応）
- タスクタイプの分析と判定
- WordPressプラグイン・設定管理
- HTMLクリーニング・最適化
"""

import re
import logging
from typing import Optional, Tuple, Dict, List
from pathlib import Path
import json

# ロガーの初期化
logger = logging.getLogger(__name__)


# ============================================================================
# TaskContentFetcher: タスク内容取得クラス
# ============================================================================

class TaskContentFetcher:
    """タスク内容取得ユーティリティ (Google Drive対応)
    
    複数のソースから記事コンテンツを取得する機能を提供:
    1. Google Driveリンク（最優先）
    2. JSONファイルパス
    3. ローカルMarkdownファイル
    4. task_logシート（フォールバック）
    """
    
    @staticmethod
    def extract_task_id(description: str) -> Optional[int]:
        """説明文からtask_idを抽出
        
        対応形式:
        - task_id 39
        - task id 39
        - タスクID 39
        
        Args:
            description: タスク説明文
            
        Returns:
            抽出されたtask_id、見つからない場合はNone
        """
        # 複数のパターンでtask_idを検索
        patterns = [
            r'task[_\s]+id[\s　]*(\d+)',  # task_id, task id形式
            r'タスク[\s　]*ID[\s　]*(\d+)',  # 日本語形式
        ]
        
        for pattern in patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                task_id = int(match.group(1))
                logger.info(f"✅ task_id抽出: {task_id}")
                return task_id
        
        logger.debug("task_idが見つかりませんでした")
        return None

    @staticmethod
    async def get_task_content(sheets_manager, task_id: int) -> Optional[str]:
        """指定されたtask_idの記事内容を取得(超堅牢版)
        
        優先順位:
        1. task_execution_log シートの Google Drive リンク(最優先)
        2. task_execution_log シートの output_data カラム(JSONファイルパス)
        3. task_execution_log シートのローカルマークダウンファイルパス
        4. task_log シート(フォールバック)
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
            task_id: タスクID
            
        Returns:
            記事内容(テキスト)、失敗時はNone
        """
        try:
            logger.info("="*60)
            logger.info(f"【記事取得開始】task_id={task_id}")
            logger.info("="*60)
            
            # === パート1: sheets_managerの検証 ===
            if not TaskContentFetcher._validate_sheets_manager(sheets_manager):
                return None
            
            # === パート2: スプレッドシートを開く ===
            sheet = TaskContentFetcher._open_spreadsheet(sheets_manager)
            if not sheet:
                return None
            
            # === パート3: task_execution_logから取得を試みる ===
            logger.info("\n【優先度1】task_execution_logから取得を試みます")
            content = await TaskContentFetcher._get_from_execution_log(
                sheet, task_id, sheets_manager
            )
            
            if content:
                logger.info(f"✅ 記事取得成功: {len(content)}文字")
                return content
            
            # === パート4: フォールバック - task_logから取得 ===
            logger.info("\n【優先度2】task_logから取得を試みます(フォールバック)")
            content = await TaskContentFetcher._get_from_task_log(
                sheet, task_id
            )
            
            if content:
                logger.info(f"✅ 記事取得成功(task_log): {len(content)}文字")
                return content
            
            logger.error("❌ すべての方法で記事取得に失敗しました")
            return None
            
        except Exception as e:
            logger.error(f"❌ task_id {task_id} の内容取得エラー: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _validate_sheets_manager(sheets_manager) -> bool:
        """sheets_managerの妥当性を検証
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            検証成功時True、失敗時False
        """
        if not sheets_manager:
            logger.error("❌ sheets_managerが設定されていません")
            return False
        
        if not sheets_manager.gc:
            logger.error("❌ Google Sheetsクライアントが初期化されていません")
            return False
        
        logger.info("✅ sheets_manager検証完了")
        return True

    @staticmethod
    def _open_spreadsheet(sheets_manager):
        """スプレッドシートを開く
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            スプレッドシートオブジェクト、失敗時None
        """
        logger.info(f"📊 スプレッドシートを開く: {sheets_manager.spreadsheet_id}")
        try:
            sheet = sheets_manager.gc.open_by_key(sheets_manager.spreadsheet_id)
            logger.info("✅ スプレッドシート接続成功")
            return sheet
        except Exception as e:
            logger.error(f"❌ スプレッドシート接続失敗: {e}")
            return None

    @staticmethod
    async def _get_from_execution_log(sheet, task_id: int, sheets_manager) -> Optional[str]:
        """task_execution_log シートから取得(超詳細ログ版)
        
        優先順位:
        1. Google Driveリンク
        2. output_data(JSONファイルパス)
        3. ローカルマークダウンファイル
        
        Args:
            sheet: スプレッドシートオブジェクト
            task_id: タスクID
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            記事内容、失敗時None
        """
        try:
            # === パート1: シートを開く ===
            logger.debug("【切り分け1】task_execution_logシートを開く")
            try:
                execution_log_sheet = sheet.worksheet("task_execution_log")
                logger.info("✅ task_execution_logシート発見")
            except Exception as e:
                logger.warning(f"❌ task_execution_logシートが見つかりません: {e}")
                return None
            
            # === パート2: シートデータを取得 ===
            logger.debug("【切り分け2】シートデータを取得")
            execution_log_data = execution_log_sheet.get_all_values()
            
            if len(execution_log_data) == 0:
                logger.warning("❌ task_execution_logシートが空です")
                return None
            
            logger.info(f"✅ {len(execution_log_data)}行のデータを取得")
            
            # === パート3: ヘッダー行を解析してカラムインデックスを特定 ===
            column_indices = TaskContentFetcher._parse_header_columns(execution_log_data[0])
            if column_indices['task_id_col'] is None:
                logger.warning("❌ task_id カラムが見つかりません")
                return None
            
            # === パート4: 対象のtask_idを検索 ===
            logger.debug(f"【切り分け6】task_id={task_id}を検索中...")
            for row_idx, row in enumerate(execution_log_data[1:], start=2):
                if len(row) <= column_indices['task_id_col']:
                    continue
                
                try:
                    task_id_in_row = int(row[column_indices['task_id_col']])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"✅ task_id {task_id} を行 {row_idx} で発見")
                    logger.debug(f"行内容: {row[:min(len(row), 10)]}...")
                    
                    # === パート5: データソースから記事を取得 ===
                    content = await TaskContentFetcher._fetch_content_from_sources(
                        row, column_indices, sheets_manager
                    )
                    
                    if content:
                        return content
                    
                    logger.warning(f"❌ task_id {task_id} のデータがすべて空です")
                    return None
            
            logger.warning(f"❌ task_id {task_id} が task_execution_log に見つかりませんでした")
            return None
            
        except Exception as e:
            logger.error(f"❌ task_execution_log からの取得エラー: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _parse_header_columns(headers: List[str]) -> Dict[str, Optional[int]]:
        """ヘッダー行を解析してカラムインデックスを特定
        
        Args:
            headers: ヘッダー行のリスト
            
        Returns:
            カラムインデックスの辞書
        """
        logger.debug("【切り分け3】ヘッダー行を解析")
        logger.debug(f"ヘッダー: {headers}")
        
        column_indices = {
            'task_id_col': None,
            'output_data_col': None,
            'markdown_file_col': None,
            'drive_link_col': None
        }
        
        logger.debug("【切り分け4】カラムインデックスを特定")
        for i, header in enumerate(headers):
            header_lower = header.lower().strip()
            
            if 'task_id' in header_lower or 'タスクid' in header_lower:
                column_indices['task_id_col'] = i
                logger.debug(f"  → task_id列: {i}")
            elif 'output_data' in header_lower or 'full_text' in header_lower or '出力データ' in header_lower or '出力' in header_lower:
                column_indices['output_data_col'] = i
                logger.debug(f"  → output_data列: {i}")
            elif 'drive' in header_lower or 'link' in header_lower or 'url' in header_lower or 'リンク' in header_lower:
                column_indices['drive_link_col'] = i
                logger.debug(f"  → drive_link列: {i}")
            elif 'markdown' in header_lower or 'file' in header_lower or 'ファイル' in header_lower:
                column_indices['markdown_file_col'] = i
                logger.debug(f"  → markdown列: {i}")
        
        logger.debug(f"【切り分け5】カラム特定結果")
        for key, value in column_indices.items():
            logger.debug(f"  {key}: {value}")
        
        return column_indices

    @staticmethod
    async def _fetch_content_from_sources(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """複数のソースから記事内容を取得（優先順位付き）
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            記事内容、失敗時None
        """
        # 優先度1: Google Driveリンク
        content = await TaskContentFetcher._fetch_from_drive_link(
            row, column_indices, sheets_manager
        )
        if content:
            return content
        
        # 優先度2: output_data(JSONファイルまたは直接テキスト)
        content = TaskContentFetcher._fetch_from_output_data(
            row, column_indices
        )
        if content:
            return content
        
        # 優先度3: ローカルマークダウンファイル
        content = TaskContentFetcher._fetch_from_markdown_file(
            row, column_indices
        )
        if content:
            return content
        
        return None

    @staticmethod
    async def _fetch_from_drive_link(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """Google Driveリンクから記事を取得
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            記事内容、失敗時None
        """
        logger.debug("【切り分け7】Google Driveリンクをチェック")
        drive_link_col = column_indices.get('drive_link_col')
        
        if drive_link_col is not None and len(row) > drive_link_col:
            drive_link = row[drive_link_col].strip()
            logger.debug(f"  drive_link列の値: '{drive_link}'")
            
            if drive_link and len(drive_link) > 0:
                logger.info(f"🔗 Google Drive リンクを発見")
                logger.debug(f"  URL: {drive_link[:80]}...")
                
                # Google Driveから読み込み
                logger.debug("【切り分け8】Google Driveから記事を読み込み中...")
                content = sheets_manager.read_file_from_drive(drive_link)
                
                if content:
                    logger.info(f"✅ Google Driveから記事取得成功")
                    logger.debug(f"  文字数: {len(content)}")
                    logger.debug(f"  先頭100文字: {content[:100]}...")
                    return content
                else:
                    logger.warning("❌ Google Driveからの読み込みに失敗")
            else:
                logger.debug("  → drive_link列が空")
        else:
            logger.debug("  → drive_link列なし")
        
        return None

    @staticmethod
    def _fetch_from_output_data(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """output_dataカラムから記事を取得（JSONまたは直接テキスト）
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            
        Returns:
            記事内容、失敗時None
        """
        logger.debug("【切り分け9】output_dataをチェック")
        output_data_col = column_indices.get('output_data_col')
        
        if output_data_col is not None and len(row) > output_data_col:
            output_data = row[output_data_col].strip()
            logger.debug(f"  output_data列の長さ: {len(output_data)}文字")
            
            if output_data and len(output_data) > 0:
                # JSONファイルパスかどうかを判定
                if output_data.endswith('.json'):
                    logger.info(f"  → JSONファイルと判定: {output_data}")
                    return TaskContentFetcher._read_json_file(output_data)
                else:
                    # 通常のテキストとして扱う
                    logger.info(f"✅ output_data から記事取得(直接)")
                    logger.debug(f"  先頭100文字: {output_data[:100]}...")
                    return output_data
            else:
                logger.debug("  → output_data列が空")
        else:
            logger.debug("  → output_data列なし")
        
        return None

    @staticmethod
    def _read_json_file(json_path_str: str) -> Optional[str]:
        """JSONファイルから記事を読み込む
        
        Args:
            json_path_str: JSONファイルパス
            
        Returns:
            記事内容、失敗時None
        """
        json_path = Path(json_path_str)
        
        # 絶対パスでない場合、候補パスを試す
        if not json_path.is_absolute():
            candidates = [
                Path.cwd() / json_path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / json_path.name,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / json_path.name,
            ]
            for candidate in candidates:
                if candidate.exists():
                    json_path = candidate
                    break
        
        if json_path.exists():
            logger.info(f"  → JSONファイル読み込み: {json_path}")
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                # html_contentを取得
                html_content = json_data.get('html_content', '')
                if html_content:
                    logger.info(f"✅ JSONからHTML記事取得成功: {len(html_content)}文字")
                    logger.debug(f"  先頭100文字: {html_content[:100]}...")
                    return html_content
                else:
                    logger.warning("❌ JSONにhtml_contentがありません")
            except Exception as e:
                logger.error(f"❌ JSONファイル読み込みエラー: {e}")
        else:
            logger.warning(f"❌ JSONファイルが見つかりません: {json_path}")
        
        return None

    @staticmethod
    def _fetch_from_markdown_file(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """ローカルマークダウンファイルから記事を取得
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            
        Returns:
            記事内容、失敗時None
        """
        logger.debug("【切り分け10】ローカルファイルをチェック")
        markdown_file_col = column_indices.get('markdown_file_col')
        
        if markdown_file_col is not None and len(row) > markdown_file_col:
            markdown_path = row[markdown_file_col]
            logger.debug(f"  markdown列の値: '{markdown_path}'")
            
            if markdown_path and len(markdown_path.strip()) > 0:
                content = TaskContentFetcher._read_local_markdown_file(markdown_path)
                if content:
                    return content
            else:
                logger.debug("  → markdown列が空")
        else:
            logger.debug("  → markdown列なし")
        
        return None

    @staticmethod
    async def _get_from_task_log(sheet, task_id: int) -> Optional[str]:
        """task_log シートから取得(フォールバック)
        
        Args:
            sheet: スプレッドシートオブジェクト
            task_id: タスクID
            
        Returns:
            記事内容、失敗時None
        """
        try:
            task_log_sheet = sheet.worksheet("task_log")
            task_log_data = task_log_sheet.get_all_values()
            
            if len(task_log_data) == 0:
                return None
            
            headers = task_log_data[0]
            
            # カラムインデックスを特定
            task_id_col = None
            output_data_col = None
            
            for i, header in enumerate(headers):
                if 'task_id' in header.lower():
                    task_id_col = i
                elif 'output_data' in header.lower() or 'full_text' in header.lower():
                    output_data_col = i
            
            # デフォルト値を設定
            if task_id_col is None:
                task_id_col = 1
            
            if output_data_col is None:
                output_data_col = len(headers) - 1
            
            # task_idを検索
            for row_idx, row in enumerate(task_log_data[1:], start=2):
                if len(row) <= task_id_col:
                    continue
                
                try:
                    task_id_in_row = int(row[task_id_col])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"✅ task_id {task_id} を task_log の行 {row_idx} で発見")
                    
                    if output_data_col and len(row) > output_data_col:
                        full_text = row[output_data_col]
                        if full_text and len(full_text) > 0:
                            logger.info(f"✅ task_log から取得 ({len(full_text)}文字)")
                            return full_text
            
            return None
            
        except Exception as e:
            logger.error(f"task_log からの取得エラー: {e}")
            return None

    @staticmethod
    def _read_local_markdown_file(file_path: str) -> Optional[str]:
        """ローカルのマークダウンファイルを読み込む(強化版)
        
        Args:
            file_path: ファイルパス
            
        Returns:
            ファイル内容、失敗時None
        """
        try:
            logger.debug("【ローカルファイル読み込み】")
            logger.debug(f"  ファイルパス: {file_path}")
            
            path = Path(file_path.strip())
            
            # 絶対パスの場合
            if path.is_absolute():
                logger.debug("  → 絶対パスとして処理")
                if path.exists():
                    logger.debug(f"  → ファイル存在確認: OK")
                    with open(path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    logger.info(f"✅ ファイル読み込み成功: {len(content)}文字")
                    logger.debug(f"  先頭100文字: {content[:100]}...")
                    
                    # タイトルと本文を抽出
                    content = TaskContentFetcher._extract_title_and_body(content)
                    
                    return content
                else:
                    logger.warning(f"❌ ファイルが見つかりません: {path}")
                    return None
            
            # 相対パスの場合、候補パスを試す
            logger.debug("  → 相対パスとして処理")
            candidates = [
                Path.cwd() / path,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "AI_Agent" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / path.name,
            ]
            
            logger.debug(f"  候補パス数: {len(candidates)}")
            
            for i, candidate in enumerate(candidates, 1):
                logger.debug(f"  候補{i}: {candidate}")
                if candidate.exists():
                    logger.info(f"  → ファイル発見: {candidate}")
                    path = candidate
                    break
            
            if not path.exists():
                logger.warning(f"❌ すべての候補でファイルが見つかりません")
                for candidate in candidates:
                    logger.warning(f"  試行: {candidate}")
                return None
            
            logger.info(f"📄 ファイル読み込み中: {path}")
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            logger.info(f"✅ ファイル読み込み成功: {len(content)}文字")
            logger.debug(f"  先頭100文字: {content[:100]}...")
            
            # タイトルと本文を抽出
            content = TaskContentFetcher._extract_title_and_body(content)
            
            return content
            
        except Exception as e:
            logger.error(f"❌ ファイル読み込みエラー: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    @staticmethod
    def _extract_title_and_body(content: str) -> str:
        """マークダウンファイルからタイトルと本文を抽出
        
        <!-- メタデータ --> や <!-- コメント --> を除去し、
        タイトル(# で始まる行)と本文のみを抽出
        
        Args:
            content: 元のマークダウンコンテンツ
            
        Returns:
            クリーニングされたコンテンツ
        """
        try:
            lines = content.split('\n')
            result_lines = []
            in_comment = False
            
            for line in lines:
                # HTMLコメント開始
                if '<!--' in line:
                    in_comment = True
                    continue
                
                # HTMLコメント終了
                if '-->' in line:
                    in_comment = False
                    continue
                
                # コメント内はスキップ
                if in_comment:
                    continue
                
                # 空行が連続する場合は1つだけにする
                if line.strip() == '':
                    if result_lines and result_lines[-1].strip() == '':
                        continue
                
                result_lines.append(line)
            
            # 先頭と末尾の空行を削除
            while result_lines and result_lines[0].strip() == '':
                result_lines.pop(0)
            
            while result_lines and result_lines[-1].strip() == '':
                result_lines.pop()
            
            cleaned_content = '\n'.join(result_lines)
            
            logger.debug(f"【記事クリーンアップ完了】")
            logger.debug(f"  元の文字数: {len(content)}")
            logger.debug(f"  処理後の文字数: {len(cleaned_content)}")
            logger.debug(f"  先頭100文字: {cleaned_content[:100]}...")
            
            return cleaned_content
            
        except Exception as e:
            logger.warning(f"記事クリーンアップエラー: {e}")
            return content


# ============================================================================
# TaskTypeAnalyzer: タスクタイプ分析クラス
# ============================================================================

class TaskTypeAnalyzer:
    """タスク内容からタイプを判定
    
    タスクの説明文を解析して、適切なタスクタイプを返す。
    """

    @staticmethod
    def analyze(description: str) -> str:
        """タスク内容からタイプを判定
        
        Args:
            description: タスク説明文
            
        Returns:
            タスクタイプ文字列
        """
        description_lower = description.lower()
        
        # 新しい判定ルールを追加
        if 'polylang' in description_lower and '言語' in description_lower:
            return 'edit_post'
        
        if '投稿' in description and '探して' in description and (
            '変更' in description or '編集' in description or '書き換え' in description
        ):
            return 'edit_post'
        
        if 'プラグイン' in description and (
            '変更' in description or '設定' in description
        ) and 'インストール' not in description:
            return 'plugin_settings'
        
        if 'プラグイン' in description and 'インストール' in description:
            return 'plugin_install'
        
        if 'テーマ' in description or 'theme' in description_lower:
            return 'theme_change'
        
        if '設定' in description or 'setting' in description_lower:
            return 'setting_change'
        
        if ('投稿' in description or '記事' in description or 'post' in description_lower) and (
            '作成' in description or '保存' in description
        ):
            return 'content_create'
        
        if 'テスト' in description or 'test' in description_lower:
            return 'test_functionality'
        
        return 'generic'


# ============================================================================
# WordPressConfig: WordPress設定クラス
# ============================================================================

class WordPressConfig:
    """WordPress設定クラス
    
    WordPress関連の設定値を一元管理する。
    - WordPress URL
    - Polylang言語コード
    - ACFフィールドタイプ
    - 推奨プラグイン
    - M&A案件デフォルトフィールド
    - FacetWPデフォルト設定
    """
    
    # WordPress URLの設定(実際のサイトURLに変更してください)
    WORDPRESS_URL = "https://your-site.com"
    
    # Polylang言語コード定義
    POLYLANG_LANGS = {
        'ja': 'ja',           # 日本語
        'en': 'en',           # 英語
        'ru': 'ru',           # ロシア語
        'uz': 'uz_UZ',        # ウズベク語
        'zh': 'zh_CN',        # 中国語(簡体字)
        'ko': 'ko_KR',        # 韓国語
        'tr': 'tr_TR'         # トルコ語
    }
    
    # ACFフィールドタイプ定義
    ACF_FIELD_TYPES = {
        # テキスト系
        'text': 'テキスト(1行)',
        'textarea': 'テキストエリア(複数行)',
        'number': '数値',
        'email': 'メールアドレス',
        'url': 'URL',
        'password': 'パスワード',
        
        # 選択系
        'select': 'セレクトメニュー',
        'checkbox': 'チェックボックス',
        'radio': 'ラジオボタン',
        'true_false': '真偽値',
        
        # 日付時刻系
        'date_picker': '日付選択',
        'date_time_picker': '日付時刻選択',
        'time_picker': '時刻選択',
        
        # ファイル系
        'file': 'ファイル',
        'image': '画像',
        'gallery': 'ギャラリー',
        
        # リレーション系
        'post_object': '投稿オブジェクト',
        'relationship': 'リレーションシップ',
        'taxonomy': 'タクソノミー',
        'user': 'ユーザー',
        
        # レイアウト系
        'repeater': 'リピーター',
        'flexible_content': 'フレキシブルコンテンツ',
        'group': 'グループ',
        
        # その他
        'wysiwyg': 'WYSIWYGエディタ',
        'oembed': 'oEmbed',
        'google_map': 'Googleマップ',
        'color_picker': 'カラーピッカー'
    }
    
    # WordPressプラグイン定義
    WORDPRESS_PLUGINS = {
        # 必須プラグイン
        'required': [
            {
                'name': 'Advanced Custom Fields PRO',
                'slug': 'advanced-custom-fields-pro',
                'version': '6.2+',
                'purpose': 'カスタムフィールド管理',
                'priority': 'critical'
            },
            {
                'name': 'Custom Post Type UI',
                'slug': 'custom-post-type-ui',
                'version': '1.15+',
                'purpose': 'カスタム投稿タイプ管理',
                'priority': 'critical'
            },
            {
                'name': 'Polylang Pro',
                'slug': 'polylang-pro',
                'version': '3.5+',
                'purpose': '多言語対応',
                'priority': 'critical'
            }
        ],
        
        # 推奨プラグイン(検索強化)
        'search': [
            {
                'name': 'FacetWP',
                'slug': 'facetwp',
                'purpose': '絞り込み検索',
                'priority': 'high'
            },
            {
                'name': 'Relevanssi',
                'slug': 'relevanssi',
                'purpose': '検索精度向上',
                'priority': 'high'
            },
            {
                'name': 'SearchWP',
                'slug': 'searchwp',
                'purpose': '検索機能強化',
                'priority': 'medium'
            }
        ],
        
        # 推奨プラグイン(ユーザー管理)
        'user_management': [
            {
                'name': 'User Role Editor',
                'slug': 'user-role-editor',
                'purpose': 'ユーザーロール管理',
                'priority': 'high'
            },
            {
                'name': 'Members',
                'slug': 'members',
                'purpose': '権限管理',
                'priority': 'medium'
            }
        ],
        
        # 推奨プラグイン(セキュリティ)
        'security': [
            {
                'name': 'Wordfence Security',
                'slug': 'wordfence',
                'purpose': '総合セキュリティ',
                'priority': 'high'
            },
            {
                'name': 'iThemes Security',
                'slug': 'ithemes-security-pro',
                'purpose': 'セキュリティ強化',
                'priority': 'medium'
            }
        ],
        
        # 推奨プラグイン(パフォーマンス)
        'performance': [
            {
                'name': 'WP Rocket',
                'slug': 'wp-rocket',
                'purpose': 'キャッシュ・最適化',
                'priority': 'high'
            },
            {
                'name': 'Autoptimize',
                'slug': 'autoptimize',
                'purpose': 'CSS/JS最適化',
                'priority': 'medium'
            }
        ]
    }
    
    # M&A案件デフォルトフィールド設定
    MA_CASE_DEFAULT_FIELDS = {
        'case_id': {
            'type': 'text',
            'label': '案件ID',
            'required': True
        },
        'ma_scheme': {
            'type': 'select',
            'label': 'M&Aスキーム',
            'choices': ['株式譲渡', '事業譲渡', '合併', '会社分割'],
            'required': True
        },
        'desired_price': {
            'type': 'number',
            'label': '希望価格',
            'min': 0,
            'step': 1000000,
            'required': False
        },
        'industry_category': {
            'type': 'taxonomy',
            'label': '業種',
            'taxonomy': 'industry_category',
            'required': True
        },
        'region': {
            'type': 'taxonomy',
            'label': '地域',
            'taxonomy': 'region',
            'required': True
        },
        'established_year': {
            'type': 'number',
            'label': '設立年',
            'min': 1900,
            'max': 2025,
            'required': False
        },
        'employees': {
            'type': 'number',
            'label': '従業員数',
            'min': 0,
            'required': False
        },
        'annual_revenue': {
            'type': 'number',
            'label': '年商',
            'min': 0,
            'required': False
        },
        'annual_profit': {
            'type': 'number',
            'label': '年間利益',
            'required': False
        },
        'reason_for_sale': {
            'type': 'textarea',
            'label': '売却理由',
            'required': False
        },
        'strengths': {
            'type': 'textarea',
            'label': '強み',
            'required': False
        }
    }
    
    # FacetWPデフォルト設定
    FACETWP_DEFAULT_FACETS = [
        {
            'name': '業種フィルター',
            'type': 'checkboxes',
            'source': 'tax/industry_category',
            'label': '業種で絞り込む'
        },
        {
            'name': '価格帯フィルター',
            'type': 'slider',
            'source': 'cf/desired_price',
            'label': '希望価格',
            'min': 0,
            'max': 1000000000,
            'step': 10000000,
            'format': '¥{value}'
        },
        {
            'name': '地域フィルター',
            'type': 'dropdown',
            'source': 'tax/region',
            'label': '地域で絞り込む'
        },
        {
            'name': '従業員数フィルター',
            'type': 'slider',
            'source': 'cf/employees',
            'label': '従業員数',
            'min': 0,
            'max': 1000,
            'step': 10
        }
    ]


# ============================================================================
# TaskRouter: タスク振り分けクラス
# ============================================================================

class TaskRouter:
    """タスクの振り分けを行うユーティリティクラス
    
    タスクの内容を解析して、適切なタイプ(M&A/記事生成/レビュー/デフォルト)を判定する。
    """
    
    # M&A関連の強力なキーワード
    MA_STRONG_KEYWORDS = [
        'custom post type', 'カスタム投稿タイプ', 'cpt',
        'acf設定', 'acf', 'カスタムフィールド', 'custom field',
        'taxonomy', 'タクソノミー', 'カテゴリ作成',
        'm&a案件', 'ma_case', 'ma case',
        '企業検索', '案件管理', '案件投稿',
        'facetwp', 'facet', '絞り込み検索',
        'user role', 'ユーザーロール', '権限管理'
    ]
    
    # 記事生成関連のキーワード
    CONTENT_KEYWORDS = [
        '記事作成', '記事執筆', 'article', 'content creation',
        '【日本語】', '【英語】', '【ロシア語】', '【ウズベク語】',
        '【中国語】', '【韓国語】', '【トルコ語】',
        'ブログ', 'blog post', 'seo記事'
    ]
    
    # 記事生成系エージェント
    CONTENT_AGENTS = [
        'writer', 'writer_ja', 'writer_en', 'writer_ru',
        'writer_uz', 'writer_zh', 'writer_ko', 'writer_tr',
        'content'
    ]
    
    # M&A関連パラメータキー
    MA_PARAMETER_KEYS = [
        'cpt_slug', 'cpt_labels', 'cpt_supports',
        'acf_field_group_name', 'acf_fields', 'acf_location_rules',
        'taxonomy_slug', 'taxonomy_labels', 'taxonomy_post_types',
        'facets', 'role_slug', 'role_name'
    ]
    
    # 記事生成関連パラメータキー
    CONTENT_PARAMETER_KEYS = [
        'language', 'polylang_lang', 'seo_keywords',
        'target_audience', 'target_url', 'article_type'
    ]
    
    @staticmethod
    def determine_task_type(task: dict) -> str:
        """タスクのタイプを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            'ma' - M&A/企業検索タスク
            'content' - 記事生成タスク
            'review' - レビュータスク
            'default' - その他のタスク
        """
        description = task.get('description', '').lower()
        agent = task.get('required_role', '').lower()
        parameters = task.get('parameters', {})
        
        # 1. レビュータスクの判定(最優先)
        if agent == 'review' or 'review_target_task_id' in parameters:
            return 'review'
        
        # 2. M&A関連タスクの判定
        # 2-1. 強力なキーワードマッチング
        if any(keyword in description for keyword in TaskRouter.MA_STRONG_KEYWORDS):
            logger.debug(f"M&Aタスク判定: キーワードマッチ")
            return 'ma'
        
        # 2-2. パラメータ判定
        if any(key in parameters for key in TaskRouter.MA_PARAMETER_KEYS):
            logger.debug(f"M&Aタスク判定: パラメータマッチ")
            return 'ma'
        
        # 2-3. エージェントと説明の組み合わせ
        if agent in ['wordpress', 'plugin']:
            # WordPressエージェントで特定の機能
            if any(word in description for word in ['設定', '作成', 'setup', 'configure']):
                logger.debug(f"M&Aタスク判定: WordPressエージェント+設定")
                return 'ma'
        
        # 3. 記事生成タスクの判定
        # 3-1. エージェント判定(最も確実)
        if agent in TaskRouter.CONTENT_AGENTS:
            logger.debug(f"記事生成タスク判定: エージェントマッチ")
            return 'content'
        
        # 3-2. パラメータ判定
        if any(key in parameters for key in TaskRouter.CONTENT_PARAMETER_KEYS):
            logger.debug(f"記事生成タスク判定: パラメータマッチ")
            return 'content'
        
        # 3-3. キーワード判定
        if any(keyword in description for keyword in TaskRouter.CONTENT_KEYWORDS):
            logger.debug(f"記事生成タスク判定: キーワードマッチ")
            return 'content'
        
        # 4. その他のタスク
        logger.debug(f"デフォルトタスク判定")
        return 'default'
    
    @staticmethod
    def is_ma_task(task: dict) -> bool:
        """M&A関連タスクかどうかを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            M&Aタスクの場合True
        """
        return TaskRouter.determine_task_type(task) == 'ma'
    
    @staticmethod
    def is_content_task(task: dict) -> bool:
        """記事生成タスクかどうかを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            記事生成タスクの場合True
        """
        return TaskRouter.determine_task_type(task) == 'content'
    
    @staticmethod
    def is_review_task(task: dict) -> bool:
        """レビュータスクかどうかを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            レビュータスクの場合True
        """
        return TaskRouter.determine_task_type(task) == 'review'


# ============================================================================
# グローバルインスタンスの作成
# ============================================================================

# グローバルインスタンスを作成
wp_config = WordPressConfig()
task_router = TaskRouter()


# ============================================================================
# PluginNameExtractor: プラグイン名抽出クラス
# ============================================================================

class PluginNameExtractor:
    """タスク説明からプラグイン名を抽出"""

    @staticmethod
    def extract(description: str) -> str:
        """タスク説明からプラグイン名を抽出
        
        Args:
            description: タスク説明文
            
        Returns:
            抽出されたプラグイン名
        """
        # 「」『』で囲まれた部分を抽出
        match = re.search(r'[「『](.+?)[」』]', description)
        if match:
            return match.group(1)
        
        # 見つからない場合は説明の先頭50文字を返す
        return description[:50]


# ============================================================================
# HTMLCleaner: HTMLクリーニングクラス
# ============================================================================

class HTMLCleaner:
    """HTML記事のクリーニングユーティリティ
    
    WordPress投稿用にHTMLを最適化・クリーニングする機能を提供。
    - 不正なネストの修正
    - WordPressクラスの追加
    - Gutenbergブロック対応
    - タイトル・本文の分離
    """
        
    @staticmethod
    def clean_html_content(html_content: str) -> str:
        """HTMLコンテンツをクリーニング - WordPress用に最適化
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            クリーニングされたHTML
        """
        try:
            logger.info("WordPress用にHTMLをクリーニング中...")
            
            # 基本的なクリーニング
            cleaned = html_content
            
            # 1. 不正なネストを修正
            cleaned = re.sub(r'<p>\s*<div', '<div', cleaned)
            cleaned = re.sub(r'</div>\s*</p>', '</div>', cleaned)
            cleaned = re.sub(r'<p>\s*</p>', '', cleaned)
            
            # 2. 適切な改行を追加(読みやすさのため)
            cleaned = re.sub(r'></(h1|h2|h3|h4|h5|h6|p|div|section|article)>', r'></\1>\n\n', cleaned)
            cleaned = re.sub(r'<(h1|h2|h3|h4|h5|h6|p|div|section|article)([^>]*)>', r'<\1\2>\n', cleaned)
            
            # 3. 連続する空白を単一スペースに
            cleaned = re.sub(r'\s+', ' ', cleaned)
            
            # 4. タグ間の空白を正規化
            cleaned = re.sub(r'>\s+<', '> <', cleaned)
            
            # 5. WordPress用のクラスを追加
            cleaned = HTMLCleaner._add_wordpress_classes(cleaned)
            
            # 6. セマンティックな構造を確認
            lines = cleaned.split('\n')
            cleaned_lines = []
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                    
                # 明らかに不正な行をスキップ
                if line in ['<p><div', '</div></p>']:
                    continue
                    
                cleaned_lines.append(line)
            
            cleaned = '\n'.join(cleaned_lines)
            
            logger.info(f"HTMLクリーニング完了: {len(html_content)} → {len(cleaned)}文字")
            return cleaned
            
        except Exception as e:
            logger.error(f"HTMLクリーニングエラー: {e}")
            return html_content
    
    @staticmethod
    def _add_wordpress_classes(html_content: str) -> str:
        """WordPress用のクラスを追加してスタイルを適用
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            WordPressクラスが追加されたHTML
        """
        try:
            # 見出しにWordPressのクラスを追加
            html_content = re.sub(r'<h1([^>]*)>', r'<h1\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h2([^>]*)>', r'<h2\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h3([^>]*)>', r'<h3\1 class="wp-block-heading has-medium-font-size">', html_content)
            
            # 段落にクラスを追加
            html_content = re.sub(r'<p([^>]*)>', r'<p\1 class="wp-block-paragraph">', html_content)
            
            # セクションにクラスを追加
            html_content = re.sub(r'<section([^>]*)>', r'<section\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<article([^>]*)>', r'<article\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<div class="article-meta"', r'<div class="wp-block-group article-meta"', html_content)
            html_content = re.sub(r'<div class="intro"', r'<div class="wp-block-group intro"', html_content)
            html_content = re.sub(r'<div class="main-content"', r'<div class="wp-block-group main-content"', html_content)
            
            return html_content
            
        except Exception as e:
            logger.error(f"WordPressクラス追加エラー: {e}")
            return html_content
        
    @staticmethod
    def validate_html_structure(html_content: str) -> bool:
        """HTML構造の基本的な検証
        
        Args:
            html_content: 検証するHTMLコンテンツ
            
        Returns:
            構造が正しい場合True
        """
        try:
            # 基本的なタグのバランスをチェック
            open_tags = len(re.findall(r'<(\w+)[^>]*>', html_content))
            close_tags = len(re.findall(r'</(\w+)>', html_content))
                
            # divタグのバランスを特別にチェック
            div_open = html_content.count('<div')
            div_close = html_content.count('</div>')
                
            logger.info(f"HTML構造検証: タグ{open_tags}/{close_tags}, div{div_open}/{div_close}")
                
            # divタグのバランスが取れているか
            if div_open != div_close:
                logger.warning(f"divタグのバランスが取れていません: {div_open} != {div_close}")
                return False
                    
            return True
                
        except Exception as e:
            logger.error(f"HTML検証エラー: {e}")
            return False
        
    @staticmethod
    def extract_title_from_html(html_content: str) -> Tuple[str, str]:
        """HTMLからタイトルと本文を分離
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            (タイトル, クリーニングされたHTML本文)のタプル
        """
        try:
            logger.info("HTMLからタイトルを抽出中...")
                
            # 複数のパターンでタイトルを検索
            title_patterns = [
                r'<h1[^>]*>(.*?)</h1>',
                r'<title[^>]*>(.*?)</title>',
                r'<h2[^>]*>(.*?)</h2>',
                r'<h3[^>]*>(.*?)</h3>'
            ]
                
            for pattern in title_patterns:
                match = re.search(pattern, html_content, re.IGNORECASE | re.DOTALL)
                if match:
                    title_html = match.group(1)
                    # HTMLタグを除去してタイトルを取得
                    title = re.sub(r'<[^>]+>', '', title_html).strip()
                        
                    if title and len(title) > 5:  # 最低5文字以上
                        logger.info(f"✅ HTMLからタイトル抽出成功: {title}")
                            
                        # タイトル部分を除去した本文を作成
                        body = re.sub(pattern, '', html_content, flags=re.IGNORECASE | re.DOTALL)
                        body = body.strip()
                            
                        # 本文をクリーニング
                        body = HTMLCleaner.clean_html_content(body)
                            
                        return title, body
                
            logger.warning("❌ HTMLからタイトルを抽出できませんでした")
            return "タイトル不明", HTMLCleaner.clean_html_content(html_content)
                
        except Exception as e:
            logger.error(f"HTMLタイトル抽出エラー: {e}")
            return "タイトル抽出エラー", html_content
        
    @staticmethod
    def prepare_html_for_wordpress(html_content: str) -> Tuple[str, str]:
        """WordPress用にHTMLを準備(改善版)
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            (タイトル, WordPress用HTML本文)のタプル
        """
        try:
            logger.info("WordPress用にHTMLを準備中...")
            
            # タイトルと本文を分離
            title, body = HTMLCleaner.extract_title_from_html(html_content)
            
            # HTMLをWordPress用に最適化
            wp_html = HTMLCleaner._optimize_for_wordpress_gutenberg(body)
            
            logger.info(f"✅ WordPress用HTML準備完了: タイトル='{title}', 本文={len(wp_html)}文字")
            return title, wp_html
            
        except Exception as e:
            logger.error(f"WordPress用HTML準備エラー: {e}")
            return "HTML処理エラー", html_content
        
    @staticmethod
    def _optimize_for_wordpress(html_content: str) -> str:
        """WordPress用にHTMLを最適化
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            最適化されたHTML
        """
        try:
            optimized = html_content
                
            # 1. セマンティックなタグを維持
            # 2. 不正なネストを修正
            optimized = re.sub(r'<p>\s*<(div|section|article)', r'<\1', optimized)
            optimized = re.sub(r'</(div|section|article)>\s*</p>', r'</\1>', optimized)
                
            # 3. 空の段落を削除
            optimized = re.sub(r'<p>\s*</p>', '', optimized)
                
            # 4. 連続する改行を整理
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
                
            # 5. 基本的なHTML構造を確保
            if not optimized.strip().startswith('<'):
                optimized = f'<div class="article-content">\n{optimized}\n</div>'
                
            return optimized
                
        except Exception as e:
            logger.error(f"HTML最適化エラー: {e}")
            return html_content
    
    @staticmethod
    def _optimize_for_wordpress_gutenberg(html_content: str) -> str:
        """Gutenbergエディタ用にHTMLを最適化
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            Gutenberg最適化されたHTML
        """
        try:
            # まず基本クリーニング
            optimized = HTMLCleaner.clean_html_content(html_content)
            
            # Gutenbergブロック用の構造を追加
            optimized = HTMLCleaner._wrap_in_gutenberg_blocks(optimized)
            
            # 最終的な改行調整
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
            optimized = optimized.strip()
            
            return optimized
            
        except Exception as e:
            logger.error(f"Gutenberg最適化エラー: {e}")
            return html_content
    
    @staticmethod
    def _wrap_in_gutenberg_blocks(html_content: str) -> str:
        """
        HTMLをGutenbergブロックでラップ
        """
        try:
            blocks = []
            lines = html_content.split('\n')
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # 見出しブロック
                if line.startswith('<h1') or line.startswith('<h2') or line.startswith('<h3'):
                    blocks.append(f'<!-- wp:heading -->\n{line}\n<!-- /wp:heading -->')
                
                # 段落ブロック
                elif line.startswith('<p'):
                    blocks.append(f'<!-- wp:paragraph -->\n{line}\n<!-- /wp:paragraph -->')
                
                # グループブロック(セクション、記事メタなど)
                elif line.startswith('<section') or line.startswith('<article') or line.startswith('<div class="wp-block-group"'):
                    if line.startswith('</section') or line.startswith('</article') or line.startswith('</div'):
                        blocks.append(line)
                    else:
                        blocks.append(f'<!-- wp:group -->\n{line}')
                
                # その他の要素
                else:
                    blocks.append(line)
            
            # 閉じタグの処理
            result = []
            for block in blocks:
                if any(tag in block for tag in ['</section>', '</article>', '</div>']):
                    result.append(f'{block}\n<!-- /wp:group -->')
                else:
                    result.append(block)
            
            return '\n\n'.join(result)
            
        except Exception as e:
            logger.error(f"Gutenbergブロックラップエラー: {e}")
            return html_content
        
    @staticmethod
    def is_valid_html(html_content: str) -> bool:
        """
        HTMLが有効かチェック
        """
        try:
            # 基本的なチェック
            if not html_content or len(html_content.strip()) < 10:
                return False
                
            # HTMLタグの存在をチェック
            if '<' not in html_content or '>' not in html_content:
                return False
                
            # 基本的なタグのバランスをチェック
            return HTMLCleaner.validate_html_structure(html_content)
                
        except Exception as e:
            logger.error(f"HTML有効性チェックエラー: {e}")
            return False