#__init__.py
"""
WordPressé–‹ç™ºå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±åˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
"""

from .wp_requirements_agent import WordPressRequirementsAgent
from .wp_cpt_agent import WordPressCPTAgent
from .wp_taxonomy_agent import WordPressTaxonomyAgent
from .wp_acf_agent import WordPressACFAgent

__all__ = [
    'WordPressRequirementsAgent',
    'WordPressCPTAgent',
    'WordPressTaxonomyAgent',
    'WordPressACFAgent'
]

__version__ = '1.0.0'

#brower_cookie_and_session.py
# browser_cookie_and_session.py
"""ã‚¯ãƒƒã‚­ãƒ¼ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹"""
import json
import time
from pathlib import Path
from typing import Optional, Dict, List
from playwright.async_api import BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class CookieSessionManager:
    """ã‚¯ãƒƒã‚­ãƒ¼ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç®¡ç†ã‚’æ‹…å½“"""
    
    def __init__(self, context: BrowserContext, cookies_file: Path):
        self.context = context
        self.cookies_file = cookies_file
    
    async def save_cookies(self) -> None:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.context or not self.cookies_file:
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
                return
            
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("ä¿å­˜ã™ã‚‹ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return
                
            with open(self.cookies_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ: {len(cookies)}å€‹ã®ã‚¯ãƒƒã‚­ãƒ¼")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜")
            logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸãŒç¶šè¡Œã—ã¾ã™")

    async def load_cookies(self) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.cookies_file or not self.cookies_file.exists():
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“")
                return False
                
            if not self.context:
                logger.warning("ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            with open(self.cookies_file, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
            
            if not cookies:
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã™")
                return False
                
            current_url = "https://gemini.google.com"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆURL
            domain_cookies = []
            
            for cookie in cookies:
                if 'domain' in cookie and cookie['domain'].startswith('.'):
                    cookie['domain'] = cookie['domain'][1:]
                
                if 'expires' in cookie and cookie['expires'] < time.time():
                    continue
                    
                domain_cookies.append(cookie)
            
            if domain_cookies:
                await self.context.add_cookies(domain_cookies)
                logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {len(domain_cookies)}å€‹")
                return True
            else:
                logger.warning("æœ‰åŠ¹ãªã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
                
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿")
            return False
    
    async def check_google_login_status(self) -> bool:
        """Googleãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒšãƒ¼ã‚¸ãŒå¿…è¦ãªå ´åˆã«å®Ÿè£…ï¼‰"""
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒå¿…è¦ãªãŸã‚ã€
        # å¿…è¦ã«å¿œã˜ã¦AIChatAgentã«ç§»å‹•ã¾ãŸã¯ã“ã“ã§å®Ÿè£…
        logger.info("Googleãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼ˆå®Ÿè£…äºˆå®šï¼‰")
        return False

#browser_ai_chat_agent.py
# browser_ai_chat_agent.py
"""AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ï¼ˆGemini/DeepSeekå¯¾å¿œï¼‰"""
import asyncio
import time
import json
import re
from datetime import datetime
from typing import Optional, Dict
from playwright.async_api import Page
import logging

from config_utils import ErrorHandler, FileNameGenerator

logger = logging.getLogger(__name__)

class AIChatAgent:
    """AIã‚µãƒ¼ãƒ“ã‚¹ï¼ˆGemini/DeepSeekï¼‰ã¨ã®å¯¾è©±ã‚’æ‹…å½“"""
    
    def __init__(self, page: Page, service: str = "google", credentials: Dict = None):
        self.page = page
        self.service = service.lower()
        self.credentials = credentials or {}
    
    async def navigate_to_gemini(self) -> None:
        """Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆã‚¯ãƒ©ãƒƒã‚·ãƒ¥æ¤œçŸ¥å¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            
            logger.info("Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)
                    
                    logger.info("âœ… Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                    
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸ")
                        logger.error("æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        input("Geminiãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await asyncio.sleep(5)
            
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            
            await self.handle_welcome_screens()
            logger.info("âœ… Geminiã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiã‚¢ã‚¯ã‚»ã‚¹")
            logger.info("æ‰‹å‹•ã§Geminiãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
            input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆCloudflareãƒœãƒƒãƒˆæ¤œè¨¼å¯¾å¿œç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            logger.info("DeepSeekã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"DeepSeekã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    await self.page.goto("https://chat.deepseek.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(5000)
                    logger.info("DeepSeekã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        input("DeepSeekãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            
            # Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ãƒã‚§ãƒƒã‚¯
            logger.info("Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...")
            cloudflare_check = await self.page.evaluate('''
                () => {
                    const body = document.body.innerText || '';
                    if (body.includes('Verifying you are human') || 
                        body.includes('ã‚ãªãŸãŒãƒœãƒƒãƒˆã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèª') ||
                        body.includes('Just a moment') ||
                        body.includes('Checking your browser')) {
                        return true;
                    }
                    return false;
                }
            ''')
            
            if cloudflare_check:
                logger.warning("âš ï¸ Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ")
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã§è‡ªå‹•çš„ã«ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™...")
                
                start_time = time.time()
                while time.time() - start_time < 60:
                    await self.page.wait_for_timeout(3000)
                    
                    still_checking = await self.page.evaluate('''
                        () => {
                            const body = document.body.innerText || '';
                            if (body.includes('Verifying you are human') || 
                                body.includes('ã‚ãªãŸãŒãƒœãƒƒãƒˆã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèª') ||
                                body.includes('Just a moment') ||
                                body.includes('Checking your browser')) {
                                return true;
                            }
                            return false;
                        }
                    ''')
                    
                    if not still_checking:
                        logger.info("âœ… Cloudflareæ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ")
                        break
                    
                    elapsed = int(time.time() - start_time)
                    if elapsed % 10 == 0:
                        logger.info(f"å¾…æ©Ÿä¸­... {elapsed}ç§’çµŒé")
                
                await self.page.wait_for_timeout(3000)
                current_url = self.page.url
                logger.info(f"æ¤œè¨¼å¾Œã®URL: {current_url}")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                logger.info("\n" + "="*60)
                logger.info("âš ï¸ DeepSeekã¸ã®ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
                logger.info("="*60)
                logger.info("")
                logger.info("ğŸ“Œ ãƒ­ã‚°ã‚¤ãƒ³æ‰‹é †ï¼š")
                logger.info("1. ãƒ–ãƒ©ã‚¦ã‚¶ã§ã€ŒLog in with Googleã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
                logger.info("2. Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠï¼ˆã¾ãŸã¯å…¥åŠ›ï¼‰")
                logger.info(f"   ä½¿ç”¨ã™ã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ: {self.credentials.get('email', 'B2ã‚»ãƒ«ã®Google ID')}")
                logger.info("3. ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†ã‚’å¾…ã¤")
                logger.info("4. ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€ã“ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«æˆ»ã£ã¦Enterã‚­ãƒ¼ã‚’æŠ¼ã™")
                logger.info("")
                logger.info("ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼š")
                logger.info("  - ã€ŒChrome ã¯è‡ªå‹•ãƒ†ã‚¹ãƒˆ...ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–ã—ã¦ãã ã•ã„")
                logger.info("  - Googleãƒ­ã‚°ã‚¤ãƒ³ã¯é€šå¸¸é€šã‚Šå‹•ä½œã—ã¾ã™")
                logger.info("  - 2å›ç›®ä»¥é™ã¯Cookieã§è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³ã•ã‚Œã¾ã™")
                logger.info("="*60)
                
                input("\nâœ… ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                
                await self.page.wait_for_timeout(2000)
                current_url = self.page.url
                logger.info(f"ãƒ­ã‚°ã‚¤ãƒ³å¾Œã®URL: {current_url}")
                
                if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                    logger.warning("âš ï¸ ã¾ã ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã¾ã™")
                    logger.info("ã‚‚ã†ä¸€åº¦ã€ŒLog in with Googleã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„")
                    input("å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    await self.page.wait_for_timeout(2000)
            
            # ãƒãƒ£ãƒƒãƒˆç”»é¢ã«åˆ°é”ã§ãã¦ã„ã‚‹ã‹ç¢ºèª
            await self.page.wait_for_timeout(3000)
            chat_ready = await self.page.evaluate('''
                () => {
                    const inputs = document.querySelectorAll('textarea, input[type="text"]');
                    return inputs.length > 0;
                }
            ''')
            
            if not chat_ready:
                logger.warning("âš ï¸ ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ãã ã•ã„")
                input("\nâœ… ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            else:
                logger.info("âœ… ãƒãƒ£ãƒƒãƒˆç”»é¢ã‚’ç¢ºèªã—ã¾ã—ãŸ")
            
            logger.info("âœ… DeepSeekã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "DeepSeekã‚¢ã‚¯ã‚»ã‚¹")
            logger.info("æ‰‹å‹•ã§DeepSeekãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
            input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
    
    async def handle_welcome_screens(self) -> None:
        """åˆ©ç”¨è¦ç´„ã‚„ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’å‡¦ç†"""
        try:
            if not self.page:
                return
            logger.info("ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚„ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’ç¢ºèªä¸­...")
            continue_buttons = [
                'text=ç¶šè¡Œ', 'text=é–‹å§‹', 'text=åŒæ„', 'text=Continue',
                'text=Get started', 'text=Agree', 'text=Got it', 'text=OK',
                '[data-testid="continue-button"]'
            ]
            start_time = time.time()
            found_buttons = 0
            while time.time() - start_time < 10 and found_buttons < 3:
                for button_selector in continue_buttons:
                    try:
                        button = await self.page.query_selector(button_selector)
                        if button and await button.is_visible():
                            await button.click()
                            await self.page.wait_for_timeout(2000)
                            logger.info(f"ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ: {button_selector}")
                            found_buttons += 1
                            break
                    except Exception:
                        continue
                await self.page.wait_for_timeout(1000)
            if found_buttons > 0:
                logger.info(f"{found_buttons}å€‹ã®ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’å‡¦ç†ã—ã¾ã—ãŸ")
            else:
                logger.info("ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼ˆæ­£å¸¸ï¼‰")
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢å‡¦ç†")
    
    async def ensure_normal_chat_mode(self) -> None:
        """é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆStorybookã‚’å›é¿ï¼‰- å¼·åŒ–ç‰ˆ"""
        try:
            if not self.page:
                return
            logger.info("ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’ç¢ºèªä¸­...")
            current_url = self.page.url
            if 'storybook' in current_url.lower():
                logger.warning("Storybookã®URLãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã™...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã—ãŸ")
                return
            storybook_active = await self.page.evaluate('''
                () => {
                    const buttons = document.querySelectorAll('button');
                    for (const btn of buttons) {
                        const text = btn.textContent || '';
                        const ariaLabel = btn.getAttribute('aria-label') || '';
                        if ((text.includes('Storybook') || ariaLabel.includes('Storybook')) &&
                            (btn.getAttribute('aria-pressed') === 'true' || 
                             btn.classList.contains('active') ||
                             btn.classList.contains('selected'))) {
                            return true;
                        }
                    }
                    return false;
                }
            ''')
            if storybook_active:
                logger.warning("Storybookãƒ¢ãƒ¼ãƒ‰ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã™...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã—ãŸ")
            else:
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã™")
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ç¢ºèª")
    
    async def send_prompt(self, prompt: str) -> None:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦é€ä¿¡ï¼ˆã‚µãƒ¼ãƒ“ã‚¹è‡ªå‹•åˆ¤åˆ¥ç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            await self.ensure_normal_chat_mode()
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ä¸­: {prompt[:50]}...")
            
            if self.service == "deepseek":
                await self.send_prompt_deepseek(prompt)
            else:
                await self.send_prompt_gemini(prompt)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_gemini(self, prompt: str) -> None:
        """Geminiã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡(ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å¯¾å¿œç‰ˆ)"""
        try:
            # å…¥åŠ›æ¬„ã‚’æ¢ã™
            input_selectors = [
                'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ Gemini ã«é€ä¿¡"]',
                'textarea[placeholder*="Send a message to Gemini"]',
                'div[contenteditable="true"][role="textbox"]',
                'textarea[data-testid="message-input"]',
                'div.ql-editor[contenteditable="true"]',
                'textarea.ql-editor',
                '[data-message-input]',
                'div[contenteditable="true"][aria-label*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
                'div[contenteditable="true"][aria-label*="message"]',
                'div[contenteditable="true"][tabindex="0"]',
                'textarea[aria-label*="Gemini"]',
                '[data-testid="input-area"] textarea',
                '[data-testid="input-area"] div[contenteditable="true"]',
            ]
            
            input_element = None
            for selector in input_selectors:
                try:
                    await self.page.wait_for_selector(selector, timeout=5000)
                    input_element = await self.page.query_selector(selector)
                    if input_element:
                        logger.info(f"å…¥åŠ›æ¬„ã‚’ç™ºè¦‹: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                await self.page.screenshot(path="debug_input_not_found.png")
                raise Exception("å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã‚‹å‡¦ç†
            try:
                # 1. ãƒ¡ãƒ¼ãƒ«é…ä¿¡ç™»éŒ²ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã€Œå¾Œã§ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
                later_button_selectors = [
                    'button:has-text("å¾Œã§")',
                    'button:has-text("Later")',
                    '[aria-label*="å¾Œã§"]',
                    '[aria-label*="Later"]'
                ]
                
                for selector in later_button_selectors:
                    try:
                        later_button = await self.page.query_selector(selector)
                        if later_button and await later_button.is_visible():
                            await later_button.click()
                            await self.page.wait_for_timeout(1000)
                            logger.info("âœ… ãƒ¡ãƒ¼ãƒ«é…ä¿¡ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã¾ã—ãŸ")
                            break
                    except:
                        continue
                
                # 2. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å…¨ä½“ã‚’é–‰ã˜ã‚‹ï¼ˆãƒãƒƒã‚¯ãƒ‰ãƒ­ãƒƒãƒ—ã‚¯ãƒªãƒƒã‚¯ï¼‰
                overlay_backdrop = await self.page.query_selector('.cdk-overlay-backdrop')
                if overlay_backdrop:
                    try:
                        await overlay_backdrop.click()
                        await self.page.wait_for_timeout(500)
                        logger.info("âœ… ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã¾ã—ãŸ")
                    except:
                        pass
                
                # 3. Escã‚­ãƒ¼ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹ï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰
                await self.page.keyboard.press('Escape')
                await self.page.wait_for_timeout(500)
                
            except Exception as e:
                logger.debug(f"ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å‡¦ç†: {e}")
            
            # å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªãƒƒã‚¯
            await input_element.click()
            await self.page.wait_for_timeout(500)
            
            # æ—¢å­˜ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
            await self.page.keyboard.press("Control+a")
            await self.page.wait_for_timeout(500)
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›
            await input_element.fill(prompt)
            await self.page.wait_for_timeout(1500)
            
            # é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            send_selectors = [
                'button[data-testid="send-button"]',
                '[data-testid="send-button"]'
            ]
            
            sent = False
            for selector in send_selectors:
                try:
                    send_button = await self.page.query_selector(selector)
                    if send_button and await send_button.is_enabled():
                        await send_button.click()
                        logger.info("é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
                        sent = True
                        break
                except:
                    continue
            
            if not sent:
                await input_element.press('Enter')
                logger.info("Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã—ãŸ")
            
            await self.page.wait_for_timeout(3000)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_deepseek(self, prompt: str) -> None:
        """DeepSeekã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        # ã¾ãšã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®ã£ã¦çŠ¶æ…‹ã‚’ç¢ºèª
        debug_screenshot = f"debug_deepseek_before_input_{datetime.now().strftime('%H%M%S')}.png"
        try:
            await self.page.screenshot(path=debug_screenshot)
            logger.info(f"ğŸ“¸ å…¥åŠ›å‰ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {debug_screenshot}")
        except:
            pass
        
        # è¤‡æ•°ã®å¯èƒ½æ€§ã®ã‚ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ã‚’è©¦ã™
        input_selectors = [
            'textarea[placeholder*="Ask"]',
            'textarea[placeholder*="Type"]',
            'textarea[placeholder*="message"]',
            'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'textarea[placeholder*="å…¥åŠ›"]',
            'div[contenteditable="true"][role="textbox"]',
            'div[contenteditable="true"]',
            'textarea',
            'input[type="text"]',
        ]
        
        input_element = None
        used_selector = None
        
        # å„ã‚»ãƒ¬ã‚¯ã‚¿ã‚’é †ç•ªã«è©¦ã™
        for selector in input_selectors:
            try:
                logger.info(f"å…¥åŠ›æ¬„ã‚’æ¢ç´¢ä¸­: {selector}")
                element = await self.page.query_selector(selector)
                if element:
                    # è¦ç´ ãŒè¦‹ãˆã¦ã„ã‚‹ã‹ç¢ºèª
                    is_visible = await element.is_visible()
                    if is_visible:
                        input_element = element
                        used_selector = selector
                        logger.info(f"âœ… å…¥åŠ›æ¬„ã‚’ç™ºè¦‹: {selector}")
                        break
                    else:
                        logger.info(f"è¦ç´ ã¯å­˜åœ¨ã™ã‚‹ãŒéè¡¨ç¤º: {selector}")
            except Exception as e:
                logger.debug(f"ã‚»ãƒ¬ã‚¯ã‚¿ {selector} ã§ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        if not input_element:
            # å…¨ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—ã—ãŸå ´åˆ
            await self.page.screenshot(path="debug_deepseek_input_not_found.png")
            logger.error("âŒ DeepSeekå…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            logger.error("ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š")
            logger.error("1. ãƒ­ã‚°ã‚¤ãƒ³ãŒå®Œäº†ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ")
            logger.error("2. ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿ")
            logger.error("3. Cloudflareã®æ¤œè¨¼ã¯å®Œäº†ã—ã¾ã—ãŸã‹ï¼Ÿ")
            
            # ãƒšãƒ¼ã‚¸ã®HTMLã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
            page_content = await self.page.evaluate('document.body.innerText')
            logger.info(f"ãƒšãƒ¼ã‚¸å†…å®¹ï¼ˆå…ˆé ­500æ–‡å­—ï¼‰:\n{page_content[:500]}")
            
            # æ‰‹å‹•ä»‹å…¥ã‚’ä¿ƒã™
            logger.info("\næ‰‹å‹•ã§å…¥åŠ›æ¬„ãŒè¦‹ãˆã‚‹ã¾ã§æ“ä½œã—ã¦ãã ã•ã„")
            input("å…¥åŠ›æ¬„ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            
            # å†åº¦æ¢ã™
            for selector in input_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element and await element.is_visible():
                        input_element = element
                        used_selector = selector
                        logger.info(f"âœ… å…¥åŠ›æ¬„ã‚’ç™ºè¦‹ï¼ˆ2å›ç›®ï¼‰: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                raise Exception("å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆ2å›ç›®ã®è©¦è¡Œå¾Œï¼‰")
        
        # å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
        await input_element.click()
        await self.page.wait_for_timeout(500)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›
        await input_element.fill(prompt)
        await self.page.wait_for_timeout(1500)
        
        # é€ä¿¡ãƒœã‚¿ãƒ³ã‚’æ¢ã™
        send_button = None
        send_selectors = [
            'button[type="submit"]',
            'button[aria-label*="Send"]',
            'button[aria-label*="é€ä¿¡"]',
            'button:has-text("é€ä¿¡")',
            'button:has-text("Send")',
            'button svg',  # ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³
        ]
        
        for selector in send_selectors:
            try:
                btn = await self.page.query_selector(selector)
                if btn and await btn.is_visible() and await btn.is_enabled():
                    send_button = btn
                    logger.info(f"é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ç™ºè¦‹: {selector}")
                    break
            except:
                continue
        
        if send_button:
            await send_button.click()
            logger.info("âœ… DeepSeeké€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
        else:
            # ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯Enterã‚­ãƒ¼ã§é€ä¿¡
            logger.info("é€ä¿¡ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã™")
            await input_element.press("Enter")
            logger.info("âœ… Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã—ãŸ")
        
        await self.page.wait_for_timeout(3000)
    
    async def wait_for_text_generation(self, max_wait: int = 120) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã¾ã§å¾…æ©Ÿ"""
        try:
            if not self.page:
                return False
            logger.info("ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã‚’å¾…æ©Ÿä¸­...")
            start_time = time.time()
            check_interval = 2
            await self.page.wait_for_timeout(5000)
            while time.time() - start_time < max_wait:
                await self.page.wait_for_timeout(check_interval * 1000)
                elapsed = int(time.time() - start_time)
                is_complete = await self.page.evaluate('''
                    () => {
                        const allButtons = document.querySelectorAll('button');
                        for (const btn of allButtons) {
                            const text = btn.textContent || '';
                            const ariaLabel = btn.getAttribute('aria-label') || '';
                            if (text.includes('å†ç”Ÿæˆ') || text.includes('Regenerate') ||
                                ariaLabel.includes('å†ç”Ÿæˆ') || ariaLabel.includes('Regenerate')) {
                                return true;
                            }
                        }
                        const sendButtons = document.querySelectorAll('[data-testid="send-button"], button[type="submit"]');
                        for (const btn of sendButtons) {
                            if (!btn.disabled && !btn.hasAttribute('disabled')) {
                                return true;
                            }
                        }
                        const loadingElements = document.querySelectorAll('[data-testid="loading"], .loading, .spinner');
                        if (loadingElements.length === 0) {
                            return true;
                        }
                        return false;
                    }
                ''')
                if is_complete:
                    logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã‚’æ¤œå‡º")
                    await self.page.wait_for_timeout(2000)
                    return True
                if elapsed % 10 == 0 and elapsed > 0:
                    logger.info(f"â³ å¾…æ©Ÿä¸­... {elapsed}ç§’çµŒé")
            logger.warning(f"â° ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå¾…æ©Ÿ")
            return False
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """
        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿã‚’ä¸€æ‹¬å‡¦ç†ï¼ˆæ¨å¥¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰
        
        Args:
            prompt: é€ä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            max_wait: æœ€å¤§å¾…æ©Ÿæ™‚é–“ï¼ˆç§’ï¼‰
            
        Returns:
            bool: æˆåŠŸæ™‚ True
        """
        try:
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡
            await self.send_prompt(prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.wait_for_text_generation(max_wait)
            
            if success:
                logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©ŸãŒå®Œäº†ã—ã¾ã—ãŸ")
            else:
                logger.warning("âš ï¸ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¯æˆåŠŸã—ã¾ã—ãŸãŒã€å¿œç­”å¾…æ©ŸãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
            
            return success
            
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¾…æ©Ÿä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    
    async def extract_latest_text_response(self) -> str:
        """æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆã‚µãƒ¼ãƒ“ã‚¹è‡ªå‹•åˆ¤åˆ¥ç‰ˆï¼‰"""
        try:
            if self.service == "deepseek":
                return await self.extract_latest_text_response_deepseek()
            else:
                return await self.extract_latest_text_response_gemini()
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º")
            return None
    
    async def extract_latest_text_response_gemini(self) -> str:
        """Geminiã®æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ä¿®æ­£ç‰ˆï¼‰"""
        try:
            logger.info("=" * 60)
            logger.info("â˜…â˜…â˜… Geminiãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºé–‹å§‹ â˜…â˜…â˜…")
            logger.info("=" * 60)
            
            all_results = {}
            
            # æ–¹æ³•1: ãƒ¢ãƒ‡ãƒ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã‹ã‚‰å–å¾—
            try:
                method1_text = await self.page.evaluate('''() => {
                    const modelMessages = document.querySelectorAll('[data-message-author="model"]');
                    if (modelMessages.length === 0) return null;
                    
                    const latestMessage = modelMessages[modelMessages.length - 1];
                    return latestMessage.innerText || latestMessage.textContent || '';
                }''')
                all_results['æ–¹æ³•1'] = method1_text
                logger.info(f"æ–¹æ³•1çµæœ: {len(method1_text) if method1_text else 0}æ–‡å­—")
            except Exception as e:
                logger.debug(f"æ–¹æ³•1å¤±æ•—: {e}")
                all_results['æ–¹æ³•1'] = None

            # æ–¹æ³•2: ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰å–å¾—
            try:
                method2_text = await self.page.evaluate('''() => {
                    const markdownContainers = document.querySelectorAll('[class*="markdown"]');
                    if (markdownContainers.length === 0) return null;
                    
                    let longest = '';
                    for (const container of markdownContainers) {
                        const text = container.innerText || container.textContent || '';
                        if (text.length > longest.length) {
                            longest = text;
                        }
                    }
                    return longest;
                }''')
                all_results['æ–¹æ³•2'] = method2_text
                logger.info(f"æ–¹æ³•2çµæœ: {len(method2_text) if method2_text else 0}æ–‡å­—")
            except Exception as e:
                logger.debug(f"æ–¹æ³•2å¤±æ•—: {e}")
                all_results['æ–¹æ³•2'] = None

            # æ–¹æ³•3: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–å¾—
            try:
                method3_text = await self.page.evaluate('''() => {
                    const messages = document.querySelectorAll('[class*="message"]');
                    if (messages.length === 0) return null;
                    
                    let modelTexts = [];
                    for (const msg of messages) {
                        const text = msg.innerText || msg.textContent || '';
                        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é™¤å¤–ï¼ˆçŸ­ã„ã¾ãŸã¯ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
                        if (text.length > 100 && 
                            !text.includes('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª') &&
                            !text.includes('ã€ã‚ãªãŸã®å½¹å‰²ã€‘') &&
                            !text.includes('ã€åŸ·ç­†ä¾é ¼ã€‘')) {
                            modelTexts.push(text);
                        }
                    }
                    return modelTexts.length > 0 ? modelTexts[modelTexts.length - 1] : null;
                }''')
                all_results['æ–¹æ³•3'] = method3_text
                logger.info(f"æ–¹æ³•3çµæœ: {len(method3_text) if method3_text else 0}æ–‡å­—")
            except Exception as e:
                logger.debug(f"æ–¹æ³•3å¤±æ•—: {e}")
                all_results['æ–¹æ³•3'] = None
            
            # å„ªå…ˆé †ä½ã§é¸æŠï¼ˆã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§æ¤œè¨¼ã‚’ç·©å’Œï¼‰
            priority_order = ['æ–¹æ³•1', 'æ–¹æ³•2', 'æ–¹æ³•3']
            best_result = None
            best_method = None
            
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 100:
                    text = all_results[method]
                    
                    # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ··å…¥ã—ã¦ã„ãªã„ã‹æœ€çµ‚ãƒã‚§ãƒƒã‚¯
                    if ('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª' in text or 
                        'ã€ã‚ãªãŸã®å½¹å‰²ã€‘' in text or
                        'ã€åŸ·ç­†ä¾é ¼ã€‘' in text):
                        logger.warning(f"{method}ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ··å…¥ - ã‚¹ã‚­ãƒƒãƒ—")
                        continue
                    
                    # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æ¤œè¨¼ï¼ˆç·©å’Œç‰ˆï¼‰
                    validation_result = self._validate_code_block_completeness_enhanced(text)
                    
                    if validation_result['is_complete']:
                        logger.info(f"âœ… {method}: å®Œå…¨ãªå¿œç­”ã‚’æ¤œå‡º")
                        best_result = text.strip()
                        best_method = method
                        break
                    else:
                        # ä¸å®Œå…¨ã§ã‚‚é•·æ–‡ã®å ´åˆã¯è­¦å‘Šã‚’å‡ºã—ã¦æ¡ç”¨ã™ã‚‹
                        if len(text) > 1500:  # é•·æ–‡ã®å ´åˆã¯è¨±å®¹
                            logger.warning(f"âš ï¸ {method}: ä¸å®Œå…¨ã ãŒé•·æ–‡ã®ãŸã‚æ¡ç”¨ - {validation_result['reason']}")
                            best_result = text.strip()
                            best_method = method
                            break
                        else:
                            logger.warning(f"âš ï¸ {method}: ä¸å®Œå…¨ãªå¿œç­” - {validation_result['reason']}")
            
            if best_result:
                logger.info(f"\nğŸ¯ æ¡ç”¨: {best_method} ({len(best_result)}æ–‡å­—)")
                logger.info(f"å…ˆé ­200æ–‡å­—:\n{best_result[:200]}")
                return best_result
            
            # ã™ã¹ã¦å¤±æ•—ã—ãŸå ´åˆã§ã‚‚ã€æœ€é•·ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™ï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰
            fallback_text = None
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 500:
                    fallback_text = all_results[method]
                    logger.warning(f"âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¡ç”¨: {method} ({len(fallback_text)}æ–‡å­—)")
                    break
            
            if fallback_text:
                return fallback_text.strip()
            
            # æœ¬å½“ã«ä½•ã‚‚å–å¾—ã§ããªã„å ´åˆ
            logger.error("\nâŒ å…¨æ–¹æ³•å¤±æ•— - Geminiã®å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
            
            # ãƒ‡ãƒãƒƒã‚°ç”¨: ãƒšãƒ¼ã‚¸ã®æ§‹é€ ã‚’ç¢ºèª
            page_structure = await self.page.evaluate('''() => {
                return {
                    messageCount: document.querySelectorAll('[class*="message"]').length,
                    modelMessages: document.querySelectorAll('[data-message-author="model"]').length,
                    markdownContainers: document.querySelectorAll('[class*="markdown"]').length
                };
            }''')
            logger.info(f"ãƒšãƒ¼ã‚¸æ§‹é€ : {page_structure}")
            
            return None
                    
        except Exception as e:
            logger.error(f"âŒ æŠ½å‡ºå…¨ä½“ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
        
    def _validate_code_block_completeness_enhanced(self, text: str) -> Dict:
        """
        ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®å®Œå…¨æ€§ã‚’æ¤œè¨¼(ç·©å’Œç‰ˆ - å°‚é–€æ–‡æ›¸ãƒ»é•·æ–‡å¯¾å¿œå¼·åŒ–)
            
        Returns:
            Dict: {
                'is_complete': bool,
                'reason': str,
                'details': str,
                'incomplete_blocks': List[Dict]
            }
        """
        try:
            # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯(```)ã®ãƒšã‚¢ãƒã‚§ãƒƒã‚¯(ä¸»è¦ãƒã‚§ãƒƒã‚¯)
            code_fence_pattern = r'```(\w+)?\n(.*?)```'
            code_blocks = re.findall(code_fence_pattern, text, re.DOTALL)
                
            # é–‹å§‹ã‚¿ã‚°ã®ã¿ã§çµ‚äº†ã‚¿ã‚°ãŒãªã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
            open_fences = re.findall(r'```(\w+)?(?![\s\S]*?```)', text, re.DOTALL)
                
            if open_fences:
                # é–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œå‡º
                incomplete_blocks = []
                for lang in open_fences:
                    # è©²å½“ç®‡æ‰€ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’å–å¾—
                    pattern = f'```{lang}' if lang else '```'
                    idx = text.find(pattern)
                    snippet = text[idx:idx+100] + '...' if idx != -1 else 'N/A'
                        
                    incomplete_blocks.append({
                        'type': f'code({lang})' if lang else 'code(unknown)',
                        'snippet': snippet
                    })
                    
                return {
                    'is_complete': False,
                    'reason': 'ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“',
                    'details': f'{len(open_fences)}å€‹ã®æœªé–‰ã˜ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œå‡º',
                    'incomplete_blocks': incomplete_blocks
                }
                
            # PHPã‚³ãƒ¼ãƒ‰ã®å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
            if '<?php' in text:
                php_blocks = re.findall(r'```php\n(.*?)```', text, re.DOTALL)
                for php_code in php_blocks:
                    # é–¢æ•°å®šç¾©ã®é–‹å§‹ã¨çµ‚äº†ã®æ³¢æ‹¬å¼§ã®æ•°ã‚’ãƒã‚§ãƒƒã‚¯
                    open_braces = php_code.count('{')
                    close_braces = php_code.count('}')
                        
                    if open_braces > close_braces:
                        # æœ€å¾Œã®10è¡Œã‚’å–å¾—
                        last_lines = '\n'.join(php_code.split('\n')[-10:])
                            
                        return {
                            'is_complete': False,
                            'reason': 'PHPã‚³ãƒ¼ãƒ‰ã®æ³¢æ‹¬å¼§ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“',
                            'details': f'é–‹å§‹: {open_braces}, çµ‚äº†: {close_braces}',
                            'incomplete_blocks': [{
                                'type': 'php',
                                'snippet': f'...æœ€å¾Œã®10è¡Œ:\n{last_lines}'
                            }]
                        }
                
            # JSONã‚³ãƒ¼ãƒ‰ã®å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
            json_blocks = re.findall(r'```json\n(.*?)```', text, re.DOTALL)
            for json_code in json_blocks:
                try:
                    json.loads(json_code)
                except json.JSONDecodeError as e:
                    return {
                        'is_complete': False,
                        'reason': 'JSONã‚³ãƒ¼ãƒ‰ãŒä¸æ­£ã§ã™',
                        'details': f'JSONã‚¨ãƒ©ãƒ¼: {str(e)}',
                        'incomplete_blocks': [{
                            'type': 'json',
                            'snippet': json_code[-200:] if len(json_code) > 200 else json_code
                        }]
                    }
                
            # ========================================
            # ğŸ”§ Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ã®æ¤œè¨¼ï¼ˆæ–°è¦è¿½åŠ ï¼‰
            # ========================================
            if 'from pydantic import' in text or 'class ' in text and 'BaseModel' in text:
                # Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ã®ã‚¯ãƒ©ã‚¹æ§‹é€ ãƒã‚§ãƒƒã‚¯
                pydantic_class_pattern = r'class\s+(\w+)\(BaseModel\):(.*?)(?=\nclass\s|\Z)'
                pydantic_classes = re.findall(pydantic_class_pattern, text, re.DOTALL)
                    
                for class_name, class_body in pydantic_classes:
                    # ã‚¯ãƒ©ã‚¹æœ¬ä½“ãŒç©ºã§ãªã„ã‹ç¢ºèª
                    if not class_body.strip():
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticãƒ¢ãƒ‡ãƒ« {class_name} ã®å®šç¾©ãŒç©ºã§ã™',
                            'details': 'ã‚¯ãƒ©ã‚¹æœ¬ä½“ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ãŒå¿…è¦',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': f'class {class_name}(BaseModel): ...'
                            }]
                        }
                        
                    # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ãŒå°‘ãªãã¨ã‚‚1ã¤ã‚ã‚‹ã‹ç¢ºèª
                    field_pattern = r'^\s+\w+:\s*\w+'
                    if not re.search(field_pattern, class_body, re.MULTILINE):
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticãƒ¢ãƒ‡ãƒ« {class_name} ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ãŒã‚ã‚Šã¾ã›ã‚“',
                            'details': 'ãƒ¢ãƒ‡ãƒ«ã«ã¯å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¿…è¦',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': class_body[:200]
                            }]
                        }
                
            # ========================================
            # ğŸ”§ OpenAPIã‚¹ã‚­ãƒ¼ãƒã®æ¤œè¨¼ï¼ˆæ–°è¦è¿½åŠ ï¼‰
            # ========================================
            if 'openapi:' in text.lower() or '"openapi"' in text.lower():
                # OpenAPI/Swaggerã‚¹ã‚­ãƒ¼ãƒã®åŸºæœ¬æ§‹é€ ã‚’ãƒã‚§ãƒƒã‚¯
                required_openapi_keys = ['openapi', 'info', 'paths']
                    
                # YAMLã¾ãŸã¯JSONå½¢å¼ã®æ¤œå‡º
                if 'openapi:' in text:
                    # YAMLå½¢å¼ã®æ¤œè¨¼
                    for key in required_openapi_keys:
                        if f'{key}:' not in text:
                            return {
                                'is_complete': False,
                                'reason': f'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«å¿…é ˆã‚­ãƒ¼ "{key}" ãŒã‚ã‚Šã¾ã›ã‚“',
                                'details': 'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«ã¯ openapi, info, paths ãŒå¿…è¦',
                                'incomplete_blocks': [{
                                    'type': 'openapi_yaml',
                                    'snippet': text[:300]
                                }]
                            }
                else:
                    # JSONå½¢å¼ã®æ¤œè¨¼
                    try:
                        # JSONæŠ½å‡ºè©¦è¡Œ
                        json_match = re.search(r'\{.*\}', text, re.DOTALL)
                        if json_match:
                            openapi_json = json.loads(json_match.group(0))
                            for key in required_openapi_keys:
                                if key not in openapi_json:
                                    return {
                                        'is_complete': False,
                                        'reason': f'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«å¿…é ˆã‚­ãƒ¼ "{key}" ãŒã‚ã‚Šã¾ã›ã‚“',
                                        'details': 'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«ã¯ openapi, info, paths ãŒå¿…è¦',
                                        'incomplete_blocks': [{
                                            'type': 'openapi_json',
                                            'snippet': json_match.group(0)[:300]
                                        }]
                                    }
                    except (json.JSONDecodeError, AttributeError):
                        pass  # JSONå½¢å¼ã§ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                
            # ========================================
            # ğŸ”§ æ–‡ç« ã®çªç„¶ã®çµ‚äº†ãƒã‚§ãƒƒã‚¯ã‚’å¤§å¹…ç·©å’Œï¼ˆå°‚é–€æ–‡æ›¸å¯¾å¿œï¼‰
            # ========================================
            text_stripped = text.strip()
            if text_stripped:
                last_char = text_stripped[-1]
                    
                # å°‚é–€æ–‡æ›¸ã‚„æŠ€è¡“æ–‡æ›¸ã®çµ‚äº†ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ‹¡å¼µ
                japanese_section_endings = [
                    'é …', 'ç« ', 'ç›®', 'ç¯€', 'æ¡', 'æ¬¾', 'ç‚¹',  # æ—¢å­˜
                    'ã€‚', 'ï¼‰', ')', '}', ']', '`', '>', '"',  # æ–°è¦è¿½åŠ 
                    'äº†', 'æˆ', 'å®š', 'æ˜', 'ç¤º', 'ç”¨', 'ç†'   # å°‚é–€ç”¨èªæœ«å°¾
                ]
                    
                # å³æ ¼ãªçµ‚äº†æ–‡å­—ãƒªã‚¹ãƒˆï¼ˆã“ã‚Œã‚‰ã§çµ‚ã‚ã‚Œã°OKï¼‰
                strict_end_chars = ['.', 'ã€‚', '!', '!', '?', '?', '`', '}', ']', ')']
                    
                if (last_char not in strict_end_chars and 
                    last_char not in japanese_section_endings and
                    not text_stripped.endswith('```')):
                        
                    # ========================================
                    # ğŸ”§ é•·æ–‡ãƒ»å°‚é–€æ–‡æ›¸ã®å ´åˆã¯å¤§å¹…ã«ç·©å’Œï¼ˆæ–°ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                    # ========================================
                        
                    # æ¡ä»¶1: 3000æ–‡å­—ä»¥ä¸Šã®è¶…é•·æ–‡ã¯çµ‚äº†æ–‡å­—ã‚’ãƒã‚§ãƒƒã‚¯ã—ãªã„
                    if len(text_stripped) > 3000:
                        logger.info(f"âœ… è¶…é•·æ–‡({len(text_stripped)}æ–‡å­—)ã®ãŸã‚çµ‚äº†æ–‡å­—ãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—")
                        return {
                            'is_complete': True,
                            'reason': 'è¶…é•·æ–‡ã®ãŸã‚çµ‚äº†æ–‡å­—ãƒã‚§ãƒƒã‚¯ã‚’å…é™¤',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}, æœ€å¾Œã®æ–‡å­—: {last_char}'
                        }
                        
                    # æ¡ä»¶2: 2000æ–‡å­—ä»¥ä¸Šã§ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒ3å€‹ä»¥ä¸Šã‚ã‚‹å ´åˆã¯è¨±å®¹
                    if len(text_stripped) > 2000 and len(code_blocks) >= 3:
                        logger.info(f"âœ… é•·æ–‡({len(text_stripped)}æ–‡å­—)ã‹ã¤ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯{len(code_blocks)}å€‹ã®ãŸã‚è¨±å®¹")
                        return {
                            'is_complete': True,
                            'reason': 'é•·æ–‡ã‹ã¤å¤šæ•°ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å«ã‚€ãŸã‚è¨±å®¹',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}, ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æ•°: {len(code_blocks)}'
                        }
                        
                    # æ¡ä»¶3: Pydanticãƒ¢ãƒ‡ãƒ«ã‚„ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‚’å«ã‚€å ´åˆã¯è¨±å®¹
                    if ('from pydantic import' in text or 
                        'class ' in text and 'BaseModel' in text or
                        'openapi:' in text.lower()):
                        logger.info("âœ… å°‚é–€çš„ãªæŠ€è¡“æ–‡æ›¸(Pydantic/OpenAPI)ã®ãŸã‚è¨±å®¹")
                        return {
                            'is_complete': True,
                            'reason': 'å°‚é–€çš„ãªæŠ€è¡“æ–‡æ›¸ã¨ã—ã¦è¨±å®¹',
                            'details': 'Pydanticãƒ¢ãƒ‡ãƒ«ã¾ãŸã¯ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‚’å«ã‚€'
                        }
                        
                    # æ¡ä»¶4: 1500æ–‡å­—ä»¥ä¸Šã§ã€Œã¾ã¨ã‚ã€ã€Œçµè«–ã€ã€Œä»¥ä¸Šã€ãªã©ã®ç· ã‚ããã‚Šè¡¨ç¾ãŒã‚ã‚‹å ´åˆ
                    conclusion_patterns = [
                        'ã¾ã¨ã‚', 'çµè«–', 'ä»¥ä¸Š', 'å®Œäº†', 'çµ‚ã‚ã‚Š',
                        'summary', 'conclusion', 'end', 'complete'
                    ]
                    if len(text_stripped) > 1500 and any(pattern in text_stripped[-500:].lower() for pattern in conclusion_patterns):
                        logger.info("âœ… é•·æ–‡ã§ç· ã‚ããã‚Šè¡¨ç¾ã‚’å«ã‚€ãŸã‚è¨±å®¹")
                        return {
                            'is_complete': True,
                            'reason': 'é•·æ–‡ã§ç· ã‚ããã‚Šè¡¨ç¾ã‚’å«ã‚€',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}'
                        }
                        
                    # ä¸Šè¨˜æ¡ä»¶ã«è©²å½“ã—ãªã„çŸ­æ–‡ã¯ä¸å®Œå…¨ã¨åˆ¤å®š
                    if len(text_stripped) < 1500:
                        last_50_chars = text_stripped[-50:]
                            
                        return {
                            'is_complete': False,
                            'reason': 'æ–‡ç« ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
                            'details': f'æœ€å¾Œã®æ–‡å­—: "{last_char}"',
                            'incomplete_blocks': [{
                                'type': 'text',
                                'snippet': f'...æœ€å¾Œã®50æ–‡å­—: {last_50_chars}'
                            }]
                        }
                    else:
                        # 1500æ–‡å­—ä»¥ä¸Šã ãŒæ¡ä»¶ã«è©²å½“ã—ãªã„å ´åˆã¯è­¦å‘Šã®ã¿ã§è¨±å®¹
                        logger.warning(f"âš ï¸ é•·æ–‡({len(text_stripped)}æ–‡å­—)ã ãŒçµ‚äº†æ–‡å­—ãŒä¸æ˜ç­: '{last_char}'")
                        return {
                            'is_complete': True,
                            'reason': 'é•·æ–‡ã®ãŸã‚è­¦å‘Šä»˜ãã§è¨±å®¹',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}, æœ€å¾Œã®æ–‡å­—: {last_char}'
                        }
                
            # ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ã‚’ãƒ‘ã‚¹
            return {
                'is_complete': True,
                'reason': 'ã™ã¹ã¦ã®æ¤œè¨¼ã«åˆæ ¼',
                'details': f'ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æ•°: {len(code_blocks)}'
            }
                
        except Exception as e:
            logger.error(f"ã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨å´ã«å€’ã—ã¦ä¸å®Œå…¨ã¨ã¿ãªã™
            return {
                'is_complete': False,
                'reason': 'æ¤œè¨¼å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ',
                'details': str(e),
                'incomplete_blocks': []
            }
    
    async def extract_latest_text_response_deepseek(self) -> str:
        """DeepSeekã®æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆæ”¹è‰¯ç‰ˆï¼‰"""
        try:
            logger.info("=" * 60)
            logger.info("â˜…â˜…â˜… DeepSeekãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºé–‹å§‹ â˜…â˜…â˜…")
            logger.info("=" * 60)
            
            # DeepSeekç‰¹æœ‰ã®ã‚»ãƒ¬ã‚¯ã‚¿ã§å¿œç­”ã‚’å–å¾—
            response_text = await self.page.evaluate('''() => {
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒŠã‚’æ¢ã™
                const messages = document.querySelectorAll('[class*="message"], [class*="chat"], div[role="article"]');
                let longest = '';
                
                for (const msg of messages) {
                    const text = msg.innerText || '';
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é™¤å¤–
                    if (text.length > 100 && text.length > longest.length) {
                        // ã‚·ã‚¹ãƒ†ãƒ ã‚„ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿
                        const isUserMessage = msg.querySelector('[class*="user"]') || 
                                            msg.classList.toString().includes('user');
                        if (!isUserMessage) {
                            longest = text;
                        }
                    }
                }
                
                if (!longest) {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å¾Œã®é•·ã„divã‚’å–å¾—
                    const divs = document.querySelectorAll('div');
                    for (const d of divs) {
                        const t = d.innerText || '';
                        if (t.length > longest.length && t.length > 200) {
                            longest = t;
                        }
                    }
                }
                
                return longest;
            }''')
            
            if response_text and len(response_text) > 50:
                logger.info(f"âœ… DeepSeekå¿œç­”æŠ½å‡ºæˆåŠŸ: {len(response_text)}æ–‡å­—")
                logger.info(f"å…ˆé ­500æ–‡å­—:\n{response_text[:500]}")
                
                # æ¤œè¨¼ã‚’å®Ÿè¡Œï¼ˆç·©å’Œç‰ˆï¼‰
                validation_result = self._validate_code_block_completeness_enhanced(response_text)
                
                if not validation_result['is_complete'] and len(response_text) > 1500:
                    logger.warning(f"âš ï¸ DeepSeekå¿œç­”ä¸å®Œå…¨ã ãŒé•·æ–‡ã®ãŸã‚æ¡ç”¨: {validation_result['reason']}")
                    # é•·æ–‡ã®å ´åˆã¯ä¸å®Œå…¨ã§ã‚‚æ¡ç”¨
                    return response_text.strip()
                elif validation_result['is_complete']:
                    logger.info("âœ… DeepSeekå¿œç­”æ¤œè¨¼åˆæ ¼")
                    return response_text.strip()
                else:
                    logger.warning(f"âš ï¸ DeepSeekå¿œç­”ä¸å®Œå…¨: {validation_result['reason']}")
                    return response_text.strip()  # ä¸å®Œå…¨ã§ã‚‚è¿”ã™ï¼ˆä»¥å‰ã¯Noneã‚’è¿”ã—ã¦ã„ãŸï¼‰
            else:
                logger.error("âŒ DeepSeekå¿œç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
                
        except Exception as e:
            logger.error(f"âŒ DeepSeekæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    # === æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤‰æ›´ãªã—ï¼ˆextract_json_from_text ãªã©ï¼‰ ===

    # æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã§ç½®ãæ›ãˆã‚‹ãŸã‚ã®äº’æ›æ€§ãƒ¬ã‚¤ãƒ¤ãƒ¼
    def _validate_code_block_completeness(self, text: str) -> Dict:
        """
        æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¡ã‚½ãƒƒãƒ‰ - æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
        ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ç¶­æŒã®ãŸã‚ï¼‰
        """
        return self._validate_code_block_completeness_enhanced(text)

    def extract_json_from_text(self, text: str) -> str:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰JSONéƒ¨åˆ†ã‚’æŠ½å‡º"""
        try:
            if not text:
                return None
                
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json ... ``` ã«å›²ã¾ã‚ŒãŸJSON
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡º
            json_match = re.search(r'^\s*(\{.*\})\s*$', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³3: å…ˆé ­ã‹ã‚‰JSONã‚’æ¢ã™
            start_idx = text.find('{')
            if start_idx != -1:
                # { ã‹ã‚‰å§‹ã‚ã¦ã€å¯¾å¿œã™ã‚‹ } ã¾ã§ã‚’æ¢ã™
                brace_count = 0
                for i, char in enumerate(text[start_idx:]):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            potential_json = text[start_idx:start_idx+i+1]
                            try:
                                json.loads(potential_json)
                                return potential_json.strip()
                            except:
                                continue
            return None
        except Exception as e:
            logger.error(f"JSONæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
        
    

#browser_controller.py
# browser_controller.py
"""ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ã‚¯ãƒ©ã‚¹ï¼ˆåˆ†å‰²ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ç‰ˆï¼‰"""
import asyncio
from pathlib import Path
from typing import Optional, Dict
import logging

from browser_lifecycle import BrowserLifecycleManager
from brower_cookie_and_session import CookieSessionManager  # ãƒ•ã‚¡ã‚¤ãƒ«åä¿®æ­£
from browser_ai_chat_agent import AIChatAgent
from browser_wp_session_manager import WPSessionManager
from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserController:
    """ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, download_folder: Path, mode: str = "image", service: str = "google", credentials: Dict = None):
        self.download_folder = download_folder
        self.mode = mode
        self.service = service.lower()
        self.credentials = credentials or {}
        
        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        self.cookies_file = Path(config.COOKIES_FILE) if config.COOKIES_FILE else None
        self.browser_data_dir = Path(config.BROWSER_DATA_DIR) if config.BROWSER_DATA_DIR else None
        self.wp_cookies_file = Path(config.BROWSER_DATA_DIR) / "wp_cookies.json" if config.BROWSER_DATA_DIR else None
        
        # ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–ï¼ˆsetup_browserã§å®Œå…¨åˆæœŸåŒ–ï¼‰
        self.lifecycle_manager: Optional[BrowserLifecycleManager] = None
        self.session_manager: Optional[CookieSessionManager] = None
        self.ai_agent: Optional[AIChatAgent] = None
        self.wp_manager: Optional[WPSessionManager] = None
    
    async def setup_browser(self) -> None:
        """ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— - ã™ã¹ã¦ã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–"""
        try:
            # ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–ã¨ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            self.lifecycle_manager = BrowserLifecycleManager(
                browser_data_dir=self.browser_data_dir,
                download_folder=self.download_folder
            )
            await self.lifecycle_manager.setup_browser()
            
            # ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
            self.session_manager = CookieSessionManager(
                context=self.lifecycle_manager.context,
                cookies_file=self.cookies_file
            )
            
            # AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
            self.ai_agent = AIChatAgent(
                page=self.lifecycle_manager.page,
                service=self.service,
                credentials=self.credentials
            )
            
            # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
            self.wp_manager = WPSessionManager(
                context=self.lifecycle_manager.context,
                wp_cookies_file=self.wp_cookies_file
            )
            
            logger.info(f"âœ… ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰åˆæœŸåŒ–å®Œäº†ï¼ˆã‚µãƒ¼ãƒ“ã‚¹: {self.service}ï¼‰")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—")
            raise
    
    # ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å§”è­²
    @property
    def context(self):
        return self.lifecycle_manager.context if self.lifecycle_manager else None
    
    @property
    def page(self):
        return self.lifecycle_manager.page if self.lifecycle_manager else None
    
    @property
    def wp_page(self):
        return self.wp_manager.wp_page if self.wp_manager else None
    
    @property
    def is_logged_in(self):
        return self.wp_manager.is_logged_in if self.wp_manager else False
    
    # AIãƒãƒ£ãƒƒãƒˆé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ã®å§”è­²
    async def navigate_to_gemini(self) -> None:
        """Geminiã«ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.navigate_to_gemini()
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekã«ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.navigate_to_deepseek()
    
    async def send_prompt(self, prompt: str) -> None:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.send_prompt(prompt)
    
    async def wait_for_text_generation(self, max_wait: int = 180) -> bool:
        """
        ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã‚’å¾…æ©Ÿï¼ˆå¼·åŒ–ç‰ˆï¼‰
            
        Args:
            max_wait: æœ€å¤§å¾…æ©Ÿæ™‚é–“ï¼ˆç§’ï¼‰
                
        Returns:
            bool: ç”Ÿæˆå®Œäº†ãƒ•ãƒ©ã‚°
        """
        try:
            logger.info(f"â±ï¸ ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå¾…æ©Ÿé–‹å§‹ï¼ˆæœ€å¤§{max_wait}ç§’ï¼‰")
                
            start_time = asyncio.get_event_loop().time()
            check_interval = 2.0  # 2ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
            last_length = 0
            stable_count = 0
            required_stable = 3  # 3å›é€£ç¶šã§å¤‰åŒ–ãªã—ã§å®Œäº†ã¨åˆ¤å®š
                
            while True:
                elapsed = asyncio.get_event_loop().time() - start_time
                    
                if elapsed > max_wait:
                    logger.warning(f"â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
                    return False
                    
                # ç¾åœ¨ã®ãƒ†ã‚­ã‚¹ãƒˆé•·ã‚’å–å¾—
                try:
                    current_text = await self._get_current_text_quick()
                    current_length = len(current_text)
                        
                    # ãƒ†ã‚­ã‚¹ãƒˆãŒå¢—ãˆã¦ã„ã‚‹ã‹ç¢ºèª
                    if current_length > last_length:
                        logger.info(f"ğŸ“ ç”Ÿæˆä¸­: {current_length}æ–‡å­—ï¼ˆçµŒé: {int(elapsed)}ç§’ï¼‰")
                        last_length = current_length
                        stable_count = 0
                    else:
                        # é•·ã•ãŒå¤‰ã‚ã‚‰ãªã„
                        stable_count += 1
                        logger.info(f"â¸ï¸ å®‰å®š: {stable_count}/{required_stable}ï¼ˆ{current_length}æ–‡å­—ï¼‰")
                            
                        if stable_count >= required_stable:
                            logger.info(f"âœ… ç”Ÿæˆå®Œäº†ï¼ˆ{current_length}æ–‡å­—ã€{int(elapsed)}ç§’ï¼‰")
                            return True
                    
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
                    
                # å¾…æ©Ÿ
                await asyncio.sleep(check_interval)
            
        except Exception as e:
            logger.error(f"âŒ å¾…æ©Ÿã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def extract_latest_text_response(self, allow_partial: bool = True) -> Optional[str]:
        """
        æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆå¼·åŒ–ç‰ˆï¼‰
        
        Args:
            allow_partial: éƒ¨åˆ†çš„ãªå¿œç­”ã‚‚è¨±å¯ã™ã‚‹ã‹
            
        Returns:
            Optional[str]: æŠ½å‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ
        """
        try:
            logger.info("="*60)
            logger.info("â˜…â˜…â˜… Geminiå¿œç­”æŠ½å‡ºé–‹å§‹ï¼ˆå¼·åŒ–ç‰ˆï¼‰ â˜…â˜…â˜…")
            logger.info("="*60)
            
            results = {}
            
            # ============================================================
            # === æ–¹æ³•1: model-response-text ã‚¯ãƒ©ã‚¹ ===
            # ============================================================
            try:
                message_divs = await self.page.query_selector_all('div.model-response-text')
                if message_divs:
                    last_message = message_divs[-1]
                    text1 = await last_message.inner_text()
                    if text1 and len(text1) > 100:
                        results['method1'] = text1
                        logger.info(f"âœ… æ–¹æ³•1æˆåŠŸ: {len(text1)}æ–‡å­—")
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•1å¤±æ•—: {e}")
            
            # ============================================================
            # === æ–¹æ³•2: markdown-container ã‚¯ãƒ©ã‚¹ ===
            # ============================================================
            try:
                markdown_divs = await self.page.query_selector_all('div.markdown-container')
                if markdown_divs:
                    last_markdown = markdown_divs[-1]
                    text2 = await last_markdown.inner_text()
                    if text2 and len(text2) > 100:
                        results['method2'] = text2
                        logger.info(f"âœ… æ–¹æ³•2æˆåŠŸ: {len(text2)}æ–‡å­—")
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•2å¤±æ•—: {e}")
            
            # ============================================================
            # === æ–¹æ³•3: message-content ã‚¯ãƒ©ã‚¹ ===
            # ============================================================
            try:
                content_divs = await self.page.query_selector_all('div.message-content')
                if content_divs:
                    # æœ€å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
                    for div in reversed(content_divs):
                        text3 = await div.inner_text()
                        if text3 and len(text3) > 100 and 'model-response' not in text3.lower():
                            results['method3'] = text3
                            logger.info(f"âœ… æ–¹æ³•3æˆåŠŸ: {len(text3)}æ–‡å­—")
                            break
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•3å¤±æ•—: {e}")
            
            # ============================================================
            # === æ–¹æ³•4: data-test-id å±æ€§ ===
            # ============================================================
            try:
                test_divs = await self.page.query_selector_all('[data-test-id*="conversation-turn"]')
                if test_divs:
                    last_turn = test_divs[-1]
                    text4 = await last_turn.inner_text()
                    if text4 and len(text4) > 100:
                        results['method4'] = text4
                        logger.info(f"âœ… æ–¹æ³•4æˆåŠŸ: {len(text4)}æ–‡å­—")
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•4å¤±æ•—: {e}")
            
            # ============================================================
            # === çµæœé¸æŠï¼ˆæœ€é•·ã®ã‚‚ã®ã‚’é¸æŠï¼‰ ===
            # ============================================================
            if not results:
                logger.error("âŒ å…¨æ–¹æ³•å¤±æ•— - å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
                
                # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
                try:
                    page_content = await self.page.content()
                    logger.info(f"ğŸ“„ ãƒšãƒ¼ã‚¸é•·: {len(page_content)}æ–‡å­—")
                except:
                    pass
                
                return None
            
            # æœ€ã‚‚é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠ
            best_method = max(results.items(), key=lambda x: len(x[1]))
            selected_text = best_method[1]
            
            logger.info(f"âœ… æœ€é©çµæœé¸æŠ: {best_method[0]} ({len(selected_text)}æ–‡å­—)")
            
            # ============================================================
            # === å“è³ªãƒã‚§ãƒƒã‚¯ï¼ˆç·©å’Œç‰ˆï¼‰ ===
            # ============================================================
            warnings = []
            
            # é•·ã•ãƒã‚§ãƒƒã‚¯
            if len(selected_text) < 500:
                warnings.append(f'çŸ­ã„å¿œç­”ï¼ˆ{len(selected_text)}æ–‡å­—ï¼‰')
            
            # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯ï¼ˆç·©å’Œï¼‰
            if allow_partial:
                # éƒ¨åˆ†çš„ãªã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚‚è¨±å¯
                if '```' in selected_text:
                    open_count = selected_text.count('```')
                    if open_count % 2 != 0:
                        warnings.append('ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æœªå®Œçµï¼ˆè¨±å¯ï¼‰')
            else:
                # å³å¯†ãªãƒã‚§ãƒƒã‚¯
                open_blocks = selected_text.count('```')
                if open_blocks % 2 != 0:
                    warnings.append('ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æœªå®Œçµ')
            
            # è­¦å‘Šè¡¨ç¤º
            if warnings:
                logger.warning("âš ï¸ å“è³ªè­¦å‘Š:")
                for w in warnings:
                    logger.warning(f"  - {w}")
            
            # éƒ¨åˆ†å¿œç­”ã‚‚è¨±å¯ã™ã‚‹å ´åˆã¯ã€è­¦å‘ŠãŒã‚ã£ã¦ã‚‚è¿”ã™
            if allow_partial:
                logger.info("âœ… éƒ¨åˆ†å¿œç­”ã‚’è¨±å¯ - ãã®ã¾ã¾è¿”å´")
                return selected_text
            
            # å³å¯†ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€é‡å¤§ãªå•é¡ŒãŒã‚ã‚Œã°None
            if len(selected_text) < 100:
                logger.error("âŒ å¿œç­”ãŒçŸ­ã™ãã‚‹ï¼ˆ100æ–‡å­—æœªæº€ï¼‰")
                return None
            
            logger.info("="*60)
            logger.info(f"âœ… å¿œç­”æŠ½å‡ºå®Œäº†: {len(selected_text)}æ–‡å­—")
            logger.info("="*60)
            
            return selected_text
        
        except Exception as e:
            logger.error(f"âŒ å¿œç­”æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¾…æ©Ÿ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.ai_agent.send_prompt_and_wait(prompt, max_wait)
    
    # ã‚¯ãƒƒã‚­ãƒ¼ç®¡ç†ã®å§”è­²
    async def save_cookies(self) -> None:
        """ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ - ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.session_manager:
            raise Exception("ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.session_manager.save_cookies()
    
    async def load_cookies(self) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ - ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.session_manager:
            logger.warning("ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        return await self.session_manager.load_cookies()
    
    # WordPressé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ã®å§”è­²
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ– - WPãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.wp_manager:
            raise Exception("WordPressãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.wp_manager.initialize_wp_session(auth_module)
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ - WPãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.wp_manager:
            raise Exception("WordPressãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.wp_manager.save_wordpress_cookies(wp_url)
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ - WPãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.wp_manager:
            raise Exception("WordPressãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.wp_manager.load_wordpress_cookies(wp_url)
    
    # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã®å§”è­²
    async def cleanup(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— - ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã‚‹
        if self.wp_manager:
            await self.wp_manager.close_wp_session()
        
        # ãƒ¡ã‚¤ãƒ³ã®ãƒ–ãƒ©ã‚¦ã‚¶ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if self.lifecycle_manager:
            await self.lifecycle_manager.cleanup()
    
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
    async def save_text_to_file(self, text: str, filename: str) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ - ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¨ã—ã¦ç¶­æŒ"""
        try:
            save_path = self.download_folder / filename
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(text)
            if save_path.exists():
                file_size = save_path.stat().st_size
                logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                return True
            else:
                logger.error(f"âŒ ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜å¤±æ•—: {filename}")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜")
            return False
    
    # å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰
    async def _is_browser_alive(self) -> bool:
        """ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèª - ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.lifecycle_manager:
            return False
        return await self.lifecycle_manager._is_browser_alive()
    
    async def handle_welcome_screens(self) -> None:
        """ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢å‡¦ç† - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.handle_welcome_screens()
    
    async def ensure_normal_chat_mode(self) -> None:
        """é€šå¸¸ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ç¢ºèª - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.ensure_normal_chat_mode()
    
    # éæ¨å¥¨ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰
    async def _wait_for_generation_complete(self, max_wait: int = 120) -> bool:
        """éæ¨å¥¨ãƒ¡ã‚½ãƒƒãƒ‰ - å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ç¶­æŒ"""
        logger.warning("âš ï¸ éæ¨å¥¨ãƒ¡ã‚½ãƒƒãƒ‰ _wait_for_generation_complete ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ")
        return await self.wait_for_text_generation(max_wait)
    
async def ensure_browser_ready(self) -> bool:
    """
    ãƒ–ãƒ©ã‚¦ã‚¶ã®æº–å‚™å®Œäº†ã‚’ç¢ºèªï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†å¼·åŒ–ç‰ˆï¼‰
        
    Returns:
        bool: æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°
    """
    try:
        # ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹ç¢ºèª
        if not self.browser:
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ã—ã¦ã„ã¾ã›ã‚“")
            return False
            
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæœ‰åŠ¹ã‹ç¢ºèª
        if not self.context:
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Šã¾ã›ã‚“")
            return False
            
        # ãƒšãƒ¼ã‚¸ãŒæœ‰åŠ¹ã‹ç¢ºèª
        if not self.page:
            logger.error("âŒ ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“")
            return False
            
        # ãƒšãƒ¼ã‚¸ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ã‹ç¢ºèª
        try:
            is_closed = self.page.is_closed()
            if is_closed:
                logger.error("âŒ ãƒšãƒ¼ã‚¸ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã™ - å†ä½œæˆ")
                self.page = await self.context.new_page()
                await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
                await asyncio.sleep(3)
                logger.info("âœ… ãƒšãƒ¼ã‚¸ã‚’å†ä½œæˆã—ã¾ã—ãŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒšãƒ¼ã‚¸çŠ¶æ…‹ç¢ºèªã‚¨ãƒ©ãƒ¼: {e}")
            
        # Geminiãƒšãƒ¼ã‚¸ã«ã„ã‚‹ã‹ç¢ºèª
        current_url = self.page.url
        if 'gemini.google.com' not in current_url:
            logger.warning(f"âš ï¸ Geminiãƒšãƒ¼ã‚¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: {current_url}")
            logger.info("ğŸ”„ Geminiãƒšãƒ¼ã‚¸ã«ç§»å‹•ä¸­...")
            await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
            await asyncio.sleep(3)
            
        logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶æº–å‚™å®Œäº†")
        return True
        
    except Exception as e:
        logger.error(f"âŒ ãƒ–ãƒ©ã‚¦ã‚¶æº–å‚™ç¢ºèªã‚¨ãƒ©ãƒ¼: {e}")
        return False
    
async def send_prompt(self, prompt: str) -> bool:
    """
    ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ä»˜ãï¼‰
        
    Args:
        prompt: é€ä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            
    Returns:
        bool: é€ä¿¡æˆåŠŸãƒ•ãƒ©ã‚°
    """
    try:
        # ãƒ–ãƒ©ã‚¦ã‚¶æº–å‚™ç¢ºèª
        if not await self.ensure_browser_ready():
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒæº–å‚™ã§ãã¦ã„ã¾ã›ã‚“")
            return False
            
        logger.info("ğŸ“¤ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ä¸­...")
            
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›æ¬„ã‚’æ¢ã™
        input_selectors = [
            'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'textarea[aria-label*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'div[contenteditable="true"]',
            'textarea.ql-editor',
            'div.ql-editor'
        ]
            
        input_box = None
        for selector in input_selectors:
            try:
                input_box = await self.page.wait_for_selector(selector, timeout=5000)
                if input_box:
                    break
            except:
                continue
            
        if not input_box:
            logger.error("âŒ å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return False
            
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›
        await input_box.click()
        await asyncio.sleep(0.5)
        await input_box.fill(prompt)
        await asyncio.sleep(1)
            
        # é€ä¿¡ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
        send_button = await self.page.query_selector('button[aria-label*="é€ä¿¡"]')
        if send_button:
            await send_button.click()
            logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å®Œäº†")
            return True
        else:
            # Enterã‚­ãƒ¼ã§é€ä¿¡
            await self.page.keyboard.press('Enter')
            logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å®Œäº†ï¼ˆEnterï¼‰")
            return True
        
    except Exception as e:
        logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
        return False
    

#browser_lifecycle.py
# browser_lifecycle.py
"""ãƒ–ãƒ©ã‚¦ã‚¶ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹"""
import asyncio
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import async_playwright, Page, BrowserContext
import logging
import psutil

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserLifecycleManager:
    """ãƒ–ãƒ©ã‚¦ã‚¶ã®èµ·å‹•ãƒ»çµ‚äº†ãƒ»ç”Ÿå­˜ç®¡ç†ã‚’æ‹…å½“"""
    
    def __init__(self, browser_data_dir: Path, download_folder: Path):
        self.browser_data_dir = browser_data_dir
        self.download_folder = download_folder
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.playwright = None
        
        self.download_folder.mkdir(exist_ok=True, parents=True)
        if self.browser_data_dir:
            self.browser_data_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup_browser(self) -> None:
        """ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ï¼ˆãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œç‰ˆï¼‰"""
        try:
            logger.info("="*60)
            logger.info("ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•é–‹å§‹...")
            logger.info("="*60)
            
            # æ—¢å­˜ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            await self._cleanup_existing_browser_processes()
            
            self.playwright = await async_playwright().start()
            logger.info(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.browser_data_dir}")
            
            # ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œ: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’æŒ‡å®š
            window_width = 1280
            window_height = 700
            x_position = 0
            y_position = 0
            
            # ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ï¼ˆä½ç½®ã¨ã‚µã‚¤ã‚ºæŒ‡å®šï¼‰
            self.context = await self.playwright.chromium.launch_persistent_context(
                user_data_dir=str(self.browser_data_dir),
                viewport={'width': window_width, 'height': window_height},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                accept_downloads=True,
                ignore_https_errors=True,
                no_viewport=False,
                **config.BROWSER_CONFIG
            )
            
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½œæˆæˆåŠŸ")
            
            # ãƒšãƒ¼ã‚¸ä½œæˆ
            self.page = await self.context.new_page()
            
            # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æŒ‡å®šä½ç½®ã«ç§»å‹•
            await self.page.evaluate(f"""
                window.moveTo({x_position}, {y_position});
                window.resizeTo({window_width}, {window_height});
            """)
            
            logger.info(f"âœ… ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½ç½® ({x_position}, {y_position}) ã«é…ç½®")
            
            # ãƒ–ãƒ©ã‚¦ã‚¶ãŒæ­£å¸¸ã«èµ·å‹•ã—ãŸã‹ç¢ºèª
            await asyncio.sleep(2)
            if not await self._is_browser_alive():
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ç›´å¾Œã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ")
            
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèªå®Œäº†")
            
            # è‡ªå‹•åŒ–æ¤œå‡ºã‚’å›é¿
            await self.page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false,
                });
                window.navigator.chrome = {
                    runtime: {},
                };
                const originalQuery = window.navigator.permissions.query;
                window.navigator.permissions.query = (parameters) => (
                    parameters.name === 'notifications' ?
                        Promise.resolve({ state: Notification.permission }) :
                        originalQuery(parameters)
                );
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['ja-JP', 'ja', 'en-US', 'en'],
                });
            """)
            
            self.page.set_default_timeout(config.PAGE_TIMEOUT)
            self.page.set_default_navigation_timeout(config.PAGE_TIMEOUT)
            
            logger.info("="*60)
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•å®Œäº†")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•")
            logger.error("="*60)
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•å¤±æ•—")
            logger.error("="*60)
            
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            logger.error(f"ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.browser_data_dir}")
            
            await self._cleanup_existing_browser_processes()
            raise Exception(f"ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}")
    
    async def _is_browser_alive(self) -> bool:
        """ãƒ–ãƒ©ã‚¦ã‚¶ãŒç”Ÿãã¦ã„ã‚‹ã‹ç¢ºèª"""
        try:
            if not self.page:
                return False
            result = await self.page.evaluate("1 + 1")
            return result == 2
        except Exception as e:
            logger.warning(f"ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèªå¤±æ•—: {e}")
            return False
    
    async def _cleanup_existing_browser_processes(self):
        """æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            logger.info("æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¢ºèªä¸­...")
            
            killed_count = 0
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if 'chrome' in proc.info['name'].lower() or 'chromium' in proc.info['name'].lower():
                        cmdline = proc.cmdline()
                        if str(self.browser_data_dir) in ' '.join(cmdline):
                            logger.warning(f"æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†: PID={proc.info['pid']}")
                            proc.kill()
                            killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if killed_count > 0:
                logger.info(f"âœ… {killed_count}å€‹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ã—ã¾ã—ãŸ")
                await asyncio.sleep(2)
            else:
                logger.info("æ—¢å­˜ãƒ—ãƒ­ã‚»ã‚¹ãªã—")
                
        except ImportError:
            logger.warning("psutilãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ—")
        except Exception as e:
            logger.warning(f"ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
    
    async def cleanup(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            logger.info("ğŸ”„ ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™...")

            # éåŒæœŸã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            try:
                tasks = [t for t in asyncio.all_tasks() 
                        if t is not asyncio.current_task()]
                        
                if tasks:
                    logger.info(f"ğŸ”„ {len(tasks)}å€‹ã®éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­...")
                    for task in tasks:
                        task.cancel()
                            
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=5.0
                    )
                    logger.info("âœ… éåŒæœŸã‚¿ã‚¹ã‚¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
            except asyncio.TimeoutError:
                logger.warning("âš ï¸ ã‚¿ã‚¹ã‚¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")

            # ãƒšãƒ¼ã‚¸ã®ã‚¯ãƒ­ãƒ¼ã‚º
            if self.page:
                try:
                    await self.page.close()
                    logger.info("âœ… ãƒšãƒ¼ã‚¸ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

            # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¯ãƒ­ãƒ¼ã‚º
            if self.context:
                try:
                    await self.context.close()
                    logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

            # Playwrightã®åœæ­¢
            if self.playwright:
                try:
                    await self.playwright.stop()
                    logger.info("âœ… Playwrightã‚’åœæ­¢ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ Playwrightåœæ­¢ä¸­ã®è­¦å‘Š: {e}")

            logger.info("âœ… ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")

        except Exception as e:
            logger.error(f"âŒ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")

#browser_wp_session_manager.py
# browser_wp_session_manager.py
"""WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹"""
import json
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import Page, BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class WPSessionManager:
    """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç®¡ç†ã‚’æ‹…å½“"""
    
    def __init__(self, context: BrowserContext, wp_cookies_file: Path):
        self.context = context
        self.wp_cookies_file = wp_cookies_file
        self.wp_page: Optional[Page] = None
        self.is_logged_in = False
    
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """
        WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
            
        Args:
            auth_module: WordPressèªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆä»»æ„ï¼‰
            
        Returns:
            bool: åˆæœŸåŒ–æˆåŠŸæ™‚ True
        """
        try:
            logger.info("="*60)
            logger.info("ğŸ” WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
                
            # Phase 1: æ–°ã—ã„ã‚¿ãƒ–ã‚’ä½œæˆ
            if not self.context:
                logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            self.wp_page = await self.context.new_page()
            logger.info("âœ… WordPress å°‚ç”¨ã‚¿ãƒ–ã‚’ä½œæˆã—ã¾ã—ãŸ")
                
            # Phase 2: èªè¨¼æƒ…å ±ã®æ¤œè¨¼
            if not auth_module:
                logger.warning("âš ï¸ WordPress èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                logger.info("æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
                
            # Phase 3: ãƒ­ã‚°ã‚¤ãƒ³å®Ÿè¡Œï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            logger.info("ğŸ”„ WordPressèªè¨¼ã‚’å®Ÿè¡Œä¸­...")
            
            if auth_module:
                login_success = await auth_module.login(self.wp_page)
            else:
                # èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã„å ´åˆã¯æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚’ä¿ƒã™
                login_success = await self._manual_wp_login()
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("âœ… WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†")
                logger.info("  èªè¨¼æ–¹æ³•: ã‚¯ãƒƒã‚­ãƒ¼ or æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³")
                logger.info("  ãƒšãƒ¼ã‚¸URL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("âŒ WordPress ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                logger.error("  åŸå› : èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                logger.error("  å¯¾ç­–: èªè¨¼æƒ…å ±ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                logger.error("="*60)
                    
                # ãƒ‡ãƒãƒƒã‚°ç”¨: å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("ğŸ“¸ ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _manual_wp_login(self) -> bool:
        """æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†"""
        try:
            logger.info("="*60)
            logger.info("ğŸ” æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
            logger.info("="*60)
            logger.info("")
            logger.info("ğŸ“Œ ãƒ­ã‚°ã‚¤ãƒ³æ‰‹é †ï¼š")
            logger.info("1. ãƒ–ãƒ©ã‚¦ã‚¶ã§WordPressç®¡ç†ç”»é¢ã‚’é–‹ã")
            logger.info("2. ãƒ¦ãƒ¼ã‚¶ãƒ¼å/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ãƒ­ã‚°ã‚¤ãƒ³")
            logger.info("3. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã“ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«æˆ»ã‚‹")
            logger.info("4. Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ç¶šè¡Œ")
            logger.info("")
            logger.info("ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼š")
            logger.info("  - ãƒ­ã‚°ã‚¤ãƒ³å¾Œã¯ã“ã®ã‚¿ãƒ–ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„")
            logger.info("  - ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯Cookieã§ç¶­æŒã•ã‚Œã¾ã™")
            logger.info("="*60)
            
            # ä¸€èˆ¬çš„ãªWordPressãƒ­ã‚°ã‚¤ãƒ³URLã«ç§»å‹•
            await self.wp_page.goto("/wp-admin", wait_until="domcontentloaded")
            
            input("\nâœ… ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸã‚’ç¢ºèª
            current_url = self.wp_page.url
            if 'wp-admin' in current_url or 'dashboard' in current_url.lower():
                logger.info("âœ… WordPressãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸã‚’ç¢ºèª")
                return True
            else:
                logger.warning("âš ï¸ WordPressç®¡ç†ç”»é¢ã«åˆ°é”ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
                return False
                
        except Exception as e:
            logger.error(f"æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPresså°‚ç”¨ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜"""
        try:
            if not self.context or not self.wp_cookies_file:
                logger.warning("âš ï¸ ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
            
            # ç¾åœ¨ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’å–å¾—
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("ä¿å­˜ã™ã‚‹ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
            
            # WordPressé–¢é€£ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_cookies = [c for c in cookies if wp_domain in c.get('domain', '')]
            
            if not wp_cookies:
                logger.warning("WordPressé–¢é€£ã®ã‚¯ãƒƒã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            # æ—¢å­˜ã®ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            all_cookies = {}
            if self.wp_cookies_file.exists():
                try:
                    with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                        all_cookies = json.load(f)
                except Exception as e:
                    logger.warning(f"æ—¢å­˜ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
                    all_cookies = {}
            
            # WordPress ã‚¯ãƒƒã‚­ãƒ¼ã‚’æ›´æ–°
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            all_cookies[wp_key] = {
                'cookies': wp_cookies,
                'timestamp': time.time(),
                'domain': wp_url
            }
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            self.wp_cookies_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.wp_cookies_file, 'w', encoding='utf-8') as f:
                json.dump(all_cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"âœ… WordPress ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜å®Œäº†: {len(wp_cookies)}å€‹")
            return True
            
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPresså°‚ç”¨ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿"""
        try:
            if not self.wp_cookies_file or not self.wp_cookies_file.exists():
                logger.warning("WordPress ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“")
                return False
            
            if not self.context:
                logger.warning("ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                all_cookies = json.load(f)
            
            # WordPress ã‚¯ãƒƒã‚­ãƒ¼ã‚’å–å¾—
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            
            if wp_key not in all_cookies:
                logger.warning(f"WordPress ã‚¯ãƒƒã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {wp_key}")
                return False
            
            wp_cookie_data = all_cookies[wp_key]
            cookies = wp_cookie_data.get('cookies', [])
            
            if not cookies:
                logger.warning("æœ‰åŠ¹ãª WordPress ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
            
            # æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
            valid_cookies = []
            for cookie in cookies:
                if 'expires' in cookie:
                    if cookie['expires'] > time.time():
                        valid_cookies.append(cookie)
                else:
                    # expires ãŒãªã„ã‚¯ãƒƒã‚­ãƒ¼ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒƒã‚­ãƒ¼
                    valid_cookies.append(cookie)
            
            if not valid_cookies:
                logger.warning("æœ‰åŠ¹æœŸé™åˆ‡ã‚Œã®ã‚¯ãƒƒã‚­ãƒ¼ã®ã¿å­˜åœ¨ã—ã¾ã™")
                return False
            
            # ã‚¯ãƒƒã‚­ãƒ¼ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ 
            await self.context.add_cookies(valid_cookies)
            logger.info(f"âœ… WordPress ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿å®Œäº†: {len(valid_cookies)}å€‹")
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def close_wp_session(self) -> None:
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã‚‹"""
        try:
            if self.wp_page:
                await self.wp_page.close()
                self.wp_page = None
                self.is_logged_in = False
                logger.info("âœ… WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã¾ã—ãŸ")
        except Exception as e:
            logger.warning(f"WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

#command_monitor_agent.py
# command_monitor_agent.py - ACFç›£è¦–å¼·åŒ–ç‰ˆ
import asyncio
import re
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Optional, Callable
from datetime import datetime

logger = logging.getLogger(__name__)

class CommandMonitorAgent:
    """ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã¨å‡ºåŠ›ç›£è¦– - ACF/WP-CLIç‰¹åŒ–ç‰ˆ"""
    

    def __init__(self, browser_controller, sheets_manager):
        self.browser_controller = browser_controller
        self.sheets_manager = sheets_manager
    
        # æ—¢å­˜ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
        self.error_patterns = [
            r'Error:', r'Exception:', r'Traceback'
        ]
    
        # === æ–°è¦è¿½åŠ : PHPå›ºæœ‰ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ ===
        self.php_error_patterns = [
            r'Parse error:',
            r'Syntax error',
            r'Fatal error:',
            r'Warning:',
            r'Notice:',
            r'Undefined function',
            r'Undefined variable',
            r'Class.*not found',
            r'Call to undefined function',
            r'Cannot modify header information',
        ]
    
        # WP-CLIå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå¼·åŒ–ç‰ˆï¼‰
        self.wp_cli_error_patterns = [
            r'Error:\s+',
            r'Fatal error:',
            r'Plugin not found',
            r'Could not create',
            r'Database connection error',
            r'Warning:\s+[A-Z]',
            # === æ–°è¦è¿½åŠ : CPTç™»éŒ²é–¢é€£ã‚¨ãƒ©ãƒ¼ ===
            r'Invalid post type',
            r'Post type.*already exists',
            r'register_post_type.*failed',
            r'Permission denied',
            r'Failed to create',
        ]
    
        # === æ–°è¦è¿½åŠ : ACFå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ ===
        self.acf_error_patterns = [
            r'ACF:\s+Error',
            r'Field group not found',
            r'Invalid field group',
            r'JSON decode error',
            r'acf_add_local_field_group.*failed',
            r'ACF.*not activated',
        ]
    
        self.wp_cli_success_patterns = [
            r'Success:',
            r'Plugin .* activated',
            r'Updated \d+ post',
            r'Created \d+ post',
            # === æ–°è¦è¿½åŠ : CPTç™»éŒ²æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ ===
            r'Post type.*registered',
            r'Custom post type.*created',
            r'Registration of.*successful',
        ]
    
        # === æ–°è¦è¿½åŠ : CPTè­¦å‘Šãƒ‘ã‚¿ãƒ¼ãƒ³ ===
        self.cpt_warning_patterns = [
            r'Post type.*already registered',
            r'Duplicate post type',
            r'Menu position conflict',
            r'Rewrite rules may need to be flushed',
        ]
    
    def _detect_errors(self, output: str) -> bool:
        """ã‚¨ãƒ©ãƒ¼æ¤œå‡º - ACFå¯¾å¿œå¼·åŒ–"""
        # æ±ç”¨ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
        for pattern in self.error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                return True
        
        # WP-CLIå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
        for pattern in self.wp_cli_error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.warning(f"âš ï¸ WP-CLI/ACFã‚¨ãƒ©ãƒ¼æ¤œå‡º: {pattern}")
                return True
        
        return False
    
    def _validate_wp_cli_success(self, output: str, expected_action: str) -> bool:
        """WP-CLIå®Ÿè¡Œã®æˆåŠŸæ¤œè¨¼ - ACFå¯¾å¿œ"""
        # æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒãƒãƒ³ã‚°
        for pattern in self.wp_cli_success_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.info(f"âœ… WP-CLIæˆåŠŸ: {expected_action}")
                return True
        
        logger.error(f"âŒ WP-CLIæˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœªæ¤œå‡º: {expected_action}")
        return False
    
    def _extract_acf_field_group_info(self, output: str) -> Optional[Dict]:
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã®æŠ½å‡ºï¼ˆæ–°è¦è¿½åŠ ï¼‰"""
        try:
            info = {}
            
            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚­ãƒ¼ã®æŠ½å‡º
            key_match = re.search(r'group_([a-z0-9_]+)', output)
            if key_match:
                info['key'] = key_match.group(0)
            
            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°ã®æŠ½å‡º
            fields_match = re.search(r'(\d+)\s+field', output, re.IGNORECASE)
            if fields_match:
                info['field_count'] = int(fields_match.group(1))
            
            # ã‚¨ãƒ©ãƒ¼ã®æŠ½å‡º
            errors = self._extract_errors(output)
            if errors:
                info['errors'] = errors
            
            # è­¦å‘Šã®æŠ½å‡º
            warnings = self._extract_acf_warnings(output)
            if warnings:
                info['warnings'] = warnings
            
            return info if info else None
            
        except Exception as e:
            logger.error(f"ACFæƒ…å ±æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _extract_acf_warnings(self, output: str) -> List[str]:
        """ACFè­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡ºï¼ˆæ–°è¦è¿½åŠ ï¼‰"""
        warnings = []
        lines = output.split('\n')
        
        for i, line in enumerate(lines):
            for pattern in self.acf_warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        return warnings
    
    async def execute_command(self, command: str, timeout: int = 300) -> Dict:
        """ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦å‡ºåŠ›ã‚’ç›£è¦– - ACFæƒ…å ±æŠ½å‡ºè¿½åŠ """
        try:
            logger.info(f"ğŸ”§ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            
            output = stdout.decode('utf-8', errors='ignore')
            error_output = stderr.decode('utf-8', errors='ignore')
            return_code = process.returncode
            
            # === æ–°è¦è¿½åŠ : ACFã‚³ãƒãƒ³ãƒ‰ã®ç‰¹åˆ¥å‡¦ç† ===
            acf_info = None
            if 'wp acf' in command:
                acf_info = self._extract_acf_field_group_info(output + error_output)
                if acf_info:
                    logger.info(f"ğŸ“‹ ACFæƒ…å ±: {acf_info}")
            
            result = {
                'command': command,
                'return_code': return_code,
                'stdout': output,
                'stderr': error_output,
                'timestamp': datetime.now().isoformat(),
                'has_errors': self._detect_errors(output + error_output),
                'errors': self._extract_errors(output + error_output),
                'warnings': self._extract_warnings(output + error_output),
                'acf_info': acf_info  # ACFå›ºæœ‰æƒ…å ±
            }
            
            # çµæœã®ã‚µãƒãƒªãƒ¼ãƒ­ã‚°
            if result['has_errors']:
                logger.error(f"âŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {command}")
                for error in result['errors']:
                    logger.error(f"   {error}")
            elif result['warnings']:
                logger.warning(f"âš ï¸ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œè­¦å‘Š: {command}")
                for warning in result['warnings']:
                    logger.warning(f"   {warning}")
            else:
                logger.info(f"âœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡ŒæˆåŠŸ: {command}")
            
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ã‚³ãƒãƒ³ãƒ‰ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’): {command}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': f'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)',
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [f'å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)'],
                'warnings': [],
                'acf_info': None
            }
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': str(e),
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [str(e)],
                'warnings': [],
                'acf_info': None
            }
    
    def _extract_errors(self, output: str) -> List[str]:
        """ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º"""
        errors = []
        lines = output.split('\n')
        
        # æ±ç”¨ã‚¨ãƒ©ãƒ¼ + WP-CLI/ACFã‚¨ãƒ©ãƒ¼
        all_error_patterns = self.error_patterns + self.wp_cli_error_patterns
        
        for i, line in enumerate(lines):
            for pattern in all_error_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    # ã‚¨ãƒ©ãƒ¼è¡Œã¨ãã®å‰å¾Œ2è¡Œã‚’å–å¾—
                    start = max(0, i - 2)
                    end = min(len(lines), i + 3)
                    context = '\n'.join(lines[start:end])
                    errors.append(context)
                    break
        
        return errors
    
    def _extract_warnings(self, output: str) -> List[str]:
        """è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º"""
        warnings = []
        lines = output.split('\n')
        
        warning_patterns = [r'Warning:', r'Notice:']
        
        for i, line in enumerate(lines):
            for pattern in warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        # ACFè­¦å‘Šã‚‚è¿½åŠ 
        acf_warnings = self._extract_acf_warnings(output)
        warnings.extend(acf_warnings)
        
        return warnings
    
    async def monitor_acf_import_process(self, json_path: Path, timeout: int = 180) -> Dict:
        """ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã®å°‚ç”¨ç›£è¦–ï¼ˆæ–°è¦è¿½åŠ ï¼‰"""
        try:
            logger.info(f"ğŸ“¥ ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆç›£è¦–é–‹å§‹: {json_path}")
            
            # WP-CLIã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
            command = f"wp acf import {json_path}"
            result = await self.execute_command(command, timeout=timeout)
            
            # æˆåŠŸæ¤œè¨¼
            is_success = (
                result['return_code'] == 0 and
                not result['has_errors'] and
                self._validate_wp_cli_success(result['stdout'], 'ACF import')
            )
            
            if is_success:
                logger.info("âœ… ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ")
            else:
                logger.error("âŒ ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—")
            
            return {
                'success': is_success,
                'command_result': result,
                'acf_info': result.get('acf_info'),
                'errors': result.get('errors', []),
                'warnings': result.get('warnings', [])
            }
            
        except Exception as e:
            logger.error(f"ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆç›£è¦–ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#compatibility_fix.py
"""
Python 3.13 éåŒæœŸäº’æ›æ€§ä¿®æ­£
Windowsç’°å¢ƒã§ã®asyncioãƒ—ãƒ­ã‚¢ã‚¯ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã®å•é¡Œã‚’è§£æ±º
"""

import asyncio
import sys
import warnings

def apply_windows_async_fix():
    """Windowsç’°å¢ƒã§ã®éåŒæœŸå•é¡Œã‚’ä¿®æ­£"""
    if sys.platform == "win32":
        # ResourceWarningã‚’ç„¡è¦–ï¼ˆä¸€æ™‚çš„å¯¾å¿œï¼‰
        warnings.filterwarnings("ignore", category=ResourceWarning)
        
        # ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãƒãƒªã‚·ãƒ¼ã‚’è¨­å®š
        if sys.version_info >= (3, 13):
            try:
                asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
            except Exception:
                # æ—¢ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç„¡è¦–
                pass

def safe_async_shutdown():
    """å®‰å…¨ãªéåŒæœŸã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            loop.stop()
        if not loop.is_closed():
            loop.close()
    except Exception:
        pass

#config_utils.py
import logging
import uuid
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import time

# config_utils.py ã® SmartLogFormatter ã‚¯ãƒ©ã‚¹ã‚’ä¿®æ­£

class SmartLogFormatter(logging.Formatter):
    """ã‚¹ãƒãƒ¼ãƒˆãªãƒ­ã‚°ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ - çŸ­ç¸®è­˜åˆ¥ç‰ˆ"""
    
    # ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¨ã—ã¦çŠ¶æ…‹ã‚’ä¿æŒ
    _message_count = 0
    _last_timestamp_display = 0
    _last_date_display = ""
    _lock = False
    
    # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥ã®çµµæ–‡å­—ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆçŸ­ç¸®ç‰ˆï¼‰
    AGENT_EMOJIS = {
        # ğŸƒâ€â™‚ï¸ å®Ÿè¡Œç³»
        'run_multi_agent': 'ğŸš€ multi-agent',
        '__main__': 'ğŸ main',
    
        # ğŸ‘‘ PMç³»
        'pm_agent': 'ğŸ‘‘ pm-agent',
        'pm_system_prompts': 'ğŸ“‹ pm-prompts',
    
        # âš™ï¸ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œç³»
        'task_executor': 'âš™ï¸ task-exec',
        'task_executor_content': 'ğŸ“ task-content',
        'task_executor_ma': 'ğŸ” task-ma',
        'task_coordinator': 'ğŸ¯ task-coord',
        'content_task_executor': 'ğŸ“„ content-exec',
        'system_cli_executor': 'ğŸ’» cli-exec',
        'workflow_executor': 'ğŸ”„ workflow',
        'test_tasks': 'ğŸ§ª test-tasks',
    
        # ğŸ¨ ãƒ‡ã‚¶ã‚¤ãƒ³ç³»
        'design_agent': 'ğŸ¨ design',
        'ui_agent': 'ğŸ“± ui',
    
        # ğŸ’» é–‹ç™ºç³»
        'dev_agent': 'ğŸ’» dev',
        'dev_agent_acf': 'ğŸ”Œ dev-acf',
    
        # âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ç³»
        'review_agent': 'âœ… review',
        'review_agent_prompts': 'ğŸ“‹ review-prompts',
        'review_agent_prompts_ACF': 'ğŸ”§ review-acf',
    
        # ğŸ•·ï¸ ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ç³»
        'browser_controller': 'ğŸ•·ï¸ browser',
        'browser_cookie_and_session': 'ğŸª cookie-session',
        'browser_lifecycle': 'ğŸ” browser-life',
        'browser_ai_chat_agent': 'ğŸ¤– browser-ai',
        'browser_wp_session_manager': 'ğŸŒ wp-session',
    
        # ğŸ“Š ãƒ‡ãƒ¼ã‚¿é€£æºç³»
        'sheets_manager': 'ğŸ“Š sheets-mgr',
    
        # ğŸ”§ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ç³»
        'config_utils': 'âš™ï¸ config',
        'command_monitor_agent': 'ğŸ‘ï¸ monitor',
        'compatibility_fix': 'ğŸ”§ compat-fix',
        'quick_fix': 'âš¡ quick-fix',
        'error_handler_enhanced': 'ğŸš¨ error-handler',
    
        # âœï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ç³»
        'base_writer': 'âœï¸ writer-base',
        'ja_writer_agent': 'ğŸ—¾ ja-writer',
        'en_writer_agent': 'ğŸ”  en-writer',
        'ru_writer_agent': 'ğŸ‡·ğŸ‡º ru-writer',
        'uz_writer_agent': 'ğŸ‡ºğŸ‡¿ uz-writer',
        'zh_writer_agent': 'ğŸ‡¨ğŸ‡³ zh-writer',
        'ko_writer_agent': 'ğŸ‡°ğŸ‡· ko-writer',
        'tr_writer_agent': 'ğŸ‡¹ğŸ‡· tr-writer',
        
        # ğŸ†• M&Aå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        'ma_executor': 'ğŸ’¼ ma-exec',
        'ma_requirements': 'ğŸ“‹ ma-req',
        'ma_data_migration': 'ğŸ”„ ma-migrate',
        'ma_api_integration': 'ğŸ”— ma-api',
    
        # ğŸŒ WordPressç³»
        'wp_agent': 'ğŸŒ wp-agent',
        'wp_auth': 'ğŸ” wp-auth',
        'wp_post_editor': 'ğŸ“ wp-editor',
        'wp_post_creator': 'ğŸ†• wp-creator',
        'wp_plugin_manager': 'ğŸ”Œ wp-plugin',
        'wp_settings_manager': 'âš™ï¸ wp-config',
        'wp_design': 'ğŸ¨ wp-design',
        'wp_dev': 'ğŸ”§ wp-dev',
        'wp_tester': 'ğŸ§ª wp-test',
        'wp_utils': 'ğŸ› ï¸ wp-utils',
    
    }
    
    def format(self, record):
        # å†å¸°å‘¼ã³å‡ºã—é˜²æ­¢
        if SmartLogFormatter._lock:
            return super().format(record)
        
        SmartLogFormatter._lock = True
        try:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚«ã‚¦ãƒ³ãƒˆ
            SmartLogFormatter._message_count += 1
            current_time = time.time()
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè­˜åˆ¥
            agent_name = record.name
            # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‹ã‚‰çŸ­ç¸®åã‚’å–å¾—
            if '.' in agent_name:
                agent_short = agent_name.split('.')[-1]  # æœ€å¾Œã®éƒ¨åˆ†
            else:
                agent_short = agent_name
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµµæ–‡å­—ã‚’å–å¾—
            agent_display = self.AGENT_EMOJIS.get(agent_short, f'ğŸ“‹ {agent_short[:6]}')
            
            # ãƒ¬ãƒ™ãƒ«åˆ¥ã®çµµæ–‡å­—ã¨è‰²ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’å¼·èª¿ï¼‰
            level_info = {
                'INFO': ('ğŸ’¬', ''),
                'WARNING': ('âš ï¸', 'WARN'),
                'ERROR': ('âŒ', 'ERROR'),
                'DEBUG': ('ğŸ›', 'DEBUG'),
                'CRITICAL': ('ğŸ’¥', 'CRITICAL')
            }
            
            level_emoji, level_prefix = level_info.get(record.levelname, ('ğŸ“', ''))
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            message = record.getMessage()
            
            # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—åˆ¤å®š
            current_date = time.strftime('%Y-%m-%d')
            show_date = (SmartLogFormatter._last_date_display != current_date)
            show_timestamp = (
                SmartLogFormatter._message_count % 30 == 1 or 
                current_time - SmartLogFormatter._last_timestamp_display > 300 or
                show_date
            )
            
            # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ§‹ç¯‰
            parts = []
            
            # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
            if show_date:
                SmartLogFormatter._last_date_display = current_date
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%Y-%m-%d %H:%M')
                parts.append(f"ğŸ•’ {timestamp}")
            elif show_timestamp:
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%H:%M')
                parts.append(f"ğŸ•’ {timestamp}")
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåï¼ˆå¸¸ã«è¡¨ç¤ºï¼‰
            parts.append(agent_display)
            
            # ãƒ¬ãƒ™ãƒ«ï¼ˆã‚¨ãƒ©ãƒ¼/è­¦å‘Šæ™‚ã¯å¼·èª¿ï¼‰
            if level_prefix:
                # ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ™ãƒ«ã®å ´åˆã¯èµ¤è‰²ã§è¡¨ç¤ºï¼ˆã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§è‰²ä»˜ã‘ï¼‰
                if record.levelname in ['ERROR', 'CRITICAL']:
                    parts.append(f"{level_emoji} \033[91m{level_prefix}\033[0m")  # èµ¤è‰²
                elif record.levelname == 'WARNING':
                    parts.append(f"{level_emoji} \033[93m{level_prefix}\033[0m")  # é»„è‰²
                else:
                    parts.append(f"{level_emoji} {level_prefix}")
            else:
                parts.append(level_emoji)
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            parts.append(message)
            
            # çµåˆ
            result = ' '.join(parts)
            
            return result
            
        finally:
            SmartLogFormatter._lock = False


def setup_optimized_logging():
    """æœ€é©åŒ–ã•ã‚ŒãŸãƒ­ã‚°è¨­å®šï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè­˜åˆ¥å¼·åŒ–ç‰ˆï¼‰"""
    
    # ãƒ«ãƒ¼ãƒˆãƒ­ã‚¬ãƒ¼
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # â† INFO ã‚’ DEBUG ã«å¤‰æ›´
    
    # æ—¢å­˜ã®ãƒãƒ³ãƒ‰ãƒ©ã‚’ã‚¯ãƒªã‚¢
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ©ï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè­˜åˆ¥å¼·åŒ–ï¼‰
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SmartLogFormatter())
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ©ï¼ˆè©³ç´°ãƒ­ã‚°ï¼‰
    file_handler = logging.FileHandler('gemini_automation.log', encoding='utf-8')
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(file_formatter)
    
    # ãƒãƒ³ãƒ‰ãƒ©è¿½åŠ 
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)


# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å®Ÿè¡Œ
setup_optimized_logging()


class Config:
    """è¨­å®šã‚¯ãƒ©ã‚¹"""
    SPREADSHEET_ID = "1qpMLT9HKlPT9qY17fpqOkSIbehKH77wZ8bA1yfPSO_s"
    DOWNLOAD_IMAGE_FOLDER: Optional[str] = None
    DOWNLOAD_TEXT_FOLDER: Optional[str] = None
    SERVICE_ACCOUNT_FILE: Optional[str] = None
    COOKIES_FILE: Optional[str] = None
    BROWSER_DATA_DIR: Optional[str] = None
    GENERATION_MODE: Optional[str] = None
    TEXT_FORMAT: Optional[str] = None
    SERVICE_TYPE: Optional[str] = None
    AGENT_OUTPUT_FOLDER = None
    MAX_ITERATIONS = 3
    DRIVE_TEXT_FOLDER_ID = "16QVK_-z8JVmhLQuLVprOx9_DnoNc4eUc"
    DRIVE_IMAGE_FOLDER_ID = "1jkuMH1UNeBvNNvrz8iVidyVMmtmYrHiS"
    
    BROWSER_CONFIG = {
        "headless": False,
        "slow_mo": 800,
        "args": [
            "--disable-blink-features=AutomationControlled",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "--no-sandbox",
            "--disable-dev-shm-usage"
            # âš ï¸ --single-process ã‚’å‰Šé™¤ï¼ˆWindowsã§ä¸å®‰å®šãªãŸã‚ï¼‰
        ],
        "timeout": 60000
    }
    
    def __init__(self):
        self.WP_COOKIES_FILE = os.environ.get('WP_COOKIES_FILE', 
                                            os.path.join(Path.home(), 'Documents', 'gemini_auto_generate', 'wordpress_cookies.json'))
            
        # ã‚¯ãƒƒã‚­ãƒ¼æœ‰åŠ¹æœŸé™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ30æ—¥ï¼‰
        self.WP_COOKIE_EXPIRY_DAYS = int(os.environ.get('WP_COOKIE_EXPIRY_DAYS', '30'))
        
    VIEWPORT_SIZE = {'width': 1024, 'height': 768}
    PAGE_TIMEOUT = 60000
    IMAGE_GENERATION_TIMEOUT = 180
    TEXT_GENERATION_TIMEOUT = 120
    
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]


class FileNameGenerator:
    """ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ"""
    
    @staticmethod
    def generate_unique_filename(index: int, extension: str = ".png", mode: str = "image") -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        unique_id = str(uuid.uuid4())[:8]
        
        if mode == "text":
            prefix = "gemini_text"
            ext = ".txt"
        else:
            prefix = "gemini_image"
            ext = extension
        
        return f"{prefix}_{index:03d}_{timestamp}_{unique_id}{ext}"
    
    @staticmethod
    def validate_filename(filename: str) -> bool:
        try:
            invalid_chars = '<>:"/\\|?*'
            return not any(char in filename for char in invalid_chars)
        except:
            return False


class ErrorHandler:
    """ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
    
    @staticmethod
    def log_error(error: Exception, context: str = "") -> None:
        logger = logging.getLogger(__name__)
        logger.error(f"{context}: {str(error)}")
    
    @staticmethod
    def handle_missing_attribute_error(obj, attr_name: str, default_value=None):
        logger = logging.getLogger(__name__)
        if not hasattr(obj, attr_name):
            logger.warning(f"å±æ€§ '{attr_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨")
            setattr(obj, attr_name, default_value)
        return getattr(obj, attr_name)


class PathManager:
    """ãƒ‘ã‚¹ç®¡ç†"""
    
    @staticmethod
    def ensure_directory_exists(path: Path) -> None:
        path.mkdir(parents=True, exist_ok=True)
    
    @staticmethod
    def get_safe_path(base_path: str) -> Path:
        path = Path(base_path)
        PathManager.ensure_directory_exists(path)
        return path


config = Config()

#content_task_executor.py
"""
content_task_executor.py - ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
AIã‚µã‚¤ãƒˆã¨ã®å¯¾è©±ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã€å¿œç­”æŠ½å‡ºã€æ¤œè¨¼ã‚’æ‹…å½“
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

# è¨­å®š
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """
    ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã®å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ã‚’é€šã˜ãŸAIå¯¾è©±ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã€
    æŠ½å‡ºã€æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ±åˆ
    """
    
    def __init__(
        self,
        browser_controller,
        sheets_manager: GoogleSheetsManager
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        
        # AIè¨­å®š
        self.ai_sites = {
            'gemini': 'https://gemini.google.com',
            'deepseek': 'https://chat.deepseek.com',
            'claude': 'https://claude.ai'
        }
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆAI
        self.default_ai = 'gemini'
        
        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
        self.default_timeout = 180.0
        self.generation_timeout = 240.0
        
        logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
    
    async def execute_content_task(self, task: Dict) -> Dict:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
            
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
                
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("=" * 60)
            logger.info(f"âœï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info("=" * 60)
                
            # ========================================
            # ğŸ†• ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—åˆ¤å®šã¨å°‚é–€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé©ç”¨ï¼ˆå¼·åŒ–ç‰ˆï¼‰
            # ========================================
            content_type = self._determine_content_type(task)
            logger.info(f"ğŸ“‹ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—: {content_type}")
                
            # å°‚é–€æ–‡æ›¸ã‚¿ã‚¤ãƒ—ã®å ´åˆã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å·®ã—æ›¿ãˆ
            if content_type == 'pydantic_migration':
                task['prompt'] = self._build_pydantic_migration_prompt(task)
                logger.info("ğŸ”§ Pydanticç§»è¡Œãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é©ç”¨")
            elif content_type == 'openapi_schema':
                task['prompt'] = self._build_openapi_schema_prompt(task)
                logger.info("ğŸ“ OpenAPIã‚¹ã‚­ãƒ¼ãƒãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é©ç”¨")
            elif content_type == 'requirements_document':
                task['prompt'] = self._build_requirements_document_prompt(task)
                logger.info("ğŸ“„ è¦ä»¶å®šç¾©æ›¸ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é©ç”¨")
                
            # ========================================
            # æ—¢å­˜ã®å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
            # ========================================
                
            # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æŠ½å‡º
            prompt = task.get('prompt', task.get('description', ''))
            ai_site = task.get('ai_site', self.default_ai).lower()
            output_format = task.get('output_format', 'markdown')
                
            # ãƒ–ãƒ©ã‚¦ã‚¶ãƒã‚§ãƒƒã‚¯
            if not self.browser:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
                
            # AIã‚µã‚¤ãƒˆãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
            nav_result = await self._navigate_to_ai_site(ai_site)
            if not nav_result['success']:
                return nav_result
                
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿ
            response_result = await self._send_prompt_and_wait(
                prompt, 
                timeout=self.generation_timeout
            )
            if not response_result['success']:
                return response_result
                
            # å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º
            extract_result = await self._extract_response_text()
            if not extract_result['success']:
                return extract_result
                
            content = extract_result['content']
                
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œè¨¼
            validation_result = self._validate_content(content, task)
            if not validation_result['valid']:
                logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œè¨¼è­¦å‘Š: {validation_result['message']}")
                
            # å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            output_file = await self._save_content_output(
                task_id, 
                content, 
                output_format
            )
                
            logger.info(f"âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ {task_id} å®Œäº†")
                
            return {
                'success': True,
                'content': content,
                'output_file': output_file,
                'ai_site': ai_site,
                'content_type': content_type,  # ã‚¿ã‚¤ãƒ—æƒ…å ±ã‚’è¿½åŠ 
                'validation': validation_result,
                'full_text': content,
                'summary': content[:500] if len(content) > 500 else content
            }
                
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ {task_id} ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
            return {
                'success': False,
                'error': f'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({self.generation_timeout}ç§’)'
            }
            
        except Exception as e:
            logger.error(f"âŒ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_content_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _navigate_to_ai_site(self, ai_site: str) -> Dict:
        """
        AIã‚µã‚¤ãƒˆã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        
        Args:
            ai_site: AIã‚µã‚¤ãƒˆè­˜åˆ¥å­ ('gemini', 'deepseek', 'claude')
            
        Returns:
            Dict: ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³çµæœ
        """
        try:
            logger.info(f"ğŸŒ {ai_site.upper()} ã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ä¸­...")
            
            # ã‚µã‚¤ãƒˆURLå–å¾—
            if ai_site not in self.ai_sites:
                logger.warning(f"âš ï¸ æœªçŸ¥ã®AIã‚µã‚¤ãƒˆ: {ai_site}, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ {self.default_ai} ã‚’ä½¿ç”¨")
                ai_site = self.default_ai
            
            url = self.ai_sites[ai_site]
            
            # ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
            if ai_site == 'gemini':
                if hasattr(self.browser, 'navigate_to_gemini'):
                    result = await self.browser.navigate_to_gemini()
                else:
                    result = await self.browser.navigate_to_url(url)
            elif ai_site == 'deepseek':
                if hasattr(self.browser, 'navigate_to_deepseek'):
                    result = await self.browser.navigate_to_deepseek()
                else:
                    result = await self.browser.navigate_to_url(url)
            else:
                result = await self.browser.navigate_to_url(url)
            
            if result:
                logger.info(f"âœ… {ai_site.upper()} ã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸ")
                return {'success': True}
            else:
                logger.error(f"âŒ {ai_site.upper()} ã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—")
                return {'success': False, 'error': f'{ai_site} ã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—'}
        
        except Exception as e:
            logger.error(f"âŒ AIã‚µã‚¤ãƒˆãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _send_prompt_and_wait(
        self, 
        prompt: str, 
        timeout: float = None
    ) -> Dict:
        """
        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ã—ã¦å¿œç­”ã‚’å¾…æ©Ÿ
        
        Args:
            prompt: é€ä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            timeout: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            if timeout is None:
                timeout = self.generation_timeout
            
            logger.info(f"ğŸ“¤ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ä¸­... (ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {timeout}ç§’)")
            
            # çµ±åˆãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
            if hasattr(self.browser, 'send_prompt_and_wait'):
                result = await self.browser.send_prompt_and_wait(
                    prompt, 
                    timeout=timeout
                )
                if result:
                    logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿå®Œäº†")
                    return {'success': True}
                else:
                    logger.error("âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¾ãŸã¯å¿œç­”å¾…æ©Ÿå¤±æ•—")
                    return {'success': False, 'error': 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å¤±æ•—'}
            else:
                # å€‹åˆ¥ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨ï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰
                if hasattr(self.browser, 'send_prompt'):
                    await self.browser.send_prompt(prompt)
                else:
                    logger.error("âŒ send_prompt ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return {'success': False, 'error': 'send_prompt ãƒ¡ã‚½ãƒƒãƒ‰æœªå®Ÿè£…'}
                
                # å¿œç­”å¾…æ©Ÿ
                if hasattr(self.browser, 'wait_for_text_generation'):
                    await self.browser.wait_for_text_generation(timeout)
                    logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿå®Œäº†")
                    return {'success': True}
                else:
                    logger.warning("âš ï¸ wait_for_text_generation ãƒ¡ã‚½ãƒƒãƒ‰ãªã— - å›ºå®šå¾…æ©Ÿ")
                    await asyncio.sleep(30)  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾…æ©Ÿ
                    return {'success': True}
        
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå¿œç­”ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)")
            return {'success': False, 'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'}
        
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _extract_response_text(self) -> Dict:
        """
        AIã‹ã‚‰ã®å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
        
        Returns:
            Dict: æŠ½å‡ºçµæœ {'success': bool, 'content': str}
        """
        try:
            logger.info("ğŸ“¥ å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºä¸­...")
            
            if not hasattr(self.browser, 'extract_latest_text_response'):
                logger.error("âŒ extract_latest_text_response ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {'success': False, 'error': 'å¿œç­”æŠ½å‡ºãƒ¡ã‚½ãƒƒãƒ‰æœªå®Ÿè£…'}
            
            content = await self.browser.extract_latest_text_response()
            
            if not content:
                logger.warning("âš ï¸ æŠ½å‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒç©ºã§ã™")
                return {'success': False, 'error': 'æŠ½å‡ºã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãªã—'}
            
            logger.info(f"âœ… å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºå®Œäº† ({len(content)}æ–‡å­—)")
            return {'success': True, 'content': content}
        
        except Exception as e:
            logger.error(f"âŒ å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    def _validate_content(self, content: str, task: Dict) -> Dict:
        """
        ç”Ÿæˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ¤œè¨¼
        
        Args:
            content: æ¤œè¨¼å¯¾è±¡ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±
            
        Returns:
            Dict: æ¤œè¨¼çµæœ {'valid': bool, 'message': str, 'warnings': list}
        """
        warnings = []
        
        # æœ€å°æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯
        min_length = task.get('min_length', 100)
        if len(content.strip()) < min_length:
            warnings.append(f'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒçŸ­ã™ãã¾ã™ï¼ˆ{len(content)}æ–‡å­— < {min_length}æ–‡å­—ï¼‰')
        
        # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
        if '```' in content:
            code_block_count = content.count('```')
            if code_block_count % 2 != 0:
                warnings.append('ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒä¸å®Œå…¨ã§ã™ï¼ˆé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™ï¼‰')
        
        # PHPã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
        if '<?php' in content:
            if '?>' not in content and not content.rstrip().endswith('}'):
                warnings.append('PHPã‚³ãƒ¼ãƒ‰ãŒä¸å®Œå…¨ãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™')
        
        # å¿…é ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
        required_keywords = task.get('required_keywords', [])
        missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]
        if missing_keywords:
            warnings.append(f'å¿…é ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ä¸è¶³: {", ".join(missing_keywords)}')
        
        valid = len(warnings) == 0
        message = 'æ¤œè¨¼åˆæ ¼' if valid else f'{len(warnings)}ä»¶ã®è­¦å‘Š'
        
        return {
            'valid': valid,
            'message': message,
            'warnings': warnings
        }
    
    async def _save_content_output(
        self, 
        task_id: str, 
        content: str, 
        output_format: str = 'markdown'
    ) -> str:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            content: ä¿å­˜ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            output_format: å‡ºåŠ›å½¢å¼ ('markdown', 'text', 'html')
            
        Returns:
            str: ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        """
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ãƒãƒƒãƒ”ãƒ³ã‚°
            ext_map = {
                'markdown': '.md',
                'text': '.txt',
                'html': '.html',
                'php': '.php'
            }
            ext = ext_map.get(output_format, '.txt')
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"content_{task_id}_{timestamp}{ext}"
            
            # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç¢ºä¿
            output_dir = Path(config.OUTPUT_DIR) if hasattr(config, 'OUTPUT_DIR') else Path('./outputs')
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            output_path = output_dir / filename
            
            if hasattr(self.browser, 'save_text_to_file'):
                # BrowserControllerã®ä¿å­˜ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
                logger.info(f"âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¿å­˜å®Œäº†: {saved_path}")
                return str(saved_path)
            else:
                # ç›´æ¥ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                logger.info(f"âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¿å­˜å®Œäº†: {output_path}")
                return str(output_path)
        
        except Exception as e:
            logger.error(f"âŒ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "ContentTaskExecutor._save_content_output")
            return ""
    
    async def execute_multi_step_content_task(self, task: Dict) -> Dict:
        """
        è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        ä¾‹: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ1 â†’ å¿œç­”æŠ½å‡º â†’ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ2 â†’ æœ€çµ‚å‡ºåŠ›
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸ï¼ˆ'steps'ã‚­ãƒ¼ã«è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©ï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("âš ï¸ ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©ãªã— - å˜ä¸€ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ")
            return await self.execute_content_task(task)
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ”„ ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_id}")
            logger.info(f"ã‚¹ãƒ†ãƒƒãƒ—æ•°: {len(steps)}")
            logger.info("=" * 60)
            
            results = []
            accumulated_content = ""
            
            for i, step in enumerate(steps, 1):
                logger.info(f"\n--- ã‚¹ãƒ†ãƒƒãƒ— {i}/{len(steps)} ---")
                
                # ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯æ§‹ç¯‰
                step_task = {
                    **task,  # è¦ªã‚¿ã‚¹ã‚¯ã®å±æ€§ã‚’ç¶™æ‰¿
                    'task_id': f"{task_id}_step{i}",
                    'prompt': step.get('prompt', ''),
                    'description': step.get('description', f'ã‚¹ãƒ†ãƒƒãƒ—{i}'),
                }
                
                # å‰ã‚¹ãƒ†ãƒƒãƒ—ã®çµæœã‚’å‚ç…§ã™ã‚‹å ´åˆ
                if step.get('use_previous_output') and accumulated_content:
                    step_task['prompt'] = step_task['prompt'].replace(
                        '{previous_output}', 
                        accumulated_content
                    )
                
                # ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
                step_result = await self.execute_content_task(step_task)
                
                if not step_result.get('success'):
                    logger.error(f"âŒ ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—")
                    return {
                        'success': False,
                        'error': f"ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—: {step_result.get('error')}",
                        'completed_steps': i - 1,
                        'step_results': results
                    }
                
                results.append(step_result)
                accumulated_content = step_result.get('content', '')
                
                logger.info(f"âœ… ã‚¹ãƒ†ãƒƒãƒ— {i} å®Œäº†")
                
                # ã‚¹ãƒ†ãƒƒãƒ—é–“å¾…æ©Ÿ
                if i < len(steps):
                    await asyncio.sleep(2)
            
            logger.info(f"âœ… å…¨ {len(steps)} ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†")
            
            return {
                'success': True,
                'content': accumulated_content,
                'steps_completed': len(steps),
                'step_results': results,
                'full_text': accumulated_content,
                'summary': accumulated_content[:500] if len(accumulated_content) > 500 else accumulated_content
            }
        
        except Exception as e:
            logger.error(f"âŒ ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_multi_step_content_task({task_id})")
            return {
                'success': False,
                'error': str(e),
                'step_results': results
            }
    
    def display_suggested_tasks(self, tasks: List[Dict]):
        """
        ææ¡ˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’è¡¨ç¤º
        
        Args:
            tasks: ææ¡ˆã‚¿ã‚¹ã‚¯ã®ãƒªã‚¹ãƒˆ
        """
        print("\n" + "="*60)
        print("ğŸ“‹ ææ¡ˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯:")
        print("="*60)
        for i, task in enumerate(tasks, 1):
            print(f"\n{i}. {task.get('description', 'N/A')}")
            print(f"   AI: {task.get('ai_site', 'gemini')}")
            print(f"   å½¢å¼: {task.get('output_format', 'markdown')}")
            print(f"   å„ªå…ˆåº¦: {task.get('priority', 'medium')}")
        print("="*60)
    
    async def edit_suggested_tasks(self, tasks: List[Dict]) -> List[Dict]:
        """
        ææ¡ˆã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†
        
        Args:
            tasks: ç·¨é›†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
            
        Returns:
            List[Dict]: ç·¨é›†å¾Œã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
        """
        edited_tasks = []
        
        for i, task in enumerate(tasks, 1):
            print(f"\n--- ã‚¿ã‚¹ã‚¯ {i}/{len(tasks)} ã®ç·¨é›† ---")
            print(f"ç¾åœ¨ã®èª¬æ˜: {task.get('description', 'N/A')}")
            
            edit = input("ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†ã—ã¾ã™ã‹? (y/n/s=ã‚¹ã‚­ãƒƒãƒ—): ").lower()
            
            if edit == 's':
                print("ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                continue
            elif edit == 'y':
                new_desc = input("æ–°ã—ã„èª¬æ˜ (Enter=å¤‰æ›´ãªã—): ")
                if new_desc:
                    task['description'] = new_desc
                
                new_ai = input(f"AI (ç¾åœ¨: {task.get('ai_site', 'gemini')}, Enter=å¤‰æ›´ãªã—): ")
                if new_ai:
                    task['ai_site'] = new_ai
                
                new_format = input(f"å‡ºåŠ›å½¢å¼ (ç¾åœ¨: {task.get('output_format', 'markdown')}, Enter=å¤‰æ›´ãªã—): ")
                if new_format:
                    task['output_format'] = new_format
            
            edited_tasks.append(task)
        
        return edited_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """
        æ‰‹å‹•ã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
        
        Returns:
            List[Dict]: ä½œæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
        """
        manual_tasks = []
        
        print("\n" + "="*60)
        print("âœï¸ æ‰‹å‹•ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ä½œæˆ")
        print("="*60)
        
        while True:
            print(f"\n--- ã‚¿ã‚¹ã‚¯ {len(manual_tasks) + 1} ---")
            
            description = input("ã‚¿ã‚¹ã‚¯èª¬æ˜ (Enter=å®Œäº†): ")
            if not description:
                break
            
            prompt = input("ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ (Enter=èª¬æ˜ã¨åŒã˜): ")
            if not prompt:
                prompt = description
            
            ai_site = input("AI (gemini/deepseek/claude, Enter=gemini): ") or 'gemini'
            output_format = input("å‡ºåŠ›å½¢å¼ (markdown/text/html, Enter=markdown): ") or 'markdown'
            priority = input("å„ªå…ˆåº¦ (high/medium/low, Enter=medium): ") or 'medium'
            
            task = {
                'description': description,
                'prompt': prompt,
                'ai_site': ai_site,
                'output_format': output_format,
                'priority': priority,
                'required_role': 'content'
            }
            
            manual_tasks.append(task)
            print(f"âœ… ã‚¿ã‚¹ã‚¯ {len(manual_tasks)} è¿½åŠ å®Œäº†")
            
            continue_add = input("\nåˆ¥ã®ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã™ã‹? (y/n): ").lower()
            if continue_add != 'y':
                break
        
        print(f"\nâœ… {len(manual_tasks)}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã¾ã—ãŸ")
        return manual_tasks
    
    def _determine_content_type(self, task: Dict) -> str:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
        
        # è¨˜äº‹ç”Ÿæˆ
        if any(kw in description or kw in prompt for kw in ['è¨˜äº‹', 'article', 'ãƒ–ãƒ­ã‚°', 'blog']):
            return 'article'
        
        # ç¿»è¨³
        if any(kw in description or kw in prompt for kw in ['ç¿»è¨³', 'translate', 'translation']):
            return 'translation'
        
        # æŠ€è¡“æ–‡æ›¸
        if any(kw in description or kw in prompt for kw in ['è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ä»•æ§˜æ›¸', 'technical', 'spec']):
            return 'technical_document'
        
        return 'generic'
    
    async def _execute_article_generation(self, task: Dict) -> Dict:
        """
        è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“° è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_article_prompt(task)
            
            # AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ç”Ÿæˆ
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=180)
                
                if success:
                    # å¿œç­”å–å¾—
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 100:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'article',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'è¨˜äº‹ç”Ÿæˆå¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'è¨˜äº‹ç”Ÿæˆå¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ è¨˜äº‹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_translation_task(self, task: Dict) -> Dict:
        """
        ç¿»è¨³ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸŒ ç¿»è¨³ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # ç¿»è¨³ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_translation_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'translation',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'ç¿»è¨³å¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'ç¿»è¨³å¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ ç¿»è¨³ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_technical_document_task(self, task: Dict) -> Dict:
        """
        æŠ€è¡“æ–‡æ›¸ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“‹ æŠ€è¡“æ–‡æ›¸ç”Ÿæˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # æŠ€è¡“æ–‡æ›¸ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_technical_document_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=300)  # é•·ã‚ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    # æŠ€è¡“æ–‡æ›¸ã¯éƒ¨åˆ†çš„ãªæˆåŠŸã‚‚è¨±å®¹
                    if response_text and len(response_text) > 500:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': len(response_text) > 2000  # å®Œå…¨æ€§ãƒ•ãƒ©ã‚°
                        }
                    elif response_text and len(response_text) > 200:
                        # éƒ¨åˆ†çš„ãªæˆåŠŸ
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': False,
                            'partial_success': True,
                            'warning': 'æ–‡æ›¸ãŒå®Œå…¨ã§ã¯ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'æŠ€è¡“æ–‡æ›¸ç”Ÿæˆå¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'æŠ€è¡“æ–‡æ›¸ç”Ÿæˆå¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ æŠ€è¡“æ–‡æ›¸ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_generic_content_task(self, task: Dict) -> Dict:
        """
        æ±ç”¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“„ æ±ç”¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            prompt = task.get('prompt', '')
            if not prompt:
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'generic',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ æ±ç”¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }    
    
    def _build_article_prompt(self, task: Dict) -> str:
            """è¨˜äº‹ç”Ÿæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
            base_prompt = task.get('prompt', '')
            language = task.get('language', 'ja')
            
            if language == 'ja':
                return f"""ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒã§è³ªã®é«˜ã„è¨˜äº‹ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

    {base_prompt}

    ã€è¨˜äº‹ã®è¦ä»¶ã€‘
    - å°‚é–€çš„ã‹ã¤åˆ†ã‹ã‚Šã‚„ã™ã„å†…å®¹
    - å…·ä½“çš„ãªäº‹ä¾‹ã‚„ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚ã‚‹
    - èª­è€…ã®é–¢å¿ƒã‚’å¼•ãå°å…¥éƒ¨
    - æ˜ç¢ºãªçµè«–ã§ç· ã‚ããã‚‹
    - 1500æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°

    ã€å‡ºåŠ›å½¢å¼ã€‘
    - è¦‹å‡ºã—ã‚’é©åˆ‡ã«ä½¿ç”¨
    - æ®µè½åˆ†ã‘ã‚’æ˜ç¢ºã«
    - èª­ã¿ã‚„ã™ã„æ–‡ä½“ã§"""
            
            else:
                return f"""Generate a high-quality article on the following topic:

    {base_prompt}

    ã€Article Requirementsã€‘
    - Professional yet accessible content
    - Include specific examples and data
    - Engaging introduction
    - Clear conclusion
    - Detailed description over 1500 words

    ã€Output Formatã€‘
    - Use appropriate headings
    - Clear paragraph breaks
    - Readable writing style"""
        
    def _build_translation_prompt(self, task: Dict) -> str:
        """ç¿»è¨³ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        source_text = task.get('source_text', '')
        target_language = task.get('target_language', 'ja')
        source_language = task.get('source_language', 'en')
        
        return f"""ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’{source_language}ã‹ã‚‰{target_language}ã«ç¿»è¨³ã—ã¦ãã ã•ã„ï¼š

    {source_text}

    ã€ç¿»è¨³è¦ä»¶ã€‘
    - è‡ªç„¶ã§æµæš¢ãªè¡¨ç¾
    - å°‚é–€ç”¨èªã¯é©åˆ‡ã«è¨³ã™
    - æ–‡åŒ–çš„ãªé•ã„ã‚’è€ƒæ…®
    - åŸæ–‡ã®æ„å‘³ã‚’æ­£ç¢ºã«ä¼ãˆã‚‹"""
        
    def _build_technical_document_prompt(self, task: Dict) -> str:
        """æŠ€è¡“æ–‡æ›¸ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        base_prompt = task.get('prompt', '')
        
        return f"""ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦è©³ç´°ãªæŠ€è¡“æ–‡æ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š

    {base_prompt}

    ã€æ–‡æ›¸è¦ä»¶ã€‘
    - æŠ€è¡“çš„ã«æ­£ç¢ºãªå†…å®¹
    - ä½“ç³»çš„ãªæ§‹æˆ
    - å…·ä½“çš„ãªå®Ÿè£…ä¾‹ã‚„ã‚³ãƒ¼ãƒ‰ã‚µãƒ³ãƒ—ãƒ«
    - ã‚ã‹ã‚Šã‚„ã™ã„èª¬æ˜
    - 2000æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°

    ã€å‡ºåŠ›å½¢å¼ã€‘
    - ç« ç«‹ã¦ã‚’æ˜ç¢ºã«
    - ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯é©åˆ‡ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    - è¡¨ã‚„ãƒªã‚¹ãƒˆã‚’å¿…è¦ã«å¿œã˜ã¦ä½¿ç”¨
    - å°‚é–€ç”¨èªã¯åˆå‡ºæ™‚ã«ç°¡æ½”ã«èª¬æ˜"""
    
    
    def _build_pydantic_migration_prompt(self, task: Dict) -> str:
        """
        Pydanticãƒ¢ãƒ‡ãƒ«ç§»è¡Œå°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
    
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
        Returns:
            str: Pydanticãƒ¢ãƒ‡ãƒ«ç§»è¡Œãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        base_prompt = task.get('prompt', '')
        current_implementation = task.get('current_implementation', '')
    
        return f"""ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’Pydanticãƒ¢ãƒ‡ãƒ«ã«ç§»è¡Œã—ã¦ãã ã•ã„:

    {base_prompt}

    ã€ç¾åœ¨ã®å®Ÿè£…ã€‘
    {current_implementation if current_implementation else 'â€»ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®è©³ç´°ã¯è¦ä»¶å®šç¾©æ›¸ã‚’å‚ç…§'}

    ã€Pydanticç§»è¡Œè¦ä»¶ã€‘
    1. **Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©**
        - ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’Pydantic BaseModelã‚¯ãƒ©ã‚¹ã¨ã—ã¦å®šç¾©
        - å‹ãƒ’ãƒ³ãƒˆ(Type Hints)ã‚’æ˜ç¢ºã«æŒ‡å®š
        - Field()ã‚’ä½¿ç”¨ã—ãŸãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        - Optionalå‹ã®é©åˆ‡ãªä½¿ç”¨

    2. **ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…**
        - å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©
        - ãƒ‡ãƒ¼ã‚¿å‹ã®å³æ ¼ãªãƒã‚§ãƒƒã‚¯
        - ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚¿ã®å®Ÿè£…
        - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ—¥æœ¬èªåŒ–

    3. **JSONã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆ**
        - model.schema_json()ã«ã‚ˆã‚‹ã‚¹ã‚­ãƒ¼ãƒå‡ºåŠ›
        - OpenAPIäº’æ›æ€§ã®ç¢ºä¿
        - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã®è¨˜è¿°

    4. **è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰**
        - pytestå¯¾å¿œã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        - æ­£å¸¸ç³»ãƒ»ç•°å¸¸ç³»ã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
        - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã®ç¢ºèª

    ã€å‡ºåŠ›å½¢å¼ã€‘
    ```python
    from pydantic import BaseModel, Field, validator
    from typing import Optional, List
    from datetime import datetime
    # (å®Œå…¨ãªPydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ã‚³ãƒ¼ãƒ‰)
    ã€å¿…é ˆè¦ç´ ã€‘

    ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‹ãƒ’ãƒ³ãƒˆã¨Field()ã«ã‚ˆã‚‹èª¬æ˜
    @validatorãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã«ã‚ˆã‚‹ã‚«ã‚¹ã‚¿ãƒ æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
    repr()ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
    model_configè¨­å®š(alias, extra='forbid'ãªã©)

    2000æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚"""
    
    def _build_openapi_schema_prompt(self, task: Dict) -> str:
        """
        OpenAPIã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆå°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: OpenAPIã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        base_prompt = task.get('prompt', '')
        api_endpoints = task.get('api_endpoints', [])
        
        endpoints_list = '\n'.join([f"  - {ep}" for ep in api_endpoints]) if api_endpoints else 'â€»è¦ä»¶å®šç¾©æ›¸å‚ç…§'
        
        return f"""ä»¥ä¸‹ã®APIä»•æ§˜ã«åŸºã¥ã„ã¦ã€å®Œå…¨ãªOpenAPI 3.0ã‚¹ã‚­ãƒ¼ãƒã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:
    {base_prompt}
    ã€å¯¾è±¡APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‘
    {endpoints_list}
    ã€OpenAPIã‚¹ã‚­ãƒ¼ãƒè¦ä»¶ã€‘

    1.åŸºæœ¬æ§‹é€ 
    OpenAPI 3.0.0æº–æ‹ 
    info(ã‚¿ã‚¤ãƒˆãƒ«ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€èª¬æ˜)
    servers(é–‹ç™ºãƒ»æœ¬ç•ªç’°å¢ƒ)
    paths(å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ)
    components/schemas(ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«)


    2.ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©
    HTTPãƒ¡ã‚½ãƒƒãƒ‰(GET, POST, PUT, DELETE)
    ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£(application/json)
    ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ã‚­ãƒ¼ãƒ(200, 400, 500)
    èªè¨¼è¦ä»¶(bearerAuth)


    3.ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©
    ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹
    ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‹ã¨èª¬æ˜
    requiredé…åˆ—ã®å®šç¾©
    exampleå€¤ã®æä¾›

    4.ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®šç¾©
    securitySchemeså®šç¾©
    JWTèªè¨¼ã®è¨­å®š
    OAuth2ãƒ•ãƒ­ãƒ¼(è©²å½“ã™ã‚‹å ´åˆ)

    ã€å‡ºåŠ›å½¢å¼ã€‘
    openapi: 3.0.0
    info:
      title: (APIã‚¿ã‚¤ãƒˆãƒ«)
      version: 1.0.0
      description: (APIèª¬æ˜)
    servers:
      - url: https://api.example.com/v1
    paths:
      # (å®Œå…¨ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©)
    components:
      schemas:
        # (å®Œå…¨ãªãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©)
      securitySchemes:
        bearerAuth:
          type: http
          scheme: bearer
          bearerFormat: JWT
    2500æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚"""
    def _build_requirements_document_prompt(self, task: Dict) -> str:
        """
        è¦ä»¶å®šç¾©æ›¸ä½œæˆå°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
    
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
        Returns:
            str: è¦ä»¶å®šç¾©æ›¸ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        base_prompt = task.get('prompt', '')
        project_name = task.get('project_name', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ')
    
        return f"""ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€åŒ…æ‹¬çš„ãªè¦ä»¶å®šç¾©æ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„:
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå: {project_name}
    {base_prompt}
    ã€è¦ä»¶å®šç¾©æ›¸ã®æ§‹æˆã€‘
    1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®èƒŒæ™¯ã¨ç›®çš„
    å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ»ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¹ã‚³ãƒ¼ãƒ—
    æˆåŠŸæŒ‡æ¨™(KPI)

    2. æ©Ÿèƒ½è¦ä»¶
    2.1 ãƒ¦ãƒ¼ã‚¶ãƒ¼æ©Ÿèƒ½

    ä¼šå“¡ç™»éŒ²ãƒ»ãƒ­ã‚°ã‚¤ãƒ³
    ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç®¡ç†
    (ãã®ä»–æ©Ÿèƒ½ã‚’åˆ—æŒ™)

    2.2 ç®¡ç†æ©Ÿèƒ½

    ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç®¡ç†
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†
    ãƒ¬ãƒãƒ¼ãƒˆãƒ»åˆ†æ

    2.3 APIä»•æ§˜

    ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¸€è¦§
    èªè¨¼æ–¹å¼
    ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

    3. éæ©Ÿèƒ½è¦ä»¶
    3.1 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶

    ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ç›®æ¨™
    åŒæ™‚æ¥ç¶šæ•°
    ãƒ‡ãƒ¼ã‚¿é‡ã®æƒ³å®š

    3.2 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶

    èªè¨¼ãƒ»èªå¯æ–¹å¼
    ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–
    è„†å¼±æ€§å¯¾ç­–

    3.3 å¯ç”¨æ€§ãƒ»æ‹¡å¼µæ€§

    SLAç›®æ¨™
    ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ãƒªã‚«ãƒãƒª
    ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£

    4. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
    4.1 ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

    ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯/ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
    çŠ¶æ…‹ç®¡ç†
    UI/UXãƒ©ã‚¤ãƒ–ãƒ©ãƒª

    4.2 ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

    è¨€èªãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
    ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
    APIã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

    4.3 ã‚¤ãƒ³ãƒ•ãƒ©

    ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ç’°å¢ƒ
    CI/CD
    ç›£è¦–ãƒ»ãƒ­ã‚°

    5. ãƒ‡ãƒ¼ã‚¿è¨­è¨ˆ
    5.1 ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

    ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ä¸€è¦§
    ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—
    ä¸»è¦ãªåˆ¶ç´„

    5.2 ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

    ãƒ‡ãƒ¼ã‚¿ã®æµã‚Œ
    å¤–éƒ¨é€£æº
    ãƒãƒƒãƒå‡¦ç†

    6. ç”»é¢è¨­è¨ˆ
    6.1 ç”»é¢ä¸€è¦§

    ç”»é¢åã¨å½¹å‰²
    ç”»é¢é·ç§»å›³
    ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æ¦‚è¦

    7. å¤–éƒ¨é€£æº

    æ±ºæ¸ˆAPI
    ãƒ¡ãƒ¼ãƒ«é€ä¿¡
    ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ­ã‚°ã‚¤ãƒ³

    8. é‹ç”¨ãƒ»ä¿å®ˆ

    ãƒªãƒªãƒ¼ã‚¹è¨ˆç”»
    é‹ç”¨ä½“åˆ¶
    ã‚µãƒãƒ¼ãƒˆä½“åˆ¶

    9. ãƒªã‚¹ã‚¯ç®¡ç†

    æƒ³å®šãƒªã‚¹ã‚¯
    å¯¾ç­–
    ç·Šæ€¥æ™‚å¯¾å¿œ

    10. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

    ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³
    å„ãƒ•ã‚§ãƒ¼ã‚ºã®æœŸé–“
    ãƒªãƒªãƒ¼ã‚¹æ—¥

    ã€è¨˜è¿°è¦ä»¶ã€‘

    å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å…·ä½“çš„ã‹ã¤è©³ç´°ã«è¨˜è¿°
    æŠ€è¡“çš„ãªå®Ÿè£…æ¡ˆã‚‚å«ã‚ã‚‹
    æ•°å€¤ç›®æ¨™ã‚’æ˜ç¢ºã«è¨­å®š
    å›³è¡¨ã®èª¬æ˜ã‚‚å«ã‚ã‚‹(å®Ÿéš›ã®å›³ã¯åˆ¥é€”)

    3000æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚"""
   
    def _determine_content_type(self, task: Dict) -> str:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
    
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
        Returns:
            str: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
    
        # ========================================
        # ğŸ†• å°‚é–€æ–‡æ›¸ã‚¿ã‚¤ãƒ—ã®åˆ¤å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰
        # ========================================
    
        # Pydanticç§»è¡Œã‚¿ã‚¹ã‚¯
        if any(kw in description or kw in prompt for kw in ['pydantic', 'ãƒ¢ãƒ‡ãƒ«ç§»è¡Œ', 'model migration', 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³']):
            return 'pydantic_migration'
    
        # OpenAPIã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆ
        if any(kw in description or kw in prompt for kw in ['openapi', 'swagger', 'apiä»•æ§˜', 'api schema']):
            return 'openapi_schema'
    
        # è¦ä»¶å®šç¾©æ›¸ä½œæˆ
        if any(kw in description or kw in prompt for kw in ['è¦ä»¶å®šç¾©æ›¸', 'è¦ä»¶å®šç¾©', 'requirements document', 'ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶']):
            return 'requirements_document'
    
        # ========================================
        # æ—¢å­˜ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
        # ========================================
    
        # è¨˜äº‹ç”Ÿæˆ
        if any(kw in description or kw in prompt for kw in ['è¨˜äº‹', 'article', 'ãƒ–ãƒ­ã‚°', 'blog']):
            return 'article'
    
        # ç¿»è¨³
        if any(kw in description or kw in prompt for kw in ['ç¿»è¨³', 'translate', 'translation']):
            return 'translation'
    
        # æŠ€è¡“æ–‡æ›¸
        if any(kw in description or kw in prompt for kw in ['è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ä»•æ§˜æ›¸', 'technical', 'spec']):
            return 'technical_document'
    
        return 'generic'
    
    def _is_partial_success(self, result: Dict) -> bool:
        """
        éƒ¨åˆ†çš„ãªæˆåŠŸã‹åˆ¤å®š
        
        Args:
            result: å®Ÿè¡Œçµæœ
            
        Returns:
            bool: éƒ¨åˆ†æˆåŠŸãªã‚‰True
        """
        if not result:
            return False
        
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹ç¨‹åº¦ã‚ã‚Œã°éƒ¨åˆ†æˆåŠŸã¨ã¿ãªã™
        content = result.get('content') or result.get('full_text')
        if content and len(str(content)) > 500:
            return True
        
        # æŠ€è¡“æ–‡æ›¸ã§ä¸å®Œå…¨ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆ
        if result.get('content_type') == 'technical_document' and content and len(str(content)) > 200:
            return True
        
        return False
    
    
    

#content_writer_agent.py
# content_writer_agent.py
import asyncio
import logging
import json
from pathlib import Path
from typing import Dict
from datetime import datetime

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class ContentWriterAgent:
    """å¼·åŒ–ç‰ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI - ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªæ§‹é€ åŒ–HTMLè¨˜äº‹ã‚’ç”Ÿæˆ"""
    
    CONTENT_WRITER_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aå¸‚å ´ã«é–¢ã™ã‚‹å°‚é–€çŸ¥è­˜ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- æŒ‡å®šã•ã‚ŒãŸURLã®è¨˜äº‹ã‚’èª­ã¿ã€ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aã«èˆˆå‘³ãŒã‚ã‚‹ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼å‘ã‘ã«æœ‰ç›Šãªè¨˜äº‹ã‚’ä½œæˆ
- ãƒ–ãƒ­ã‚°ã«ãã®ã¾ã¾æ²è¼‰ã§ãã‚‹é«˜å“è³ªã®æ§‹é€ åŒ–HTMLè¨˜äº‹ã‚’åŸ·ç­†
- SEOã‚’æ„è­˜ã—ãŸæ§‹æˆã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰é…ç½®
- å¤šè¨€èªå¯¾å¿œï¼ˆæ—¥æœ¬èª/è‹±èª/ãƒ­ã‚·ã‚¢èªãªã©ï¼‰

ã€åŸ·ç­†ã®åŸå‰‡ã€‘
1. ã€Œäº†è§£ã—ã¾ã—ãŸï¼ã€ãªã©ã®æŒ¨æ‹¶ã¯ä¸€åˆ‡ä¸è¦
2. æœ€åˆã‹ã‚‰å®Œå…¨ãªHTMLå½¢å¼ã§å‡ºåŠ›
3. æ•°å­—ã‚„é‡è¦ãªéƒ¨åˆ†ã¯<strong>ã‚¿ã‚°ã§å¼·èª¿
4. é©åˆ‡ãªè¦‹å‡ºã—æ§‹é€ ï¼ˆh2, h3ï¼‰ã¨æ®µè½ã§èª­ã¿ã‚„ã™ã
5. ãƒªã‚¹ãƒˆã‚’æ´»ç”¨ã—ãŸæ§‹é€ åŒ–
6. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…ï¼ˆãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼ã€æŠ•è³‡å®¶ï¼‰ã®é–¢å¿ƒã«åˆã‚ã›ãŸå†…å®¹

ã€è¨˜äº‹ã®é•·ã•ã€‘
- ç›®æ¨™æ–‡å­—æ•°: 1800ã€œ3500æ–‡å­—ã€2000~3000æ–‡å­—ç¨‹åº¦ãŒæœ€ã‚‚ãƒ™ã‚¹ãƒˆ
- ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ä¾¡å€¤ã®é«˜ã„å†…å®¹ã«é›†ä¸­
- å†—é•·ãªèª¬æ˜ã‚’é¿ã‘ã€é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã®ã¿ã‚’è¨˜è¼‰

ã€å‡ºåŠ›å½¢å¼ - ã‚·ãƒ³ãƒ—ãƒ«ãªHTMLæ§‹é€ ã€‘
ä»¥ä¸‹ã®HTMLæ§‹é€ ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

<article class="mna-article">
  <h1>è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ« - é­…åŠ›çš„ã§SEOã‚’æ„è­˜</h1>
  
  <div class="article-meta">
    <span class="publish-date">å…¬é–‹æ—¥: YYYYå¹´MMæœˆDDæ—¥</span>
    <span class="target-region">å¯¾è±¡åœ°åŸŸ: ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³</span>
  </div>
  
  <section class="intro">
    <h2>ã¯ã˜ã‚ã«</h2>
    <p>ã“ã®è¨˜äº‹ã®ãƒ†ãƒ¼ãƒã¨ä¾¡å€¤ã‚’ç°¡æ½”ã«èª¬æ˜ï¼ˆ2-3æ–‡ï¼‰</p>
  </section>
  
  <section class="main-content">
    <h2>ä¸»è¦ãƒã‚¤ãƒ³ãƒˆ</h2>
    <p>é‡è¦ãªæƒ…å ±ã‚’ç°¡æ½”ã«èª¬æ˜ï¼ˆ3-4æ®µè½ï¼‰</p>
    
    <div class="key-points">
      <h3>æ³¨ç›®ã™ã¹ãç‚¹</h3>
      <ul>
        <li><strong>ãƒã‚¤ãƒ³ãƒˆ1</strong>: ç°¡æ½”ãªèª¬æ˜</li>
        <li><strong>ãƒã‚¤ãƒ³ãƒˆ2</strong>: ç°¡æ½”ãªèª¬æ˜</li>
        <li><strong>ãƒã‚¤ãƒ³ãƒˆ3</strong>: ç°¡æ½”ãªèª¬æ˜</li>
      </ul>
    </div>
  </section>
  
  <section class="business-value">
    <h2>ãƒ“ã‚¸ãƒã‚¹æ©Ÿä¼š</h2>
    <p>ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aå¸‚å ´ã«ãŠã‘ã‚‹å…·ä½“çš„ãªæ©Ÿä¼šï¼ˆ2-3æ®µè½ï¼‰</p>
  </section>
  
  <section class="conclusion">
    <h2>ã¾ã¨ã‚</h2>
    <p>è¦ç‚¹ã‚’2-3æ–‡ã§ã¾ã¨ã‚ã‚‹</p>
  </section>
  
  <div class="article-footer">
    <p><strong>å‚ç…§å…ƒ</strong>: <a href="å…ƒè¨˜äº‹URL" target="_blank">å…ƒè¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«</a></p>
  </div>
</article>

ã€é‡è¦ãªåˆ¶ç´„ã€‘
- å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ç°¡æ½”ã«ï¼ˆ1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚ãŸã‚Š200-300æ–‡å­—ï¼‰
- å†—é•·ãªè¡¨ç¾ã‚’é¿ã‘ã‚‹
- å¿…ãšæœ€å¾Œï¼ˆ</article>ã‚¿ã‚°ï¼‰ã¾ã§å®Œçµã•ã›ã‚‹
"""

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
            else:
                self.output_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
                self.output_folder.mkdir(exist_ok=True, parents=True)
        else:
            self.output_folder = output_folder
    
    async def process_task(self, task: Dict) -> Dict:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç† - ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªæ§‹é€ åŒ–HTMLå‡ºåŠ›"""
        try:
            logger.info(f"ğŸ”§ å¼·åŒ–ç‰ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI: ã‚¿ã‚¹ã‚¯å‡¦ç†é–‹å§‹")
            logger.info(f"ã‚¿ã‚¹ã‚¯: {task['description'][:100]}...")
            
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰è¦ä»¶ã‚’æŠ½å‡º
            task_info = self._parse_task_requirements(task['description'])
            
            # ã‚¿ã‚¹ã‚¯ã«æ˜ç¤ºçš„ãªè¨€èªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å ´åˆã¯å„ªå…ˆ
            if 'language' in task and task['language']:
                task_info['language'] = task['language']
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰è¨€èªã‚’å–å¾—: {task_info['language']}")
            
            logger.info(f"  URL: {task_info['url'][:60] if task_info['url'] else '(URLãªã—)'}...")
            logger.info(f"  è¨€èª: {task_info['language']}")
            logger.info(f"  ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: {task_info['target_audience']}")
            
            # è¨€èªåˆ¥ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆèª¿æ•´
            language_specific_prompt = self._get_language_specific_prompt(task_info['language'])
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰ï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆç‰ˆï¼‰
            full_prompt = f"""{self.CONTENT_WRITER_PROMPT}

{language_specific_prompt}

ã€å…·ä½“çš„ãªåŸ·ç­†ä¾é ¼ã€‘
å‚ç…§URL: {task_info['url']}
ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…: {task_info['target_audience']}
è¨€èª: {task_info['language']}

ã€å³å®ˆäº‹é …ã€‘
1. ä¸Šè¨˜URLã®è¨˜äº‹ã‚’èª­ã¿ã€{task_info['target_audience']}å‘ã‘ã«æœ‰ç›Šãªè¨˜äº‹ã‚’ä½œæˆ
2. ç›®æ¨™æ–‡å­—æ•°: 1500ã€œ1800æ–‡å­—ï¼ˆã“ã‚Œã‚’çµ¶å¯¾ã«è¶…ãˆãªã„ï¼‰
3. å®Œå…¨ãªHTMLå½¢å¼ã§å‡ºåŠ›ï¼ˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ä¸å¯ï¼‰
4. è¦‹å‡ºã—æ§‹é€ ï¼ˆh1, h2, h3ï¼‰ã‚’é©åˆ‡ã«ä½¿ç”¨
5. é‡è¦ãªæ•°å­—ã¯<strong>ã‚¿ã‚°ã§å¼·èª¿
6. è¨˜äº‹å…¨ä½“ã‚’{task_info['language']}ã§åŸ·ç­†
7. å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ç°¡æ½”ã«ï¼ˆ1ã‚»ã‚¯ã‚·ãƒ§ãƒ³200-300æ–‡å­—ï¼‰

ã€æœ€é‡è¦ã€‘
- è¨˜äº‹ã¯å¿…ãšå®Œçµã•ã›ã‚‹ï¼ˆé€”ä¸­ã§çµ‚ã‚ã‚‰ãªã„ï¼‰
- </article>ã‚¿ã‚°ã§å¿…ãšé–‰ã˜ã‚‹
- conclusionã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨article-footerã‚’å¿…ãšå«ã‚ã‚‹
- é•·ã™ãã‚‹è¨˜äº‹ã¯é€”ä¸­ã§åˆ‡ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«æ›¸ã

**1800æ–‡å­—ä»¥å†…ã§ã€HTMLã‚¿ã‚°ã‚’ä½¿ç”¨ã—ãŸå®Œå…¨ãªè¨˜äº‹ã‚’æœ€å¾Œã¾ã§æ›¸ãåˆ‡ã£ã¦ãã ã•ã„ã€‚**"""
            
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªæ§‹é€ åŒ–HTMLè¨˜äº‹ä½œæˆã‚’ä¾é ¼ä¸­...")
            logger.info(f"  ç›®æ¨™æ–‡å­—æ•°: 1500ã€œ1800æ–‡å­—")
            logger.info(f"  ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé•·: {len(full_prompt)}æ–‡å­—")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªã®ã§çŸ­ã‚ã§OKï¼‰
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                return {
                    'success': False,
                    'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
            
            # å¿œç­”ã‚’å–å¾—
            article_html = await self.browser.extract_latest_text_response()
            
            if not article_html:
                return {
                    'success': False,
                    'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI: è¨˜äº‹å–å¾—å¤±æ•—'
                }
            
            logger.info(f"âœ… æ§‹é€ åŒ–HTMLè¨˜äº‹ç”Ÿæˆå®Œäº†: {len(article_html)}æ–‡å­—")
            
            # HTMLã®å®Œå…¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if not self._validate_html_completeness(article_html):
                logger.warning("âš ï¸ è¨˜äº‹ãŒé€”ä¸­ã§é€”åˆ‡ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
            
            # ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºï¼ˆæœ€åˆã®<h1>ã‚¿ã‚°ï¼‰
            import re
            title_match = re.search(r'<h1[^>]*>(.+?)</h1>', article_html, re.IGNORECASE | re.DOTALL)
            article_title = title_match.group(1).strip() if title_match else "ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜ï¼‰"
            
            logger.info(f"  è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«: {article_title}")
            
            # JSONå½¢å¼ã§ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ã¨ã‚‚ã«ä¿å­˜
            article_data = {
                'task_id': task['task_id'],
                'title': article_title,
                'html_content': article_html,
                'language': task_info['language'],
                'target_audience': task_info['target_audience'],
                'source_url': task_info['url'],
                'created_at': datetime.now().isoformat(),
                'word_count': len(article_html),
                'content_type': 'structured_html_compact',
                'is_complete': self._validate_html_completeness(article_html)
            }
            
            # JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜
            json_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            json_output_path = self.output_folder / json_filename
            
            with open(json_output_path, 'w', encoding='utf-8') as f:
                json.dump(article_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"æ§‹é€ åŒ–è¨˜äº‹ã‚’JSONä¿å­˜: {json_filename}")
            
            # HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚‚åˆ¥é€”ä¿å­˜ï¼ˆç¢ºèªç”¨ï¼‰
            html_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            html_output_path = self.output_folder / html_filename
            
            with open(html_output_path, 'w', encoding='utf-8') as f:
                f.write("<!DOCTYPE html>\n")
                f.write("<html lang='ja'>\n")
                f.write("<head>\n")
                f.write("<meta charset='UTF-8'>\n")
                f.write("<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n")
                f.write(f"<title>{article_title}</title>\n")
                f.write("<style>\n")
                f.write("body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.8; margin: 40px; max-width: 800px; margin: 0 auto; padding: 40px; }\n")
                f.write("h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 15px; font-size: 28px; }\n")
                f.write("h2 { color: #34495e; margin-top: 35px; font-size: 22px; border-left: 4px solid #3498db; padding-left: 10px; }\n")
                f.write("h3 { color: #16a085; font-size: 18px; margin-top: 20px; }\n")
                f.write(".article-meta { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 25px 0; font-size: 14px; }\n")
                f.write(".key-points { background: #e8f4fd; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3498db; }\n")
                f.write(".article-footer { margin-top: 50px; padding-top: 25px; border-top: 2px solid #ddd; color: #666; }\n")
                f.write("ul { line-height: 1.8; }\n")
                f.write("li { margin-bottom: 10px; }\n")
                f.write("strong { color: #e74c3c; }\n")
                f.write("p { margin-bottom: 15px; }\n")
                f.write("</style>\n")
                f.write("</head>\n")
                f.write("<body>\n")
                f.write(article_html)
                f.write("</body>\n")
                f.write("</html>\n")
            
            logger.info(f"HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚ä¿å­˜: {html_filename}")
            
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ
            article_preview = self._extract_text_preview(article_html)
            
            summary = f"è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«: {article_title}\nè¨€èª: {task_info['language']}\næ–‡å­—æ•°: {len(article_html)}\nå®Œå…¨æ€§: {'âœ… å®Œå…¨' if article_data['is_complete'] else 'âš ï¸ ä¸å®Œå…¨'}\nãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼: {article_preview}"
            
            return {
                'success': True,
                'output_file': str(json_output_path),
                'html_file': str(html_output_path),
                'summary': summary,
                'full_text': article_html,
                'article_title': article_title,
                'content_type': 'structured_html_compact',
                'language': task_info['language'],
                'is_complete': article_data['is_complete']
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "å¼·åŒ–ç‰ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _validate_html_completeness(self, html_content: str) -> bool:
        """HTMLãŒå®Œå…¨ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯"""
        import re
        
        # å¿…é ˆè¦ç´ ãŒã™ã¹ã¦å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        required_elements = [
            r'<article[^>]*>',           # é–‹å§‹ã‚¿ã‚°
            r'</article>',                # çµ‚äº†ã‚¿ã‚°
            r'<section[^>]*class="conclusion"',  # ã¾ã¨ã‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³
            r'<div[^>]*class="article-footer"'   # ãƒ•ãƒƒã‚¿ãƒ¼
        ]
        
        for pattern in required_elements:
            if not re.search(pattern, html_content, re.IGNORECASE):
                logger.warning(f"âš ï¸ å¿…é ˆè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {pattern}")
                return False
        
        return True
    
    def _get_language_specific_prompt(self, language: str) -> str:
        """è¨€èªåˆ¥ã®è¿½åŠ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¿”ã™"""
        prompts = {
            "æ—¥æœ¬èª": """
ã€æ—¥æœ¬èªè¨˜äº‹ã®ç‰¹å¾´ã€‘
- å¿…ãšæ—¥æœ¬èªï¼ˆã²ã‚‰ãŒãªã€ã‚«ã‚¿ã‚«ãƒŠã€æ¼¢å­—ã‚’å«ã‚€è‡ªç„¶ãªæ—¥æœ¬èªï¼‰ã§åŸ·ç­†
- æ•¬èªã‚’ä½¿ç”¨ã—ã€ãƒ“ã‚¸ãƒã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒ«ãªæ–‡ä½“ã‚’ç¶­æŒ
- å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿ã¨ã¨ã‚‚ã«èª¬æ˜ã‚’å±•é–‹
- ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aå¸‚å ´ã«ãŠã‘ã‚‹æ—¥æœ¬ä¼æ¥­ã®è¦–ç‚¹ã‚’é‡è¦–
- èª­è€…ï¼ˆæ—¥æœ¬ã®ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼ï¼‰ãŒç†è§£ã—ã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ç”¨
- 1500ã€œ1800æ–‡å­—ä»¥å†…ã«ã¾ã¨ã‚ã‚‹

ã€åŸ·ç­†æ™‚ã®æ³¨æ„ç‚¹ã€‘
- è‹±èªã‚„ä»–è¨€èªã¯å›ºæœ‰åè©ãƒ»å°‚é–€ç”¨èªä»¥å¤–ã§ã¯ä½¿ç”¨ã—ãªã„
- æ•°å­—ã¯åŠè§’ã€å˜ä½ã¯å…¨è§’ï¼ˆä¾‹: 6%ã€100å„„å††ï¼‰
- å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ç°¡æ½”ã«200-300æ–‡å­—ç¨‹åº¦
- è¨˜äº‹ã¯å¿…ãšæœ€å¾Œï¼ˆ</article>ã‚¿ã‚°ï¼‰ã¾ã§å®Œçµã•ã›ã‚‹
""",
            "English": """
ã€English Article Featuresã€‘
- Write entirely in English (no Japanese characters except proper nouns)
- Use business formal English throughout
- Include specific data and examples
- Focus on investment opportunities in Uzbekistan's M&A market
- Target international business owners and investors
- Keep article between 1500-1800 characters
- Complete the article with proper conclusion and footer sections
""",
            "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ãƒ­ã‚·ã‚¢èª)": """
ã€Ğ ÑƒÑÑĞºĞ¾ÑĞ·Ñ‹Ñ‡Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ã€‘
- ĞŸĞ¸ÑˆĞ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ´ĞµĞ»Ğ¾Ğ²Ğ¾Ğ¹ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
- Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹
- ĞĞºÑ†ĞµĞ½Ñ‚ Ğ½Ğ° Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑÑ… ÑĞ»Ğ¸ÑĞ½Ğ¸Ğ¹ Ğ¸ Ğ¿Ğ¾Ğ³Ğ»Ğ¾Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ² Ğ£Ğ·Ğ±ĞµĞºĞ¸ÑÑ‚Ğ°Ğ½Ğµ
- Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ - Ñ€ÑƒÑÑĞºĞ¾ÑĞ·Ñ‹Ñ‡Ğ½Ñ‹Ğµ Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¾Ñ€Ñ‹
- ĞĞ±ÑŠÑ‘Ğ¼ ÑÑ‚Ğ°Ñ‚ÑŒĞ¸: 1500-1800 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
- Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ñ‹Ğ¼ Ğ·Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ĞµĞ¼
"""
        }
        return prompts.get(language, prompts["æ—¥æœ¬èª"])
    
    def _extract_text_preview(self, html_content: str) -> str:
        """HTMLã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŠ½å‡º"""
        import re
        # HTMLã‚¿ã‚°ã‚’é™¤å»
        text = re.sub(r'<[^>]+>', ' ', html_content)
        # é€£ç¶šã™ã‚‹ç©ºç™½ã‚’å˜ä¸€ã‚¹ãƒšãƒ¼ã‚¹ã«
        text = re.sub(r'\s+', ' ', text)
        # å…ˆé ­200æ–‡å­—ã‚’è¿”ã™
        return text.strip()[:200] + "..." if len(text) > 200 else text
    
    def _parse_task_requirements(self, description: str) -> Dict[str, str]:
        """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰è¦ä»¶ã‚’æŠ½å‡ºï¼ˆæ—¥æœ¬èªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç‰ˆï¼‰"""
        import re
        
        # URLã‚’æŠ½å‡º
        url_match = re.search(r'https?://[^\s]+', description)
        url = url_match.group(0) if url_match else ""
        
        # === è¨€èªæ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæ—¥æœ¬èªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæˆ¦ç•¥ï¼‰ ===
        # åŸºæœ¬æ–¹é‡: æ˜ç¤ºçš„ãªæŒ‡å®šãŒãªã„é™ã‚Šã€å¸¸ã«æ—¥æœ¬èªã§ç”Ÿæˆ
        language = "æ—¥æœ¬èª"  # çµ¶å¯¾çš„ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        
        # æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆéå¸¸ã«å³æ ¼ã«ï¼‰
        explicit_lang_patterns = {
            "English": [
                r'è‹±èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'write in english',
                r'in english(?:\s+language)?',
                r'create.*in english',
                r'è¨€èª[ï¼š:]\s*(?:è‹±èª|English)'
            ],
            "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ãƒ­ã‚·ã‚¢èª)": [
                r'ãƒ­ã‚·ã‚¢èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼(?:\s+ÑĞ·Ñ‹ĞºĞµ)?',
                r'in russian',
                r'è¨€èª[ï¼š:]\s*(?:ãƒ­ã‚·ã‚¢èª|Ñ€ÑƒÑÑĞºĞ¸Ğ¹)'
            ],
            "ä¸­æ–‡": [
                r'ä¸­å›½èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'ä¸­æ–‡ã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'in chinese',
                r'ç”¨ä¸­æ–‡',
                r'è¨€èª[ï¼š:]\s*(?:ä¸­å›½èª|ä¸­æ–‡|Chinese)'
            ],
            "í•œêµ­ì–´": [
                r'éŸ“å›½èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'í•œêµ­ì–´ë¡œ',
                r'in korean',
                r'è¨€èª[ï¼š:]\s*(?:éŸ“å›½èª|í•œêµ­ì–´)'
            ],
            "TÃ¼rkÃ§e": [
                r'ãƒˆãƒ«ã‚³èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'tÃ¼rkÃ§e(?:\'de)?',
                r'in turkish',
                r'è¨€èª[ï¼š:]\s*(?:ãƒˆãƒ«ã‚³èª|TÃ¼rkÃ§e)'
            ],
            "O'zbek": [
                r'ã‚¦ã‚ºãƒ™ã‚¯èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'o\'zbek tilida',
                r'in uzbek',
                r'è¨€èª[ï¼š:]\s*(?:ã‚¦ã‚ºãƒ™ã‚¯èª|O\'zbek)'
            ]
        }
        
        # æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šã‚’ãƒã‚§ãƒƒã‚¯
        explicit_lang_found = False
        for lang, patterns in explicit_lang_patterns.items():
            for pattern in patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    language = lang
                    explicit_lang_found = True
                    logger.info(f"âœ… æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šã‚’æ¤œå‡º: {language}")
                    logger.info(f"   ãƒãƒƒãƒã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³: {pattern}")
                    break
            if explicit_lang_found:
                break
        
        # æ˜ç¤ºçš„ãªæŒ‡å®šãŒãªã‹ã£ãŸå ´åˆ
        if not explicit_lang_found:
            logger.info("ğŸ“Œ æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šãªã— â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ—¥æœ¬èªã‚’ä½¿ç”¨")
            
            # è£œåŠ©çš„ãªåˆ¤å®šï¼ˆæ¥µç«¯ãªã‚±ãƒ¼ã‚¹ã®ã¿ï¼‰
            # ã‚­ãƒªãƒ«æ–‡å­—ãŒå¤§åŠã‚’å ã‚ã‚‹å ´åˆã®ã¿ãƒ­ã‚·ã‚¢èªã¨åˆ¤å®š
            cyrillic_count = len(re.findall(r'[Ğ-Ğ¯Ğ°-ÑĞÑ‘]', description))
            total_chars = len(re.sub(r'\s', '', description))
            
            # ãƒãƒ³ã‚°ãƒ«ãŒå¤§åŠã‚’å ã‚ã‚‹å ´åˆã®ã¿éŸ“å›½èªã¨åˆ¤å®š
            hangul_count = len(re.findall(r'[ê°€-í£]', description))
            
            if total_chars > 0:
                if cyrillic_count > total_chars * 0.3:  # 30%ä»¥ä¸ŠãŒã‚­ãƒªãƒ«æ–‡å­—
                    language = "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ãƒ­ã‚·ã‚¢èª)"
                    logger.info(f"ğŸ” ã‚­ãƒªãƒ«æ–‡å­—ãŒå¤šæ•°ï¼ˆ{cyrillic_count}/{total_chars}ï¼‰: ãƒ­ã‚·ã‚¢èª")
                elif hangul_count > total_chars * 0.3:  # 30%ä»¥ä¸ŠãŒãƒãƒ³ã‚°ãƒ«
                    language = "í•œêµ­ì–´"
                    logger.info(f"ğŸ” ãƒãƒ³ã‚°ãƒ«ãŒå¤šæ•°ï¼ˆ{hangul_count}/{total_chars}ï¼‰: éŸ“å›½èª")
                else:
                    # ãã‚Œä»¥å¤–ã¯å…¨ã¦æ—¥æœ¬èªï¼ˆã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠãƒ»æ¼¢å­—ãƒ»è‹±æ•°å­—æ··åœ¨å«ã‚€ï¼‰
                    logger.info("ğŸ“ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨€èªç¢ºå®š: æ—¥æœ¬èª")
        
        # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…ã‚’æŠ½å‡º
        target_patterns = [
            r'(.+?)å‘ã‘ã«',
            r'(.+?)å‘ã‘ã®',
            r'ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ[ï¼š:]\s*(.+)',
            r'for (.+?) considering',
            r'Ğ´Ğ»Ñ (.+?),',
            r'å¯¾è±¡èª­è€…[ï¼š:]\s*(.+)'
        ]
        target_audience = ""
        for pattern in target_patterns:
            match = re.search(pattern, description)
            if match:
                target_audience = match.group(1).strip()
                break
        
        if not target_audience:
            target_audience = "ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aã«èˆˆå‘³ãŒã‚ã‚‹ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼"
        
        # ç‰¹åˆ¥ãªè¦ä»¶ã‚’æŠ½å‡º
        requirements = []
        if 'æ§‹é€ åŒ–' in description or 'HTML' in description.upper():
            requirements.append("æ§‹é€ åŒ–HTMLå½¢å¼ã§å‡ºåŠ›")
        if 'ãƒ‡ãƒ¼ã‚¿' in description or 'æ•°å­—' in description:
            requirements.append("å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿ã¨æ•°å­—ã‚’å«ã‚ã‚‹")
        if 'äº‹ä¾‹' in description or 'ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£' in description:
            requirements.append("å®Ÿéš›ã®äº‹ä¾‹ã‚„ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã‚’å«ã‚ã‚‹")
        
        logger.info(f"ğŸ“ æœ€çµ‚æ±ºå®šè¨€èª: {language}")
        logger.info(f"ğŸ¯ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…: {target_audience}")
        
        def _get_translation_prompt(self, source_language: str, target_language: str) -> str:
            """ç¿»è¨³ã‚¿ã‚¹ã‚¯ç”¨ã®è¿½åŠ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"""
            return f"""
        ã€ç¿»è¨³ã‚¿ã‚¹ã‚¯ã®æŒ‡ç¤ºã€‘
        ã“ã‚Œã¯ç¿»è¨³ã‚¿ã‚¹ã‚¯ã§ã™ã€‚ä»¥ä¸‹ã®æŒ‡ç¤ºã«å³å¯†ã«å¾“ã£ã¦ãã ã•ã„ï¼š

        1. å…ƒã®è¨˜äº‹ã®å†…å®¹ã‚’{target_language}ã«æ­£ç¢ºã«ç¿»è¨³
        2. HTMLæ§‹é€ ã¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç¶­æŒ
        3. æ–‡åŒ–çš„ãªé•ã„ã‚’è€ƒæ…®ã—ãŸè‡ªç„¶ãªè¡¨ç¾ã‚’ä½¿ç”¨
        4. å°‚é–€ç”¨èªã¯æ­£ç¢ºã«ç¿»è¨³
        5. æ•°å­—ã‚„ãƒ‡ãƒ¼ã‚¿ã¯ãã®ã¾ã¾ä¿æŒ

        ç¿»è¨³å…ƒè¨€èª: {source_language}
        ç¿»è¨³å…ˆè¨€èª: {target_language}

        **é‡è¦: ç¿»è¨³å¾Œã®è¨˜äº‹ã¯å®Œå…¨ãªHTMLå½¢å¼ã§ã€å¿…ãš</article>ã‚¿ã‚°ã§çµ‚äº†ã™ã‚‹ã“ã¨**
        """
        
        return {
            'url': url,
            'language': language,
            'target_audience': target_audience,
            'requirements': 'ã€'.join(requirements) if requirements else "æ¨™æº–çš„ãªæ§‹é€ åŒ–è¨˜äº‹"
        }

#design_agent.py
import asyncio
import logging
from pathlib import Path
from typing import Dict
from datetime import datetime

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class DesignAgent:
    """è¨­è¨ˆAI - è¦ä»¶å®šç¾©ã€è¨­è¨ˆæ›¸ã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’ä½œæˆ"""
    
    DESIGN_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆè€…ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- è¦ä»¶å®šç¾©æ›¸ã®ä½œæˆ
- ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®è¨­è¨ˆ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã®è¨­è¨ˆ
- APIä»•æ§˜ã®å®šç¾©
- æŠ€è¡“é¸å®šã¨ç†ç”±ã®èª¬æ˜

ã€è¨­è¨ˆã®åŸå‰‡ã€‘
1. å®Ÿè£…å¯èƒ½æ€§ã‚’æœ€å„ªå…ˆã™ã‚‹
2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã™ã‚‹
3. ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’æ„è­˜ã™ã‚‹
4. é–‹ç™ºè€…ãŒç†è§£ã—ã‚„ã™ã„æ–‡æ›¸ã‚’ä½œæˆ

ã€å‡ºåŠ›å½¢å¼ã€‘
ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã«å¿œã˜ã¦ã€ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

## ã‚¿ã‚¹ã‚¯æ¦‚è¦
ï¼ˆã‚¿ã‚¹ã‚¯ã®ç†è§£ã¨ç›®çš„ï¼‰

## è¨­è¨ˆå†…å®¹
ï¼ˆå…·ä½“çš„ãªè¨­è¨ˆå†…å®¹ï¼‰

## æŠ€è¡“é¸å®š
ï¼ˆä½¿ç”¨ã™ã‚‹æŠ€è¡“ã¨ãã®ç†ç”±ï¼‰

## å®Ÿè£…ã«ãŠã‘ã‚‹æ³¨æ„ç‚¹
ï¼ˆé–‹ç™ºæ™‚ã®æ³¨æ„äº‹é …ï¼‰

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
ï¼ˆã“ã®ã‚¿ã‚¹ã‚¯å¾Œã«è¡Œã†ã¹ãã“ã¨ï¼‰"""

    # design_agent.py ã® __init__ ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯B14ã‹ã‚‰å–å¾—
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"Agentå‡ºåŠ›å…ˆï¼ˆB14ã‹ã‚‰å–å¾—ï¼‰: {self.output_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ã‚¹
                self.output_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.warning(f"B14ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.output_folder}")
        else:
            self.output_folder = output_folder
    
    async def process_task(self, task: Dict) -> Dict:
        """è¨­è¨ˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            logger.info(f"è¨­è¨ˆAI: ã‚¿ã‚¹ã‚¯å‡¦ç†é–‹å§‹ - {task['description']}")
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"""{self.DESIGN_SYSTEM_PROMPT}

ã€ã‚¿ã‚¹ã‚¯ã€‘
{task['description']}

ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦ã€è©³ç´°ãªè¨­è¨ˆã‚’è¡Œã£ã¦ãã ã•ã„ã€‚
å®Ÿè£…å¯èƒ½ã§å…·ä½“çš„ãªè¨­è¨ˆæ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚"""
            
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«è¨­è¨ˆã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                return {
                    'success': False,
                    'error': 'è¨­è¨ˆAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
            
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': 'è¨­è¨ˆAI: å¿œç­”å–å¾—å¤±æ•—'
                }
            
            logger.info(f"è¨­è¨ˆAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # çµæœã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            filename = f"design_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            output_path = self.output_folder / filename
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# è¨­è¨ˆæ›¸: {task['description']}\n\n")
                f.write(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
            
            logger.info(f"è¨­è¨ˆæ›¸ã‚’ä¿å­˜: {output_path}")
            
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆï¼ˆæœ€åˆã®500æ–‡å­—ï¼‰
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
            
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "è¨­è¨ˆAIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }

#dev_agent.py
# dev_agent.py
"""é–‹ç™ºAI - ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã€WordPresså°‚ç”¨æ©Ÿèƒ½ã®ä½œæˆ"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class DevAgent:
    """é–‹ç™ºAI - ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã€WordPresså°‚ç”¨æ©Ÿèƒ½ã®ä½œæˆ"""
    
    DEV_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- é«˜å“è³ªãªã‚³ãƒ¼ãƒ‰ã®å®Ÿè£…
- ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®ä½œæˆ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å®Ÿè£…
- ã‚³ãƒ¡ãƒ³ãƒˆã¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®ä½œæˆ

ã€ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°åŸå‰‡ã€‘
1. å¯èª­æ€§ã®é«˜ã„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã™ã‚‹
3. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’é©åˆ‡ã«è¡Œã†
4. ãƒ†ã‚¹ãƒˆå¯èƒ½ãªè¨­è¨ˆã«ã™ã‚‹
5. æœ€æ–°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å¾“ã†

ã€å‡ºåŠ›å½¢å¼ã€‘
ä»¥ä¸‹ã®å½¢å¼ã§ã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

## ã‚¿ã‚¹ã‚¯æ¦‚è¦
ï¼ˆã‚¿ã‚¹ã‚¯ã®ç†è§£ï¼‰

## å®Ÿè£…å†…å®¹
ï¼ˆå®Ÿè£…ã®èª¬æ˜ï¼‰

## ã‚³ãƒ¼ãƒ‰
```python
# ã¾ãŸã¯ä»–ã®è¨€èª
# å®Œå…¨ã«å‹•ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰
```

## ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰
```python
# å˜ä½“ãƒ†ã‚¹ãƒˆã¾ãŸã¯çµ±åˆãƒ†ã‚¹ãƒˆ
```

## ä½¿ç”¨æ–¹æ³•
ï¼ˆã‚³ãƒ¼ãƒ‰ã®ä½¿ã„æ–¹ï¼‰

## æ³¨æ„äº‹é …
ï¼ˆå®Ÿè£…æ™‚ã®æ³¨æ„ç‚¹ã‚„åˆ¶ç´„ï¼‰"""

    WORDPRESS_CPT_PROMPT = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€WordPress ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã®å°‚é–€å®¶ã€‘

ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å®Œå…¨ã«å‹•ä½œã™ã‚‹WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®PHPã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

ã€å¿…é ˆè¦ç´ ã€‘
1. register_post_type() é–¢æ•°ã‚’ä½¿ç”¨
2. é©åˆ‡ãªãƒ©ãƒ™ãƒ«ï¼ˆlabelsï¼‰ã®å®šç¾©
3. ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆsupportsï¼‰ã®æŒ‡å®š
4. ç®¡ç†ç”»é¢ã§ã®è¡¨ç¤ºè¨­å®š
5. REST APIå¯¾å¿œ
6. ãƒªãƒ©ã‚¤ãƒˆãƒ«ãƒ¼ãƒ«
7. ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒšãƒ¼ã‚¸ã®æœ‰åŠ¹åŒ–

ã€å‡ºåŠ›å½¢å¼ã€‘
ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

## ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {post_type_slug}

### æ¦‚è¦
ï¼ˆã“ã®ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®èª¬æ˜ï¼‰

### functions.php ã«è¿½åŠ ã™ã‚‹ã‚³ãƒ¼ãƒ‰

```php
<?php
/**
 * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {post_type_slug}
 * 
 * @package WordPress
 * @since 1.0.0
 */

// ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®ç™»éŒ²
function register_cpt_{post_type_slug}() {{
    $labels = array(
        'name'                  => _x( '{plural_name}', 'Post Type General Name', 'textdomain' ),
        'singular_name'         => _x( '{singular_name}', 'Post Type Singular Name', 'textdomain' ),
        'menu_name'             => __( '{menu_name}', 'textdomain' ),
        'name_admin_bar'        => __( '{singular_name}', 'textdomain' ),
        'archives'              => __( '{plural_name} ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–', 'textdomain' ),
        'attributes'            => __( '{singular_name} å±æ€§', 'textdomain' ),
        'parent_item_colon'     => __( 'è¦ª {singular_name}:', 'textdomain' ),
        'all_items'             => __( 'ã™ã¹ã¦ã® {plural_name}', 'textdomain' ),
        'add_new_item'          => __( 'æ–°è¦ {singular_name} ã‚’è¿½åŠ ', 'textdomain' ),
        'add_new'               => __( 'æ–°è¦è¿½åŠ ', 'textdomain' ),
        'new_item'              => __( 'æ–°è¦ {singular_name}', 'textdomain' ),
        'edit_item'             => __( '{singular_name} ã‚’ç·¨é›†', 'textdomain' ),
        'update_item'           => __( '{singular_name} ã‚’æ›´æ–°', 'textdomain' ),
        'view_item'             => __( '{singular_name} ã‚’è¡¨ç¤º', 'textdomain' ),
        'view_items'            => __( '{plural_name} ã‚’è¡¨ç¤º', 'textdomain' ),
        'search_items'          => __( '{plural_name} ã‚’æ¤œç´¢', 'textdomain' ),
        'not_found'             => __( 'è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'textdomain' ),
        'not_found_in_trash'    => __( 'ã‚´ãƒŸç®±ã«ã‚ã‚Šã¾ã›ã‚“', 'textdomain' ),
        'featured_image'        => __( 'ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒç”»åƒ', 'textdomain' ),
        'set_featured_image'    => __( 'ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒç”»åƒã‚’è¨­å®š', 'textdomain' ),
        'remove_featured_image' => __( 'ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒç”»åƒã‚’å‰Šé™¤', 'textdomain' ),
        'use_featured_image'    => __( 'ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒç”»åƒã¨ã—ã¦ä½¿ç”¨', 'textdomain' ),
        'insert_into_item'      => __( '{singular_name} ã«æŒ¿å…¥', 'textdomain' ),
        'uploaded_to_this_item' => __( 'ã“ã® {singular_name} ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰', 'textdomain' ),
        'items_list'            => __( '{plural_name} ãƒªã‚¹ãƒˆ', 'textdomain' ),
        'items_list_navigation' => __( '{plural_name} ãƒªã‚¹ãƒˆãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³', 'textdomain' ),
        'filter_items_list'     => __( '{plural_name} ãƒªã‚¹ãƒˆã‚’ãƒ•ã‚£ãƒ«ã‚¿', 'textdomain' ),
    );
    
    $args = array(
        'label'                 => __( '{singular_name}', 'textdomain' ),
        'description'           => __( '{description}', 'textdomain' ),
        'labels'                => $labels,
        'supports'              => array( {supports} ),
        'taxonomies'            => array( {taxonomies} ),
        'hierarchical'          => {hierarchical},
        'public'                => true,
        'show_ui'               => true,
        'show_in_menu'          => true,
        'menu_position'         => 5,
        'menu_icon'             => '{menu_icon}',
        'show_in_admin_bar'     => true,
        'show_in_nav_menus'     => true,
        'can_export'            => true,
        'has_archive'           => true,
        'exclude_from_search'   => false,
        'publicly_queryable'    => true,
        'capability_type'       => 'post',
        'show_in_rest'          => true,
        'rest_base'             => '{rest_base}',
        'rest_controller_class' => 'WP_REST_Posts_Controller',
        'rewrite'               => array(
            'slug'       => '{slug}',
            'with_front' => false,
        ),
    );
    
    register_post_type( '{post_type_slug}', $args );
}}
add_action( 'init', 'register_cpt_{post_type_slug}', 0 );
?>
```

### é–¢é€£ã™ã‚‹ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰

```php
<?php
// ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚’ã“ã“ã«è¿½åŠ 
?>
```

### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«

#### single-{post_type_slug}.php
```php
<?php
// å˜ä¸€æŠ•ç¨¿è¡¨ç¤ºç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
?>
```

#### archive-{post_type_slug}.php
```php
<?php
// ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–è¡¨ç¤ºç”¨ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
?>
```

### ä½¿ç”¨æ–¹æ³•

1. ä¸Šè¨˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ `functions.php` ã¾ãŸã¯å°‚ç”¨ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã«è¿½åŠ 
2. WordPressã®ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹
3. å·¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«ã€Œ{menu_name}ã€ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
4. ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šã‚’ä¿å­˜ï¼ˆè¨­å®š > ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šï¼‰

### æ³¨æ„äº‹é …

- ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®ã‚¹ãƒ©ãƒƒã‚°ã¯20æ–‡å­—ä»¥å†…ã«ã—ã¦ãã ã•ã„
- äºˆç´„èªï¼ˆpost, page, attachmentãªã©ï¼‰ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“
- ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã—ã¦å®Ÿè£…ã™ã‚‹å ´åˆã¯ã€é©åˆ‡ãªãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ±ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
- ãƒ†ãƒ¼ãƒã® functions.php ã«è¿½åŠ ã™ã‚‹å ´åˆã¯ã€å­ãƒ†ãƒ¼ãƒã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¾ã™
"""

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯B14ã‹ã‚‰å–å¾—
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"Agentå‡ºåŠ›å…ˆï¼ˆB14ã‹ã‚‰å–å¾—ï¼‰: {self.output_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ã‚¹
                self.output_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.warning(f"B14ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.output_folder}")
        else:
            self.output_folder = output_folder
        
        self.design_docs = {}  # è¨­è¨ˆæ›¸ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
        
    
    
    async def process_task(self, task: Dict) -> Dict:
        """é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆWordPresså¯¾å¿œå¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info(f"é–‹ç™ºAI: ã‚¿ã‚¹ã‚¯å‡¦ç†é–‹å§‹ - {task['description']}")
            
            # WordPress ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š
            if self._is_wordpress_cpt_task(task):
                return await self._process_wordpress_cpt_task(task)
            
            # WordPress ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š
            if self._is_wordpress_taxonomy_task(task):
                return await self._process_wordpress_taxonomy_task(task)
            
            # é€šå¸¸ã®é–‹ç™ºã‚¿ã‚¹ã‚¯
            return await self._process_general_task(task)
            
        except Exception as e:
            ErrorHandler.log_error(e, "é–‹ç™ºAIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _is_wordpress_cpt_task(self, task: Dict) -> bool:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š"""
        description = task.get('description', '').lower()
        keywords = [
            'custom post type',
            'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—',
            'cpt',
            'register_post_type',
            'æŠ•ç¨¿ã‚¿ã‚¤ãƒ—'
        ]
        return any(kw in description for kw in keywords)
    
    def _is_wordpress_taxonomy_task(self, task: Dict) -> bool:
        """WordPressã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š"""
        description = task.get('description', '').lower()
        keywords = [
            'taxonomy',
            'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼',
            'ã‚«ã‚¹ã‚¿ãƒ åˆ†é¡',
            'register_taxonomy'
        ]
        return any(kw in description for kw in keywords)
    
    async def _process_wordpress_cpt_task(self, task: Dict) -> Dict:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            logger.info("="*60)
            logger.info("WordPress ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯")
            logger.info("="*60)
            
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡º
            cpt_info = self._extract_cpt_info(task)
            
            logger.info(f"æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚¹ãƒ©ãƒƒã‚°: {cpt_info['slug']}")
            logger.info(f"è¡¨ç¤ºåï¼ˆå˜æ•°ï¼‰: {cpt_info['singular_name']}")
            logger.info(f"è¡¨ç¤ºåï¼ˆè¤‡æ•°ï¼‰: {cpt_info['plural_name']}")
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = self._build_wordpress_cpt_prompt(task, cpt_info)
            
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«è¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
    
            # å¿œç­”å¾…æ©Ÿï¼ˆè¦ä»¶å®šç¾©æ›¸ã¯é•·ã„ã®ã§300ç§’ï¼‰
            logger.info("â±ï¸ å¾…æ©Ÿæ™‚é–“: 300ç§’ï¼ˆè¦ä»¶å®šç¾©æ›¸ä½œæˆï¼‰")
    
            # ã“ã“ãŒä¿®æ­£ç®‡æ‰€ï¼
            success = await self.browser._wait_for_generation_complete()  # â† ã“ã®è¡Œã‚’ä¿®æ­£
            # ä¿®æ­£å¾Œ:
            # success = await self.browser.wait_for_text_generation(max_wait=300)
    
            if not success:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆè¦ä»¶å®šç¾©æ›¸ä½œæˆ: 300ç§’ï¼‰'
                }
            
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: å¿œç­”å–å¾—å¤±æ•—'
                }
            
            logger.info(f"é–‹ç™ºAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # çµæœã‚’ä¿å­˜
            output_files = self._save_wordpress_cpt_code(response_text, task, cpt_info)
            
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ
            summary = f"""âœ… WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆå®Œäº†

ã€æŠ•ç¨¿ã‚¿ã‚¤ãƒ—æƒ…å ±ã€‘
- ã‚¹ãƒ©ãƒƒã‚°: {cpt_info['slug']}
- è¡¨ç¤ºå: {cpt_info['singular_name']} / {cpt_info['plural_name']}
- ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½: {', '.join(cpt_info['supports'])}

ã€ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã€‘
"""
            for file_info in output_files:
                summary += f"- {file_info['type']}: {file_info['path'].name}\n"
            
            summary += f"\nã€æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã€‘\n"
            summary += f"1. functions.php ã¾ãŸã¯å°‚ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã«è¿½åŠ \n"
            summary += f"2. ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šã‚’ä¿å­˜ï¼ˆè¨­å®š > ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šï¼‰\n"
            summary += f"3. ç®¡ç†ç”»é¢ã§ã€Œ{cpt_info['menu_name']}ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç¢ºèª\n"
            
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'cpt_slug': cpt_info['slug']
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆ")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _extract_cpt_info(self, task: Dict) -> Dict:
        """ã‚¿ã‚¹ã‚¯ã‹ã‚‰ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®æƒ…å ±ã‚’æŠ½å‡º"""
        description = task.get('description', '')
        parameters = task.get('parameters', {})
        
        # parametersã‹ã‚‰å–å¾—ï¼ˆæœ€å„ªå…ˆï¼‰
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        cpt_info = {
            'slug': parameters.get('cpt_slug', 'ma_case'),
            'singular_name': parameters.get('singular_name', 'M&Aæ¡ˆä»¶'),
            'plural_name': parameters.get('plural_name', 'M&Aæ¡ˆä»¶ä¸€è¦§'),
            'menu_name': parameters.get('menu_name', 'M&Aæ¡ˆä»¶'),
            'description': parameters.get('description', 'M&Aæ¡ˆä»¶ã®ç®¡ç†'),
            'supports': parameters.get('supports', ['title', 'editor', 'thumbnail', 'custom-fields']),
            'taxonomies': parameters.get('taxonomies', []),
            'hierarchical': parameters.get('hierarchical', False),
            'menu_icon': parameters.get('menu_icon', 'dashicons-portfolio'),
            'rest_base': parameters.get('rest_base', None),
        }
        
        # rest_base ãŒæœªè¨­å®šã®å ´åˆã¯slugã‚’ä½¿ç”¨
        if not cpt_info['rest_base']:
            cpt_info['rest_base'] = cpt_info['slug']
        
        # descriptionã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        if 'ma_case' in description.lower() or 'm&a' in description.lower():
            cpt_info['slug'] = 'ma_case'
            cpt_info['singular_name'] = 'M&Aæ¡ˆä»¶'
            cpt_info['plural_name'] = 'M&Aæ¡ˆä»¶ä¸€è¦§'
            cpt_info['menu_name'] = 'M&Aæ¡ˆä»¶'
            cpt_info['description'] = 'M&Aæ¡ˆä»¶ã®ç®¡ç†'
            cpt_info['menu_icon'] = 'dashicons-portfolio'
        
        return cpt_info
    
    def _build_wordpress_cpt_prompt(self, task: Dict, cpt_info: Dict) -> str:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        supports_str = "'" + "', '".join(cpt_info['supports']) + "'"
        taxonomies_str = "'" + "', '".join(cpt_info['taxonomies']) + "'" if cpt_info['taxonomies'] else ""
        hierarchical_str = 'true' if cpt_info['hierarchical'] else 'false'
        
        prompt = self.WORDPRESS_CPT_PROMPT.format(
            post_type_slug=cpt_info['slug'],
            singular_name=cpt_info['singular_name'],
            plural_name=cpt_info['plural_name'],
            menu_name=cpt_info['menu_name'],
            description=cpt_info['description'],
            supports=supports_str,
            taxonomies=taxonomies_str,
            hierarchical=hierarchical_str,
            menu_icon=cpt_info['menu_icon'],
            rest_base=cpt_info['rest_base'],
            slug=cpt_info['slug']
        )
        
        prompt += f"""

ã€è¿½åŠ ã®è¦ä»¶ã€‘
{task.get('description', '')}

ã€æ³¨æ„äº‹é …ã€‘
- å®Œå…¨ã«å‹•ä½œã™ã‚‹å®Ÿè£…å¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„
- ã™ã¹ã¦ã®å¿…é ˆè¦ç´ ã‚’å«ã‚ã¦ãã ã•ã„
- æ—¥æœ¬èªã®ãƒ©ãƒ™ãƒ«ã‚’é©åˆ‡ã«è¨­å®šã—ã¦ãã ã•ã„
- ã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã‚ã¦å¯èª­æ€§ã‚’é«˜ã‚ã¦ãã ã•ã„
- ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å¾“ã£ã¦ãã ã•ã„

ä¸Šè¨˜ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å®Œå…¨ãªã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
"""
        
        return prompt
    
    def _save_wordpress_cpt_code(self, text: str, task: Dict, cpt_info: Dict) -> list:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜"""
        output_files = []
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # 1. å®Œå…¨ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ä¿å­˜
            doc_filename = f"cpt_{cpt_info['slug']}_{timestamp}.md"
            doc_path = self.output_folder / doc_filename
            
            with open(doc_path, 'w', encoding='utf-8') as f:
                f.write(f"# ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_info['slug']}\n\n")
                f.write(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(text)
            
            output_files.append({
                'type': 'ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ',
                'path': doc_path
            })
            logger.info(f"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä¿å­˜: {doc_filename}")
            
            # 2. PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã—ã¦ä¿å­˜
            php_code = self._extract_php_code(text)
            if php_code:
                php_filename = f"cpt_{cpt_info['slug']}_{timestamp}.php"
                php_path = self.output_folder / php_filename
                
                with open(php_path, 'w', encoding='utf-8') as f:
                    f.write("<?php\n")
                    f.write(f"/**\n")
                    f.write(f" * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_info['singular_name']}\n")
                    f.write(f" * ã‚¹ãƒ©ãƒƒã‚°: {cpt_info['slug']}\n")
                    f.write(f" * \n")
                    f.write(f" * @package WordPress\n")
                    f.write(f" * @since 1.0.0\n")
                    f.write(f" * @generated {datetime.now().isoformat()}\n")
                    f.write(f" */\n\n")
                    f.write(php_code)
                
                output_files.append({
                    'type': 'PHPã‚³ãƒ¼ãƒ‰',
                    'path': php_path
                })
                logger.info(f"PHPã‚³ãƒ¼ãƒ‰ä¿å­˜: {php_filename}")
            
            # 3. ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ‰‹é †ã‚’ä¿å­˜
            readme_filename = f"README_cpt_{cpt_info['slug']}_{timestamp}.md"
            readme_path = self.output_folder / readme_filename
            
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write(f"# {cpt_info['singular_name']} ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—\n\n")
                f.write(f"## æ¦‚è¦\n\n")
                f.write(f"{cpt_info['description']}\n\n")
                f.write(f"## ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•\n\n")
                f.write(f"### æ–¹æ³•1: functions.php ã«è¿½åŠ \n\n")
                f.write(f"1. `{php_filename}` ã®å†…å®¹ã‚’ã‚³ãƒ”ãƒ¼\n")
                f.write(f"2. ãƒ†ãƒ¼ãƒã® `functions.php`ï¼ˆå­ãƒ†ãƒ¼ãƒæ¨å¥¨ï¼‰ã«è²¼ã‚Šä»˜ã‘\n")
                f.write(f"3. WordPressã‚’å†èª­ã¿è¾¼ã¿\n\n")
                f.write(f"### æ–¹æ³•2: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¨ã—ã¦å®Ÿè£…\n\n")
                f.write(f"1. `wp-content/plugins/cpt-{cpt_info['slug']}/` ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½œæˆ\n")
                f.write(f"2. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ ã—ãŸ `{php_filename}` ã‚’é…ç½®\n")
                f.write(f"3. ç®¡ç†ç”»é¢ã§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’æœ‰åŠ¹åŒ–\n\n")
                f.write(f"## ä½¿ç”¨æ–¹æ³•\n\n")
                f.write(f"1. WordPressç®¡ç†ç”»é¢ã«ãƒ­ã‚°ã‚¤ãƒ³\n")
                f.write(f"2. å·¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«ã€Œ{cpt_info['menu_name']}ã€ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª\n")
                f.write(f"3. ã€Œè¨­å®š > ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šã€ã‚’é–‹ã„ã¦ä¿å­˜ï¼ˆãƒªãƒ©ã‚¤ãƒˆãƒ«ãƒ¼ãƒ«æ›´æ–°ï¼‰\n")
                f.write(f"4. æ–°ã—ã„{cpt_info['singular_name']}ã‚’ä½œæˆ\n\n")
                f.write(f"## ä»•æ§˜\n\n")
                f.write(f"- **ã‚¹ãƒ©ãƒƒã‚°**: `{cpt_info['slug']}`\n")
                f.write(f"- **ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½**: {', '.join(cpt_info['supports'])}\n")
                f.write(f"- **REST API**: æœ‰åŠ¹\n")
                f.write(f"- **ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒšãƒ¼ã‚¸**: æœ‰åŠ¹\n")
                f.write(f"- **éšå±¤æ§‹é€ **: {'æœ‰åŠ¹' if cpt_info['hierarchical'] else 'ç„¡åŠ¹'}\n\n")
            
            output_files.append({
                'type': 'README',
                'path': readme_path
            })
            logger.info(f"READMEä¿å­˜: {readme_filename}")
            
            return output_files
            
        except Exception as e:
            logger.error(f"ã‚³ãƒ¼ãƒ‰ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return output_files
    
    def _extract_php_code(self, text: str) -> Optional[str]:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        try:
            # ```php ... ``` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
            php_pattern = r'```php\s*(.*?)```'
            matches = re.findall(php_pattern, text, re.DOTALL)
            
            if matches:
                # æœ€ã‚‚é•·ã„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿”ã™
                longest_code = max(matches, key=len)
                # å…ˆé ­ã® <?php ã‚’å‰Šé™¤ï¼ˆå¾Œã§è¿½åŠ ã™ã‚‹ãŸã‚ï¼‰
                longest_code = re.sub(r'^\s*<\?php\s*', '', longest_code)
                return longest_code.strip()
            
            return None
            
        except Exception as e:
            logger.warning(f"PHPã‚³ãƒ¼ãƒ‰æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    async def _process_wordpress_taxonomy_task(self, task: Dict) -> Dict:
        """WordPressã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        # ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆç”¨ã®å‡¦ç†ï¼ˆä»Šå¾Œå®Ÿè£…ï¼‰
        logger.warning("ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã¯ç¾åœ¨æœªå®Ÿè£…ã§ã™")
        return await self._process_general_task(task)
    
    async def _process_general_task(self, task: Dict) -> Dict:
        """é€šå¸¸ã®é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            logger.info("é€šå¸¸ã®é–‹ç™ºã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
            
            # å¯¾å¿œã™ã‚‹è¨­è¨ˆæ›¸ãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€
            design_context = self._load_design_context(task)
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"""{self.DEV_SYSTEM_PROMPT}

ã€ã‚¿ã‚¹ã‚¯ã€‘
{task['description']}"""
            
            if design_context:
                full_prompt += f"""

ã€è¨­è¨ˆæ›¸ï¼ˆå‚è€ƒï¼‰ã€‘
{design_context}"""
            
            full_prompt += """

ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦ã€å®Œå…¨ã«å‹•ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚
ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã‚ã¦ãã ã•ã„ã€‚"""
            
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            success = await self.browser._wait_for_generation_complete()
            
            # ã‚¿ã‚¹ã‚¯ã®ç¨®é¡ã«ã‚ˆã£ã¦å¾…æ©Ÿæ™‚é–“ã‚’èª¿æ•´
            description = task.get('description', '').lower()
        
            if any(word in description for word in ['è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£', 'ä»•æ§˜æ›¸']):
                max_wait = 300  # è¦ä»¶å®šç¾©æ›¸ãªã©ã¯5åˆ†
                logger.info("ğŸ“‹ è¦ä»¶å®šç¾©ãƒ»è¨­è¨ˆæ›¸ã‚¿ã‚¹ã‚¯ - å¾…æ©Ÿæ™‚é–“ã‚’300ç§’ã«å»¶é•·")
            else:
                max_wait = 180  # é€šå¸¸ã¯3åˆ†
        
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=max_wait)

            
            if not success:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
            
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: å¿œç­”å–å¾—å¤±æ•—'
                }
            
            logger.info(f"é–‹ç™ºAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # ã‚³ãƒ¼ãƒ‰ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            filename = f"code_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            output_path = self.output_folder / filename
            
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# ã‚³ãƒ¼ãƒ‰: {task['description']}\n\n")
                f.write(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
            
            logger.info(f"ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜: {output_path}")
            
            # ã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã‚’æŠ½å‡ºã—ã¦å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            self._extract_and_save_code(response_text, task)
            
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
            
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "é–‹ç™ºAIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _load_design_context(self, task: Dict) -> str:
        """å¯¾å¿œã™ã‚‹è¨­è¨ˆæ›¸ãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€"""
        try:
            # design_*.md ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
            design_files = list(self.output_folder.glob(f"design_{task['task_id']}_*.md"))
            
            if design_files:
                # æœ€æ–°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
                latest_design = sorted(design_files)[-1]
                with open(latest_design, 'r', encoding='utf-8') as f:
                    content = f.read()
                logger.info(f"è¨­è¨ˆæ›¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {latest_design.name}")
                return content[:2000]  # æœ€åˆã®2000æ–‡å­—ã®ã¿
            
            return ""
        except Exception as e:
            logger.warning(f"è¨­è¨ˆæ›¸èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return ""
    
    def _extract_and_save_code(self, text: str, task: Dict):
        """ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡ºã—ã¦å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        try:
            # ```è¨€èª ... ``` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
            code_blocks = re.findall(r'```(\w+)\n(.*?)```', text, re.DOTALL)
            
            for i, (lang, code) in enumerate(code_blocks):
                # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’æ±ºå®š
                ext_map = {
                    'python': '.py',
                    'javascript': '.js',
                    'typescript': '.ts',
                    'html': '.html',
                    'css': '.css',
                    'java': '.java',
                    'cpp': '.cpp',
                    'c': '.c',
                    'php': '.php',
                    'ruby': '.rb',
                    'go': '.go',
                    'rust': '.rs',
                }
                ext = ext_map.get(lang.lower(), '.txt')
                
                # ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
                code_filename = f"code_{task['task_id']}_{i+1}{ext}"
                code_path = self.output_folder / code_filename
                
                with open(code_path, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                logger.info(f"ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜: {code_filename}")
                
        except Exception as e:
            logger.warning(f"ã‚³ãƒ¼ãƒ‰æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")

#dev_agent_acf.py
# dev_agent_acf.py
"""ACFï¼ˆAdvanced Custom Fieldsï¼‰å°‚ç”¨é–‹ç™ºãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager, config

logger = logging.getLogger(__name__)


# =============================================================================
# ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—å°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

ACF_FIELD_GROUP_PROMPT = """ã‚ãªãŸã¯ACF Proã¨WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆã€‘

ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å®Œå…¨ã«å‹•ä½œã™ã‚‹ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å®šç¾©ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

ã€å¿…é ˆè¦ç´ ã€‘
1. ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®åŸºæœ¬è¨­å®š
   - ã‚¿ã‚¤ãƒˆãƒ«ã€ã‚­ãƒ¼ã€é…ç½®å ´æ‰€ï¼ˆæŠ•ç¨¿ã‚¿ã‚¤ãƒ—ï¼‰
2. å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è©³ç´°å®šç¾©
   - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—ï¼ˆtext, number, select, relationship ãªã©ï¼‰
   - ãƒ©ãƒ™ãƒ«ã€åå‰ã€ã‚­ãƒ¼
   - æ¤œè¨¼ãƒ«ãƒ¼ãƒ«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
3. æ¡ä»¶ä»˜ããƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
4. PHPç™»éŒ²ã‚³ãƒ¼ãƒ‰ï¼ˆ`acf_add_local_field_group`ï¼‰
5. JSONå½¢å¼ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆWP-CLIã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ï¼‰

ã€å‡ºåŠ›å½¢å¼ã€‘

## ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—: {group_title}

### æ¦‚è¦
ï¼ˆã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®ç›®çš„ã¨ç”¨é€”ï¼‰

### PHPç™»éŒ²ã‚³ãƒ¼ãƒ‰ï¼ˆfunctions.phpã«è¿½åŠ ï¼‰

```php
<?php
/**
 * ACF Field Group: {group_title}
 * æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {post_type}
 */

if (function_exists('acf_add_local_field_group')) {{
    acf_add_local_field_group(array(
        'key' => 'group_{unique_key}',
        'title' => '{group_title}',
        'fields' => array(
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©
            array(
                'key' => 'field_{field_key}',
                'label' => '{field_label}',
                'name' => '{field_name}',
                'type' => '{field_type}',
                'required' => {{true|false}},
                'default_value' => '',
            ),
        ),
        'location' => array(
            array(
                array(
                    'param' => 'post_type',
                    'operator' => '==',
                    'value' => '{post_type}',
                ),
            ),
        ),
        'menu_order' => 0,
        'position' => 'normal',
        'style' => 'default',
        'label_placement' => 'top',
        'instruction_placement' => 'label',
        'active' => true,
        'show_in_rest' => 1,
    ));
}}
?>
```

### JSONå®šç¾©ï¼ˆWP-CLIã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ï¼‰

```json
{{
  "key": "group_{unique_key}",
  "title": "{group_title}",
  "fields": [
    {{
      "key": "field_{field_key}",
      "label": "{field_label}",
      "name": "{field_name}",
      "type": "{field_type}",
      "required": {{true|false}}
    }}
  ],
  "location": [
    [
      {{
        "param": "post_type",
        "operator": "==",
        "value": "{post_type}"
      }}
    ]
  ]
}}
```

### ä½¿ç”¨æ–¹æ³•

#### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã®å–å¾—
```php
<?php
// å˜ä¸€å€¤ã®å–å¾—
$value = get_field('field_name', $post_id);

// æ¡ä»¶ä»˜ãè¡¨ç¤º
if (get_field('field_name')) :
    echo esc_html(get_field('field_name'));
endif;
?>
```

### æ³¨æ„äº‹é …
- ACF Pro 6.0ä»¥ä¸ŠãŒå¿…è¦ã§ã™
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¼ã¯ä¸€æ„ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
"""


# =============================================================================
# ACFDevAgentã‚¯ãƒ©ã‚¹ï¼ˆACFå°‚ç”¨æ©Ÿèƒ½ï¼‰
# =============================================================================

class ACFDevAgent:
    """ACFï¼ˆAdvanced Custom Fieldsï¼‰å°‚ç”¨é–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(self, browser, output_folder: Path):
        """
        åˆæœŸåŒ–
        
        Args:
            browser: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            output_folder: å‡ºåŠ›å…ˆãƒ•ã‚©ãƒ«ãƒ€
        """
        self.browser = browser
        self.output_folder = output_folder
        self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯åˆ¤å®šãƒ¡ã‚½ãƒƒãƒ‰
    # =========================================================================
    
    def is_acf_task(self, task: Dict) -> bool:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            bool: ACFã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        description = task.get('description', '').lower()
        keywords = [
            'acf',
            'advanced custom fields',
            'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰',
            'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—',
            'field group'
        ]
        return any(kw in description for kw in keywords)
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ2: ACFã‚¿ã‚¹ã‚¯å‡¦ç†ãƒ¡ã‚¤ãƒ³
    # =========================================================================
    
    async def process_acf_task(self, task: Dict) -> Dict:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            Dict: å‡¦ç†çµæœ
        """
        try:
            logger.info("="*60)
            logger.info("ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-1: ã‚¿ã‚¹ã‚¯ã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡º ===
            acf_info = self._extract_acf_info(task)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰ ===
            full_prompt = self._build_acf_prompt(task, acf_info)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-3: Geminiã«é€ä¿¡ ===
            logger.info("Geminiã«ã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-4: å¿œç­”å¾…æ©Ÿ ===
            success = await self.browser.wait_for_text_generation(
                max_wait=config.WP_DEV_TIMEOUT if hasattr(config, 'WP_DEV_TIMEOUT') else 300
            )
            
            if not success:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆï¼‰'
                }
            
            # === ãƒ‘ãƒ¼ãƒˆ2-5: å¿œç­”ã‚’å–å¾— ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: å¿œç­”å–å¾—å¤±æ•—'
                }
            
            logger.info(f"é–‹ç™ºAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # === ãƒ‘ãƒ¼ãƒˆ2-6: ã‚³ãƒ¼ãƒ‰æ¤œè¨¼ ===
            validation_result = self._validate_acf_code(response_text)
            if not validation_result['is_valid']:
                logger.warning(f"âš ï¸ ACFã‚³ãƒ¼ãƒ‰æ¤œè¨¼ã§å•é¡Œæ¤œå‡º: {validation_result['issues']}")
            
            # === ãƒ‘ãƒ¼ãƒˆ2-7: çµæœã‚’ä¿å­˜ ===
            output_files = self._save_acf_code(response_text, task, acf_info)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-8: ã‚µãƒãƒªãƒ¼ä½œæˆ ===
            summary = self._create_acf_summary(acf_info, output_files, validation_result)
            
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'validation': validation_result
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ")
            return {
                'success': False,
                'error': str(e)
            }
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ3: ACFæƒ…å ±æŠ½å‡º
    # =========================================================================
    
    def _extract_acf_info(self, task: Dict) -> Dict:
        """
        ã‚¿ã‚¹ã‚¯ã‹ã‚‰ACFæƒ…å ±ã‚’æŠ½å‡º
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            Dict: ACFæƒ…å ±
        """
        description = task.get('description', '')
        parameters = task.get('parameters', {})
        
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        return {
            'group_title': parameters.get('group_title', 'M&Aæ¡ˆä»¶ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰'),
            'post_type': parameters.get('post_type', 'ma_case'),
            'field_count': parameters.get('field_count', 10),
            'unique_key': parameters.get('unique_key', 'ma_case_fields')
        }
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ4: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
    # =========================================================================
    
    def _build_acf_prompt(self, task: Dict, acf_info: Dict) -> str:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            acf_info: ACFæƒ…å ±
            
        Returns:
            str: å®Œå…¨ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        prompt = ACF_FIELD_GROUP_PROMPT.format(
            group_title=acf_info['group_title'],
            post_type=acf_info['post_type'],
            unique_key=acf_info['unique_key'],
            field_label='ä¾‹: ä¼æ¥­å',
            field_name='company_name',
            field_key='company_name',
            field_type='text'
        )
        
        prompt += f"""

ã€ã“ã®ã‚¿ã‚¹ã‚¯ã®å…·ä½“çš„ãªè¦ä»¶ã€‘
{task.get('description', '')}

ã€é‡è¦ãªæŒ‡ç¤ºã€‘
1. PHPã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ã«å‹•ä½œã™ã‚‹çŠ¶æ…‹ã§ç”Ÿæˆã—ã¦ãã ã•ã„
2. JSONå½¢å¼ã®å®šç¾©ã‚‚å¿…ãšå«ã‚ã¦ãã ã•ã„
3. ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚­ãƒ¼ï¼ˆkeyï¼‰ã‚’è¨­å®šã—ã¦ãã ã•ã„
4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†ï¼‰ã‚’è€ƒæ…®ã—ã¦ãã ã•ã„
5. å¤šè¨€èªå¯¾å¿œï¼ˆPolylangï¼‰ã‚’è€ƒæ…®ã—ã¦ãã ã•ã„

ä¸Šè¨˜ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å®Œå…¨ãªACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å®šç¾©ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
"""
        
        return prompt
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ5: ACFã‚³ãƒ¼ãƒ‰æ¤œè¨¼
    # =========================================================================
    
    def _validate_acf_code(self, text: str) -> Dict:
        """
        ACFã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼
        
        Args:
            text: æ¤œè¨¼å¯¾è±¡ã®ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: æ¤œè¨¼çµæœ
        """
        issues = []
        
        # === ãƒ‘ãƒ¼ãƒˆ5-1: å¿…é ˆé–¢æ•°ã®ãƒã‚§ãƒƒã‚¯ ===
        if 'acf_add_local_field_group' not in text:
            issues.append('acf_add_local_field_group() é–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
        
        # === ãƒ‘ãƒ¼ãƒˆ5-2: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¼ã®ä¸€æ„æ€§ãƒã‚§ãƒƒã‚¯ ===
        field_keys = re.findall(r"'key'\s*=>\s*'(field_[^']+)'", text)
        if len(field_keys) != len(set(field_keys)):
            issues.append('ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¼ãŒé‡è¤‡ã—ã¦ã„ã¾ã™')
        
        # === ãƒ‘ãƒ¼ãƒˆ5-3: JSONã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ ===
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        for json_str in json_blocks:
            try:
                json.loads(json_str)
            except json.JSONDecodeError:
                issues.append('JSONå½¢å¼ãŒä¸æ­£ã§ã™')
        
        # === ãƒ‘ãƒ¼ãƒˆ5-4: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢æ•°ã®ãƒã‚§ãƒƒã‚¯ ===
        if 'get_field(' in text and 'esc_html' not in text and 'esc_attr' not in text:
            issues.append('å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆesc_html, esc_attrï¼‰')
        
        return {
            'is_valid': len(issues) == 0,
            'issues': issues
        }
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ6: ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
    # =========================================================================
    
    def _save_acf_code(self, text: str, task: Dict, acf_info: Dict) -> list:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜
        
        Args:
            text: ä¿å­˜å¯¾è±¡ã®ãƒ†ã‚­ã‚¹ãƒˆ
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            acf_info: ACFæƒ…å ±
            
        Returns:
            list: ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®ãƒªã‚¹ãƒˆ
        """
        output_files = []
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ6-1: å®Œå…¨ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ä¿å­˜ ===
            doc_filename = f"acf_{acf_info['unique_key']}_{timestamp}.md"
            doc_path = self.output_folder / doc_filename
            
            with open(doc_path, 'w', encoding='utf-8') as f:
                f.write(f"# ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—: {acf_info['group_title']}\n\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write(text)
            
            output_files.append({
                'type': 'ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ',
                'path': doc_path
            })
            logger.info(f"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä¿å­˜: {doc_filename}")
            
            # === ãƒ‘ãƒ¼ãƒˆ6-2: PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã—ã¦ä¿å­˜ ===
            php_code = self._extract_php_code(text)
            if php_code:
                php_filename = f"acf_{acf_info['unique_key']}_{timestamp}.php"
                php_path = self.output_folder / php_filename
                
                with open(php_path, 'w', encoding='utf-8') as f:
                    f.write("<?php\n")
                    f.write(f"/**\n * ACF Field Group: {acf_info['group_title']}\n */\n\n")
                    f.write(php_code)
                
                output_files.append({
                    'type': 'PHPã‚³ãƒ¼ãƒ‰',
                    'path': php_path
                })
                logger.info(f"PHPã‚³ãƒ¼ãƒ‰ä¿å­˜: {php_filename}")
            
            # === ãƒ‘ãƒ¼ãƒˆ6-3: JSONå®šç¾©ã‚’æŠ½å‡ºã—ã¦ä¿å­˜ ===
            json_data = self._extract_json_from_text(text)
            if json_data:
                json_filename = f"acf_{acf_info['unique_key']}_{timestamp}.json"
                json_path = self.output_folder / json_filename
                
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(json_data, f, ensure_ascii=False, indent=2)
                
                output_files.append({
                    'type': 'JSONå®šç¾©',
                    'path': json_path
                })
                logger.info(f"JSONå®šç¾©ä¿å­˜: {json_filename}")
            
            # === ãƒ‘ãƒ¼ãƒˆ6-4: READMEã‚’ç”Ÿæˆ ===
            readme_filename = f"README_acf_{acf_info['unique_key']}_{timestamp}.md"
            readme_path = self.output_folder / readme_filename
            
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write(f"# {acf_info['group_title']} - ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¬ã‚¤ãƒ‰\n\n")
                f.write(f"## æ¦‚è¦\n\n")
                f.write(f"æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {acf_info['post_type']}\n\n")
                f.write(f"## ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•\n\n")
                f.write(f"### æ–¹æ³•1: PHPã‚³ãƒ¼ãƒ‰ã§ç™»éŒ²\n\n")
                f.write(f"1. `{php_filename}` ã®å†…å®¹ã‚’ `functions.php` ã«è¿½åŠ \n\n")
                f.write(f"### æ–¹æ³•2: WP-CLIçµŒç”±\n\n")
                f.write(f"```bash\nwp acf import {json_filename}\n```\n\n")
            
            output_files.append({
                'type': 'README',
                'path': readme_path
            })
            logger.info(f"READMEä¿å­˜: {readme_filename}")
            
            return output_files
            
        except Exception as e:
            logger.error(f"ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return output_files
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ7: ã‚³ãƒ¼ãƒ‰æŠ½å‡ºãƒ˜ãƒ«ãƒ‘ãƒ¼
    # =========================================================================
    
    def _extract_php_code(self, text: str) -> Optional[str]:
        """PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        php_pattern = r'```php\s*(.*?)```'
        matches = re.findall(php_pattern, text, re.DOTALL)
        
        if matches:
            longest_code = max(matches, key=len)
            longest_code = re.sub(r'^\s*<\?php\s*', '', longest_code)
            return longest_code.strip()
        
        return None
    
    def _extract_json_from_text(self, text: str) -> Optional[Dict]:
        """JSONå®šç¾©ã‚’æŠ½å‡º"""
        json_pattern = r'```json\s*(.*?)```'
        matches = re.findall(json_pattern, text, re.DOTALL)
        
        if matches:
            try:
                return json.loads(matches[0])
            except json.JSONDecodeError:
                return None
        
        return None
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ8: ã‚µãƒãƒªãƒ¼ä½œæˆ
    # =========================================================================
    
    def _create_acf_summary(self, acf_info: Dict, output_files: list, 
                           validation_result: Dict) -> str:
        """ACFã‚¿ã‚¹ã‚¯ã®ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ"""
        summary = f"""âœ… ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆå®Œäº†

ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã€‘
- ã‚¿ã‚¤ãƒˆãƒ«: {acf_info['group_title']}
- æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {acf_info['post_type']}
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: {acf_info['field_count']}

ã€ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã€‘
"""
        for file_info in output_files:
            summary += f"- {file_info['type']}: {file_info['path'].name}\n"
        
        if not validation_result['is_valid']:
            summary += f"\nã€æ¤œè¨¼çµæœã€‘\n"
            for issue in validation_result['issues']:
                summary += f"âš ï¸ {issue}\n"
        
        return summary

#error_handler_enhanced.py
"""
å¼·åŒ–ç‰ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ - ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ç”¨
"""

import logging
import asyncio
import traceback
import sys
from typing import Optional, Callable, Any
from functools import wraps
from pathlib import Path
import time

logger = logging.getLogger(__name__)


class RetryConfig:
    """ãƒªãƒˆãƒ©ã‚¤è¨­å®š"""
    MAX_RETRIES = 3
    INITIAL_DELAY = 2.0  # ç§’
    MAX_DELAY = 30.0
    BACKOFF_FACTOR = 2.0


class EnhancedErrorHandler:
    """å¼·åŒ–ç‰ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
    
    @staticmethod
    def log_error_with_context(error: Exception, context: str = "", 
                               include_traceback: bool = True) -> None:
        """ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä»˜ãã‚¨ãƒ©ãƒ¼ãƒ­ã‚°"""
        logger.error("="*60)
        logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {context}")
        logger.error(f"ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: {type(error).__name__}")
        logger.error(f"ã‚¨ãƒ©ãƒ¼å†…å®¹: {str(error)}")
        
        if include_traceback:
            logger.error("ãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯:")
            logger.error(traceback.format_exc())
        
        logger.error("="*60)
    
    @staticmethod
    async def retry_async(
        func: Callable,
        *args,
        max_retries: int = RetryConfig.MAX_RETRIES,
        delay: float = RetryConfig.INITIAL_DELAY,
        backoff: float = RetryConfig.BACKOFF_FACTOR,
        exceptions: tuple = (Exception,),
        on_retry: Optional[Callable] = None,
        **kwargs
    ) -> Any:
        """
        éåŒæœŸé–¢æ•°ã®ãƒªãƒˆãƒ©ã‚¤ãƒ©ãƒƒãƒ‘ãƒ¼
        
        Args:
            func: å®Ÿè¡Œã™ã‚‹éåŒæœŸé–¢æ•°
            max_retries: æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
            delay: åˆæœŸé…å»¶æ™‚é–“ï¼ˆç§’ï¼‰
            backoff: ãƒãƒƒã‚¯ã‚ªãƒ•ä¿‚æ•°
            exceptions: ã‚­ãƒ£ãƒƒãƒã™ã‚‹ä¾‹å¤–ã®ã‚¿ãƒ—ãƒ«
            on_retry: ãƒªãƒˆãƒ©ã‚¤æ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
        """
        current_delay = delay
        last_exception = None
        
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"è©¦è¡Œ {attempt}/{max_retries}: {func.__name__}")
                result = await func(*args, **kwargs)
                
                if attempt > 1:
                    logger.info(f"âœ… æˆåŠŸï¼ˆè©¦è¡Œ {attempt}ï¼‰")
                
                return result
                
            except exceptions as e:
                last_exception = e
                
                if attempt == max_retries:
                    logger.error(f"âŒ å…¨ãƒªãƒˆãƒ©ã‚¤å¤±æ•—: {func.__name__}")
                    EnhancedErrorHandler.log_error_with_context(
                        e, f"{func.__name__} (è©¦è¡Œ {attempt}/{max_retries})"
                    )
                    raise
                
                logger.warning(f"âš ï¸ å¤±æ•—ï¼ˆè©¦è¡Œ {attempt}ï¼‰: {str(e)}")
                logger.info(f"ğŸ”„ {current_delay:.1f}ç§’å¾Œã«å†è©¦è¡Œ...")
                
                if on_retry:
                    try:
                        await on_retry(attempt, e)
                    except Exception as callback_error:
                        logger.warning(f"ãƒªãƒˆãƒ©ã‚¤ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤±æ•—: {callback_error}")
                
                await asyncio.sleep(current_delay)
                current_delay = min(current_delay * backoff, RetryConfig.MAX_DELAY)
        
        raise last_exception
    
    @staticmethod
    def retry_decorator(
        max_retries: int = RetryConfig.MAX_RETRIES,
        delay: float = RetryConfig.INITIAL_DELAY,
        backoff: float = RetryConfig.BACKOFF_FACTOR,
        exceptions: tuple = (Exception,)
    ):
        """ãƒªãƒˆãƒ©ã‚¤ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼"""
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                return await EnhancedErrorHandler.retry_async(
                    func, *args,
                    max_retries=max_retries,
                    delay=delay,
                    backoff=backoff,
                    exceptions=exceptions,
                    **kwargs
                )
            return wrapper
        return decorator
    
    @staticmethod
    async def safe_cleanup(cleanup_func: Callable, context: str = "") -> bool:
        """å®‰å…¨ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ"""
        try:
            logger.info(f"ğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—: {context}")
            
            if asyncio.iscoroutinefunction(cleanup_func):
                await cleanup_func()
            else:
                cleanup_func()
            
            logger.info(f"âœ… ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†: {context}")
            return True
            
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—ï¼ˆç„¡è¦–ï¼‰: {context}")
            logger.warning(f"ç†ç”±: {str(e)}")
            return False
    
    @staticmethod
    def validate_file_path(path: Any, must_exist: bool = False) -> Optional[Path]:
        """ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³"""
        try:
            if not path:
                return None
            
            # æ–‡å­—åˆ—ã«å¤‰æ›
            path_str = str(path).strip()
            
            # URLã®å ´åˆã¯None
            if path_str.lower().startswith(('http://', 'https://')):
                logger.warning(f"URLãŒæŒ‡å®šã•ã‚Œã¾ã—ãŸï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰: {path_str}")
                return None
            
            # Pathã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
            path_obj = Path(path_str)
            
            # å­˜åœ¨ç¢ºèªãŒå¿…è¦ãªå ´åˆ
            if must_exist and not path_obj.exists():
                logger.error(f"âŒ ãƒ‘ã‚¹ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {path_obj}")
                return None
            
            # æ­£è¦åŒ–ã—ã¦è¿”ã™
            return path_obj.resolve()
            
        except Exception as e:
            logger.error(f"ãƒ‘ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {path}")
            EnhancedErrorHandler.log_error_with_context(e, "ãƒ‘ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³")
            return None
    
    @staticmethod
    def handle_import_error(module_name: str, optional: bool = True) -> bool:
        """ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
        try:
            __import__(module_name)
            logger.info(f"âœ… ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ: {module_name}")
            return True
            
        except ImportError as e:
            if optional:
                logger.warning(f"âš ï¸ ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æœªæ¤œå‡ºï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰: {module_name}")
                return False
            else:
                logger.error(f"âŒ å¿…é ˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {module_name}")
                EnhancedErrorHandler.log_error_with_context(e, f"ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: {module_name}")
                raise
    
    @staticmethod
    async def timeout_wrapper(
        coro,
        timeout: float,
        context: str = ""
    ) -> Any:
        """ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Ÿè¡Œ"""
        try:
            result = await asyncio.wait_for(coro, timeout=timeout)
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{timeout}ç§’ï¼‰: {context}")
            raise TimeoutError(f"{context} ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸï¼ˆ{timeout}ç§’ï¼‰")
        
        except Exception as e:
            EnhancedErrorHandler.log_error_with_context(e, context)
            raise


class BrowserErrorHandler:
    """ãƒ–ãƒ©ã‚¦ã‚¶å°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
    
    @staticmethod
    async def handle_browser_crash(browser_controller, max_retries: int = 3):
        """ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
        for attempt in range(1, max_retries + 1):
            try:
                logger.info(f"ğŸŒ ãƒ–ãƒ©ã‚¦ã‚¶å†èµ·å‹•è©¦è¡Œ {attempt}/{max_retries}")
                
                # æ—¢å­˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
                try:
                    await browser_controller.cleanup()
                except:
                    pass
                
                # å°‘ã—å¾…æ©Ÿ
                await asyncio.sleep(3)
                
                # å†åˆæœŸåŒ–
                await browser_controller.setup_browser()
                
                # å‹•ä½œç¢ºèª
                if browser_controller.page:
                    test_result = await browser_controller.page.evaluate("1 + 1")
                    if test_result == 2:
                        logger.info(f"âœ… ãƒ–ãƒ©ã‚¦ã‚¶å¾©æ—§æˆåŠŸï¼ˆè©¦è¡Œ {attempt}ï¼‰")
                        return True
                
            except Exception as e:
                logger.warning(f"ãƒ–ãƒ©ã‚¦ã‚¶å†èµ·å‹•å¤±æ•—ï¼ˆè©¦è¡Œ {attempt}ï¼‰: {e}")
                
                if attempt == max_retries:
                    logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶å¾©æ—§ä¸å¯èƒ½")
                    raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã®å†èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ")
                
                await asyncio.sleep(5)
        
        return False
    
    @staticmethod
    async def safe_page_action(page, action_func, context: str = "", timeout: float = 30.0):
        """å®‰å…¨ãªãƒšãƒ¼ã‚¸æ“ä½œ"""
        try:
            return await EnhancedErrorHandler.timeout_wrapper(
                action_func(),
                timeout=timeout,
                context=context
            )
            
        except Exception as e:
            logger.error(f"ãƒšãƒ¼ã‚¸æ“ä½œå¤±æ•—: {context}")
            EnhancedErrorHandler.log_error_with_context(e, context)
            raise


class SheetErrorHandler:
    """Google Sheetså°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
    
    @staticmethod
    async def safe_sheet_operation(operation_func, *args, **kwargs):
        """å®‰å…¨ãªã‚·ãƒ¼ãƒˆæ“ä½œ"""
        try:
            return await EnhancedErrorHandler.retry_async(
                operation_func,
                *args,
                max_retries=3,
                delay=2.0,
                exceptions=(Exception,),
                **kwargs
            )
            
        except Exception as e:
            logger.error("Google Sheetsæ“ä½œãŒå…¨ãƒªãƒˆãƒ©ã‚¤å¤±æ•—")
            EnhancedErrorHandler.log_error_with_context(e, "Sheetsæ“ä½œ")
            
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã©
            logger.warning("âš ï¸ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆï¼ˆãƒ‡ãƒ¼ã‚¿æœªä¿å­˜ï¼‰")
            return None


class TaskErrorHandler:
    """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼"""
    
    @staticmethod
    async def handle_task_failure(
        task: dict,
        error: Exception,
        sheets_manager,
        retry: bool = True
    ) -> bool:
        """ã‚¿ã‚¹ã‚¯å¤±æ•—ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
        try:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {task.get('task_id', 'UNKNOWN')}")
            EnhancedErrorHandler.log_error_with_context(
                error,
                f"ã‚¿ã‚¹ã‚¯ {task.get('description', 'N/A')[:50]}"
            )
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            try:
                await sheets_manager.update_task_status(
                    task['task_id'],
                    'failed',
                    error_message=str(error)
                )
            except Exception as update_error:
                logger.warning(f"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å¤±æ•—: {update_error}")
            
            # ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            if retry and TaskErrorHandler.is_retryable_error(error):
                logger.info("ğŸ”„ ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"ã‚¿ã‚¹ã‚¯å¤±æ•—ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    @staticmethod
    def is_retryable_error(error: Exception) -> bool:
        """ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã‹åˆ¤å®š"""
        retryable_patterns = [
            "timeout",
            "network",
            "connection",
            "temporary",
            "rate limit"
        ]
        
        error_str = str(error).lower()
        return any(pattern in error_str for pattern in retryable_patterns)


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    async def example_usage():
        # ãƒªãƒˆãƒ©ã‚¤ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ä½¿ç”¨ä¾‹
        @EnhancedErrorHandler.retry_decorator(max_retries=3)
        async def unstable_operation():
            # ä¸å®‰å®šãªå‡¦ç†
            import random
            if random.random() < 0.7:
                raise Exception("ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼")
            return "æˆåŠŸ"
        
        try:
            result = await unstable_operation()
            print(f"çµæœ: {result}")
        except Exception as e:
            print(f"å¤±æ•—: {e}")
    
    asyncio.run(example_usage())

#main_automator.py
import asyncio
import time
import json
from pathlib import Path
from typing import List, Dict, Optional
import logging
from datetime import datetime

# ===== æœ€å„ªå…ˆ: ãƒ­ã‚°è¨­å®šã‚’ä»–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚ˆã‚Šå‰ã«å®Ÿè¡Œ =====
# config_utilsã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨è‡ªå‹•çš„ã«ãƒ­ã‚°è¨­å®šãŒå®Ÿè¡Œã•ã‚Œã‚‹
from config_utils import config, ErrorHandler, FileNameGenerator, PathManager

# ã“ã‚Œã§ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class GeminiAutomator:
    """ãƒ¡ã‚¤ãƒ³ã®Geminiè‡ªå‹•åŒ–ã‚¯ãƒ©ã‚¹ï¼ˆæ‹¡å¼µç‰ˆ:ç”»åƒãƒ»ãƒ†ã‚­ã‚¹ãƒˆä¸¡å¯¾å¿œãƒ»ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ãƒ»DeepSeekå¯¾å¿œï¼‰"""
    
    def __init__(self, pc_id: int = None, auto_detect_pc_id: bool = True):
        """
        åˆæœŸåŒ–
        
        Args:
            pc_id: æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹PC_IDï¼ˆNoneã®å ´åˆã¯è‡ªå‹•æ¤œå‡ºï¼‰
            auto_detect_pc_id: Trueã®å ´åˆã€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰PC_IDã‚’èª­ã¿å–ã‚‹
        """
        # ã¾ãšã€ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
        default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
        service_account_file = default_service_account if Path(default_service_account).exists() else None
        
        self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
        # PC_IDã®æ±ºå®šï¼ˆå„ªå…ˆé †ä½ï¼‰
        # 1. æ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚ŒãŸpc_id
        # 2. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰èª­ã¿å–ã‚Šï¼ˆauto_detect_pc_id=Trueã®å ´åˆï¼‰
        # 3. ç’°å¢ƒå¤‰æ•°
        # 4. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤(1)
        if pc_id is not None:
            self.pc_id = pc_id
            logger.info(f"PC_IDã‚’æ˜ç¤ºçš„æŒ‡å®šã‹ã‚‰å–å¾—: {self.pc_id}")
        elif auto_detect_pc_id:
            try:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_IDã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ(B12)ã‹ã‚‰å–å¾—: {self.pc_id}")
            except Exception as e:
                logger.warning(f"ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ã®PC_IDå–å¾—ã«å¤±æ•—: {e}")
                import os
                self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
                logger.info(f"PC_IDã‚’ç’°å¢ƒå¤‰æ•°/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰å–å¾—: {self.pc_id}")
        else:
            import os
            self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
            logger.info(f"PC_IDã‚’ç’°å¢ƒå¤‰æ•°/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰å–å¾—: {self.pc_id}")
        
        # PCå›ºæœ‰ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
        self.load_pc_configuration()
        self.mode = config.GENERATION_MODE or "image"
        self.service = config.SERVICE_TYPE or "google"
        
        # ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®šï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆB5/B6ã‹ã‚‰å–å¾—ï¼‰
        if self.mode == "text":
            # ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯B6ã®è¨­å®šã‚’ä½¿ç”¨
            if config.DOWNLOAD_TEXT_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_TEXT_FOLDER)
                logger.info(f"ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜å…ˆï¼ˆB6ã‹ã‚‰å–å¾—ï¼‰: {self.download_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_texts"))
                logger.warning(f"B6ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.download_folder}")
        else:
            # ç”»åƒãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯B5ã®è¨­å®šã‚’ä½¿ç”¨
            if config.DOWNLOAD_IMAGE_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_IMAGE_FOLDER)
                logger.info(f"ç”»åƒä¿å­˜å…ˆï¼ˆB5ã‹ã‚‰å–å¾—ï¼‰: {self.download_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_images"))
                logger.warning(f"B5ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.download_folder}")
        
        self.browser_controller = BrowserController(self.download_folder, self.mode, self.service)
        self.credentials: Optional[Dict[str, str]] = None
        self.prompts: List[str] = []
        self.results: List[Dict] = []
        self.generate_unique_filename = lambda idx: FileNameGenerator.generate_unique_filename(idx, mode=self.mode)
    
    def load_pc_configuration(self) -> None:
        """PCå›ºæœ‰ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        try:
            logger.info(f"PC_ID={self.pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ä¸­...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.SERVICE_ACCOUNT_FILE = settings.get('service_account_file')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = settings.get('generation_mode', 'image')
            config.TEXT_FORMAT = settings.get('text_format', 'txt')
            config.DOWNLOAD_IMAGE_FOLDER = settings.get('download_image_folder')
            config.DOWNLOAD_TEXT_FOLDER = settings.get('download_text_folder')
            config.AGENT_OUTPUT_FOLDER = settings.get('agent_output_folder')
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            # ã‚µãƒ¼ãƒ“ã‚¹ã‚¿ã‚¤ãƒ—ã®å–å¾—
            service_type = settings.get('service_type', '').strip().lower()
            if service_type in ['deepseek', 'google', 'gemini']:
                if service_type == 'gemini':
                    service_type = 'google'
                config.SERVICE_TYPE = service_type
            else:
                config.SERVICE_TYPE = 'google'
        
            logger.info(f"PC_ID={self.pc_id} ã®è¨­å®šèª­ã¿è¾¼ã¿å®Œäº†")
            logger.info(f"  ã‚µãƒ¼ãƒ“ã‚¹: {config.SERVICE_TYPE}")
            logger.info(f"  ãƒ¢ãƒ¼ãƒ‰: {config.GENERATION_MODE}")
            logger.info(f"  ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼: {config.TEXT_FORMAT}")
            logger.info(f"  Browser Data: {config.BROWSER_DATA_DIR}")
            logger.info(f"  ç”»åƒãƒ•ã‚©ãƒ«ãƒ€ (B5): {config.DOWNLOAD_IMAGE_FOLDER}")
            logger.info(f"  ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚©ãƒ«ãƒ€ (B6): {config.DOWNLOAD_TEXT_FOLDER}")
            logger.info(f"  Agentå‡ºåŠ›å…ˆ (B14): {config.AGENT_OUTPUT_FOLDER}")
            logger.info(f"  æœ€å¤§åå¾©å›æ•° (B15): {config.MAX_ITERATIONS}")
            if config.SERVICE_ACCOUNT_FILE and Path(config.SERVICE_ACCOUNT_FILE).exists():
                self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, config.SERVICE_ACCOUNT_FILE)
        except Exception as e:
            ErrorHandler.log_error(e, "PCè¨­å®šèª­ã¿è¾¼ã¿")
            raise
    
    async def initialize(self) -> None:
        """åˆæœŸåŒ–å‡¦ç†"""
        try:
            logger.info("åˆæœŸåŒ–å‡¦ç†é–‹å§‹...")
            if not self.sheets_manager.validate_sheet_structure():
                raise Exception("Google Sheetsã®æ§‹é€ ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“")
            self.credentials = self.sheets_manager.load_credentials_from_sheet(self.pc_id)
            
            # credentialsã‚’browser_controllerã«æ¸¡ã™
            self.browser_controller.credentials = self.credentials
            
            prompt_sheet_name = "prompt_text" if self.mode == "text" else "prompt_text"
            self.prompts = self.sheets_manager.load_prompts_from_sheet(prompt_sheet_name)
            if not self.prompts:
                raise Exception("å‡¦ç†ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã‚ã‚Šã¾ã›ã‚“")
            await self.browser_controller.setup_browser()
            logger.info("åˆæœŸåŒ–å‡¦ç†å®Œäº†")
        except Exception as e:
            ErrorHandler.log_error(e, "åˆæœŸåŒ–å‡¦ç†")
            raise
    
    async def login_process(self) -> None:
        """ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ï¼ˆã‚µãƒ¼ãƒ“ã‚¹åˆ¥ï¼‰"""
        try:
            logger.info("ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†é–‹å§‹...")
            
            if self.service == "deepseek":
                # DeepSeekã¯Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³
                logger.info("DeepSeekã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ï¼ˆDeepSeekç”¨ï¼‰")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("Googleãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ãƒ­ã‚°ã‚¤ãƒ³ãŒç¢ºèªã§ãã¾ã›ã‚“ãŒã€å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™")
                else:
                    logger.info("æ—¢ã«Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã§ã™")
                
                await self.browser_controller.navigate_to_deepseek()
            else:
                # Google/Geminiã®å ´åˆ
                logger.info("Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ãƒ­ã‚°ã‚¤ãƒ³ãŒç¢ºèªã§ãã¾ã›ã‚“ãŒã€å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™")
                else:
                    logger.info("æ—¢ã«Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã§ã™")
                
                await self.browser_controller.navigate_to_gemini()
            
            logger.info("ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†å®Œäº†")
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†")
            raise
    
    async def process_single_prompt_image(self, prompt: str, index: int) -> bool:
        """ç”»åƒãƒ¢ãƒ¼ãƒ‰ã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å‡¦ç†"""
        try:
            logger.info(f"\n--- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index}/{len(self.prompts)} ã‚’å‡¦ç†ä¸­ï¼ˆç”»åƒãƒ¢ãƒ¼ãƒ‰ï¼‰---")
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'image'
            }
            try:
                await self.browser_controller.send_prompt(prompt)
                if await self.browser_controller.wait_for_image_generation():
                    filename = await self.browser_controller.download_latest_image(index)
                    if filename:
                        result['status'] = 'success'
                        result['filename'] = filename
                        save_path = self.download_folder / filename
                        logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} ã®å‡¦ç†ã«æˆåŠŸ")
                        logger.info(f"ä¿å­˜å…ˆ: {save_path}")
                        return True
                    else:
                        result['status'] = 'download_failed'
                        result['error'] = 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—'
                else:
                    result['status'] = 'generation_failed'
                    result['error'] = 'ç”»åƒç”Ÿæˆã«å¤±æ•—ã¾ãŸã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
            except Exception as e:
                result['status'] = 'error'
                result['error'] = str(e)
                ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†")
            return False
        finally:
            self.results.append(result)
    
    async def process_single_prompt_text(self, prompt: str, index: int, max_retries: int = 2) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å‡¦ç†"""
        try:
            logger.info(f"\n--- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index}/{len(self.prompts)} ã‚’å‡¦ç†ä¸­ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼‰---")
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'text'
            }
            for attempt in range(1, max_retries + 1):
                try:
                    logger.info(f"è©¦è¡Œ {attempt}/{max_retries}")
                    await self.browser_controller.send_prompt(prompt)
                    if await self.browser_controller.wait_for_text_generation():
                        response_text = await self.browser_controller.extract_latest_text_response()
                        if response_text:
                            # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¿œã˜ã¦ãƒ•ã‚¡ã‚¤ãƒ«åã¨ä¿å­˜å½¢å¼ã‚’å¤‰æ›´
                            text_format = config.TEXT_FORMAT or 'txt'
                            
                            if text_format == 'json':
                                # JSONå½¢å¼
                                filename = self.generate_unique_filename(index)
                                filename = filename.replace('.txt', '.json')
                                json_data = {"response": response_text}
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        json.dump(json_data, f, ensure_ascii=False, indent=2)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"âœ… JSONä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                                        logger.info(f"ä¿å­˜å…ˆ: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {str(e)}'
                                    logger.error(f"JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
                            else:
                                # TXTå½¢å¼ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                                filename = self.generate_unique_filename(index)
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        f.write(response_text)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                                        logger.info(f"ä¿å­˜å…ˆ: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: {str(e)}'
                                    logger.error(f"ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
                        else:
                            result['status'] = 'extraction_failed'
                            result['error'] = 'ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºã«å¤±æ•—'
                    else:
                        result['status'] = 'generation_failed'
                        result['error'] = 'ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã«å¤±æ•—ã¾ãŸã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    if attempt < max_retries:
                        logger.info(f"5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await asyncio.sleep(5)
                    else:
                        break
                except Exception as e:
                    result['status'] = 'error'
                    result['error'] = str(e)
                    ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†ï¼ˆè©¦è¡Œ {attempt}ï¼‰")
                    if attempt < max_retries:
                        await asyncio.sleep(5)
                    else:
                        break
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†")
            return False
        finally:
            self.results.append(result)
    
    async def run_automation(self) -> None:
        """è‡ªå‹•åŒ–å‡¦ç†ã®å®Ÿè¡Œ"""
        try:
            logger.info("=== Geminiè‡ªå‹•åŒ–å‡¦ç†ã‚’é–‹å§‹ ===")
            logger.info(f"PC_ID: {self.pc_id}")
            logger.info(f"ãƒ¢ãƒ¼ãƒ‰: {self.mode.upper()}")
            logger.info(f"ä¿å­˜å…ˆ: ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚©ãƒ«ãƒ€")
            logger.info(f"ä¿å­˜ãƒ‘ã‚¹: {self.download_folder.absolute()}")
            await self.initialize()
            await self.login_process()
            if self.browser_controller.page:
                await self.browser_controller.page.screenshot(path="gemini_initial.png")
            successful_count = 0
            failed_prompts = []
            for i, prompt in enumerate(self.prompts, 1):
                try:
                    if self.mode == "text":
                        success = await self.process_single_prompt_text(prompt, i)
                    else:
                        success = await self.process_single_prompt_image(prompt, i)
                    if success:
                        successful_count += 1
                    else:
                        failed_prompts.append(f"{i}: {prompt[:50]}...")
                    if i < len(self.prompts):
                        await asyncio.sleep(8)
                except Exception as e:
                    logger.error(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {i} ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
                    failed_prompts.append(f"{i}: {prompt[:50]}... (ã‚¨ãƒ©ãƒ¼)")
                    continue
            try:
                self.sheets_manager.save_result_to_sheet(self.results, self.mode)
            except Exception as e:
                logger.warning(f"çµæœã®ã‚·ãƒ¼ãƒˆä¿å­˜ã«å¤±æ•—: {e}")
            self.generate_final_report(successful_count, failed_prompts)
        except Exception as e:
            ErrorHandler.log_error(e, "è‡ªå‹•åŒ–å‡¦ç†ã®é‡å¤§ãªã‚¨ãƒ©ãƒ¼")
            try:
                if self.browser_controller.page:
                    await self.browser_controller.page.screenshot(path="final_error.png")
            except:
                pass
            raise
        finally:
            await self.browser_controller.cleanup()
    
    def generate_final_report(self, successful: int, failed_prompts: list):
        """æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        logger.info(f"\n{'='*50}")
        logger.info("å‡¦ç†å®Œäº†ãƒ¬ãƒãƒ¼ãƒˆ")
        logger.info(f"{'='*50}")
        logger.info(f"PC_ID: {self.pc_id}")
        logger.info(f"ãƒ¢ãƒ¼ãƒ‰: {self.mode.upper()}")
        logger.info(f"æˆåŠŸ: {successful}/{len(self.prompts)} ä»¶")
        logger.info(f"å¤±æ•—: {len(failed_prompts)} ä»¶")
        logger.info(f"æˆåŠŸç‡: {successful/len(self.prompts)*100:.1f}%")
        logger.info(f"ä¿å­˜å…ˆ: {self.download_folder.absolute()}")
        if failed_prompts:
            logger.info("\nå¤±æ•—ã—ãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:")
            for failed in failed_prompts:
                logger.info(f"  - {failed}")

async def main():
    import argparse
    import os
    
    parser = argparse.ArgumentParser(description='Geminiè‡ªå‹•ç”Ÿæˆï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ç‰ˆï¼‰')
    parser.add_argument('--pc-id', type=int, default=None, help='PC_IDã‚’æ˜ç¤ºçš„ã«æŒ‡å®šï¼ˆæŒ‡å®šã—ãªã„å ´åˆã¯ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰è‡ªå‹•å–å¾—ï¼‰')
    parser.add_argument('--no-auto-detect', action='store_true', help='ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ã®PC_IDè‡ªå‹•å–å¾—ã‚’ç„¡åŠ¹åŒ–')
    args = parser.parse_args()
    
    print("=== Gemini è‡ªå‹•ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ç‰ˆï¼‰===")
    if args.pc_id is not None:
        print(f"PC_ID: {args.pc_id} (æ˜ç¤ºçš„æŒ‡å®š)")
        automator = GeminiAutomator(pc_id=args.pc_id, auto_detect_pc_id=False)
    elif args.no_auto_detect:
        default_pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
        print(f"PC_ID: {default_pc_id} (ç’°å¢ƒå¤‰æ•°/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)")
        automator = GeminiAutomator(pc_id=default_pc_id, auto_detect_pc_id=False)
    else:
        print("PC_ID: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ(B12ã‚»ãƒ«)ã‹ã‚‰è‡ªå‹•å–å¾—")
        automator = GeminiAutomator(auto_detect_pc_id=True)
    
    try:
        await automator.run_automation()
        print("\nå‡¦ç†ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
    except KeyboardInterrupt:
        print("\nå‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã—ãŸ")
    except Exception as e:
        print(f"\nã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        logger.error(f"ãƒ¡ã‚¤ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")

if __name__ == "__main__":
    asyncio.run(main())

#pm_agent.py
import asyncio
import json
import logging
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime

from config_utils import config, ErrorHandler
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_system_prompts import PM_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class PMAgent:
    """PM AI - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ã¨ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚’æ‹…å½“"""
    
    def __init__(self, sheets_manager: GoogleSheetsManager, browser_controller: BrowserController):
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.current_goal = None
        self.generated_tasks = []
        self.system_prompt = PM_SYSTEM_PROMPT
    
    async def load_project_goal(self) -> Optional[Dict]:
        """project_goalã‚·ãƒ¼ãƒˆã‹ã‚‰æœ€æ–°ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™ã‚’èª­ã¿è¾¼ã‚€"""
        try:
            logger.info("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            
            try:
                goal_sheet = sheet.worksheet("project_goal")
            except:
                logger.error("'project_goal'ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
            
            all_values = goal_sheet.get_all_values()
            
            if len(all_values) <= 1:
                logger.warning("ç›®æ¨™ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return None
            
            for row in all_values[1:]:
                if len(row) >= 3 and row[2].lower() == 'active':
                    goal = {
                        'goal_id': row[0],
                        'description': row[1],
                        'status': row[2],
                        'created_at': row[3] if len(row) > 3 else ''
                    }
                    logger.info(f"ç›®æ¨™ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {goal['description']}")
                    self.current_goal = goal
                    return goal
            
            logger.warning("ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None
            
        except Exception as e:
            ErrorHandler.log_error(e, "ç›®æ¨™èª­ã¿è¾¼ã¿")
            raise
    async def analyze_and_create_tasks(self, goal_description: str) -> Dict:
        """ç›®æ¨™ã‚’åˆ†æã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: é–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
            logger.info("="*60)
            logger.info("PM AI: ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚’é–‹å§‹ã—ã¾ã™")
            logger.info("="*60)
    
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰ ===
            full_prompt = f"""{self.system_prompt}

    ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã€‘
    {goal_description}

    ã€é‡è¦ãªå‡ºåŠ›æŒ‡ç¤ºã€‘
    1. **å¿…ãšæœ‰åŠ¹ãªJSONå½¢å¼ã®ã¿ã§å‡ºåŠ›ã—ã¦ãã ã•ã„**
    2. èª¬æ˜æ–‡ã€ã‚³ãƒ¡ãƒ³ãƒˆã€æŒ¨æ‹¶ãªã©ã¯ä¸€åˆ‡ä¸è¦ã§ã™
    3. æœ€åˆã®æ–‡å­—ãŒ {{ ã§ã€æœ€å¾Œã®æ–‡å­—ãŒ }} ã®å®Œå…¨ãªJSONå½¢å¼ã®ã¿ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„
    4. **ã‚¿ã‚¹ã‚¯æ•°ã¯æœ€å¤§15å€‹ã¾ã§**ã¨ã—ã€JSONãŒé•·ããªã‚Šã™ããªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„
    5. ã™ã¹ã¦ã®æ–‡å­—åˆ—å€¤ã¯æ­£ã—ããƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§å›²ã‚“ã§ãã ã•ã„

    ä¸Šè¨˜ã®ç›®æ¨™ã‚’é”æˆã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã‚’ã€JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚"""
    
            # === ãƒ‘ãƒ¼ãƒˆ3: Geminiã¸ã®é€ä¿¡ ===
            logger.info("Geminiã«é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
    
            # === ãƒ‘ãƒ¼ãƒˆ4: å¿œç­”å¾…æ©Ÿ ===
            logger.info("PM AIã®åˆ†æã‚’å¾…æ©Ÿä¸­...")
            success = await self.browser.wait_for_text_generation(max_wait=180)
    
            if not success:
                raise Exception("PM AIã®ã‚¿ã‚¹ã‚¯ç”ŸæˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
    
            # === ãƒ‘ãƒ¼ãƒˆ5: å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã®æŠ½å‡º ===
            response_text = await self.browser.extract_latest_text_response()
    
            if not response_text:
                raise Exception("PM AIã‹ã‚‰ã®å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
    
            logger.info(f"PM AIã®å¿œç­”ã‚’å–å¾—ã—ã¾ã—ãŸï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            logger.info(f"å¿œç­”ã®å…ˆé ­500æ–‡å­—:\n{response_text[:500]}")
            logger.info(f"å¿œç­”ã®æœ«å°¾500æ–‡å­—:\n{response_text[-500:]}")
    
            # === ãƒ‘ãƒ¼ãƒˆ6: JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æ ===
            task_plan = self._parse_json_response(response_text)
    
            if task_plan:
                # === ãƒ‘ãƒ¼ãƒˆ7: æˆåŠŸæ™‚ã®å‡¦ç† ===
                logger.info("="*60)
                logger.info("PM AI: ã‚¿ã‚¹ã‚¯åˆ†è§£å®Œäº†")
                logger.info(f"ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯æ•°: {len(task_plan.get('tasks', []))}")
                logger.info("="*60)
                self.generated_tasks = task_plan.get('tasks', [])
                return task_plan
            else:
                # === ãƒ‘ãƒ¼ãƒˆ8: JSONè§£æå¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç† ===
                logger.error("JSONè§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚å¿œç­”å…¨ä½“ã‚’ä¿å­˜ã—ã¾ã™ã€‚")
                fallback_path = Path("pm_ai_response_error.txt")
                with open(fallback_path, 'w', encoding='utf-8') as f:
                    f.write(response_text)
                logger.info(f"å¿œç­”ã‚’ä¿å­˜ã—ã¾ã—ãŸ: {fallback_path}")
        
                logger.error("="*60)
                logger.error("âŒ è‡ªå‹•ä¿®å¾©ã‚‚å¤±æ•—ã—ã¾ã—ãŸ")
                logger.error("="*60)
        
                # === ãƒ‘ãƒ¼ãƒˆ9: ä¿®æ­£æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚§ãƒƒã‚¯ ===
                fixed_path = Path("pm_ai_response_fixed.json")
                if fixed_path.exists():
                    logger.info("ä¿®æ­£æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡ºã—ã¾ã—ãŸ!")
                    try:
                        with open(fixed_path, 'r', encoding='utf-8') as f:
                            task_plan = json.load(f)
                        logger.info(f"âœ… ä¿®æ­£æ¸ˆã¿JSONã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: ã‚¿ã‚¹ã‚¯æ•°={len(task_plan.get('tasks', []))}")
                        self.generated_tasks = task_plan.get('tasks', [])
                        return task_plan
                    except Exception as e:
                        logger.error(f"ä¿®æ­£æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: {e}")
        
                raise Exception("PM AIã®å¿œç­”ã‚’JSONå½¢å¼ã§ãƒ‘ãƒ¼ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸ")
    
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ç”Ÿæˆ")
            raise
        
        
    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """å¿œç­”ã‹ã‚‰JSONéƒ¨åˆ†ã‚’æŠ½å‡ºã—ã¦ãƒ‘ãƒ¼ã‚¹ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å…¥åŠ›æ¤œè¨¼ ===
            if not text:
                logger.warning("ç©ºã®å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆ")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ2: è§£æé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
            logger.info("="*60)
            logger.info("JSONè§£æé–‹å§‹")
            logger.info("="*60)
            logger.info(f"å¿œç­”å…¨ä½“ã®é•·ã•: {len(text)}æ–‡å­—")
            
            import re
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ‘ã‚¿ãƒ¼ãƒ³1 - ```json ... ``` å½¢å¼ã®æ¤œå‡º ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                logger.info("âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json...``` å½¢å¼ã‚’æ¤œå‡º")
                try:
                    result = json.loads(json_str)
                    logger.info(f"âœ… JSONè§£ææˆåŠŸï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³1ï¼‰: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                    return result
                except json.JSONDecodeError as e:
                    logger.warning(f"ãƒ‘ã‚¿ãƒ¼ãƒ³1ã§JSONè§£æå¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‘ã‚¿ãƒ¼ãƒ³2 - ä¸­æ‹¬å¼§ã®ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ã—ãŸæŠ½å‡º ===
            start_idx = text.find('{')
            if start_idx != -1:
                logger.info(f"âœ… '{{' ã‚’ä½ç½® {start_idx} ã§æ¤œå‡º")
                
                # === ãƒ‘ãƒ¼ãƒˆ5: ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¤œå‡º ===
                brace_count = 0
                in_string = False
                escape_next = False
                
                for i, char in enumerate(text[start_idx:], start=start_idx):
                    if escape_next:
                        escape_next = False
                        continue
                    
                    if char == '\\':
                        escape_next = True
                        continue
                    
                    if char == '"' and not escape_next:
                        in_string = not in_string
                        continue
                    
                    if not in_string:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                # === ãƒ‘ãƒ¼ãƒˆ6: å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡ºã¨è§£æ ===
                                potential_json = text[start_idx:i+1]
                                logger.info(f"âœ… å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡º: {len(potential_json)}æ–‡å­—")
                                
                                try:
                                    result = json.loads(potential_json)
                                    logger.info(f"âœ… JSONè§£ææˆåŠŸ: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                                    return result
                                except json.JSONDecodeError as e:
                                    # === ãƒ‘ãƒ¼ãƒˆ7: è§£æã‚¨ãƒ©ãƒ¼ã®è©³ç´°ãƒ­ã‚° ===
                                    logger.error(f"âŒ JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
                                    logger.error(f"ã‚¨ãƒ©ãƒ¼ä½ç½®: line {e.lineno}, column {e.colno}")
                                    
                                    error_pos = e.pos if hasattr(e, 'pos') else 0
                                    context_start = max(0, error_pos - 100)
                                    context_end = min(len(potential_json), error_pos + 100)
                                    logger.error(f"ã‚¨ãƒ©ãƒ¼å‘¨è¾ºã®ãƒ†ã‚­ã‚¹ãƒˆ:\n{potential_json[context_start:context_end]}")
                                    
                                    # === ãƒ‘ãƒ¼ãƒˆ8: JSONä¿®å¾©ã®è©¦è¡Œ ===
                                    repaired_json = self._attempt_json_repair(potential_json, e)
                                    if repaired_json:
                                        return repaired_json
            
            # === ãƒ‘ãƒ¼ãƒˆ9: ãƒ‘ã‚¿ãƒ¼ãƒ³3 - ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’JSONã¨ã—ã¦è§£æ ===
            logger.info("ãƒ‘ã‚¿ãƒ¼ãƒ³3: ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’JSONã¨ã—ã¦è§£æ")
            try:
                result = json.loads(text)
                logger.info(f"âœ… JSONè§£ææˆåŠŸï¼ˆå…¨ä½“è§£æï¼‰: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                return result
            except json.JSONDecodeError as e:
                logger.error(f"âŒ å…¨ä½“è§£æã‚‚å¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ10: å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³å¤±æ•—æ™‚ã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚° ===
            logger.error("="*60)
            logger.error("âŒ ã™ã¹ã¦ã®JSONè§£æãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå¤±æ•—")
            logger.error("="*60)
            logger.error(f"å¿œç­”ã®å…ˆé ­500æ–‡å­—:\n{text[:500]}")
            logger.error(f"å¿œç­”ã®æœ«å°¾500æ–‡å­—:\n{text[-500:]}")
            
            return None
            
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ11: äºˆæœŸã—ãªã„ä¾‹å¤–ã®å‡¦ç† ===
            logger.error(f"âŒ JSONè§£æã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _attempt_json_repair(self, json_str: str, error: json.JSONDecodeError) -> Optional[Dict]:
        """å£Šã‚ŒãŸJSONã®ä¿®å¾©ã‚’è©¦ã¿ã‚‹"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ä¿®å¾©é–‹å§‹ ===
            logger.info("ğŸ”§ JSONä¿®å¾©ã‚’è©¦ã¿ã¾ã™...")
            
            error_pos = error.pos if hasattr(error, 'pos') else len(json_str)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ä¿®å¾©è©¦è¡Œ1 - ãƒ‡ãƒªãƒŸã‚¿ã‚¨ãƒ©ãƒ¼ã®ä¿®æ­£ ===
            if "Expecting ',' delimiter" in str(error) or "Expecting ':' delimiter" in str(error):
                last_complete_task = json_str.rfind('},', 0, error_pos)
                if last_complete_task > 0:
                    repaired = json_str[:last_complete_task + 1] + '], "risks": [], "success_criteria": []}'
                    logger.info(f"ä¿®å¾©è©¦è¡Œ1: ä½ç½®{last_complete_task}ã§åˆ‡ã‚Šæ¨ã¦")
                    try:
                        result = json.loads(repaired)
                        logger.info(f"âœ… ä¿®å¾©æˆåŠŸ! ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                        return result
                    except:
                        pass
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ä¿®å¾©è©¦è¡Œ2 - è¡Œãƒ™ãƒ¼ã‚¹ã®åˆ‡ã‚Šæ¨ã¦ ===
            lines = json_str.split('\n')
            error_line = error.lineno if hasattr(error, 'lineno') else len(lines)
            
            if error_line > 0 and error_line <= len(lines):
                truncated_lines = lines[:error_line-1]
                truncated = '\n'.join(truncated_lines)
                open_braces = truncated.count('{') - truncated.count('}')
                
                repaired = truncated
                if ',"tasks":[' in repaired and not repaired.rstrip().endswith(']'):
                    repaired += ']'
                
                # === ãƒ‘ãƒ¼ãƒˆ4: é–‹ã„ãŸä¸­æ‹¬å¼§ã‚’é–‰ã˜ã‚‹ ===
                for _ in range(open_braces):
                    repaired += '}'
                
                logger.info("ä¿®å¾©è©¦è¡Œ2: ä¸å®Œå…¨ãªéƒ¨åˆ†ã‚’å‰Šé™¤ã—ã¦é–‰ã˜ã‚‹")
                try:
                    result = json.loads(repaired)
                    logger.info(f"âœ… ä¿®å¾©æˆåŠŸ! ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                    return result
                except:
                    pass
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ä¿®å¾©å¤±æ•— ===
            logger.warning("âŒ JSONä¿®å¾©ã«å¤±æ•—")
            return None
            
        except Exception as e:
            logger.error(f"JSONä¿®å¾©ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")
            return None
        
    async def save_tasks_to_sheet(self, task_plan: Dict) -> bool:
        """ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ï¼ˆè¿½åŠ æ–¹å¼ï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ä¿å­˜é–‹å§‹ ===
            logger.info("ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ä¸­...")
        
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                # === ãƒ‘ãƒ¼ãƒˆ2: æ—¢å­˜ã‚·ãƒ¼ãƒˆã®èª­ã¿è¾¼ã¿ ===
                task_sheet = sheet.worksheet("pm_tasks")
                existing_data = task_sheet.get_all_values()
                start_row = len(existing_data) + 1
            
                if len(existing_data) == 0:
                    # === ãƒ‘ãƒ¼ãƒˆ3: æ–°è¦ã‚·ãƒ¼ãƒˆã®ãƒ˜ãƒƒãƒ€ãƒ¼ä½œæˆ ===
                    headers = [
                        "task_id", "parent_goal_id", "task_description", 
                        "required_role", "status", "priority", 
                        "estimated_time", "dependencies", "created_at", "batch_id"
                    ]
                    task_sheet.update('A1:J1', [headers])
                    start_row = 2
                
            except:
                # === ãƒ‘ãƒ¼ãƒˆ4: ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã®ä½œæˆ ===
                logger.info("'pm_tasks'ã‚·ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™")
                task_sheet = sheet.add_worksheet(title="pm_tasks", rows=1000, cols=10)
                headers = [
                    "task_id", "parent_goal_id", "task_description", 
                    "required_role", "status", "priority", 
                    "estimated_time", "dependencies", "created_at", "batch_id"
                ]
                task_sheet.update('A1:J1', [headers])
                start_row = 2
                existing_data = []
        
            # === ãƒ‘ãƒ¼ãƒˆ5: ãƒãƒƒãƒIDã®ç”Ÿæˆ ===
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            # === ãƒ‘ãƒ¼ãƒˆ6: æ—¢å­˜ã‚¿ã‚¹ã‚¯IDã®åé›† ===
            existing_task_ids = []
            if len(existing_data) > 1:
                for row in existing_data[1:]:
                    if row and row[0].isdigit():
                        existing_task_ids.append(int(row[0]))
        
            # === ãƒ‘ãƒ¼ãƒˆ7: æ¬¡ã®ã‚¿ã‚¹ã‚¯IDã®æ±ºå®š ===
            next_task_id = max(existing_task_ids) + 1 if existing_task_ids else 1
        
            # === ãƒ‘ãƒ¼ãƒˆ8: ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ ===
            tasks = task_plan.get('tasks', [])
            rows_data = []
        
            for i, task in enumerate(tasks):
                row = [
                    next_task_id + i,
                    self.current_goal['goal_id'] if self.current_goal else '',
                    task.get('description', ''),
                    task.get('required_role', 'dev'),
                    'pending',
                    task.get('priority', 'medium'),
                    task.get('estimated_time', ''),
                    ','.join(map(str, task.get('dependencies', []))),
                    datetime.now().isoformat(),
                    batch_id
                ]
                rows_data.append(row)
        
            # === ãƒ‘ãƒ¼ãƒˆ9: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã¸ã®æ›¸ãè¾¼ã¿ ===
            if rows_data:
                end_row = start_row + len(rows_data) - 1
                task_sheet.update(f'A{start_row}:J{end_row}', rows_data)
                logger.info(f"ã‚¿ã‚¹ã‚¯ {len(rows_data)} ä»¶ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼ˆãƒãƒƒãƒ: {batch_id}ï¼‰")
        
            # === ãƒ‘ãƒ¼ãƒˆ10: ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ ===
            self._save_project_metadata(task_plan)
        
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ä¿å­˜")
            return False
    
    def _save_project_metadata(self, task_plan: Dict):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚¿æƒ…å ±ï¼ˆåˆ†æçµæœã€ãƒªã‚¹ã‚¯ã€æˆåŠŸåŸºæº–ï¼‰ã‚’ä¿å­˜ï¼ˆè¿½åŠ æ–¹å¼ï¼‰"""
        try:
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                meta_sheet = sheet.worksheet("project_metadata")
                existing_data = meta_sheet.get_all_values()
                start_row = len(existing_data) + 2
            except:
                meta_sheet = sheet.add_worksheet(title="project_metadata", rows=100, cols=5)
                existing_data = []
                start_row = 1
        
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            data = [
                ["ãƒãƒƒãƒID", batch_id],
                ["ç›®æ¨™ID", self.current_goal['goal_id'] if self.current_goal else ''],
                ["åˆ†æçµæœ", task_plan.get('project_analysis', '')],
                ["", ""],
                ["ãƒªã‚¹ã‚¯", ""],
            ]
        
            for risk in task_plan.get('risks', []):
                data.append(["", risk])
        
            data.append(["", ""])
            data.append(["æˆåŠŸåŸºæº–", ""])
        
            for criteria in task_plan.get('success_criteria', []):
                data.append(["", criteria])
        
            if existing_data:
                data = [["", ""], ["="*50, "="*50]] + data
        
            end_row = start_row + len(data) - 1
            meta_sheet.update(f'A{start_row}:B{end_row}', data)
            logger.info("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
        
        except Exception as e:
            logger.warning(f"ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã«å¤±æ•—: {e}")
    
    def display_task_summary(self, task_plan: Dict):
        """ã‚¿ã‚¹ã‚¯æ¦‚è¦ã‚’è¡¨ç¤º"""
        print("\n" + "="*60)
        print("PM AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯åˆ†è§£çµæœ")
        print("="*60)
        
        print(f"\nã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æã€‘")
        print(task_plan.get('project_analysis', ''))
        
        print(f"\nã€ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯: {len(task_plan.get('tasks', []))}ä»¶ã€‘")
        for i, task in enumerate(task_plan.get('tasks', []), 1):
            role_icon = {
                'design': 'ğŸ“',
                'dev': 'ğŸ’»',
                'ui': 'ğŸ¨',
                'review': 'âœ…'
            }.get(task.get('required_role', 'dev'), 'ğŸ“‹')
            
            priority_icon = {
                'high': 'ğŸ”´',
                'medium': 'ğŸŸ¡',
                'low': 'ğŸŸ¢'
            }.get(task.get('priority', 'medium'), 'âšª')
            
            print(f"{i}. {priority_icon} {role_icon} {task.get('description', '')}")
            print(f"   æ‹…å½“: {task.get('required_role', 'dev')} | å„ªå…ˆåº¦: {task.get('priority', 'medium')}")
            if task.get('dependencies'):
                print(f"   ä¾å­˜: ã‚¿ã‚¹ã‚¯ {task.get('dependencies')}")
            print()
        
        if task_plan.get('risks'):
            print(f"\nã€æƒ³å®šãƒªã‚¹ã‚¯ã€‘")
            for risk in task_plan.get('risks', []):
                print(f"- {risk}")
        
        if task_plan.get('success_criteria'):
            print(f"\nã€æˆåŠŸåŸºæº–ã€‘")
            for criteria in task_plan.get('success_criteria', []):
                print(f"- {criteria}")
        
        print("="*60)

async def main():
    """PM AIå˜ä½“ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    import argparse
        
    # === ãƒ‘ãƒ¼ãƒˆ1: å¼•æ•°è§£æ ===
    parser = argparse.ArgumentParser(description='PM AI - ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ')
    parser.add_argument('--goal', type=str, help='ç›´æ¥ç›®æ¨™ã‚’æŒ‡å®šã™ã‚‹ï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’ä½¿ã‚ãªã„å ´åˆï¼‰')
    args = parser.parse_args()
        
    # === ãƒ‘ãƒ¼ãƒˆ2: èµ·å‹•ãƒ˜ãƒƒãƒ€ãƒ¼ ===
    print("="*60)
    print("PM AIèµ·å‹•ä¸­...")
    print("="*60)
        
    # === ãƒ‘ãƒ¼ãƒˆ3: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®š ===
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
        
    # === ãƒ‘ãƒ¼ãƒˆ4: ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ– ===
    sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
    # === ãƒ‘ãƒ¼ãƒˆ5: PCè¨­å®šã®èª­ã¿è¾¼ã¿ ===
    pc_id = sheets_manager.get_current_pc_id()
    settings = sheets_manager.load_pc_settings(pc_id)
        
    config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
    config.COOKIES_FILE = settings.get('cookies_file')
    config.GENERATION_MODE = 'text'
    config.SERVICE_TYPE = 'google'
        
    # === ãƒ‘ãƒ¼ãƒˆ6: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š ===
    download_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\temp_texts")
    download_folder.mkdir(exist_ok=True, parents=True)
        
    # === ãƒ‘ãƒ¼ãƒˆ7: ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åˆæœŸåŒ– ===
    browser = BrowserController(download_folder, mode='text', service='google')
    await browser.setup_browser()
        
    logger.info("Geminiã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
    await browser.navigate_to_gemini()
        
    # === ãƒ‘ãƒ¼ãƒˆ8: PMã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
    pm_agent = PMAgent(sheets_manager, browser)
        
    # === ãƒ‘ãƒ¼ãƒˆ9: ç›®æ¨™ã®å–å¾—ï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ or ã‚·ãƒ¼ãƒˆï¼‰===
    if args.goal:
        goal_description = args.goal
        logger.info(f"ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰ç›®æ¨™ã‚’å–å¾—: {goal_description}")
    else:
        goal = await pm_agent.load_project_goal()
        if not goal:
            print("\nã‚¨ãƒ©ãƒ¼: ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            print("ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®'project_goal'ã‚·ãƒ¼ãƒˆã«statusãŒ'active'ã®ç›®æ¨™ã‚’è¨­å®šã—ã¦ãã ã•ã„")
            await browser.cleanup()
            return
        goal_description = goal['description']
        
    try:
        # === ãƒ‘ãƒ¼ãƒˆ10: ã‚¿ã‚¹ã‚¯è¨ˆç”»ã®ç”Ÿæˆ ===
        task_plan = await pm_agent.analyze_and_create_tasks(goal_description)
            
        # === ãƒ‘ãƒ¼ãƒˆ11: ã‚¿ã‚¹ã‚¯æ¦‚è¦ã®è¡¨ç¤º ===
        pm_agent.display_task_summary(task_plan)
            
        # === ãƒ‘ãƒ¼ãƒˆ12: ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªã¨ä¿å­˜ ===
        save = input("\nã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
        if save.lower() == 'y':
            success = await pm_agent.save_tasks_to_sheet(task_plan)
            if success:
                print("ã‚¿ã‚¹ã‚¯ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
            else:
                print("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ")
            
    except Exception as e:
        # === ãƒ‘ãƒ¼ãƒˆ13: ä¾‹å¤–å‡¦ç† ===
        logger.error(f"PM AIå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        traceback.print_exc()
        
    finally:
        # === ãƒ‘ãƒ¼ãƒˆ14: ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— ===
        await browser.cleanup()
        print("\nPM AIã‚’çµ‚äº†ã—ã¾ã—ãŸ")

if __name__ == "__main__":
    asyncio.run(main())


#pm_system_prompts.py
"""
PM AIã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©ï¼ˆå®Œå…¨ç‰ˆï¼‰
ACF & Custom Post Type UI å¯¾å¿œ
"""

PM_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼AIã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç›®æ¨™ã‚’åˆ†æã—ã€é”æˆã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã«åˆ†è§£ã™ã‚‹
- å„ã‚¿ã‚¹ã‚¯ã«é©åˆ‡ãªæ‹…å½“è€…ï¼ˆAI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰ã‚’å‰²ã‚Šå½“ã¦ã‚‹
- **å¤šè¨€èªå¯¾å¿œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€å¿…ãšè¨€èªã¨Polylangè¨­å®šã‚’æ˜è¨˜ã™ã‚‹**
- **é–‹ç™ºã‚¿ã‚¹ã‚¯ã¯åŸå‰‡WordPressã§å®Ÿè£…å¯èƒ½ã‹æ¤œè¨ã™ã‚‹**
- ã‚¿ã‚¹ã‚¯ã®å„ªå…ˆé †ä½ã‚’æ±ºå®šã™ã‚‹
- å®Ÿç¾å¯èƒ½ã§å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã™ã‚‹

ã€é‡è¦: WordPresså„ªå…ˆé–‹ç™ºãƒãƒªã‚·ãƒ¼ã€‘
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ **WordPressä¸­å¿ƒã®é–‹ç™ºã‚¹ã‚¿ã‚¤ãƒ«** ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚
ä»¥ä¸‹ã®å„ªå…ˆé †ä½ã§ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„:

**å„ªå…ˆåº¦1: WordPressæ¨™æº–æ©Ÿèƒ½ + ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè£…**
- ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— â†’ **wordpress**: Custom Post Type UI ã§GUIè¨­å®š
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ â†’ **wordpress**: Advanced Custom Fields (ACF) ã§GUIè¨­å®š
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ â†’ **design**: ACFè¨­è¨ˆæ›¸ä½œæˆ â†’ **wordpress**: ACFè¨­å®š
- UI/ç”»é¢ãƒ‡ã‚¶ã‚¤ãƒ³ â†’ **ui**: ãƒ‡ã‚¶ã‚¤ãƒ³è¨­è¨ˆ â†’ **wordpress**: ãƒ†ãƒ¼ãƒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- æ¤œç´¢ãƒ»çµã‚Šè¾¼ã¿ â†’ **wordpress**: FacetWP / SearchWP / Relevanssiè¨­å®š
- ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆ â†’ **wordpress**: ACFãƒ•ã‚©ãƒ¼ãƒ  / Contact Form 7è¨­å®š
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç† â†’ **wordpress**: User Role Editor / Membersè¨­å®š

**å„ªå…ˆåº¦2: è»½é‡ã‚«ã‚¹ã‚¿ãƒ é–‹ç™ºï¼ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ´»ç”¨å¾Œã®å¾®èª¿æ•´ï¼‰**
- ACFé€£æºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º â†’ **dev**: functions.phpè¿½è¨˜
- æ¤œç´¢ã‚¯ã‚¨ãƒªèª¿æ•´ â†’ **dev**: pre_get_posts ãƒ•ãƒƒã‚¯å®Ÿè£…
- è¡¨ç¤ºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º â†’ **dev**: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ

**å„ªå…ˆåº¦3: é«˜åº¦ãªé–‹ç™ºï¼ˆWordPressæ¨™æº–ã§å®Ÿç¾å›°é›£ãªå ´åˆã®ã¿ï¼‰**
- è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ â†’ **dev**: ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™º
- å¤–éƒ¨APIé€£æº â†’ **dev**: REST APIçµ±åˆ
- ç‰¹æ®Šãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ â†’ **design**: ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ â†’ **dev**: å®Ÿè£…

**åˆ¤æ–­åŸºæº–:**
ã€ŒWordPressã®æ¨™æº–æ©Ÿèƒ½ã‚„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã§å®Ÿç¾ã§ãã‚‹ã‹ï¼Ÿã€
â†’ YES: wordpress / plugin ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
â†’ NO: design â†’ dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ã€åˆ©ç”¨å¯èƒ½ãªAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€‘

**é–‹ç™ºãƒ»è¨­è¨ˆç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **design** (è¨­è¨ˆAI): ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã€è¦ä»¶å®šç¾©æ›¸ä½œæˆã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã€APIä»•æ§˜æ›¸ä½œæˆã€ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­è¨ˆæ›¸ä½œæˆ
- **dev** (é–‹ç™ºAI): ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä½œæˆã€å®Ÿè£…ã€è¤‡æ•°è¨€èªå¯¾å¿œï¼ˆPython, JavaScript, PHP ãªã©ï¼‰ã€functions.php ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **ui** (UI/UX AI): ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆã€ç”»é¢è¨­è¨ˆã€UXæœ€é©åŒ–ã€ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ

**ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **writer** (æ±ç”¨ãƒ©ã‚¤ã‚¿ãƒ¼AI): ãƒ–ãƒ­ã‚°è¨˜äº‹ä½œæˆã€HTMLè¨˜äº‹åŸ·ç­†ã€SEOã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
- **writer_ja** (æ—¥æœ¬èªãƒ©ã‚¤ã‚¿ãƒ¼AI): æ—¥æœ¬èªè¨˜äº‹ä½œæˆã€å“è³ªé‡è¦–ã€æ—¥æœ¬ã®ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼å‘ã‘
- **writer_en** (è‹±èªãƒ©ã‚¤ã‚¿ãƒ¼AI): è‹±èªè¨˜äº‹ä½œæˆã€SEOæœ€é©åŒ–ã€å›½éš›æŠ•è³‡å®¶å‘ã‘
- **writer_ru** (ãƒ­ã‚·ã‚¢èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ãƒ­ã‚·ã‚¢èªè¨˜äº‹ä½œæˆã€ç¾åœ°ãƒ“ã‚¸ãƒã‚¹å‘ã‘
- **writer_uz** (ã‚¦ã‚ºãƒ™ã‚¯èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ã‚¦ã‚ºãƒ™ã‚¯èªè¨˜äº‹ä½œæˆã€ç¾åœ°ä¼æ¥­å‘ã‘
- **writer_zh** (ä¸­å›½èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ä¸­å›½èªè¨˜äº‹ä½œæˆã€ä¸­å›½æŠ•è³‡å®¶å‘ã‘
- **writer_ko** (éŸ“å›½èªãƒ©ã‚¤ã‚¿ãƒ¼AI): éŸ“å›½èªè¨˜äº‹ä½œæˆã€éŸ“å›½ãƒ“ã‚¸ãƒã‚¹å‘ã‘
- **writer_tr** (ãƒˆãƒ«ã‚³èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ãƒˆãƒ«ã‚³èªè¨˜äº‹ä½œæˆã€ãƒˆãƒ«ã‚³ãƒ“ã‚¸ãƒã‚¹å‘ã‘
- **content** (ã‚³ãƒ³ãƒ†ãƒ³ãƒ„AI): writerã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰

**WordPressãƒ»ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **wordpress** (WordPressAI): WordPressæŠ•ç¨¿ã€è¨˜äº‹å…¬é–‹ã€è¨˜äº‹ç·¨é›†ã€Polylangè¨€èªè¨­å®šã€ä¸‹æ›¸ãä¿å­˜ã€ACFè¨­å®šã€Custom Post Type UIè¨­å®šã€ãƒ†ãƒ¼ãƒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **plugin** (ãƒ—ãƒ©ã‚°ã‚¤ãƒ³AI): WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã€è¨­å®šå¤‰æ›´ã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é¸å®š

**å“è³ªç®¡ç†ç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **review** (ãƒ¬ãƒ“ãƒ¥ãƒ¼AI): å“è³ªãƒã‚§ãƒƒã‚¯ã€ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€è¨˜äº‹ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€å‡ºåŠ›ç‰©è©•ä¾¡

ã€é‡è¦: ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€‘
ä»¥ä¸‹ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯ã™ã§ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã§ã™ã€‚ã“ã‚Œã‚‰ã‚’æ´»ç”¨ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š
- Advanced Custom Fields (ACF) Pro
- Custom Post Type UI
- Polylang Pro
- FacetWPï¼ˆæ¤œç´¢æ©Ÿèƒ½å¼·åŒ–ï¼‰
- User Role Editorï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ç®¡ç†ï¼‰
- Wordfence Securityï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼‰
- WP Rocketï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼‰

ã€é‡è¦: ACF & Custom Post Type UI è¨­å®šã‚¿ã‚¹ã‚¯ã®ãƒ«ãƒ¼ãƒ«ã€‘

**ACFè¨­å®šã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€ACFè¨­å®šã€‘M&Aæ¡ˆä»¶ç”¨ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä½œæˆ",
  "acf_field_group_name": "M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±",
  "acf_fields": [
    {"name": "case_id", "type": "text", "label": "æ¡ˆä»¶ID", "required": true},
    {"name": "ma_scheme", "type": "select", "label": "M&Aã‚¹ã‚­ãƒ¼ãƒ ", "choices": ["æ ªå¼è­²æ¸¡", "äº‹æ¥­è­²æ¸¡"]},
    {"name": "desired_price", "type": "number", "label": "å¸Œæœ›ä¾¡æ ¼", "min": 0}
  ],
  "acf_location_rules": {
    "post_type": "ma_case"
  }
}
```

**ä½¿ç”¨å¯èƒ½ãªACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—:**
- ãƒ†ã‚­ã‚¹ãƒˆç³»: text, textarea, number, email, url, password
- é¸æŠç³»: select, checkbox, radio, true_false
- æ—¥ä»˜æ™‚åˆ»ç³»: date_picker, date_time_picker, time_picker
- ãƒ•ã‚¡ã‚¤ãƒ«ç³»: file, image, gallery
- ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç³»: post_object, relationship, taxonomy, user
- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç³»: repeater, flexible_content, group
- ãã®ä»–: wysiwyg, oembed, google_map, color_picker

**Custom Post Typeè¨­å®šã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€Custom Post Typeã€‘M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆ",
  "cpt_slug": "ma_case",
  "cpt_labels": {
    "singular": "M&Aæ¡ˆä»¶",
    "plural": "M&Aæ¡ˆä»¶ä¸€è¦§"
  },
  "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"],
  "cpt_settings": {
    "public": true,
    "has_archive": true,
    "show_in_rest": true,
    "menu_icon": "dashicons-portfolio"
  }
}
```

**ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼è¨­å®šã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã€‘æ¥­ç¨®ã‚«ãƒ†ã‚´ãƒªä½œæˆ",
  "taxonomy_slug": "industry_category",
  "taxonomy_labels": {
    "singular": "æ¥­ç¨®",
    "plural": "æ¥­ç¨®ä¸€è¦§"
  },
  "taxonomy_post_types": ["ma_case"],
  "taxonomy_hierarchical": true
}
```

**M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€M&Aæ¡ˆä»¶ç™»éŒ²ã€‘è£½é€ æ¥­ã®äº‹æ¥­æ‰¿ç¶™æ¡ˆä»¶æŠ•ç¨¿",
  "post_title": "è£½é€ æ¥­ãƒ»å¹´å•†5å„„å††ãƒ»é»’å­—ä¼æ¥­ã®äº‹æ¥­æ‰¿ç¶™æ¡ˆä»¶",
  "post_content": "ä¼æ¥­æ¦‚è¦...",
  "acf_fields": {
    "case_id": "MA2025001",
    "ma_scheme": "æ ªå¼è­²æ¸¡",
    "desired_price": "100000000",
    "industry_category": "è£½é€ æ¥­",
    "region": "é–¢æ±",
    "established_year": "1995",
    "employees": "50"
  },
  "polylang_lang": "ja",
  "post_status": "draft"
}
```

ã€é‡è¦: è¨€èªæŒ‡å®šã®ãƒ«ãƒ¼ãƒ«ã€‘
1. **è¨˜äº‹ä½œæˆã‚¿ã‚¹ã‚¯**ã«ã¯å¿…ãšä»¥ä¸‹ã‚’å«ã‚ã‚‹:
   - `language`: å¯¾è±¡è¨€èªã‚³ãƒ¼ãƒ‰ (ja/en/ru/uz/zh/ko/tr)
   - `polylang_lang`: Polylangã®è¨€èªè¨­å®š (ja/en/ru/uz_UZ/zh_CN/ko_KR/tr_TR)
   - `target_url`: å‚ç…§å…ƒURLï¼ˆã‚ã‚‹å ´åˆï¼‰
   - `seo_keywords`: SEOã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
   - `target_audience`: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…

2. **WordPressæŠ•ç¨¿ã‚¿ã‚¹ã‚¯**ã«ã¯å¿…ãšä»¥ä¸‹ã‚’å«ã‚ã‚‹:
   - `language`: æŠ•ç¨¿å…ˆè¨€èª
   - `polylang_lang`: Polylangè¨€èªã‚³ãƒ¼ãƒ‰
   - `source_task_id`: å…ƒè¨˜äº‹ã®ã‚¿ã‚¹ã‚¯ID
   - `post_action`: "create" ã¾ãŸã¯ "edit"
   - `post_status`: "publish" / "draft" / "pending"

3. **ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯**ã«ã¯ä»¥ä¸‹ã‚’å«ã‚ã‚‹:
   - `review_language`: ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã®è¨€èª
   - `review_target_task_id`: ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚¿ã‚¹ã‚¯ID
   - `review_criteria`: è©•ä¾¡åŸºæº–

ã€ã‚¿ã‚¹ã‚¯åˆ†è§£ã®åŸºæœ¬ãƒ•ãƒ­ãƒ¼ã€‘

**ãƒ‘ã‚¿ãƒ¼ãƒ³1: å¤šè¨€èªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "writer_ja",
      "description": "ã€æ—¥æœ¬èªã€‘M&Aå¸‚å ´å‹•å‘è¨˜äº‹ä½œæˆ",
      "language": "ja",
      "polylang_lang": "ja",
      "seo_keywords": "M&A,ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³,å¸‚å ´å‹•å‘"
    },
    {
      "id": 2,
      "agent": "review",
      "description": "ã€æ—¥æœ¬èªã€‘è¨˜äº‹å“è³ªãƒã‚§ãƒƒã‚¯",
      "review_language": "ja",
      "review_target_task_id": 1
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "ã€æ—¥æœ¬èªã€‘WordPressæŠ•ç¨¿",
      "polylang_lang": "ja",
      "source_task_id": 1,
      "post_action": "create",
      "post_status": "publish"
    },
    {
      "id": 4,
      "agent": "writer_en",
      "description": "ã€è‹±èªã€‘M&A market trends article",
      "language": "en",
      "polylang_lang": "en",
      "target_url": "å‚ç…§å…ƒè¨˜äº‹URL"
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "ã€è‹±èªã€‘WordPressæŠ•ç¨¿",
      "polylang_lang": "en",
      "source_task_id": 4,
      "post_action": "create"
    }
  ]
}
```

**ãƒ‘ã‚¿ãƒ¼ãƒ³2: M&Aãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ãƒˆæ©Ÿèƒ½é–‹ç™ºãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**
```json
{
  "project_name": "M&Aãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ãƒˆæ§‹ç¯‰",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "ã€è¦ä»¶å®šç¾©ã€‘M&Aæ¡ˆä»¶ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®è¦ä»¶å®šç¾©æ›¸ä½œæˆ",
      "priority": "high",
      "deliverables": ["è¦ä»¶å®šç¾©æ›¸.md"]
    },
    {
      "id": 2,
      "agent": "design",
      "description": "ã€ACFè¨­è¨ˆã€‘M&Aæ¡ˆä»¶ç”¨ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­è¨ˆæ›¸ä½œæˆ",
      "priority": "high",
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "ã€Custom Post Typeã€‘M&Aæ¡ˆä»¶ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆ",
      "priority": "high",
      "dependencies": [2],
      "cpt_slug": "ma_case",
      "cpt_labels": {"singular": "M&Aæ¡ˆä»¶", "plural": "M&Aæ¡ˆä»¶ä¸€è¦§"},
      "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"]
    },
    {
      "id": 4,
      "agent": "wordpress",
      "description": "ã€ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã€‘æ¥­ç¨®ã‚«ãƒ†ã‚´ãƒªä½œæˆ",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "industry_category",
      "taxonomy_labels": {"singular": "æ¥­ç¨®", "plural": "æ¥­ç¨®ä¸€è¦§"},
      "taxonomy_post_types": ["ma_case"],
      "taxonomy_hierarchical": true
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "ã€ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã€‘åœ°åŸŸã‚«ãƒ†ã‚´ãƒªä½œæˆ",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "region",
      "taxonomy_labels": {"singular": "åœ°åŸŸ", "plural": "åœ°åŸŸä¸€è¦§"}
    },
    {
      "id": 6,
      "agent": "wordpress",
      "description": "ã€ACFè¨­å®šã€‘M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ",
      "priority": "high",
      "dependencies": [3, 4, 5],
      "acf_field_group_name": "M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±",
      "acf_fields": [
        {"name": "case_id", "type": "text", "label": "æ¡ˆä»¶ID"},
        {"name": "ma_scheme", "type": "select", "label": "M&Aã‚¹ã‚­ãƒ¼ãƒ "},
        {"name": "desired_price", "type": "number", "label": "å¸Œæœ›ä¾¡æ ¼"},
        {"name": "industry_category", "type": "taxonomy", "label": "æ¥­ç¨®"},
        {"name": "region", "type": "taxonomy", "label": "åœ°åŸŸ"}
      ],
      "acf_location_rules": {"post_type": "ma_case"}
    },
    {
      "id": 7,
      "agent": "plugin",
      "description": "ã€FacetWPã€‘çµã‚Šè¾¼ã¿æ¤œç´¢è¨­å®š",
      "priority": "medium",
      "dependencies": [6],
      "plugin_name": "facetwp",
      "facets": [
        {"name": "æ¥­ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", "type": "checkboxes", "source": "tax/industry_category"},
        {"name": "ä¾¡æ ¼å¸¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", "type": "slider", "source": "cf/desired_price"},
        {"name": "åœ°åŸŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", "type": "dropdown", "source": "tax/region"}
      ]
    },
    {
      "id": 8,
      "agent": "ui",
      "description": "ã€æ¤œç´¢UIè¨­è¨ˆã€‘æ¤œç´¢ãƒ•ã‚©ãƒ¼ãƒ ç”»é¢ãƒ‡ã‚¶ã‚¤ãƒ³ä½œæˆ",
      "priority": "medium",
      "dependencies": [7]
    },
    {
      "id": 9,
      "agent": "plugin",
      "description": "ã€User Roleã€‘ææºãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ãƒ­ãƒ¼ãƒ«ä½œæˆ",
      "priority": "medium",
      "dependencies": [3],
      "plugin_name": "user-role-editor",
      "role_slug": "ma_partner",
      "role_name": "ææºãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼",
      "capabilities": {"read": true, "edit_posts": true}
    },
    {
      "id": 10,
      "agent": "plugin",
      "description": "ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€‘WordfenceåŸºæœ¬è¨­å®š",
      "priority": "high",
      "plugin_name": "wordfence"
    },
    {
      "id": 11,
      "agent": "plugin",
      "description": "ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€‘WP Rocketè¨­å®š",
      "priority": "medium",
      "plugin_name": "wp-rocket"
    },
    {
      "id": 12,
      "agent": "review",
      "description": "ã€ç·åˆè©•ä¾¡ã€‘æ©Ÿèƒ½å…¨ä½“ã®å“è³ªãƒã‚§ãƒƒã‚¯",
      "priority": "high",
      "dependencies": [7, 8, 9, 10, 11]
    }
  ]
}
```

**ãƒ‘ã‚¿ãƒ¼ãƒ³3: æ—¢å­˜WordPressè¨˜äº‹ã®å¤šè¨€èªå±•é–‹**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "wordpress",
      "description": "ã€è¨˜äº‹å–å¾—ã€‘æ—¢å­˜æŠ•ç¨¿ã®å†…å®¹å–å¾—",
      "post_id": 123
    },
    {
      "id": 2,
      "agent": "writer_en",
      "description": "ã€è‹±èªç¿»è¨³ã€‘è‹±èªç‰ˆè¨˜äº‹ä½œæˆ",
      "language": "en",
      "polylang_lang": "en",
      "source_post_id": 123,
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "ã€è‹±èªæŠ•ç¨¿ã€‘Polylangé€£æºã§è‹±èªç‰ˆå…¬é–‹",
      "polylang_lang": "en",
      "source_task_id": 2,
      "translation_of": 123,
      "dependencies": [2]
    }
  ]
}
```

ã€å‡ºåŠ›å½¢å¼ã€‘
å¿…ãšJSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

**JSONå‡ºåŠ›ä¾‹:**
```json
{
  "project_name": "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå",
  "total_tasks": 10,
  "estimated_duration": "2é€±é–“",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "ã€è¦ä»¶å®šç¾©ã€‘ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶å®šç¾©æ›¸ä½œæˆ",
      "priority": "high",
      "dependencies": [],
      "parameters": {}
    }
  ]
}
```

ã€é‡è¦ãªæ³¨æ„äº‹é …ã€‘
- ã‚¿ã‚¹ã‚¯èª¬æ˜ã®å†’é ­ã«å¿…ãšã€æ©Ÿèƒ½åã€‘ã¾ãŸã¯ã€è¨€èªåã€‘ã‚’ä»˜ã‘ã‚‹
- WordPressæŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã«ã¯å¿…ãš`source_task_id`ã‚’æŒ‡å®šï¼ˆç¿»è¨³ã®å ´åˆï¼‰
- ACFè¨­å®šã‚¿ã‚¹ã‚¯ã«ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è©³ç´°ã‚’å¿…ãšè¨˜è¼‰
- Custom Post Typeè¨­å®šã‚¿ã‚¹ã‚¯ã«ã¯ã‚¹ãƒ©ãƒƒã‚°ã¨ãƒ©ãƒ™ãƒ«ã‚’å¿…ãšæŒ‡å®š
- å„è¨€èªå°‚ç”¨ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ­£ã—ãæŒ‡å®š
- Polylangè¨€èªã‚³ãƒ¼ãƒ‰ã‚’æ­£ç¢ºã«è¨˜è¼‰ã™ã‚‹
  - æ—¥æœ¬èª: ja
  - è‹±èª: en
  - ãƒ­ã‚·ã‚¢èª: ru
  - ã‚¦ã‚ºãƒ™ã‚¯èª: uz_UZ
  - ä¸­å›½èª: zh_CN
  - éŸ“å›½èª: ko_KR
  - ãƒˆãƒ«ã‚³èª: tr_TR
- ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚¿ã‚¹ã‚¯ã«ã¯å…·ä½“çš„ãªè¨­å®šå†…å®¹ã‚’è¨˜è¼‰
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¿ã‚¹ã‚¯ã¯å¿…ãšå«ã‚ã‚‹
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã‚¿ã‚¹ã‚¯ã‚’å¿˜ã‚Œãšã«è¿½åŠ 
- ä¾å­˜é–¢ä¿‚ï¼ˆdependenciesï¼‰ã‚’æ­£ç¢ºã«è¨­å®š

ã€ã‚¿ã‚¹ã‚¯åˆ†è§£æ™‚ã®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã€‘
âœ… Custom Post Type ã¯ä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã¯ä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… æ¤œç´¢æ©Ÿèƒ½ã¯å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ã¯è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… Polylangè¨­å®šã¯å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯å°å…¥ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã¯å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… å„ã‚¿ã‚¹ã‚¯ã®ä¾å­˜é–¢ä¿‚ã¯æ­£ã—ã„ã‹ï¼Ÿ
âœ… ACF/CPT UIã®è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å…·ä½“çš„ã‹ï¼Ÿ
âœ… M&Aæ¡ˆä»¶æŠ•ç¨¿ã«ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
"""

#quick_fix.py
#!/usr/bin/env python3
"""
ã‚¯ã‚¤ãƒƒã‚¯ä¿®æ­£ã‚¹ã‚¯ãƒªãƒ—ãƒˆ - ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ä¿®æ­£
ä½¿ã„æ–¹: python quick_fix.py
"""

import os
import re
from pathlib import Path
import shutil
from datetime import datetime


def create_backup(file_path: Path) -> Path:
    """ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = file_path.with_suffix(f'.backup_{timestamp}{file_path.suffix}')
    shutil.copy2(file_path, backup_path)
    print(f"âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ: {backup_path}")
    return backup_path


def fix_wp_plugin_manager(base_dir: Path) -> bool:
    """wp_plugin_manager.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
    file_path = base_dir / "wordpress" / "wp_plugin_manager.py"
    
    if not file_path.exists():
        print(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
        return False
    
    print(f"\nğŸ”§ ä¿®æ­£ä¸­: {file_path}")
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    create_backup(file_path)
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ—¢ã«ä¿®æ­£æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    if 'from typing import' in content and 'List' in content:
        print("âœ… æ—¢ã«ä¿®æ­£æ¸ˆã¿ã§ã™")
        return True
    
    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’æ¢ã™
    import_pattern = r'^(import logging\s*\n)'
    
    # æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡
    new_imports = '''import logging
import asyncio
from typing import Dict, List, Optional, Any
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

'''
    
    # ç½®æ›
    if re.search(import_pattern, content, re.MULTILINE):
        content = re.sub(import_pattern, new_imports, content, count=1, flags=re.MULTILINE)
        print("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
    else:
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å…ˆé ­ã«è¿½åŠ 
        lines = content.split('\n')
        # docstring ã®å¾Œã«æŒ¿å…¥
        insert_index = 0
        for i, line in enumerate(lines):
            if '"""' in line or "'''" in line:
                # docstringã®çµ‚ã‚ã‚Šã‚’æ¢ã™
                for j in range(i+1, len(lines)):
                    if '"""' in lines[j] or "'''" in lines[j]:
                        insert_index = j + 1
                        break
                break
        
        if insert_index == 0:
            insert_index = 1  # ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®è¡Œã®å¾Œ
        
        lines.insert(insert_index, '\n' + new_imports.strip())
        content = '\n'.join(lines)
        print("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’å…ˆé ­ã«è¿½åŠ ã—ã¾ã—ãŸ")
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("âœ… wp_plugin_manager.py ã®ä¿®æ­£å®Œäº†")
    return True


def fix_wordpress_init(base_dir: Path) -> bool:
    """wordpress/__init__.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
    file_path = base_dir / "wordpress" / "__init__.py"
    
    if not file_path.exists():
        print(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
        return False
    
    print(f"\nğŸ”§ ãƒã‚§ãƒƒã‚¯ä¸­: {file_path}")
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå¿…è¦ã‹ç¢ºèª
    needs_fix = False
    
    if 'from .wp_agent import WordPressAgent' in content:
        if 'try:' not in content:
            needs_fix = True
    
    if not needs_fix:
        print("âœ… ä¿®æ­£ä¸è¦ã§ã™")
        return True
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    create_backup(file_path)
    
    # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤‰æ›´
    new_content = '''"""
WordPress ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
"""

try:
    from .wp_agent import WordPressAgent
    from .wp_utils import WordPressConfig, task_router
    __all__ = ['WordPressAgent', 'WordPressConfig', 'task_router']
except ImportError as e:
    import logging
    logger = logging.getLogger(__name__)
    logger.warning(f"âš ï¸ WordPress ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
    WordPressAgent = None
    WordPressConfig = None
    task_router = None
    __all__ = []
'''
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("âœ… wordpress/__init__.py ã®ä¿®æ­£å®Œäº†")
    return True


def check_all_typing_imports(base_dir: Path) -> list:
    """å…¨Pythonãƒ•ã‚¡ã‚¤ãƒ«ã® typing ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯"""
    print("\nğŸ” å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚§ãƒƒã‚¯ä¸­...")
    
    issues = []
    
    for py_file in base_dir.rglob("*.py"):
        if 'venv' in str(py_file) or '__pycache__' in str(py_file):
            continue
        
        try:
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # List, Dict ãªã©ã‚’ä½¿ã£ã¦ã„ã‚‹ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ãªã„
            if ('List[' in content or 'Dict[' in content or 
                'Optional[' in content or 'Tuple[' in content):
                if 'from typing import' not in content:
                    issues.append(str(py_file))
        except Exception as e:
            print(f"âš ï¸ {py_file} ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
    
    return issues


def fix_task_executor_imports(base_dir: Path) -> bool:
    """task_executor.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
    file_path = base_dir / "task_executor.py"
    
    if not file_path.exists():
        print(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
        return False
    
    print(f"\nğŸ”§ ä¿®æ­£ä¸­: {file_path}")
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    create_backup(file_path)
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ—¢ã«ä¿®æ­£æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    if 'from sheets_manager import GoogleSheetsManager' in content:
        print("âœ… æ—¢ã«ä¿®æ­£æ¸ˆã¿ã§ã™")
        return True
    
    # æ­£ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆé †åº
    correct_imports = '''"""
Task Executor - ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
from config_utils import ErrorHandler, config

# ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====
from sheets_manager import GoogleSheetsManager

# ===== ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    import warnings
    warnings.warn("âš ï¸ error_handler_enhancedæœªæ¤œå‡ºï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")

# ===== åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    import warnings
    warnings.warn("âš ï¸ task_executor_content/ma ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

# ===== WordPressé€£æºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None
    import warnings
    warnings.warn("âš ï¸ wordpress.wp_utils.task_router ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

logger = logging.getLogger(__name__)


'''
    
    # æ—¢å­˜ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆéƒ¨åˆ†ã‚’æ¢ã—ã¦ç½®ãæ›ãˆ
    # ã‚¯ãƒ©ã‚¹å®šç¾©ã®å‰ã¾ã§ã‚’ç½®ãæ›ãˆã‚‹
    class_pattern = r'class TaskExecutor:'
    class_match = re.search(class_pattern, content)
    
    if class_match:
        # ã‚¯ãƒ©ã‚¹å®šç¾©ä»¥é™ã‚’ä¿æŒ
        class_and_rest = content[class_match.start():]
        # æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆ + ã‚¯ãƒ©ã‚¹å®šç¾©ä»¥é™
        new_content = correct_imports + class_and_rest
    else:
        print("âš ï¸ TaskExecutor ã‚¯ãƒ©ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return False
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("âœ… task_executor.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¿®æ­£å®Œäº†")
    return True


def main():
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    print("="*60)
    print("ğŸ”§ ã‚¯ã‚¤ãƒƒã‚¯ä¿®æ­£ã‚¹ã‚¯ãƒªãƒ—ãƒˆ v2")
    print("="*60)
    
    # ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å–å¾—
    base_dir = Path.cwd()
    print(f"\nğŸ“ ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {base_dir}")
    
    # ä¿®æ­£å®Ÿè¡Œ
    success_count = 0
    
    # 1. wp_plugin_manager.py ã®ä¿®æ­£
    if fix_wp_plugin_manager(base_dir):
        success_count += 1
    
    # 2. wordpress/__init__.py ã®ä¿®æ­£
    if fix_wordpress_init(base_dir):
        success_count += 1
    
    # 3. task_executor.py ã®ä¿®æ­£ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    if fix_task_executor_imports(base_dir):
        success_count += 1
    
    # 4. ãã®ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
    issues = check_all_typing_imports(base_dir)
    
    if issues:
        print(f"\nâš ï¸ è¿½åŠ ã§ä¿®æ­£ãŒå¿…è¦ãªå¯èƒ½æ€§ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«: {len(issues)}ä»¶")
        for issue_file in issues[:10]:  # æœ€åˆã®10ä»¶ã®ã¿è¡¨ç¤º
            print(f"  - {issue_file}")
        
        if len(issues) > 10:
            print(f"  ... ä»– {len(issues) - 10} ä»¶")
    
    # çµæœã‚µãƒãƒªãƒ¼
    print("\n" + "="*60)
    print("ğŸ“Š ä¿®æ­£å®Œäº†")
    print("="*60)
    print(f"âœ… ä¿®æ­£æˆåŠŸ: {success_count} ãƒ•ã‚¡ã‚¤ãƒ«")
    
    if issues:
        print(f"âš ï¸ è¦ç¢ºèª: {len(issues)} ãƒ•ã‚¡ã‚¤ãƒ«")
        print("\nğŸ’¡ ãƒ’ãƒ³ãƒˆ: å„ãƒ•ã‚¡ã‚¤ãƒ«ã§ä»¥ä¸‹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„:")
        print("   from typing import Dict, List, Optional, Any")
    
    print("\nğŸ‰ ä¿®æ­£å®Œäº†ï¼")
    print("æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã§å®Ÿè¡Œã—ã¦ãã ã•ã„:")
    print("   python run_multi_agent.py --auto")


if __name__ == "__main__":
    main()

#review_agent.py
# review_agent.py
"""ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController
from sheets_manager import GoogleSheetsManager
from review_agent_prompts import REVIEW_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class ReviewAgent:
    """ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
    
    def __init__(self):
        """ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ - å¾Œã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®šã™ã‚‹"""
        self.browser = None
        self.sheets_manager = None
        self.system_prompt = REVIEW_SYSTEM_PROMPT

    async def process_task(self, task: Dict) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰"""
        return await self.review_completed_task(task, task.get('output_content', ''))

    async def review_completed_task(self, task: Dict, output_content: str) -> Dict:
        """å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå¤±æ•—åŸå› åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹å‡¦ç† ===
            logger.info("="*60)
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¹ã‚¯ {task['task_id']} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹")
            logger.info("="*60)
            
            # ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç¢ºèª
            task_status = task.get('status', 'unknown')
            is_failed_task = task_status in ['failed', 'error', 'timeout']
            
            # äº‹å‰ãƒã‚§ãƒƒã‚¯ï¼šå‡ºåŠ›å†…å®¹ã®æ§‹é€ ã‚’æ¤œè¨¼
            pre_check_result = self._pre_check_content(output_content, task['required_role'])
            if pre_check_result:
                logger.info(f"äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœ: {pre_check_result}")
            
            # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’å–å¾—
            error_info = task.get('error', '')
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰ã¨Geminié€ä¿¡ ===
            full_prompt = self._build_review_prompt(
                task, task_status, is_failed_task, 
                output_content, error_info, pre_check_result
            )
            
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’Geminiã«ä¾é ¼ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
                return self._create_default_review(task, is_failed_task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: å¿œç­”å–å¾—ã¨çµæœè§£æ ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
            
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            review_result = self._parse_review_json(response_text)
            
            if review_result:
                # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
                validated_review = self._validate_review_result(review_result, output_content)
                self._display_review_summary(validated_review, is_failed_task)
                return {
                    'success': True,
                    'review': validated_review,
                    'summary': validated_review.get('evaluation', {}).get('overall_assessment', ''),
                    'full_text': response_text
                }
            else:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONè§£æã«å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ¬ãƒ“ãƒ¥ãƒ¼AIå‡¦ç†")
            return self._create_default_review(task, False)

    def _build_review_prompt(self, task: Dict, task_status: str, is_failed_task: bool,
                           output_content: str, error_info: str, pre_check_result: str) -> str:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰(ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£æƒ…å ±ä»˜ã)"""
    
        # === ğŸ†• æ–°è¦è¿½åŠ : ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£æƒ…å ±ã®æŠ½å‡º ===
        traceability = task.get('_traceability', {})
        executed_by = traceability.get('executed_by_agent', 'ä¸æ˜')
        agent_class = traceability.get('agent_class', 'ä¸æ˜')
    
        return f"""{self.system_prompt}

    ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚¿ã‚¹ã‚¯ã€‘
    ã‚¿ã‚¹ã‚¯ID: {task['task_id']}
    å†…å®¹: {task['description']}
    æ‹…å½“: {task['required_role']}
    ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task_status}
    å‡ºåŠ›æ–‡å­—æ•°: {len(output_content)}æ–‡å­—

    ğŸ†•ã€å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæƒ…å ±ã€‘(åŸå› åˆ‡ã‚Šåˆ†ã‘ç”¨)
    å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {executed_by}
    ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹: {agent_class}
    å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—: {traceability.get('execution_timestamp', 'N/A')}

    ã€ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ã€‘
    {'âŒ ã“ã®ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸ' if is_failed_task else 'âœ… ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã—ã¾ã—ãŸ'}
    {f'ã‚¨ãƒ©ãƒ¼æƒ…å ±: {error_info}' if error_info else ''}

    ã€äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœã€‘
    {pre_check_result if pre_check_result else 'ç‰¹è¨˜äº‹é …ãªã—'}

    ã€ã‚¿ã‚¹ã‚¯ã®å‡ºåŠ›ã€‘
    {output_content[:4000] if output_content else '(å‡ºåŠ›ãªã—)'}

    ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã€æŒ‡å®šã•ã‚ŒãŸJSONå½¢å¼ã§è©•ä¾¡ã¨æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚
    {'ç‰¹ã«å¤±æ•—åŸå› ã‚’è©³ç´°ã«åˆ†æã—ã€é©åˆ‡ãªæ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚' if is_failed_task else 'ç‰¹ã«ã€æ§‹é€ çš„ã«å®Œçµã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’é‡ç‚¹çš„ã«ç¢ºèªã—ã¦ãã ã•ã„ã€‚'}

    ğŸ†•ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã®æ³¨æ„ã€‘
    - ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒé€”ä¸­ã§é€”åˆ‡ã‚Œã¦ã„ã‚‹å ´åˆã¯å¿…ãšæŒ‡æ‘˜ã—ã¦ãã ã•ã„
    - å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ({executed_by})ã®å‡ºåŠ›å“è³ªã«å•é¡ŒãŒã‚ã‚‹å ´åˆã€ãã®æ—¨ã‚’æ˜è¨˜ã—ã¦ãã ã•ã„
    - æ‰‹å‹•ä½œæ¥­ãŒå¿…è¦ãªæ‰‹é †ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€è‡ªå‹•åŒ–ã®ææ¡ˆã‚‚å«ã‚ã¦ãã ã•ã„
    """


    def _pre_check_content(self, content: str, role: str) -> str:
        """å‡ºåŠ›å†…å®¹ã®äº‹å‰ãƒã‚§ãƒƒã‚¯"""
        checks = []
        
        # === ãƒ‘ãƒ¼ãƒˆ1: æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯ ===
        if len(content) < 100:
            checks.append("âš ï¸ æ–‡å­—æ•°ãŒå°‘ãªã™ãã¾ã™ï¼ˆ100æ–‡å­—æœªæº€ï¼‰")
        elif len(content) > 5000:
            checks.append("âœ… æ–‡å­—æ•°ãŒååˆ†ã§ã™")
        
        # === ãƒ‘ãƒ¼ãƒˆ2: è¨˜äº‹ãƒ»æ–‡æ›¸ç³»ã‚¿ã‚¹ã‚¯ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯ ===
        if role in ['writer', 'content', 'wordpress', 'writer_ja', 'writer_en', 'writer_ru']:
            if '<h1' in content or '<h2' in content or '# ' in content:
                checks.append("âœ… è¦‹å‡ºã—æ§‹é€ ãŒã‚ã‚Šã¾ã™")
            
            if any(phrase in content for phrase in ['ã¾ã¨ã‚', 'çµè«–', 'çµ‚ã‚ã‚Š', 'ä»¥ä¸Š', 'æœ€å¾Œã«', 'Conclusion', 'Summary']):
                checks.append("âœ… çµè«–ãƒ»ã¾ã¨ã‚ãŒã‚ã‚Šã¾ã™")
            else:
                checks.append("âš ï¸ æ˜ç¤ºçš„ãªçµè«–ãƒ»ã¾ã¨ã‚ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®é–‰ã˜å¿˜ã‚Œãƒã‚§ãƒƒã‚¯
            if content.count('<div') > content.count('</div'):
                checks.append("âš ï¸ HTMLã®divã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
            if content.count('<p>') > content.count('</p>'):
                checks.append("âš ï¸ HTMLã®pã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚³ãƒ¼ãƒ‰ç³»ã‚¿ã‚¹ã‚¯ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯ ===
        if role in ['dev', 'programming']:
            if 'def ' in content or 'function ' in content or 'class ' in content:
                checks.append("âœ… é–¢æ•°/ã‚¯ãƒ©ã‚¹å®šç¾©ãŒã‚ã‚Šã¾ã™")
            if 'import ' in content or 'require ' in content:
                checks.append("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚Šã¾ã™")
        
        return " | ".join(checks) if checks else "âœ… åŸºæœ¬çš„ãªæ§‹é€ ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“"

    def _validate_review_result(self, review: Dict, original_content: str) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼"""
        evaluation = review.get('evaluation', {})
        next_actions = review.get('next_actions', {})
        
        # === ãƒ‘ãƒ¼ãƒˆ1: ã€Œéƒ¨åˆ†çš„ã€åˆ¤å®šã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ ===
        if evaluation.get('completeness') == 'éƒ¨åˆ†çš„':
            issues = evaluation.get('issues', [])
            new_issues = []
            
            for issue in issues:
                # æ–‡å­—æ•°é–¢é€£ã®æŒ‡æ‘˜ã‚’æ¤œè¨¼
                if any(word in issue for word in ['æ–‡å­—æ•°', 'æ–‡å­—', 'çŸ­ã„', 'å°‘ãªã„']):
                    if len(original_content) > 1000:  # 1000æ–‡å­—ä»¥ä¸Šã‚ã‚Œã°æ–‡å­—æ•°ä¸è¶³ã§ã¯ãªã„
                        continue
                # æ§‹é€ çš„ãªæŒ‡æ‘˜ã‚’æ¤œè¨¼
                elif 'åˆ‡ã‚Œã¦' in issue or 'é€”åˆ‡ã‚Œ' in issue:
                    # å®Ÿéš›ã«æ–‡ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if self._is_content_properly_ended(original_content):
                        continue
                
                new_issues.append(issue)
            
            # å•é¡Œç‚¹ã‚’æ›´æ–°
            evaluation['issues'] = new_issues
            
            # å•é¡Œç‚¹ãŒãªããªã£ãŸå ´åˆã¯ã€Œå®Œäº†ã€ã«å¤‰æ›´
            if not new_issues and len(original_content) > 500:
                evaluation['completeness'] = 'å®Œäº†'
                evaluation['overall_assessment'] = 'å†è©•ä¾¡: å†…å®¹ã¯å®Œçµã—ã¦ãŠã‚Šã€æ–‡å­—æ•°ã‚‚ååˆ†ã§ã™'
                next_actions['required'] = False
                next_actions['suggested_tasks'] = []
        
        return review

    def _is_content_properly_ended(self, content: str) -> bool:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒé©åˆ‡ã«çµ‚äº†ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        # === ãƒ‘ãƒ¼ãƒˆ1: æ–‡ã®çµ‚äº†ãƒã‚§ãƒƒã‚¯ ===
        sentences = re.split(r'[ã€‚ï¼ï¼Ÿ!?\.]', content.strip())
        if sentences and sentences[-1].strip():
            return False  # æœ€å¾Œã®æ–‡ãŒçµ‚äº†è¨˜å·ã§çµ‚ã‚ã£ã¦ã„ãªã„
        
        # === ãƒ‘ãƒ¼ãƒˆ2: HTMLã‚¿ã‚°ã®é–‰ã˜ãƒã‚§ãƒƒã‚¯ ===
        if content.count('<') > 0 and content.count('>') > 0:
            open_tags = len(re.findall(r'<(?!\/)[^>]+>', content))
            close_tags = len(re.findall(r'<\/[^>]+>', content))
            if open_tags != close_tags:
                return False
        
        return True

    def _parse_review_json(self, text: str) -> Optional[Dict]:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONã‚’ãƒ‘ãƒ¼ã‚¹"""
        try:
            import re
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ```json ... ``` å½¢å¼ã®æŠ½å‡º ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡º ===
            json_match = re.search(r'(\{.*\})', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            logger.warning("JSONå½¢å¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None
            
        except json.JSONDecodeError as e:
            logger.error(f"JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def _create_default_review(self, task: Dict, is_failed: bool = False) -> Dict:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœï¼ˆå¤±æ•—æ™‚ï¼‰"""
        if is_failed:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å¤±æ•—',
                        'quality_score': 3,
                        'issues': ['ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ'],
                        'good_points': [],
                        'overall_assessment': 'ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸãŒã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚‚å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ',
                        'failure_analysis': {
                            'is_failed': True,
                            'failure_category': 'ç’°å¢ƒå•é¡Œ',
                            'root_cause': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—',
                            'impact': 'å¤±æ•—åŸå› ã®è©³ç´°ãŒä¸æ˜',
                            'recommended_action': 'immediate_retry',
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': True,
                        'reasoning': 'ã‚¿ã‚¹ã‚¯ã®å†å®Ÿè¡Œã¾ãŸã¯ä¿®æ­£ãŒå¿…è¦',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ã‚¿ã‚¹ã‚¯å¤±æ•—',
                'full_text': ''
            }
        else:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å®Œäº†',
                        'quality_score': 7,
                        'issues': [],
                        'good_points': ['ã‚¿ã‚¹ã‚¯å®Œäº†'],
                        'overall_assessment': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸãŒã€ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã¨ã¿ãªã—ã¾ã™',
                        'failure_analysis': {
                            'is_failed': False,
                            'failure_category': None,
                            'root_cause': None,
                            'impact': None,
                            'recommended_action': None,
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': False,
                        'reasoning': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—ã—ãŸãŸã‚ã€è¿½åŠ ã‚¿ã‚¹ã‚¯ãªã—',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè©•ä¾¡',
                'full_text': ''
            }

    def _display_review_summary(self, review: Dict, is_failed_task: bool = False):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’è¡¨ç¤ºï¼ˆå¤±æ•—åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        
        print("\n" + "ğŸ¯" * 30)
        print("ğŸ“‹ ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ")
        print("ğŸ¯" * 30)
        
        evaluation = review.get('evaluation', {})
        
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬æƒ…å ±è¡¨ç¤º ===
        completeness = evaluation.get('completeness', 'N/A')
        completeness_icon = {
            'å®Œäº†': 'âœ…',
            'éƒ¨åˆ†çš„': 'âš ï¸',
            'ä¸å®Œå…¨': 'âŒ',
            'å¤±æ•—': 'ğŸ’¥'
        }.get(completeness, 'â“')
        
        print(f"\n{completeness_icon} å®Œæˆåº¦: {completeness}")
        print(f"â­ å“è³ªã‚¹ã‚³ã‚¢: {evaluation.get('quality_score', 'N/A')}/10")
        
        # === ãƒ‘ãƒ¼ãƒˆ2: å¤±æ•—åˆ†æè¡¨ç¤º ===
        failure_analysis = evaluation.get('failure_analysis', {})
        if failure_analysis.get('is_failed'):
            print("\n" + "ğŸ’¥" * 30)
            print("ğŸ” å¤±æ•—åŸå› åˆ†æ")
            print("ğŸ’¥" * 30)
            
            category = failure_analysis.get('failure_category', 'N/A')
            category_icon = {
                'è¦ä»¶ä¸æ˜ç­': 'ğŸ“',
                'æŠ€è¡“çš„å•é¡Œ': 'âš™ï¸',
                'ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³': 'ğŸ“¦',
                'ä¾å­˜é–¢ä¿‚': 'ğŸ”—',
                'ç’°å¢ƒå•é¡Œ': 'ğŸŒ',
                'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ': 'â±ï¸',
                'å‡ºåŠ›ä¸å®Œå…¨': 'âœ‚ï¸',
                'å“è³ªä¸è¶³': 'ğŸ“‰'
            }.get(category, 'â“')
            
            print(f"\n{category_icon} å¤±æ•—ã‚«ãƒ†ã‚´ãƒª: {category}")
            print(f"ğŸ” æ ¹æœ¬åŸå› : {failure_analysis.get('root_cause', 'N/A')}")
            print(f"ğŸ’¡ å½±éŸ¿: {failure_analysis.get('impact', 'N/A')}")
            
            action = failure_analysis.get('recommended_action', 'N/A')
            action_map = {
                'immediate_retry': 'ğŸ”„ å³åº§ã«å†å®Ÿè¡Œ',
                'modify_task': 'âœï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¿®æ­£',
                'add_prerequisite': 'â• å‰æã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ',
                'escalate': 'ğŸš¨ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆäººé–“ã®åˆ¤æ–­ãŒå¿…è¦ï¼‰',
                'skip': 'â­ï¸ ã‚¹ã‚­ãƒƒãƒ—ã¾ãŸã¯å¾Œå›ã—'
            }
            print(f"ğŸ“Œ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_map.get(action, action)}")
            
            prereqs = failure_analysis.get('prerequisites', [])
            if prereqs:
                print(f"\nğŸ“‹ å‰ææ¡ä»¶:")
                for prereq in prereqs:
                    print(f"   â€¢ {prereq}")
            
            print("ğŸ’¥" * 30)
        
        # === ãƒ‘ãƒ¼ãƒˆ3: è‰¯ã„ç‚¹ãƒ»å•é¡Œç‚¹è¡¨ç¤º ===
        good_points = evaluation.get('good_points', [])
        if good_points:
            print(f"\nâœ¨ è‰¯ã„ç‚¹:")
            for point in good_points:
                print(f"   âœ… {point}")
        
        issues = evaluation.get('issues', [])
        if issues:
            print(f"\nâš ï¸ å•é¡Œç‚¹:")
            for issue in issues:
                print(f"   âŒ {issue}")
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ç·åˆè©•ä¾¡è¡¨ç¤º ===
        overall = evaluation.get('overall_assessment', '')
        if overall:
            print(f"\nğŸ’ ç·åˆè©•ä¾¡:")
            print(f"   {overall}")
        
        # === ãƒ‘ãƒ¼ãƒˆ5: æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤º ===
        next_actions = review.get('next_actions', {})
        required = next_actions.get('required', False)
        
        action_icon = 'ğŸ”´' if required else 'ğŸŸ¢'
        print(f"\nğŸ¯ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_icon} {'å¿…è¦' if required else 'ä¸è¦'}")
        
        if required:
            reasoning = next_actions.get('reasoning', '')
            if reasoning:
                print(f"   ğŸ“Œ ç†ç”±: {reasoning}")
            
            # ææ¡ˆã‚¿ã‚¹ã‚¯
            suggested_tasks = next_actions.get('suggested_tasks', [])
            if suggested_tasks:
                print(f"\nğŸš€ ææ¡ˆã‚¿ã‚¹ã‚¯ ({len(suggested_tasks)}ä»¶):")
                for i, task in enumerate(suggested_tasks, 1):
                    priority_icon = {
                        'high': 'ğŸ”´',
                        'medium': 'ğŸŸ¡',
                        'low': 'ğŸŸ¢'
                    }.get(task.get('priority', 'medium'), 'âšª')
                    
                    role_icon = {
                        'design': 'ğŸ“',
                        'dev': 'ğŸ’»',
                        'ui': 'ğŸ¨',
                        'review': 'âœ…',
                        'wordpress': 'ğŸŒ',
                        'content': 'âœï¸',
                        'writer': 'ğŸ“',
                        'writer_ja': 'ğŸ—¾',
                        'writer_en': 'ğŸ” ',
                        'writer_ru': 'ğŸ‡·ğŸ‡º'
                    }.get(task.get('required_role', 'dev'), 'ğŸ“‹')
                    
                    print(f"   {i}. {priority_icon} {role_icon} {task.get('description', 'N/A')}")
                    
                    deps = task.get('dependencies', [])
                    if deps:
                        print(f"      ğŸ“ ä¾å­˜: {', '.join(map(str, deps))}")
        
        print("ğŸ¯" * 30 + "\n")

    async def add_suggested_tasks_to_sheet(self, parent_task_id: str, suggested_tasks: List[Dict]) -> int:
        """ææ¡ˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’pm_tasksã‚·ãƒ¼ãƒˆã«è¿½åŠ ï¼ˆæ­£ã—ã„åˆ—é…ç½®ç‰ˆï¼‰"""
        try:
            if not suggested_tasks:
                return 0
            
            logger.info(f"ææ¡ˆã‚¿ã‚¹ã‚¯ {len(suggested_tasks)} ä»¶ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«è¿½åŠ ä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæº–å‚™ ===
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            task_sheet = sheet.worksheet("pm_tasks")
            
            # æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            all_values = task_sheet.get_all_values()
            
            if len(all_values) < 1:
                logger.error("pm_tasksã‚·ãƒ¼ãƒˆãŒç©ºã§ã™")
                return 0
            
            # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ç¢ºèª
            headers = all_values[0]
            logger.info(f"åˆ—ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯IDã®æ±ºå®š ===
            existing_task_ids = []
            for row in all_values[1:]:  # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if row and len(row) > 0:
                    try:
                        task_id = int(row[0])
                        existing_task_ids.append(task_id)
                    except (ValueError, IndexError):
                        continue
            
            # æ¬¡ã®ã‚¿ã‚¹ã‚¯IDã‚’æ±ºå®š
            if existing_task_ids:
                next_task_id = max(existing_task_ids) + 1
            else:
                next_task_id = 1
            
            logger.info(f"æ¬¡ã®ã‚¿ã‚¹ã‚¯ID: {next_task_id}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ ===
            rows_to_add = []
            for task in suggested_tasks:
                row = [
                    next_task_id,  # A: task_id
                    '',  # B: parent_goal_idï¼ˆç©ºæ¬„ï¼‰
                    task.get('description', ''),  # C: task_description
                    task.get('required_role', 'dev'),  # D: required_role
                    'pending',  # E: status
                    task.get('priority', 'medium'),  # F: priority
                    task.get('estimated_time', ''),  # G: estimated_time
                    ','.join(map(str, task.get('dependencies', [parent_task_id]))),  # H: dependencies
                    datetime.now().isoformat(),  # I: created_at
                    f"Review suggested from task {parent_task_id}"  # J: notes
                ]
                rows_to_add.append(row)
                logger.info(f"è¿½åŠ äºˆå®šã‚¿ã‚¹ã‚¯: ID={next_task_id}, å†…å®¹={task.get('description', '')[:50]}")
                next_task_id += 1
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‡ãƒ¼ã‚¿è¿½åŠ å‡¦ç† ===
            if rows_to_add:
                # æœ€çµ‚è¡Œã®æ¬¡ã®è¡Œã‹ã‚‰è¿½åŠ 
                start_row = len(all_values) + 1
                
                # ã‚»ãƒ«ç¯„å›²ã‚’æŒ‡å®šã—ã¦è¿½åŠ 
                range_notation = f'A{start_row}:J{start_row + len(rows_to_add) - 1}'
                
                logger.info(f"ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ : {range_notation}")
                task_sheet.update(range_notation, rows_to_add)
                
                logger.info(f"âœ… ææ¡ˆã‚¿ã‚¹ã‚¯ {len(rows_to_add)} ä»¶ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
                
                # è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯IDã‚’ãƒ­ã‚°å‡ºåŠ›
                added_ids = [row[0] for row in rows_to_add]
                logger.info(f"è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ID: {added_ids}")
            
            return len(rows_to_add)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ææ¡ˆã‚¿ã‚¹ã‚¯è¿½åŠ ")
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return 0

#review_agent_prompts.py
# review_agent_prompts.py
"""ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©"""

REVIEW_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- ã‚¿ã‚¹ã‚¯ã®å®Œæˆåº¦ã‚’è©•ä¾¡ã™ã‚‹
- å‡ºåŠ›ç‰©ã®å“è³ªã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
- **å¤±æ•—åŸå› ã‚’ç‰¹å®šã—åˆ†é¡ã™ã‚‹**
- æ¬¡ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã‚’ç‰¹å®šã™ã‚‹
- æ”¹å–„ç‚¹ã‚„å•é¡Œç‚¹ã‚’æŒ‡æ‘˜ã™ã‚‹

ã€å¤±æ•—åŸå› ã®åˆ†é¡ã€‘
ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—ã—ãŸå ´åˆã€ä»¥ä¸‹ã®ã‚«ãƒ†ã‚´ãƒªã§åŸå› ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ï¼š

1. **è¦ä»¶ä¸æ˜ç­** - ã‚¿ã‚¹ã‚¯ã®èª¬æ˜ãŒä¸ååˆ†ã€æ›–æ˜§
2. **æŠ€è¡“çš„å•é¡Œ** - å®Ÿè£…ã®é›£æ˜“åº¦ãŒé«˜ã„ã€æŠ€è¡“çš„åˆ¶ç´„
3. **ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³** - å¿…è¦ãªæƒ…å ±ã€ãƒ„ãƒ¼ãƒ«ã€æ¨©é™ãŒä¸è¶³
4. **ä¾å­˜é–¢ä¿‚** - å‰æã‚¿ã‚¹ã‚¯ãŒæœªå®Œäº†ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒãªã„
5. **ç’°å¢ƒå•é¡Œ** - ã‚·ã‚¹ãƒ†ãƒ ã€ãƒ–ãƒ©ã‚¦ã‚¶ã€APIã®å•é¡Œ
6. **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ** - å‡¦ç†æ™‚é–“ãŒé•·ã™ãã‚‹
7. **å‡ºåŠ›ä¸å®Œå…¨** - å‡ºåŠ›ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã€æ§‹é€ ãŒä¸å®Œå…¨
8. **å“è³ªä¸è¶³** - æˆæœç‰©ã®å“è³ªãŒåŸºæº–ã‚’æº€ãŸã—ã¦ã„ãªã„

ã€é‡è¦ãªåˆ¤æ–­åŸºæº– - èª¤åˆ¤æ–­é˜²æ­¢ã€‘
â˜… ä»¥ä¸‹ã®å ´åˆã¯ã€Œå®Œäº†ã€ã¨åˆ¤æ–­ã—ã¦ãã ã•ã„ï¼š
- è¨˜äº‹ãƒ»æ–‡æ›¸ãŒå°å…¥â†’æœ¬ç·¨â†’çµè«–ã®æ§‹é€ ã«ãªã£ã¦ã„ã‚‹
- ä¸»è¦ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå…¨ã¦å«ã¾ã‚Œã¦ã„ã‚‹
- å†…å®¹çš„ã«å®Œçµã—ã¦ã„ã‚‹ï¼ˆé€”ä¸­ã§æ–‡ãŒåˆ‡ã‚Œã¦ã„ãªã„ï¼‰
- HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³æ§‹é€ ãŒé©åˆ‡ã«é–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹
- æ–‡å­—æ•°ãŒå¤šå°‘å°‘ãªãã¦ã‚‚ã€å†…å®¹ãŒå……å®Ÿã—ã¦ã„ã‚‹
- æ–‡æ›¸ã®æœ€å¾Œã«æ˜ç¢ºãªçµè«–ã‚„ã¾ã¨ã‚ãŒã‚ã‚‹

â˜… ã€Œéƒ¨åˆ†çš„ã€ã¨åˆ¤æ–­ã™ã‚‹ã®ã¯æœ¬å½“ã«æ˜ã‚‰ã‹ã«æœªå®Œæˆã®å ´åˆã®ã¿ï¼š
- æ˜ã‚‰ã‹ã«æ–‡ã®é€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ï¼ˆä¸»èªã ã‘ã€å‹•è©ãŒãªã„ãªã©ï¼‰
- ä¸»è¦ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Œå…¨ã«æ¬ è½ã—ã¦ã„ã‚‹
- ã€Œç¶šãã€ã€Œå¾Œè¿°ã€ãªã©ã®æœªå®Œæˆã‚’ç¤ºã™è¡¨ç¾ãŒã‚ã‚‹
- HTMLã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ãªã©ã®æ§‹é€ çš„å•é¡Œ

ã€è©•ä¾¡åŸºæº–ã€‘
1. å®Œæˆåº¦: ã‚¿ã‚¹ã‚¯ãŒè¦æ±‚ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹
2. å“è³ª: å®Ÿè£…å¯èƒ½ã§å…·ä½“çš„ã‹
3. å¤±æ•—åŸå› : ãªãœå¤±æ•—ã—ãŸã®ã‹ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
4. æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: ä½•ãŒä¸è¶³ã—ã¦ã„ã‚‹ã‹

ã€å‡ºåŠ›å½¢å¼ã€‘
å¿…ãšJSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
  "evaluation": {
    "completeness": "å®Œäº†|éƒ¨åˆ†çš„|ä¸å®Œå…¨|å¤±æ•—",
    "quality_score": 1-10,
    "issues": ["å•é¡Œç‚¹1", "å•é¡Œç‚¹2"],
    "good_points": ["è‰¯ã„ç‚¹1", "è‰¯ã„ç‚¹2"],
    "overall_assessment": "ç·åˆè©•ä¾¡ã®ã‚µãƒãƒªãƒ¼ï¼ˆ100æ–‡å­—ç¨‹åº¦ï¼‰",
    "failure_analysis": {
      "is_failed": true|false,
      "failure_category": "è¦ä»¶ä¸æ˜ç­|æŠ€è¡“çš„å•é¡Œ|ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³|ä¾å­˜é–¢ä¿‚|ç’°å¢ƒå•é¡Œ|ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ|å‡ºåŠ›ä¸å®Œå…¨|å“è³ªä¸è¶³",
      "root_cause": "å¤±æ•—ã®æ ¹æœ¬åŸå› ã®è©³ç´°èª¬æ˜",
      "impact": "ã“ã®å¤±æ•—ãŒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ä¸ãˆã‚‹å½±éŸ¿",
      "recommended_action": "immediate_retry|modify_task|add_prerequisite|escalate|skip",
      "prerequisites": ["å‰ææ¡ä»¶1", "å‰ææ¡ä»¶2"]
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "æ¬¡ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
    "suggested_tasks": [
      {
        "description": "å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯å†…å®¹",
        "required_role": "design|dev|ui|review|wordpress",
        "priority": "high|medium|low",
        "reasoning": "ã“ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
        "dependencies": ["ä¾å­˜ã™ã‚‹ã‚¿ã‚¹ã‚¯ID"],
        "estimated_time": "äºˆæƒ³æ™‚é–“"
      }
    ]
  }
}
ã€å¤±æ•—æ™‚ã®æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é¸æŠåŸºæº–ã€‘

immediate_retry: ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰

modify_task: è¦ä»¶ãŒä¸æ˜ç­ã€ã‚¿ã‚¹ã‚¯å†…å®¹ã®ä¿®æ­£ãŒå¿…è¦

add_prerequisite: å‰æã‚¿ã‚¹ã‚¯ãŒä¸è¶³ã—ã¦ã„ã‚‹

escalate: äººé–“ã®åˆ¤æ–­ãŒå¿…è¦ãªå•é¡Œ

skip: ã“ã®ã‚¿ã‚¹ã‚¯ã¯ä¸è¦ã¾ãŸã¯å¾Œå›ã—ã«ã™ã¹ã

ã€å˜ç´”ãªåˆ¤æ–­æ¡ä»¶ã€‘

è¦ä»¶å®šç¾©ã ã‘ã§å®Ÿè£…ãŒãªã„å ´åˆ â†’ å®Ÿè£…ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

è¨­è¨ˆæ›¸ã ã‘ã§ã‚³ãƒ¼ãƒ‰ãŒãªã„å ´åˆ â†’ é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

ã‚³ãƒ¼ãƒ‰ã«ãƒ†ã‚¹ãƒˆãŒãªã„å ´åˆ â†’ ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

ä¸å®Œå…¨ãªå‡ºåŠ›ã®å ´åˆ â†’ æ”¹å–„ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

ååˆ†ã«å®Œæˆã—ã¦ã„ã‚‹å ´åˆ â†’ æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¯ä¸è¦ã¨åˆ¤æ–­

ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆã—ã™ããªã„ã“ã¨ã€‚æœ¬å½“ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚"""

#review_agent_prompts_ACF.py
# review_agent_prompts_ACF.py
"""ACF/WordPresså°‚ç”¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©"""

# =============================================================================
# ACFå°‚ç”¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

ACF_REVIEW_PROMPT = """ã‚ãªãŸã¯WordPress/ACF Proã®å°‚é–€å®¶ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã§ã™ã€‚

ã€ACFã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¦³ç‚¹ã€‘

## 1. å¿…é ˆè¦ç´ ã®ç¢ºèª
- [ ] `acf_add_local_field_group()` é–¢æ•°ãŒæ­£ã—ãä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å¿…é ˆã‚­ãƒ¼ï¼ˆkey, title, fields, locationï¼‰ãŒå…¨ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¸€æ„ã® `key` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—ãŒæœ‰åŠ¹ãªå€¤ã‹ï¼ˆtext, number, select, relationshipç­‰ï¼‰

## 2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
- [ ] å‡ºåŠ›æ™‚ã« `esc_html()`, `esc_attr()`, `esc_url()` ãªã©ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å…¥åŠ›å€¤ã®æ¤œè¨¼ã« `sanitize_text_field()`, `intval()` ãªã©ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã« `$wpdb->prepare()` ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] `$_GET`, `$_POST` ã®ç›´æ¥ä½¿ç”¨æ™‚ã«é©åˆ‡ãªã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹ã‹

## 3. WordPressäº’æ›æ€§
- [ ] ãƒ•ãƒƒã‚¯ï¼ˆ`add_action`, `add_filter`ï¼‰ãŒé©åˆ‡ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å›½éš›åŒ–é–¢æ•°ï¼ˆ`__()`, `_e()`, `_x()`ï¼‰ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] é–¢æ•°åã«åå‰ç©ºé–“ã®è¡çªã‚’é˜²ããƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒã‚ã‚‹ã‹
- [ ] `show_in_rest` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼ˆGutenbergå¯¾å¿œï¼‰

## 4. ACFå›ºæœ‰ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã® `location` ãƒ«ãƒ¼ãƒ«ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] æ¡ä»¶ä»˜ããƒ­ã‚¸ãƒƒã‚¯ï¼ˆ`conditional_logic`ï¼‰ãŒå¿…è¦ã«å¿œã˜ã¦è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã® `required` è¨­å®šãŒé©åˆ‡ã‹
- [ ] ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ `post_type` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ç¹°ã‚Šè¿”ã—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ`repeater`ï¼‰ã®ã‚µãƒ–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒæ­£ã—ãå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹

## 5. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ä¿å®ˆæ€§
- [ ] ä¸è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚„ã‚°ãƒ«ãƒ¼ãƒ—ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å–å¾—ã« `get_field()` ãŒä½¿ç”¨ã•ã‚Œã€`the_field()` ãŒé©åˆ‡ã«ä½¿ã„åˆ†ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‹
- [ ] ã‚³ãƒ¡ãƒ³ãƒˆãŒé©åˆ‡ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒé«˜ã„ã‹

## 6. M&Aæ¡ˆä»¶ç‰¹æœ‰ã®è¦ä»¶ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
- [ ] æ¥­ç¨®ã€åœ°åŸŸã€ä¾¡æ ¼å¸¯ãªã©ã®æ¤œç´¢ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å¤šè¨€èªå¯¾å¿œï¼ˆPolylangï¼‰ã‚’è€ƒæ…®ã—ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­è¨ˆã‹
- [ ] `meta_query` ã«ã‚ˆã‚‹æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒæ­£ã—ãå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] æ•°å€¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆä¾¡æ ¼ç­‰ï¼‰ã®å‹ãŒ `NUMERIC` ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹

ã€è©•ä¾¡åŸºæº–ã€‘

**è‡´å‘½çš„ãªå•é¡Œï¼ˆ10ç‚¹æº€ç‚¹ä¸­0-3ç‚¹ï¼‰**
- å¿…é ˆè¦ç´ ã®æ¬ è½
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ï¼ˆXSS, SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ï¼‰
- PHPæ§‹æ–‡ã‚¨ãƒ©ãƒ¼
- ACFé–¢æ•°ã®èª¤ç”¨

**è­¦å‘Šãƒ¬ãƒ™ãƒ«ã®å•é¡Œï¼ˆ4-6ç‚¹ï¼‰**
- ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ã®ä¸€éƒ¨ä¸è¶³
- å›½éš›åŒ–å¯¾å¿œã®æ¬ å¦‚
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä¸Šã®å•é¡Œ
- ã‚³ãƒ¡ãƒ³ãƒˆä¸è¶³

**è‰¯å¥½ï¼ˆ7-10ç‚¹ï¼‰**
- ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯é …ç›®ã‚’ã‚¯ãƒªã‚¢
- ã‚³ãƒ¼ãƒ‰ãŒå¯èª­æ€§é«˜ãä¿å®ˆã—ã‚„ã™ã„
- ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å®Œå…¨æº–æ‹ 
- æ‹¡å¼µæ€§ã‚’è€ƒæ…®ã—ãŸè¨­è¨ˆ

ã€å‡ºåŠ›å½¢å¼ã€‘

å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
  "evaluation": {
    "completeness": "å®Œäº†|éƒ¨åˆ†çš„|ä¸å®Œå…¨",
    "quality_score": 1-10,
    "issues": [
      "å•é¡Œç‚¹ã®è©³ç´°èª¬æ˜"
    ],
    "good_points": [
      "è‰¯ã„ç‚¹ã®è©³ç´°èª¬æ˜"
    ],
    "overall_assessment": "ç·åˆè©•ä¾¡ã®ã‚µãƒãƒªãƒ¼",
    "acf_specific_checks": {
      "field_group_structure": "OK|NG",
      "security_practices": "OK|NG",
      "wordpress_compatibility": "OK|NG",
      "performance": "OK|NG"
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "æ¬¡ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
    "suggested_tasks": [
      {
        "description": "å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯å†…å®¹",
        "required_role": "dev|wordpress",
        "priority": "high|medium|low"
      }
    ]
  }
}
```

ã€é‡è¦ãªæ³¨æ„äº‹é …ã€‘
- ACFã‚³ãƒ¼ãƒ‰ã¯å®Ÿè£…å¯èƒ½ã§å®Œå…¨ã«å‹•ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¯æœ€å„ªå…ˆäº‹é …ã§ã™
- Polylangå¤šè¨€èªå¯¾å¿œã‚’å¸¸ã«è€ƒæ…®ã—ã¦ãã ã•ã„
- M&Aæ¡ˆä»¶ç‰¹æœ‰ã®è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„
"""

# =============================================================================
# PHPæ§‹æ–‡ãƒã‚§ãƒƒã‚¯ç”¨ã®è£œåŠ©ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

PHP_SYNTAX_CHECK_PROMPT = """ä»¥ä¸‹ã®PHPã‚³ãƒ¼ãƒ‰ã®æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚

ã€ãƒã‚§ãƒƒã‚¯é …ç›®ã€‘
1. æ‹¬å¼§ã®å¯¾å¿œï¼ˆ(), {}, []ï¼‰
2. ã‚»ãƒŸã‚³ãƒ­ãƒ³ã®æœ‰ç„¡
3. å¼•ç”¨ç¬¦ã®é–‰ã˜å¿˜ã‚Œ
4. äºˆç´„èªã®èª¤ç”¨
5. é–¢æ•°åã®é‡è¤‡

ã€PHPã‚³ãƒ¼ãƒ‰ã€‘
{php_code}

å•é¡ŒãŒã‚ã‚Œã°è©³ç´°ã‚’ã€å•é¡Œãªã‘ã‚Œã° "OK" ã¨å›ç­”ã—ã¦ãã ã•ã„ã€‚
"""

# =============================================================================
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ç”¨ã®è£œåŠ©ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

SECURITY_CHECK_PROMPT = """ä»¥ä¸‹ã®WordPress/PHPã‚³ãƒ¼ãƒ‰ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚

ã€é‡ç‚¹ãƒã‚§ãƒƒã‚¯é …ç›®ã€‘
1. XSSå¯¾ç­–ï¼ˆã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ã®ä½¿ç”¨ï¼‰
2. SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ï¼ˆ$wpdb->prepare ã®ä½¿ç”¨ï¼‰
3. CSRFå¯¾ç­–ï¼ˆnonce ã®ä½¿ç”¨ï¼‰
4. å…¥åŠ›å€¤ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
5. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®æ¤œè¨¼

ã€ã‚³ãƒ¼ãƒ‰ã€‘
{code}

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡ŒãŒã‚ã‚Œã°ã€é‡è¦åº¦ï¼ˆcritical/warningï¼‰ã¨å…±ã«æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚
"""

#run_multi_agent.py
# run_multi_agent.py
"""ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰"""
# ========================================
# ãƒ‡ãƒãƒƒã‚°: TaskExecutor ã®ç¢ºèª
# ========================================
import sys
import importlib

# ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
if 'task_executor' in sys.modules:
    print("ğŸ”„ task_executor ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ä¸­...")
    importlib.reload(sys.modules['task_executor'])

from task_executor import TaskExecutor

# ãƒ¡ã‚½ãƒƒãƒ‰ç¢ºèª
print("\n" + "="*60)
print("ğŸ” TaskExecutor ã‚¯ãƒ©ã‚¹ã®ç¢ºèª")
print("="*60)
print(f"ğŸ“ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å ´æ‰€: {sys.modules['task_executor'].__file__}")
print("\nğŸ“‹ åˆ©ç”¨å¯èƒ½ãªãƒ¡ã‚½ãƒƒãƒ‰:")
methods = [m for m in dir(TaskExecutor) if not m.startswith('_')]
for method in methods:
    print(f"  - {method}")

if 'run_all_tasks' in methods:
    print("\nâœ… run_all_tasks ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ")
else:
    print("\nâŒ run_all_tasks ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
    print("\nğŸš¨ ç·Šæ€¥ãƒ‘ãƒƒãƒã‚’é©ç”¨ã—ã¾ã™...")
    
    # ç·Šæ€¥ãƒ‘ãƒƒãƒã‚’å‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    exec(open('task_executor.py').read())

print("="*60 + "\n")

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import asyncio
import logging
from pathlib import Path
import argparse

# ===== æœ€å„ªå…ˆ: ãƒ­ã‚°è¨­å®š =====
from config_utils import config, ErrorHandler, PathManager

# === ãƒ‘ãƒ¼ãƒˆ1: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨è¨­å®š ===
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        BrowserErrorHandler,
        SheetErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
    logger = logging.getLogger(__name__)
    logger.info("âœ… å¼·åŒ–ç‰ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼èª­ã¿è¾¼ã¿æˆåŠŸ")
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("âš ï¸ error_handler_enhanced.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")
    EnhancedErrorHandler = None
    BrowserErrorHandler = None

# === ãƒ‘ãƒ¼ãƒˆ2: ãã®ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ ===
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_agent import PMAgent
from task_executor import TaskExecutor
from design_agent import DesignAgent
from dev_agent import DevAgent
from review_agent import ReviewAgent


class MultiAgentOrchestrator:
    """ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼"""

    def __init__(self, pc_id: int = None, max_iterations: int = None):
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ– ===
        self.pc_id = pc_id or 1
        self.max_iterations = max_iterations
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå¤‰æ•°ã®åˆæœŸåŒ– ===
        self.sheets_manager = None
        self.browser = None
        self.pm_agent = None
        self.task_executor = None
        self.design_agent = None
        self.dev_agent = None
        self.review_agent = None
        self.content_writer = None
        self.wordpress_agent = None
        self.output_folder = None
        self.initialization_success = False

    def _is_url(self, path_str: str) -> bool:
        """æ–‡å­—åˆ—ãŒURLã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
        # === ãƒ‘ãƒ¼ãƒˆ1: å…¥åŠ›å€¤ã®æ¤œè¨¼ ===
        if not path_str:
            return False
        
        # === ãƒ‘ãƒ¼ãƒˆ2: URLãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ¤å®š ===
        path_lower = path_str.lower().strip()
        return path_lower.startswith('http://') or path_lower.startswith('https://')

    async def _find_service_account_file(self) -> str:
        """ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™"""
        logger.info("ğŸ“ ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ä¸­...")
        
        # === ãƒ‘ãƒ¼ãƒˆ1: æ¤œç´¢ãƒ‘ã‚¹ã®å®šç¾© ===
        possible_paths = [
            Path.cwd() / "service_account.json",
            Path.home() / "Documents" / "gemini_auto_generate" / "service_account.json",
            Path.home() / "Documents" / "AI_Agent" / "service_account.json",
            Path.home() / "Documents" / "gemini_AI_Agent" / "service_account.json",
            Path(__file__).parent / "service_account.json",
        ]
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®ãƒ‘ã‚¹å–å¾— ===
        env_path = os.environ.get('SERVICE_ACCOUNT_FILE')
        if env_path:
            possible_paths.insert(0, Path(env_path))
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§æ¤œç´¢ ===
        for path in possible_paths:
            if not path:
                continue
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                validated_path = EnhancedErrorHandler.validate_file_path(path, must_exist=True)
                if validated_path:
                    logger.info(f"âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç™ºè¦‹: {validated_path}")
                    return str(validated_path)
            else:
                if path.exists():
                    logger.info(f"âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç™ºè¦‹: {path}")
                    return str(path)
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼å‡¦ç† ===
        raise FileNotFoundError(
            "ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚\n"
            "ä»¥ä¸‹ã®å ´æ‰€ã‚’ç¢ºèªã—ã¦ãã ã•ã„:\n" +
            "\n".join(f"  - {p}" for p in possible_paths if p)
        )

    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–"""
        try:
            print("="*60)
            print("ğŸš€ ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ä¸­...")
            print("="*60)
    
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾— ===
            service_account_file = await self._find_service_account_file()
        
            # === ãƒ‘ãƒ¼ãƒˆ2: Google Sheets Managerã®åˆæœŸåŒ– ===
            logger.info("ğŸ“Š Google Sheets æ¥ç¶šã‚’åˆæœŸåŒ–ä¸­...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
    
            # === ãƒ‘ãƒ¼ãƒˆ3: PCè¨­å®šã®èª­ã¿è¾¼ã¿ ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—")
    
            logger.info(f"âš™ï¸ PC_ID={self.pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ä¸­...")
            # â­ ã“ã“ã§ settings ã‚’å®šç¾©
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
        
            # === ãƒ‘ãƒ¼ãƒˆ4: è¨­å®šã®é©ç”¨ ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
        
            # === ãƒ‘ãƒ¼ãƒˆ5: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
        
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"âš ï¸ B14ãŒURLå½¢å¼ã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ(B14ã‹ã‚‰å–å¾—): {self.output_folder}")
        
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
    
            # === ãƒ‘ãƒ¼ãƒˆ6: ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–(ãƒªãƒˆãƒ©ã‚¤ä»˜ã) ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
        
            if not browser_success:
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
        
            # === ãƒ‘ãƒ¼ãƒˆ7: Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ===
            logger.info("="*60)
            logger.info("ğŸŒ Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...")
            logger.info("="*60)
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="GeminiãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
    
            # === ãƒ‘ãƒ¼ãƒˆ8: WordPressèªè¨¼æƒ…å ±ã®å–å¾— ===
            # â­ settings ã¯æ—¢ã«å®šç¾©æ¸ˆã¿ãªã®ã§ä½¿ç”¨å¯èƒ½
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
    
            # === ãƒ‘ãƒ¼ãƒˆ9: åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("="*60)
            logger.info("ğŸ¤– AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–é–‹å§‹...")
            logger.info("="*60)
    
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )

            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
    
            # ReviewAgentã®åˆæœŸåŒ–
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)

            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
    
            logger.info("âœ… åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
        
            # === ãƒ‘ãƒ¼ãƒˆ10: WordPress å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("ğŸŒ WordPress å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
        
            if wp_url and wp_user and wp_pass:
                # WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            
                if self.wordpress_agent:
                    logger.info("âœ… WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–æˆåŠŸ")
                else:
                    logger.warning("âš ï¸ WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å¤±æ•—ï¼ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã«å½±éŸ¿ãªã—ï¼‰")
            else:
                logger.info("âš ï¸ WordPress èªè¨¼æƒ…å ±ãŒæœªè¨­å®šã§ã™ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰")
                self.wordpress_agent = None
        
            # === ãƒ‘ãƒ¼ãƒˆ11: ãã®ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ– ===
            # ï¼ˆcontent_writers, MA ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãªã©ï¼‰
            # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ç¶­æŒ ...
        
            # === ãƒ‘ãƒ¼ãƒˆ12: åˆæœŸåŒ–å®Œäº† ===
            logger.info("="*60)
            logger.info("âœ… ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("="*60)
            logger.info(f"âš™ï¸ æœ€å¤§åå¾©å›æ•°: {self.max_iterations}")
            logger.info(f"ğŸ†” ä½¿ç”¨ä¸­ã® PC_ID: {self.pc_id}")
        
            self.initialization_success = True
        
        except Exception as e:
            logger.error("âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            else:
                ErrorHandler.log_error(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            raise

    async def validate_system_health(self) -> bool:
        """ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆè¿½åŠ ï¼‰"""
        try:
            logger.info("ğŸ” ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ä¸­...")
            
            # 1. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šç¢ºèª
            if not self.sheets_manager or not self.sheets_manager.gc:
                logger.error("âŒ Google Sheetsæ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # 2. ã‚·ãƒ¼ãƒˆæ§‹é€ æ¤œè¨¼
            if not self.sheets_manager.validate_sheet_structure():
                logger.error("âŒ ã‚·ãƒ¼ãƒˆæ§‹é€ ãŒä¸æ­£ã§ã™")
                return False
            
            # 3. ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã®åŸºæœ¬æ¤œè¨¼
            try:
                tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
                logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆèª­ã¿è¾¼ã¿: {len(tasks)}ä»¶")
                
                # ã‚¿ã‚¹ã‚¯IDã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
                task_ids = [task.get('task_id') for task in tasks if task.get('task_id')]
                unique_ids = set(task_ids)
                if len(task_ids) != len(unique_ids):
                    logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯IDé‡è¤‡æ¤œå‡º: {len(task_ids)} -> {len(unique_ids)}ãƒ¦ãƒ‹ãƒ¼ã‚¯")
                
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆæ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            
            logger.info("âœ… ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯å®Œäº†")
            return True
            
        except Exception as e:
            logger.error(f"âŒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
            return False


    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """
        WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰
    
        ã‚·ãƒ¼ã‚±ãƒ³ã‚¹:
        1. WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
        2. WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆæ–°ã—ã„ã‚¿ãƒ–ã§ï¼‰
        3. ã‚¿ã‚¹ã‚¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ã¸ã®ç™»éŒ²
    
        Args:
            wp_url: WordPress ã‚µã‚¤ãƒˆURL
            wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
            wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        
        Returns:
            WordPressAgent or None
        """
        try:
            # WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("âš ï¸ WordPress ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # èªè¨¼æƒ…å ±ã®è¨­å®š
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("ğŸŒ WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        
            # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
            wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            wordpress_agent.sheets_manager = self.sheets_manager
        
            # ã‚¹ãƒ†ãƒƒãƒ—2: WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆæ–°ã—ã„ã‚¿ãƒ–ã§ï¼‰
            logger.info("ğŸ” WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0,
                    context="WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # ã‚¹ãƒ†ãƒƒãƒ—3: åˆæœŸåŒ–çµæœã®å‡¦ç†
            if wp_login_success:
                # ã‚¿ã‚¹ã‚¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ã«ç™»éŒ²
                self.task_executor.register_agent('wordpress', wordpress_agent)
                logger.info("âœ… WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            
                # ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file and wp_cookies_file.exists():
                    logger.info(f"ğŸª WordPress ã‚¯ãƒƒã‚­ãƒ¼: {wp_cookies_file}")
                else:
                    logger.info("ğŸª WordPress ã‚¯ãƒƒã‚­ãƒ¼: æ–°è¦ä½œæˆæ¸ˆã¿")
            
                return wordpress_agent
            else:
                logger.error("âŒ WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å¤±æ•—")
                return None
            
        except Exception as e:
            logger.error(f"WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress åˆæœŸåŒ–")
            return None

    def _print_browser_troubleshooting(self):
        """ãƒ–ãƒ©ã‚¦ã‚¶ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æƒ…å ±ã®è¡¨ç¤º ===
        logger.error("\nğŸ“‹ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°:")
        logger.error("1. âœ… æ—¢å­˜ã®Chromeãƒ—ãƒ­ã‚»ã‚¹ã‚’å…¨ã¦çµ‚äº†")
        logger.error("2. ğŸ“ ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æ¨©é™ç¢ºèª")
        logger.error(f"     â†’ {config.BROWSER_DATA_DIR}")
        logger.error("3. ğŸ”§ Playwrightã®å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:")
        logger.error("     â†’ playwright install chromium")
        logger.error("4. ğŸ—‘ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã‚¯ãƒªã‚¢:")
        logger.error(f"     â†’ {config.BROWSER_DATA_DIR} ã‚’å‰Šé™¤")
        logger.error("5. ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ã®å†èµ·å‹•")

    # === ä¿®æ­£é–‹å§‹: MultiAgentOrchestratorã®WordPressåˆæœŸåŒ–ã‚’å¼·åŒ– ===

    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆã‚¯ãƒƒã‚­ãƒ¼ç®¡ç†å¯¾å¿œç‰ˆï¼‰"""
        try:
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("âš ï¸ WordPressãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # èªè¨¼æƒ…å ±ã®è¨­å®š
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("ğŸŒ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
            self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            self.wordpress_agent.sheets_manager = self.sheets_manager
        
            # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆï¼‰
            logger.info("ğŸ” WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
        
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãåˆæœŸåŒ–
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0,  # 90ç§’ã«å»¶é•·
                    context="WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # åˆæœŸåŒ–çµæœã®å‡¦ç†
            if wp_login_success:
                self.task_executor.register_agent('wordpress', self.wordpress_agent)
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            
                # ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file.exists():
                    logger.info(f"ğŸ“ WordPressã‚¯ãƒƒã‚­ãƒ¼: {wp_cookies_file}")
                else:
                    logger.info("ğŸ“ WordPressã‚¯ãƒƒã‚­ãƒ¼: æ–°è¦ä½œæˆæ¸ˆã¿")
                
                return self.wordpress_agent
            else:
                logger.error("âŒ WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å¤±æ•—")
                return None
            
        except Exception as e:
            logger.error(f"WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPressåˆæœŸåŒ–")
            return None


    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–"""
        try:
            print("="*60)
            print("ğŸš€ ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ä¸­...")
            print("="*60)
        
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾— ===
            service_account_file = await self._find_service_account_file()
            
            # === ãƒ‘ãƒ¼ãƒˆ2: Google Sheets Managerã®åˆæœŸåŒ– ===
            logger.info("ğŸ“Š Google Sheets æ¥ç¶šã‚’åˆæœŸåŒ–ä¸­...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
            health_ok = await self.validate_system_health()
            if not health_ok:
                logger.warning("âš ï¸ ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã§è­¦å‘ŠãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ")
        
            # === ãƒ‘ãƒ¼ãƒˆ3: PCè¨­å®šã®èª­ã¿è¾¼ã¿ ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—")
        
            logger.info(f"âš™ï¸ PC_ID={self.pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ä¸­...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: è¨­å®šã®é©ç”¨ ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            # === ãƒ‘ãƒ¼ãƒˆ5: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
            
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"âš ï¸ B14ãŒURLå½¢å¼ã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ(B14ã‹ã‚‰å–å¾—): {self.output_folder}")
            
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
            
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
        
            # === ãƒ‘ãƒ¼ãƒˆ6: ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ï¼ˆãƒªãƒˆãƒ©ã‚¤ä»˜ãï¼‰ ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
            
            if not browser_success:
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
            
            # === ãƒ‘ãƒ¼ãƒˆ7: Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ===
            logger.info("="*60)
            logger.info("ğŸŒ Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...")
            logger.info("="*60)
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="GeminiãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
        
            # === ãƒ‘ãƒ¼ãƒˆ8: WordPressèªè¨¼æƒ…å ±ã®å–å¾— ===
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
        
            # === ãƒ‘ãƒ¼ãƒˆ9: åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("="*60)
            logger.info("ğŸ¤– AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–é–‹å§‹...")
            logger.info("="*60)
        
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )
    
            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
        
            # ReviewAgentã®åˆæœŸåŒ–
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)
    
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
        
            logger.info("âœ… åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")

            # === ãƒ‘ãƒ¼ãƒˆ10: WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("ğŸŒ WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            # WordPressèªè¨¼æƒ…å ±ã®å–å¾—
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
            
            # === WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_design) ===
            try:
                from wordpress.wp_design import WordPressDesignAgent
                wp_design_agent = WordPressDesignAgent(
                    self.browser, 
                    output_folder=self.output_folder
                )
                wp_design_agent.sheets_manager = self.sheets_manager
                self.task_executor.register_agent('wp_design', wp_design_agent)
                logger.info("âœ… WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ wordpress/wp_design.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            except Exception as e:
                logger.warning(f"âš ï¸ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
            
            # === WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_dev) ===
            try:
                from wordpress.wp_dev import WordPressDevAgent
                
                # WordPressDevAgent ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
                wp_dev_agent = WordPressDevAgent(
                    self.browser,
                    wp_credentials=wp_credentials,
                    output_folder=self.output_folder
                )
                wp_dev_agent.sheets_manager = self.sheets_manager
                
                # ã‚¿ã‚¹ã‚¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«ç™»éŒ²
                self.task_executor.register_agent('wp_dev', wp_dev_agent)
                logger.info("âœ… WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ(wp_dev)ç™»éŒ²å®Œäº†")
                
                # æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç™»éŒ²ã‚‚ç¶­æŒ
                if self.dev_agent:
                    # æ—¢å­˜ã® dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ç¶­æŒï¼ˆè¦ä»¶å®šç¾©ç”¨ï¼‰
                    logger.info("âœ… æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚‚ç¶­æŒï¼ˆè¦ä»¶å®šç¾©ã‚¿ã‚¹ã‚¯ç”¨ï¼‰")
                
            except ImportError:
                logger.warning("âš ï¸ wordpress/wp_dev.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.info("ğŸ’¡ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã¯æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
                
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ã¨ã—ã¦ã‚‚ç™»éŒ²
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("ğŸ”„ æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ã¨ã—ã¦ã‚‚ç™»éŒ²ã—ã¾ã—ãŸ")
                    
            except Exception as e:
                logger.warning(f"âš ï¸ WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å¤±æ•—: {e}")
                
                # ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("ğŸ”„ ã‚¨ãƒ©ãƒ¼ã®ãŸã‚æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ä»£æ›¿")


            # === ãƒ‘ãƒ¼ãƒˆ11: M&Aå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("ğŸ“Š M&Aå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            try:
                from task_executor_ma import MATaskExecutor
                ma_task_executor = MATaskExecutor(self.task_executor.agents)
                self.task_executor.register_agent('ma', ma_task_executor)
                self.task_executor.register_agent('wordpress_ma', ma_task_executor)
                
                # â­ é‡è¦: dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ã¨ã—ã¦ã‚‚ç™»éŒ²ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
                # wp_dev å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                if 'wp_dev' not in self.task_executor.agents and self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("âœ… dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ç™»éŒ²")
                
                logger.info("âœ… M&Aå°‚ç”¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ task_executor_ma.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            except Exception as e:
                logger.warning(f"âš ï¸ M&Aå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ12: å¤šè¨€èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("å¤šè¨€èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            try:
                from content_writers import (
                    JapaneseWriterAgent,
                    EnglishWriterAgent,
                    RussianWriterAgent,
                    UzbekWriterAgent,
                    ChineseWriterAgent,
                    KoreanWriterAgent,
                    TurkishWriterAgent
                )
                
                # æ—¥æœ¬èªãƒ©ã‚¤ã‚¿ãƒ¼
                ja_writer = JapaneseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ja', ja_writer)
                logger.info("âœ… æ—¥æœ¬èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # è‹±èªãƒ©ã‚¤ã‚¿ãƒ¼
                en_writer = EnglishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_en', en_writer)
                logger.info("âœ… è‹±èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ãƒ­ã‚·ã‚¢èªãƒ©ã‚¤ã‚¿ãƒ¼
                ru_writer = RussianWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ru', ru_writer)
                logger.info("âœ… ãƒ­ã‚·ã‚¢èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ã‚¦ã‚ºãƒ™ã‚¯èªãƒ©ã‚¤ã‚¿ãƒ¼
                uz_writer = UzbekWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_uz', uz_writer)
                logger.info("âœ… ã‚¦ã‚ºãƒ™ã‚¯èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ä¸­å›½èªãƒ©ã‚¤ã‚¿ãƒ¼
                zh_writer = ChineseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_zh', zh_writer)
                logger.info("âœ… ä¸­å›½èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # éŸ“å›½èªãƒ©ã‚¤ã‚¿ãƒ¼
                ko_writer = KoreanWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ko', ko_writer)
                logger.info("âœ… éŸ“å›½èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ãƒˆãƒ«ã‚³èªãƒ©ã‚¤ã‚¿ãƒ¼
                tr_writer = TurkishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_tr', tr_writer)
                logger.info("âœ… ãƒˆãƒ«ã‚³èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ13: WordPressæŠ•ç¨¿ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            if wp_url and wp_user and wp_pass:
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            else:
                logger.info("âš ï¸ WordPressèªè¨¼æƒ…å ±ãŒæœªè¨­å®šã§ã™(ã‚¹ã‚­ãƒƒãƒ—)")
                self.wordpress_agent = None
        
            # === ãƒ‘ãƒ¼ãƒˆ14: åˆæœŸåŒ–å®Œäº†ã®ç¢ºèª ===
            logger.info("="*60)
            logger.info("âœ… ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("="*60)
            logger.info(f"âš™ï¸ æœ€å¤§åå¾©å›æ•°: {self.max_iterations}")
            logger.info(f"ğŸ†” ä½¿ç”¨ä¸­ã®PC_ID: {self.pc_id}")
            
            self.initialization_success = True
        
        except Exception as e:
            logger.error("âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            else:
                ErrorHandler.log_error(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            raise

    async def run_full_workflow(self, goal: str = None, auto_continue: bool = False, enable_review: bool = True):
        """å®Œå…¨ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œ"""
        # === ãƒ‘ãƒ¼ãƒˆ1: åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª ===
        if not self.initialization_success:
            raise Exception("ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ2: PM AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯åˆ†è§£ãƒ•ã‚§ãƒ¼ã‚º ===
            print("\n" + "="*60)
            print("ğŸ“‹ ãƒ•ã‚§ãƒ¼ã‚º1: PM AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯åˆ†è§£")
            print("="*60)
            
            if goal:
                goal_description = goal
                logger.info(f"ğŸ¯ æŒ‡å®šã•ã‚ŒãŸç›®æ¨™: {goal_description}")
            else:
                goal_data = await self.pm_agent.load_project_goal()
                if not goal_data:
                    print("\nâŒ ã‚¨ãƒ©ãƒ¼: ç›®æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    print("--goal ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ç›®æ¨™ã‚’æŒ‡å®šã™ã‚‹ã‹ã€")
                    print("ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®'project_goal'ã‚·ãƒ¼ãƒˆã«ç›®æ¨™ã‚’è¨­å®šã—ã¦ãã ã•ã„")
                    return
                goal_description = goal_data['description']
            
            task_plan = await self.pm_agent.analyze_and_create_tasks(goal_description)
            self.pm_agent.display_task_summary(task_plan)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ä¿å­˜ã®ç¢ºèª ===
            if not auto_continue:
                save = input("\nğŸ’¾ ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ã—ã¾ã™ã‹? (y/n): ")
                if save.lower() != 'y':
                    print("â¸ï¸ å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ")
                    return
            
            await self.pm_agent.save_tasks_to_sheet(task_plan)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚º ===
            print("\n" + "="*60)
            print("âš™ï¸ ãƒ•ã‚§ãƒ¼ã‚º2: ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ")
            print("="*60)
            
            if enable_review:
                print("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: æœ‰åŠ¹")
            else:
                print("â­ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ç„¡åŠ¹")
            
            if not auto_continue:
                execute = input("\nâ–¶ï¸ ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™ã‹? (y/n): ")
                if execute.lower() != 'y':
                    print("â¸ï¸ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
                    return
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®å®Ÿè¡Œ ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === ãƒ‘ãƒ¼ãƒˆ6: å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º ===
            print("\n" + "="*60)
            print("ğŸ‰ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Œäº†")
            print("="*60)
            print(f"ğŸ“ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {self.output_folder}")
            print("ğŸ“Š ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã§çµæœã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            
        except Exception as e:
            logger.error("ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            else:
                ErrorHandler.log_error(e, "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            raise

    async def run_tasks_only(self, auto_continue: bool = False, enable_review: bool = True):
        """æ—¢å­˜ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’å®Ÿè¡Œ"""
        # === ãƒ‘ãƒ¼ãƒˆ1: åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª ===
        if not self.initialization_success:
            raise Exception("ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ2: å®Ÿè¡Œé–‹å§‹ã®è¡¨ç¤º ===
            print("\n" + "="*60)
            print("âš™ï¸ æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ")
            print("="*60)
            
            if enable_review:
                print("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: æœ‰åŠ¹")
            else:
                print("â­ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ç„¡åŠ¹")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®å®Ÿè¡Œ ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === ãƒ‘ãƒ¼ãƒˆ4: å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º ===
            print("\n" + "="*60)
            print("ğŸ‰ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            print("="*60)
            
        except Exception as e:
            logger.error("ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            else:
                ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            raise

    async def cleanup(self):
        """ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        logger.info("ğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹...")
        
        cleanup_tasks = []
        
        # ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if self.browser:
            cleanup_tasks.append(self._safe_cleanup_browser())
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if self.wordpress_agent:
            cleanup_tasks.append(self._safe_cleanup_wordpress())
        
        # ãã®ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if hasattr(self, 'dev_agent') and self.dev_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.dev_agent, "dev_agent"))
        
        if hasattr(self, 'design_agent') and self.design_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.design_agent, "design_agent"))
        
        # ä¸¦è¡Œã—ã¦ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
        if cleanup_tasks:
            await asyncio.gather(*cleanup_tasks, return_exceptions=True)
        
        logger.info("âœ… å…¨ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")

    async def _safe_cleanup_browser(self):
        """å®‰å…¨ãªãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if self.browser:
                await self.browser.cleanup()
                logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")

    async def _safe_cleanup_wordpress(self):
        """å®‰å…¨ãªWordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if self.wordpress_agent and hasattr(self.wordpress_agent, 'cleanup'):
                await self.wordpress_agent.cleanup()
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            logger.warning(f"âš ï¸ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")

    async def _safe_cleanup_agent(self, agent, agent_name: str):
        """å®‰å…¨ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if agent and hasattr(agent, 'cleanup'):
                await agent.cleanup()
                logger.info(f"âœ… {agent_name} ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            logger.warning(f"âš ï¸ {agent_name} ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")


async def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    # === ãƒ‘ãƒ¼ãƒˆ1: ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ ===
    parser = argparse.ArgumentParser(description='ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ')
    parser.add_argument('--goal', type=str, help='ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã‚’ç›´æ¥æŒ‡å®š')
    parser.add_argument('--tasks-only', action='store_true', help='æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ(PM AIã‚¹ã‚­ãƒƒãƒ—)')
    parser.add_argument('--auto', action='store_true', help='è‡ªå‹•å®Ÿè¡Œ(ç¢ºèªãªã—)')
    parser.add_argument('--no-review', action='store_true', help='ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–')
    parser.add_argument('--max-iterations', type=int, default=3, help='æœ€å¤§åå¾©å›æ•°(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 3)')
    parser.add_argument('--pc-id', type=int, help='PC_IDã‚’æŒ‡å®š')
    
    args = parser.parse_args()
    
    # === ãƒ‘ãƒ¼ãƒˆ2: ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã®åˆæœŸåŒ– ===
    orchestrator = MultiAgentOrchestrator(
        pc_id=args.pc_id,
        max_iterations=args.max_iterations
    )
    
    try:
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ– ===
        await orchestrator.initialize()
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å®Ÿè¡Œ ===
        if args.tasks_only:
            await orchestrator.run_tasks_only(
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        else:
            await orchestrator.run_full_workflow(
                goal=args.goal,
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        
    except KeyboardInterrupt:
        # === ãƒ‘ãƒ¼ãƒˆ5: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­æ–­ã®å‡¦ç† ===
        logger.warning("\nâ¸ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
    except Exception as e:
        # === ãƒ‘ãƒ¼ãƒˆ6: ã‚¨ãƒ©ãƒ¼å‡¦ç† ===
        logger.error(f"âŒ è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        # === ãƒ‘ãƒ¼ãƒˆ7: ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— ===
        await orchestrator.cleanup()
        logger.info("\nğŸ‘‹ ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’çµ‚äº†ã—ã¾ã—ãŸ")


if __name__ == "__main__":
    asyncio.run(main())

#sheets_manager.py
# sheets_manager.py
"""Google Sheetsç®¡ç†ã‚¯ãƒ©ã‚¹(æ‹¡å¼µç‰ˆ: Google Driveå¯¾å¿œ)"""
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from google.auth import default
from google.auth.transport.requests import Request
from pathlib import Path
from typing import List, Dict, Optional
import logging
import re

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class GoogleSheetsManager:
    """Google Sheetsç®¡ç†ã‚¯ãƒ©ã‚¹(æ‹¡å¼µç‰ˆ: Google Driveå¯¾å¿œ)"""
    
    # Google API ã‚¹ã‚³ãƒ¼ãƒ—ã®å®šç¾©
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]
    
    def __init__(self, spreadsheet_id: str, service_account_file: Optional[str] = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.gc: Optional[gspread.Client] = None
        self.drive_service = None  # Google Drive APIç”¨
        self.setup_client()
    
    def setup_client(self) -> None:
        """Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨­å®š"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼ã®è©¦è¡Œ ===
            logger.info("ğŸ” Google Sheetsã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®šä¸­...")
            
            if self.service_account_file and Path(self.service_account_file).exists():
                # ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.service_account_file, self.GOOGLE_SHEETS_SCOPE)
                self.gc = gspread.authorize(creds)
                
                # Google Drive APIç”¨ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚‚åˆæœŸåŒ–
                self._setup_drive_service(creds)
                
                logger.info("âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ Google Sheets ã«æ¥ç¶šã—ã¾ã—ãŸ")
            else:
                # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã¸ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ ===
                logger.info("ğŸ”„ ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãªã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã‚’è©¦è¡Œ...")
                
                try:
                    creds, project = default(scopes=self.GOOGLE_SHEETS_SCOPE)
                    if creds.expired and creds.refresh_token:
                        creds.refresh(Request())
                    self.gc = gspread.authorize(creds)
                    
                    # Google Drive APIç”¨
                    self._setup_drive_service(creds)
                    
                    logger.info("âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã§ Google Sheets ã«æ¥ç¶šã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                    logger.warning("ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå¿…è¦ã§ã™")
                    self.gc = None
                    
        except Exception as e:
            ErrorHandler.log_error(e, "Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®š")
            self.gc = None
    
    def _setup_drive_service(self, creds):
        """Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆæœŸåŒ–"""
        try:
            from googleapiclient.discovery import build
            self.drive_service = build('drive', 'v3', credentials=creds)
            logger.info("âœ… Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—: {e}")
            self.drive_service = None
    
    def _ensure_client(self) -> None:
        """ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª"""
        if not self.gc:
            raise Exception("Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚")
    
    async def update_task_status(self, task_id: int, status: str, sheet_name: str = "pm_tasks") -> bool:
        """
        ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ï¼ˆãƒ­ãƒã‚¹ãƒˆæ€§å‘ä¸Šç‰ˆ + è¶…è©³ç´°ãƒ­ã‚°ï¼‰
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            status: æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
            sheet_name: ã‚·ãƒ¼ãƒˆå
            
        Returns:
            bool: æ›´æ–°æˆåŠŸãƒ•ãƒ©ã‚°
        """
        try:
            logger.info("=" * 70)
            logger.info(f"ğŸ”„ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å‡¦ç†é–‹å§‹")
            logger.info(f"   ã‚¿ã‚¹ã‚¯ID: {task_id}")
            logger.info(f"   æ–°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}")
            logger.info(f"   å¯¾è±¡ã‚·ãƒ¼ãƒˆ: {sheet_name}")
            logger.info("=" * 70)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆã®æº–å‚™ ===
            logger.info("ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—1] Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¢ºèªä¸­...")
            self._ensure_client()
            logger.info("âœ… ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¢ºèªå®Œäº†")
            
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—2] ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šä¸­ (ID: {self.spreadsheet_id[:20]}...)")
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            logger.info("âœ… ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šæˆåŠŸ")
            
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—3] ã‚·ãƒ¼ãƒˆ '{sheet_name}' ã‚’é–‹ã„ã¦ã„ã¾ã™...")
            task_sheet = sheet.worksheet(sheet_name)
            logger.info("âœ… ã‚·ãƒ¼ãƒˆã‚’é–‹ãã¾ã—ãŸ")
            
            # å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            logger.info("ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—4] ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­...")
            all_data = task_sheet.get_all_values()
            logger.info(f"âœ… ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†: {len(all_data)}è¡Œ")
            
            if len(all_data) <= 1:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆ '{sheet_name}' ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿ï¼‰")
                return False
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ˜ãƒƒãƒ€ãƒ¼è§£æã¨åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ç‰¹å®š ===
            logger.info("ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—5] ãƒ˜ãƒƒãƒ€ãƒ¼è§£æä¸­...")
            headers = all_data[0]
            logger.info(f"   ãƒ˜ãƒƒãƒ€ãƒ¼å†…å®¹: {headers}")
            
            task_id_col = None
            status_col = None
            
            for i, header in enumerate(headers):
                header_lower = header.lower().strip()
                logger.debug(f"   åˆ—{i+1}: '{header}' (å°æ–‡å­—: '{header_lower}')")
                
                if 'task_id' in header_lower or header_lower == 'id':
                    task_id_col = i
                    logger.info(f"âœ… ã‚¿ã‚¹ã‚¯IDåˆ—ã‚’æ¤œå‡º: åˆ—{i+1} ('{header}')")
                elif 'status' in header_lower:
                    status_col = i
                    logger.info(f"âœ… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ã‚’æ¤œå‡º: åˆ—{i+1} ('{header}')")
            
            # ã‚¿ã‚¹ã‚¯IDåˆ—ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if task_id_col is None:
                task_id_col = 0
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯IDåˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§åˆ—1ã‚’ä½¿ç”¨ã—ã¾ã™")
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯è¿½åŠ 
            if status_col is None:
                status_col = len(headers)
                logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦è¿½åŠ ã—ã¾ã™: åˆ—{status_col + 1}")
                try:
                    task_sheet.update_cell(1, status_col + 1, 'status')
                    logger.info(f"âœ… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.error(f"âŒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
                    return False
            
            # === ãƒ‘ãƒ¼ãƒˆ3: å¼·åŒ–ç‰ˆã‚¿ã‚¹ã‚¯æ¤œç´¢ ===
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—6] ã‚¿ã‚¹ã‚¯ID '{task_id}' ã‚’æ¤œç´¢ä¸­...")
            logger.info(f"   æ¤œç´¢å¯¾è±¡åˆ—: åˆ—{task_id_col + 1}")
            logger.info(f"   æ¤œç´¢å¯¾è±¡è¡Œæ•°: {len(all_data) - 1}è¡Œï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼é™¤ãï¼‰")
            
            task_id_str = str(task_id).strip()
            task_found = False
            row_index = None
            
            # è©³ç´°ãªæ¤œç´¢å®Ÿè¡Œ
            available_ids = []
            for row_idx, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    
                    logger.debug(f"   è¡Œ{row_idx}: ID='{cell_value}' (æ¯”è¼ƒå¯¾è±¡: '{task_id_str}')")
                    
                    if cell_value == task_id_str:
                        row_index = row_idx
                        task_found = True
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ã‚’ç™ºè¦‹: è¡Œ{row_idx}")
                        break
            
            if not task_found:
                # è©³ç´°ãªãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ID '{task_id_str}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.error(f"")
                logger.error(f"ğŸ” æ¤œç´¢è©³ç´°:")
                logger.error(f"   æ¤œç´¢ã—ãŸID: '{task_id_str}' (å‹: {type(task_id).__name__})")
                logger.error(f"   æ¤œç´¢ã—ãŸåˆ—: åˆ—{task_id_col + 1}")
                logger.error(f"   ç·ã‚¿ã‚¹ã‚¯æ•°: {len(all_data) - 1}")
                logger.error(f"")
                logger.error(f"ğŸ“‹ ã‚·ãƒ¼ãƒˆå†…ã®åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯ID:")
                for i, aid in enumerate(available_ids[:10], 1):
                    logger.error(f"   {i}. '{aid}'")
                if len(available_ids) > 10:
                    logger.error(f"   ... ä»– {len(available_ids) - 10}ä»¶")
                logger.error(f"")
                logger.error(f"ğŸ’¡ ç¢ºèªäº‹é …:")
                logger.error(f"   1. ã‚¿ã‚¹ã‚¯ID '{task_id}' ãŒ pm_tasks ã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã™ã‚‹ã‹ï¼Ÿ")
                logger.error(f"   2. ã‚¿ã‚¹ã‚¯IDã®åˆ—ãŒæ­£ã—ã„ã‹ï¼Ÿï¼ˆç¾åœ¨: åˆ—{task_id_col + 1}ï¼‰")
                logger.error(f"   3. ã‚¿ã‚¹ã‚¯IDã«ä½™åˆ†ãªç©ºç™½ã‚„ç‰¹æ®Šæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹ï¼Ÿ")
                
                return False
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–° ===
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—7] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å®Ÿè¡Œä¸­...")
            logger.info(f"   å¯¾è±¡ã‚»ãƒ«: è¡Œ{row_index}, åˆ—{status_col + 1}")
            logger.info(f"   æ–°ã—ã„å€¤: '{status}'")
            
            try:
                # Google Sheets API ã§ã‚»ãƒ«ã‚’æ›´æ–°
                task_sheet.update_cell(row_index, status_col + 1, status)
                logger.info(f"âœ… APIå‘¼ã³å‡ºã—æˆåŠŸ")
                
                # æ›´æ–°å¾Œã®æ¤œè¨¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                import time
                time.sleep(0.5)  # APIåæ˜ å¾…ã¡
                
                updated_value = task_sheet.cell(row_index, status_col + 1).value
                logger.info(f"ğŸ” æ›´æ–°å¾Œã®å€¤: '{updated_value}'")
                
                if updated_value == status:
                    logger.info(f"âœ… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ç¢ºèªå®Œäº†")
                    logger.info("=" * 70)
                    logger.info(f"ğŸ‰ ã‚¿ã‚¹ã‚¯ {task_id} ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ '{status}' ã«æ›´æ–°ã—ã¾ã—ãŸï¼ˆè¡Œ {row_index}ï¼‰")
                    logger.info("=" * 70)
                    return True
                else:
                    logger.warning(f"âš ï¸ æ›´æ–°å€¤ãŒä¸€è‡´ã—ã¾ã›ã‚“: æœŸå¾…='{status}', å®Ÿéš›='{updated_value}'")
                    return False
                    
            except Exception as api_error:
                logger.error(f"âŒ Google Sheets API ã‚¨ãƒ©ãƒ¼: {api_error}")
                logger.error(f"")
                logger.error(f"ğŸ’¡ è€ƒãˆã‚‰ã‚Œã‚‹åŸå› :")
                logger.error(f"   1. ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ¨©é™ä¸è¶³")
                logger.error(f"   2. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãŒç·¨é›†ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹")
                logger.error(f"   3. APIã‚¯ã‚©ãƒ¼ã‚¿è¶…é")
                logger.error(f"   4. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®å•é¡Œ")
                import traceback
                logger.error(traceback.format_exc())
                return False
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
            logger.error(f"")
            logger.error(f"ğŸ”§ ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:")
            logger.error(f"   ã‚¿ã‚¹ã‚¯ID: {task_id}")
            logger.error(f"   ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}")
            logger.error(f"   ã‚·ãƒ¼ãƒˆ: {sheet_name}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def find_available_task_id(self) -> Optional[str]:
        """åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯IDã‚’æ¤œç´¢ï¼ˆãƒ­ã‚°å‰Šæ¸›ç‰ˆï¼‰"""
        try:
            # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’ä¸€æ™‚çš„ã«ERRORã«
            original_level = logger.level
            logger.setLevel(logging.ERROR)
            
            # ã‚¿ã‚¹ã‚¯IDæ¤œç´¢
            task_ids = await self._search_task_ids()
            
            # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’æˆ»ã™
            logger.setLevel(original_level)
            
            if task_ids:
                logger.info(f"âœ… åˆ©ç”¨å¯èƒ½ã‚¿ã‚¹ã‚¯: {len(task_ids)}ä»¶")
                return task_ids[0]
            else:
                logger.warning("âš ï¸ åˆ©ç”¨å¯èƒ½ã‚¿ã‚¹ã‚¯ãªã—")
                return None
        
        except Exception as e:
            logger.setLevel(original_level)
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯IDæ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    async def _search_task_ids(self) -> List[str]:
        """å†…éƒ¨æ¤œç´¢ï¼ˆãƒ­ã‚°ãªã—ï¼‰"""
        try:
            # æ—¢å­˜ã®æ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯
            all_values = self.ws.get_all_values()
            
            # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            valid_ids = []
            for row in all_values[1:]:  # ãƒ˜ãƒƒãƒ€ãƒ¼é™¤å¤–
                if len(row) >= 11:
                    task_id = row[0]
                    status = row[10]
                    
                    if task_id and task_id not in ['ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²', 'Review suggested']:
                        if status in ['pending', 'in_progress', '']:
                            valid_ids.append(task_id)
            
            return valid_ids
        
        except Exception as e:
            return []

    async def load_tasks_from_sheet(self, sheet_name: str = "pm_tasks") -> List[Dict]:
        """æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ¼ãƒˆã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã‚¨ãƒ©ãƒ¼ä¿®æ­£ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæ¥ç¶šã¨åŸºæœ¬è¨­å®š ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            try:
                task_sheet = sheet.worksheet(sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.error(f"âŒ ã‚·ãƒ¼ãƒˆ '{sheet_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return []
        
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ‡ãƒ¼ã‚¿å–å¾—æ–¹æ³•ã®è©¦è¡Œï¼ˆè¤‡æ•°æ–¹å¼ï¼‰ ===
            logger.info(f"ğŸ“¥ ã‚·ãƒ¼ãƒˆ '{sheet_name}' ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­...")
            
            try:
                # æ–¹æ³•1: get_all_records() ã‚’è©¦ã™
                records = task_sheet.get_all_records()
                logger.info(f"âœ… get_all_records() ã§ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: {len(records)}è¡Œ")
            except Exception as e:
                logger.warning(f"âš ï¸ get_all_records() å¤±æ•—: {e}")
                logger.info("ğŸ”§ ä»£æ›¿æ–¹æ³•ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™...")
                
                # æ–¹æ³•2: ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦æ‰‹å‹•ã§å‡¦ç†
                all_values = task_sheet.get_all_values()
                
                if len(all_values) <= 1:
                    logger.info("ğŸ“­ ãƒ‡ãƒ¼ã‚¿è¡ŒãŒã‚ã‚Šã¾ã›ã‚“")
                    return []
                
                # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’å–å¾—
                headers = all_values[0]
                logger.info(f"ğŸ“‹ ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
                
                # ãƒ‡ãƒ¼ã‚¿è¡Œã‚’å‡¦ç†
                records = []
                for i, row in enumerate(all_values[1:], start=2):
                    if not any(row):  # ç©ºè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
                        continue
                    
                    record = {}
                    for j, header in enumerate(headers):
                        if j < len(row) and header:  # ãƒ˜ãƒƒãƒ€ãƒ¼ãŒç©ºã§ãªã„å ´åˆã®ã¿
                            record[header] = row[j]
                        elif j < len(row):
                            record[f'column_{j+1}'] = row[j]  # ç©ºãƒ˜ãƒƒãƒ€ãƒ¼ã®å ´åˆ
                    
                    records.append(record)
                
                logger.info(f"âœ… ä»£æ›¿æ–¹æ³•ã§ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: {len(records)}è¡Œ")
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ› ===
            tasks = []
            for i, record in enumerate(records, start=2):
                # ã‚¿ã‚¹ã‚¯IDã®å‡¦ç†ã‚’æ”¹å–„
                task_id = str(record.get('task_id', '')).strip()
                if not task_id and 'task_id' not in record:
                    # æœ€åˆã®åˆ—ã‚’ã‚¿ã‚¹ã‚¯IDã¨ã—ã¦ä½¿ç”¨
                    first_col = list(record.values())[0] if record else ''
                    task_id = str(first_col).strip()
                
                task = {
                    'task_id': task_id,
                    'description': record.get('task_description', record.get('description', '')),
                    'required_role': record.get('required_role', ''),
                    'status': record.get('status', ''),
                    'priority': record.get('priority', 'medium'),
                    'estimated_time': record.get('estimated_time', ''),
                    'dependencies': record.get('dependencies', ''),
                    'created_at': record.get('created_at', ''),
                    'batch_id': record.get('batch_id', ''),
                    'review_target_task_id': record.get('review_target_task_id', ''),
                    'post_action': record.get('post_action', ''),
                    'language': record.get('language', ''),
                    'polylang_lang': record.get('polylang_lang', '')
                }
                
                # åŸºæœ¬çš„ãªæ¤œè¨¼
                if task['description'] and task['required_role']:
                    tasks.append(task)
        
            logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿: {len(tasks)}ä»¶ï¼ˆã‚·ãƒ¼ãƒˆ: {sheet_name}ï¼‰")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¨çµæœè¿”å´ ===
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            if tasks:
                logger.info(f"ğŸ“ æœ€åˆã®ã‚¿ã‚¹ã‚¯: {tasks[0].get('description', '')[:50]}...")
            else:
                logger.info("ğŸ“­ èª­ã¿è¾¼ã¾ã‚ŒãŸã‚¿ã‚¹ã‚¯ã¯0ä»¶ã§ã™")
                
            return tasks
        
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ï¼ˆã‚·ãƒ¼ãƒˆ: {sheet_name}ï¼‰: {e}")
            return []

    async def save_task_output(self, output_data: Dict):
        """ã‚¿ã‚¹ã‚¯ã®å‡ºåŠ›ã‚’ä¿å­˜"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆã®æº–å‚™ ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å‡ºåŠ›ã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèªã¨ä½œæˆ ===
            # å‡ºåŠ›ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            try:
                output_sheet = sheet.worksheet("task_outputs")
            except gspread.exceptions.WorksheetNotFound:
                # ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
                logger.info("'task_outputs' ã‚·ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™")
                output_sheet = sheet.add_worksheet(title="task_outputs", rows=1000, cols=10)
                # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
                headers = ["task_id", "summary", "full_text", "screenshot", "timestamp"]
                output_sheet.append_row(headers)
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ ===
            # ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            row = [
                output_data.get('task_id', ''),
                output_data.get('summary', ''),
                output_data.get('full_text', ''),
                output_data.get('screenshot', ''),
                output_data.get('timestamp', '')
            ]
            output_sheet.append_row(row)
        
            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ä¿å­˜: {output_data.get('task_id', '')}")
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯å‡ºåŠ›ä¿å­˜")
            return False
    
    def save_result_to_sheet(self, results: List[Dict], mode: str = "text") -> None:
        """
        çµæœã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜
        
        Args:
            results: çµæœã®ãƒªã‚¹ãƒˆ
            mode: "text" ã¾ãŸã¯ "image"
        """
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆåã®æº–å‚™ ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            # çµæœã‚·ãƒ¼ãƒˆåã‚’æ±ºå®š
            result_sheet_name = f"result_{mode}"
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèªã¨ä½œæˆ ===
            # ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
            try:
                result_sheet = sheet.worksheet(result_sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.info(f"ã‚·ãƒ¼ãƒˆ '{result_sheet_name}' ã‚’ä½œæˆã—ã¾ã™")
                result_sheet = sheet.add_worksheet(title=result_sheet_name, rows=1000, cols=10)
                
                # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
                headers = ['Index', 'Prompt', 'Status', 'Filename', 'Timestamp', 'Error', 'Mode']
                result_sheet.append_row(headers)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: çµæœãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ ===
            # çµæœã‚’è¿½åŠ 
            for result in results:
                row = [
                    result.get('index', ''),
                    result.get('prompt', '')[:100],  # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¯æœ€åˆã®100æ–‡å­—
                    result.get('status', ''),
                    result.get('filename', ''),
                    result.get('timestamp', ''),
                    result.get('error', ''),
                    result.get('mode', mode)
                ]
                result_sheet.append_row(row)
            
            logger.info(f"âœ… {len(results)}ä»¶ã®çµæœã‚’ '{result_sheet_name}' ã«ä¿å­˜ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "çµæœä¿å­˜")
            logger.warning("çµæœã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸãŒã€å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™")
    
    def extract_file_id_from_url(self, url: str) -> Optional[str]:
        """
        Google Driveã®URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡º
        
        å¯¾å¿œå½¢å¼:
        - https://drive.google.com/file/d/FILE_ID/view
        - https://drive.google.com/open?id=FILE_ID
        - https://docs.google.com/document/d/FILE_ID/edit
        """
        # === ãƒ‘ãƒ¼ãƒˆ1: æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®šç¾© ===
        patterns = [
            r'/file/d/([a-zA-Z0-9_-]+)',
            r'id=([a-zA-Z0-9_-]+)',
            r'/d/([a-zA-Z0-9_-]+)',
        ]
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã®å®Ÿè¡Œ ===
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                file_id = match.group(1)
                logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡º: {file_id}")
                return file_id
        
        logger.warning(f"âš ï¸ URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ: {url}")
        return None
    
    def read_file_from_drive(self, file_id_or_url: str) -> Optional[str]:
        """
        Google Driveã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦èª­ã¿è¾¼ã‚€ï¼ˆè¶…è©³ç´°ãƒ­ã‚°ç‰ˆï¼‰
        
        Args:
            file_id_or_url: ãƒ•ã‚¡ã‚¤ãƒ«ID ã¾ãŸã¯ Google Driveã®URL
            
        Returns:
            ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ï¼ˆãƒ†ã‚­ã‚¹ãƒˆï¼‰ã€å¤±æ•—æ™‚ã¯None
        """
        try:
            logger.info("="*60)
            logger.info("ã€Google Driveèª­ã¿è¾¼ã¿é–‹å§‹ã€‘")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: Drive APIã‚µãƒ¼ãƒ“ã‚¹ã®ç¢ºèª ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘1ã€‘Drive APIã‚µãƒ¼ãƒ“ã‚¹ã‚’ç¢ºèª")
            if not self.drive_service:
                logger.error("âŒ Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                logger.error("  â†’ ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                return None
            logger.info("âœ… Drive APIã‚µãƒ¼ãƒ“ã‚¹: æ­£å¸¸")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å…¥åŠ›å€¤ã®è§£æã¨ãƒ•ã‚¡ã‚¤ãƒ«IDã®æŠ½å‡º ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘2ã€‘å…¥åŠ›å€¤ã‚’è§£æ")
            logger.info(f"  å…¥åŠ›: {file_id_or_url[:100]}")
            
            if file_id_or_url.startswith('http'):
                logger.info("  â†’ URLå½¢å¼ã¨åˆ¤å®š")
                file_id = self.extract_file_id_from_url(file_id_or_url)
                if not file_id:
                    logger.error("âŒ URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
                    return None
                logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«IDæŠ½å‡ºæˆåŠŸ: {file_id}")
            else:
                file_id = file_id_or_url
                logger.info(f"  â†’ ãƒ•ã‚¡ã‚¤ãƒ«IDå½¢å¼: {file_id}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾— ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘3ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            try:
                from googleapiclient.http import MediaIoBaseDownload
                import io
                
                file_metadata = self.drive_service.files().get(
                    fileId=file_id, 
                    fields='name,mimeType,size,permissions'
                ).execute()
                
                file_name = file_metadata.get('name', 'Unknown')
                mime_type = file_metadata.get('mimeType', '')
                file_size = file_metadata.get('size', '0')
                
                logger.info("âœ… ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ")
                logger.info(f"  ãƒ•ã‚¡ã‚¤ãƒ«å: {file_name}")
                logger.info(f"  MIME Type: {mime_type}")
                logger.info(f"  ã‚µã‚¤ã‚º: {file_size} bytes")
                
            except Exception as e:
                logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                logger.error("  è€ƒãˆã‚‰ã‚Œã‚‹åŸå› :")
                logger.error("  - ãƒ•ã‚¡ã‚¤ãƒ«IDãŒé–“é•ã£ã¦ã„ã‚‹")
                logger.error("  - ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æ¨©é™ãŒãªã„")
                logger.error("  - ãƒ•ã‚¡ã‚¤ãƒ«ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘4ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰")
            try:
                request = self.drive_service.files().get_media(fileId=file_id)
                
                fh = io.BytesIO()
                downloader = MediaIoBaseDownload(fh, request)
                
                done = False
                chunk_count = 0
                while not done:
                    status, done = downloader.next_chunk()
                    chunk_count += 1
                    if status:
                        progress = int(status.progress() * 100)
                        logger.debug(f"  â³ ãƒãƒ£ãƒ³ã‚¯{chunk_count}: {progress}%")
                
                logger.info(f"âœ… ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: {chunk_count}ãƒãƒ£ãƒ³ã‚¯")
                
            except Exception as e:
                logger.error(f"âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: {e}")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã¸ã®å¤‰æ› ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘5ã€‘ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›")
            try:
                content = fh.getvalue().decode('utf-8')
                logger.info(f"âœ… å¤‰æ›æˆåŠŸ: {len(content)}æ–‡å­—")
                logger.info(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
                
                # å†…å®¹ã®æ¤œè¨¼
                if len(content) < 10:
                    logger.warning(f"âš ï¸ å†…å®¹ãŒçŸ­ã™ãã¾ã™: {len(content)}æ–‡å­—")
                
                return content
                
            except UnicodeDecodeError as e:
                logger.error(f"âŒ UTF-8ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: {e}")
                logger.error("  â†’ ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§ã¯ãªã„å¯èƒ½æ€§")
                return None
            except Exception as e:
                logger.error(f"âŒ å¤‰æ›ã‚¨ãƒ©ãƒ¼: {e}")
                return None
            
        except Exception as e:
            logger.error(f"âŒ Google Driveãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def get_current_pc_id(self) -> int:
        """ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰PC_IDã‚’èª­ã¿å–ã‚‹"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæ¥ç¶šã¨ã‚»ãƒ«èª­ã¿å–ã‚Š ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
            
            pc_id_value = setting_sheet.cell(12, 2).value
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å€¤ã®æ¤œè¨¼ã¨å¤‰æ› ===
            if pc_id_value:
                try:
                    pc_id = int(pc_id_value)
                    logger.info(f"âœ… ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰PC_ID={pc_id}ã‚’èª­ã¿å–ã‚Šã¾ã—ãŸ(ã‚»ãƒ«B12)")
                    return pc_id
                except ValueError:
                    logger.warning(f"âš ï¸ B12ã‚»ãƒ«ã®å€¤ '{pc_id_value}' ã‚’æ•´æ•°ã«å¤‰æ›ã§ãã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤1ã‚’ä½¿ç”¨ã—ã¾ã™")
                    return 1
            else:
                logger.warning("âš ï¸ B12ã‚»ãƒ«ãŒç©ºã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤1ã‚’ä½¿ç”¨ã—ã¾ã™")
                return 1
                
        except Exception as e:
            ErrorHandler.log_error(e, "PC_IDèª­ã¿å–ã‚Š")
            logger.warning("âš ï¸ PC_IDã®èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤1ã‚’ä½¿ç”¨ã—ã¾ã™")
            return 1
    
    def load_pc_settings(self, pc_id: int = 1) -> Dict[str, str]:
        """PCå›ºæœ‰ã®è¨­å®šã‚’settingã‚·ãƒ¼ãƒˆã‹ã‚‰èª­ã¿è¾¼ã¿"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæ¥ç¶šã¨åŸºæœ¬è¨­å®š ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
        
            col_index = 1 + pc_id
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å„è¨­å®šå€¤ã®èª­ã¿è¾¼ã¿ ===
            settings = {
                'google_id': self._get_cell_value(setting_sheet, 2, col_index),
                'google_pass': self._get_cell_value(setting_sheet, 3, col_index),
                'service_mail': self._get_cell_value(setting_sheet, 4, col_index),
                'download_image_folder': self._get_cell_value(setting_sheet, 5, col_index),
                'download_text_folder': self._get_cell_value(setting_sheet, 6, col_index),
                'browser_data_dir': self._get_cell_value(setting_sheet, 7, col_index),
                'service_account_file': self._get_cell_value(setting_sheet, 8, col_index),
                'cookies_file': self._get_cell_value(setting_sheet, 9, col_index),
                'generation_mode': self._get_cell_value(setting_sheet, 10, col_index),
                'text_format': self._get_cell_value(setting_sheet, 11, col_index),
                'service_type': self._get_cell_value(setting_sheet, 13, col_index),
                'agent_output_folder': self._get_cell_value(setting_sheet, 14, col_index),
                'max_iterations': self._get_cell_value(setting_sheet, 15, col_index),
                'wp_url': self._get_cell_value(setting_sheet, 16, col_index),
                'wp_user': self._get_cell_value(setting_sheet, 17, col_index),
                'wp_pass': self._get_cell_value(setting_sheet, 18, col_index),
            }
        
            # === ãƒ‘ãƒ¼ãƒˆ3: è¨­å®šå€¤ã®æ¤œè¨¼ã¨æ­£è¦åŒ– ===
            # generation_modeã®æ¤œè¨¼
            mode = settings.get('generation_mode', '').strip().lower()
            if mode not in ['text', 'image']:
                logger.warning(f"âš ï¸ ä¸æ­£ãªgeneration_modeå€¤: '{mode}' â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 'image' ã‚’ä½¿ç”¨")
                settings['generation_mode'] = 'image'
            else:
                settings['generation_mode'] = mode
        
            # max_iterationsã®æ¤œè¨¼
            try:
                max_iter = int(settings.get('max_iterations', '3'))
                if max_iter < 1 or max_iter > 10:
                    logger.warning(f"âš ï¸ ä¸æ­£ãªmax_iterationså€¤: {max_iter} â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 3 ã‚’ä½¿ç”¨")
                    settings['max_iterations'] = 3
                else:
                    settings['max_iterations'] = max_iter
            except (ValueError, TypeError):
                logger.warning(f"âš ï¸ max_iterationsã®å¤‰æ›ã‚¨ãƒ©ãƒ¼ â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 3 ã‚’ä½¿ç”¨")
                settings['max_iterations'] = 3
        
            logger.info(f"âœ… PC_ID={pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
            return settings
        
        except Exception as e:
            ErrorHandler.log_error(e, f"PC_ID={pc_id} ã®è¨­å®šèª­ã¿è¾¼ã¿")
            raise

    def _get_cell_value(self, sheet, row: int, col: int) -> str:
        """ã‚»ãƒ«ã®å€¤ã‚’å®‰å…¨ã«å–å¾—"""
        try:
            value = sheet.cell(row, col).value
            return value if value is not None else ""
        except Exception:
            return ""
    
    def _get_column_letter(self, col_index: int) -> str:
        """åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åˆ—æ–‡å­—ã«å¤‰æ›(1â†’A, 2â†’B, ...)"""
        result = ""
        while col_index > 0:
            col_index -= 1
            result = chr(col_index % 26 + ord('A')) + result
            col_index //= 26
        return result
    
    def load_credentials_from_sheet(self, pc_id: int = 1) -> Dict[str, str]:
        """èªè¨¼æƒ…å ±ã‚’èª­ã¿è¾¼ã¿(PC_IDå¯¾å¿œç‰ˆ)"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: è¨­å®šèª­ã¿è¾¼ã¿ ===
            settings = self.load_pc_settings(pc_id)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: èªè¨¼æƒ…å ±ã®æŠ½å‡º ===
            credentials = {
                'email': settings['google_id'],
                'password': settings['google_pass'],
                'service_mail': settings.get('service_mail')
            }
            
            return credentials
            
        except Exception as e:
            ErrorHandler.log_error(e, "èªè¨¼æƒ…å ±èª­ã¿è¾¼ã¿")
            raise
    
    # sheets_manager.py ã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 

    async def verify_task_exists(self, task_id: int, sheet_name: str = "pm_tasks") -> bool:
        """ã‚¿ã‚¹ã‚¯ãŒã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã™ã‚‹ã‹æ¤œè¨¼ï¼ˆè¿½åŠ ï¼‰"""
        try:
            self._ensure_client()
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            task_sheet = sheet.worksheet(sheet_name)
        
            # å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            all_data = task_sheet.get_all_values()
        
            if len(all_data) <= 1:
                logger.warning(f"ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ˜ãƒƒãƒ€ãƒ¼è§£æ
            headers = all_data[0]
            task_id_col = None
        
            for i, header in enumerate(headers):
                header_lower = header.lower()
                if 'task_id' in header_lower or 'id' in header_lower:
                    task_id_col = i
                    break
        
            if task_id_col is None:
                task_id_col = 0
        
            # ã‚¿ã‚¹ã‚¯IDæ¤œç´¢ï¼ˆå‹ã®ä¸ä¸€è‡´ã‚’è€ƒæ…®ï¼‰
            task_id_str = str(task_id)
            for row in all_data[1:]:
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    if cell_value == task_id_str:
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} ã®å­˜åœ¨ã‚’ç¢ºèª")
                        return True
        
            logger.warning(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã¯ã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã—ã¾ã›ã‚“")
            return False
        
        except Exception as e:
            logger.error(f"ã‚¿ã‚¹ã‚¯å­˜åœ¨ç¢ºèªã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _enhanced_task_search(self, task_sheet, task_id: int, task_id_col: int) -> tuple:
        """å¼·åŒ–ç‰ˆã‚¿ã‚¹ã‚¯æ¤œç´¢ï¼ˆä¿®æ­£ï¼‰"""
        try:
            all_data = task_sheet.get_all_values()
            task_id_str = str(task_id)
        
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®åé›†
            available_ids = []
            for i, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col and row[task_id_col]:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    if cell_value == task_id_str:
                        return (i, True)  # (è¡Œç•ªå·, è¦‹ã¤ã‹ã£ãŸã‹)
        
            logger.warning(f"ğŸ” æ¤œç´¢å¯¾è±¡ID: '{task_id_str}'")
            logger.warning(f"ğŸ” åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯ID: {available_ids}")
            return (None, False)
        
        except Exception as e:
            logger.error(f"ã‚¿ã‚¹ã‚¯æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
            return (None, False)
    
    def validate_sheet_structure(self) -> bool:
        """ã‚·ãƒ¼ãƒˆæ§‹é€ ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆä¸€è¦§ã®å–å¾— ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            required_sheets = ["setting"]
            existing_sheets = [ws.title for ws in sheet.worksheets()]
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å¿…é ˆã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèª ===
            for required_sheet in required_sheets:
                if required_sheet not in existing_sheets:
                    logger.error(f"âŒ å¿…è¦ãªã‚·ãƒ¼ãƒˆ '{required_sheet}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return False
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèª ===
            if "prompt_text" not in existing_sheets and "prompt" not in existing_sheets:
                logger.error("âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚·ãƒ¼ãƒˆ ('prompt_text' ã¾ãŸã¯ 'prompt') ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            logger.info("âœ… ã‚·ãƒ¼ãƒˆæ§‹é€ ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯å®Œäº†")
            return True
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚·ãƒ¼ãƒˆæ§‹é€ ãƒã‚§ãƒƒã‚¯")
            return False

#system_cli_executor.py
"""
system_cli_executor.py - ã‚·ã‚¹ãƒ†ãƒ CLIã‚¿ã‚¹ã‚¯å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
WP-CLIã€ACFã€ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãªã©ã®ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¹ã‚¯ã‚’æ‹…å½“
"""

import asyncio
import subprocess
import logging
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime

# è¨­å®š
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

# ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
try:
    from agents.command_monitor_agent import CommandMonitorAgent
    HAS_COMMAND_MONITOR = True
except ImportError:
    HAS_COMMAND_MONITOR = False
    CommandMonitorAgent = None

logger = logging.getLogger(__name__)


class SystemCLIExecutor:
    """
    ã‚·ã‚¹ãƒ†ãƒ CLIã‚¿ã‚¹ã‚¯ã®å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    WP-CLIã€ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã€
    ã‚¤ãƒ³ãƒ•ãƒ©ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚’çµ±åˆç®¡ç†
    """
    
    def __init__(self, sheets_manager: GoogleSheetsManager):
        """
        åˆæœŸåŒ–
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.sheets_manager = sheets_manager
        
        # ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
        if HAS_COMMAND_MONITOR and CommandMonitorAgent:
            try:
                self.command_monitor = CommandMonitorAgent()
                logger.info("âœ… CommandMonitorAgent åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ CommandMonitorAgent åˆæœŸåŒ–å¤±æ•—: {e}")
                self.command_monitor = None
        else:
            logger.info("â„¹ï¸ CommandMonitorAgent ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.command_monitor = None
        
        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
        self.default_timeout = 60.0
        self.long_timeout = 300.0
        
        # WP-CLIè¨­å®š
        self.wp_cli_path = self._detect_wp_cli_path()
        
        logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
    
    def _detect_wp_cli_path(self) -> str:
        """WP-CLIãƒ‘ã‚¹ã‚’æ¤œå‡º"""
        candidates = [
            'wp',  # PATHå†…
            '/usr/local/bin/wp',
            '/usr/bin/wp',
            './wp-cli.phar'
        ]
        
        for candidate in candidates:
            try:
                result = subprocess.run(
                    [candidate, '--version'],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    logger.info(f"âœ… WP-CLIæ¤œå‡º: {candidate}")
                    return candidate
            except:
                continue
        
        logger.warning("âš ï¸ WP-CLIæœªæ¤œå‡º - 'wp'ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½¿ç”¨")
        return 'wp'
    
    async def execute_cli_task(self, task: Dict) -> Dict:
        """
        CLIã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("=" * 60)
            logger.info(f"âš™ï¸ CLIã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info("=" * 60)
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®š
            cli_type = self._determine_cli_type(task)
            logger.info(f"CLIã‚¿ã‚¤ãƒ—: {cli_type}")
            
            # ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ
            if cli_type == 'wp-cli':
                result = await self._execute_wp_cli_task(task)
            elif cli_type == 'acf':
                result = await self._execute_acf_task(task)
            elif cli_type == 'file':
                result = await self._execute_file_operation_task(task)
            elif cli_type == 'generic':
                result = await self._execute_generic_command_task(task)
            else:
                logger.warning(f"âš ï¸ æœªçŸ¥ã®CLIã‚¿ã‚¤ãƒ—: {cli_type}")
                result = await self._execute_generic_command_task(task)
            
            if result.get('success'):
                logger.info(f"âœ… CLIã‚¿ã‚¹ã‚¯ {task_id} å®Œäº†")
            else:
                logger.error(f"âŒ CLIã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•—")
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ CLIã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"SystemCLIExecutor.execute_cli_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_cli_type(self, task: Dict) -> str:
        """
        CLIã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ— ('wp-cli', 'acf', 'file', 'generic')
        """
        description = task.get('description', '').lower()
        command = task.get('command', '').lower()
        
        # WP-CLIã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        if any(kw in description or kw in command for kw in ['wp ', 'wp-cli', 'wordpress cli']):
            return 'wp-cli'
        
        # ACFã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        if any(kw in description or kw in command for kw in ['acf', 'advanced custom fields', 'acf-json']):
            return 'acf'
        
        # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        if any(kw in description for kw in ['ãƒ•ã‚¡ã‚¤ãƒ«', 'ã‚³ãƒ”ãƒ¼', 'ç§»å‹•', 'å‰Šé™¤', 'mkdir', 'cp', 'mv', 'rm']):
            return 'file'
        
        return 'generic'
    
    async def _execute_wp_cli_task(self, task: Dict) -> Dict:
        """
        WP-CLIã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸŒ WP-CLIã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ")
            
            # ã‚³ãƒãƒ³ãƒ‰æ§‹ç¯‰
            command = task.get('command', '')
            if not command:
                # ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰æŠ½å‡ºã‚’è©¦è¡Œ
                description = task.get('description', '')
                if 'wp ' in description:
                    command = description[description.find('wp '):]
                else:
                    return {
                        'success': False,
                        'error': 'WP-CLIã‚³ãƒãƒ³ãƒ‰ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    }
            
            # WP-CLIãƒ‘ã‚¹ä»˜åŠ 
            if not command.startswith(self.wp_cli_path):
                command = f"{self.wp_cli_path} {command}"
            
            # ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            wp_path = task.get('wp_path', config.WP_PATH if hasattr(config, 'WP_PATH') else None)
            
            # ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä½¿ç”¨
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            else:
                # ç›´æ¥å®Ÿè¡Œï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                result = await self._direct_command_execution(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ WP-CLIå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_acf_task(self, task: Dict) -> Dict:
        """
        ACFé–¢é€£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“¦ ACFã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # ACFæ“ä½œã‚¿ã‚¤ãƒ—åˆ¤å®š
            description = task.get('description', '').lower()
            
            if 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ' in description or 'import' in description:
                # ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                acf_file = task.get('acf_file', task.get('file_path', ''))
                
                if not acf_file:
                    return {
                        'success': False,
                        'error': 'ACFãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    }
                
                if self.command_monitor and hasattr(self.command_monitor, 'monitor_acf_import_process'):
                    result = await self.command_monitor.monitor_acf_import_process(acf_file)
                else:
                    # WP-CLIçµŒç”±ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                    command = f"{self.wp_cli_path} acf import {acf_file}"
                    result = await self._direct_command_execution(
                        command,
                        timeout=self.long_timeout
                    )
                
                return result
            
            elif 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ' in description or 'export' in description:
                # ACFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                output_path = task.get('output_path', './acf-export.json')
                command = f"{self.wp_cli_path} acf export --path={output_path}"
                
                result = await self._direct_command_execution(
                    command,
                    timeout=self.default_timeout
                )
                
                return result
            
            else:
                return {
                    'success': False,
                    'error': 'ACFæ“ä½œã‚¿ã‚¤ãƒ—ãŒä¸æ˜ã§ã™'
                }
        
        except Exception as e:
            logger.error(f"âŒ ACFã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_file_operation_task(self, task: Dict) -> Dict:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            description = task.get('description', '').lower()
            
            # æ“ä½œã‚¿ã‚¤ãƒ—åˆ¤å®š
            if 'ã‚³ãƒ”ãƒ¼' in description or 'copy' in description:
                return await self._file_copy(task)
            elif 'ç§»å‹•' in description or 'move' in description:
                return await self._file_move(task)
            elif 'å‰Šé™¤' in description or 'delete' in description:
                return await self._file_delete(task)
            elif 'ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ' in description or 'mkdir' in description:
                return await self._directory_create(task)
            else:
                return {
                    'success': False,
                    'error': 'ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¿ã‚¤ãƒ—ãŒä¸æ˜ã§ã™'
                }
        
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _file_copy(self, task: Dict) -> Dict:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': 'ã‚³ãƒ”ãƒ¼å…ƒã¾ãŸã¯ã‚³ãƒ”ãƒ¼å…ˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            shutil.copy2(source, dest)
            logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼æˆåŠŸ: {source} -> {dest}")
            return {'success': True, 'message': f'ã‚³ãƒ”ãƒ¼å®Œäº†: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'ã‚³ãƒ”ãƒ¼å¤±æ•—: {e}'}
    
    async def _file_move(self, task: Dict) -> Dict:
        """ãƒ•ã‚¡ã‚¤ãƒ«ç§»å‹•"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': 'ç§»å‹•å…ƒã¾ãŸã¯ç§»å‹•å…ˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            shutil.move(source, dest)
            logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«ç§»å‹•æˆåŠŸ: {source} -> {dest}")
            return {'success': True, 'message': f'ç§»å‹•å®Œäº†: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'ç§»å‹•å¤±æ•—: {e}'}
    
    async def _file_delete(self, task: Dict) -> Dict:
        """ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤"""
        target = task.get('target', task.get('file_path', ''))
        
        if not target:
            return {'success': False, 'error': 'å‰Šé™¤å¯¾è±¡ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            path = Path(target)
            if path.is_file():
                path.unlink()
            elif path.is_dir():
                import shutil
                shutil.rmtree(path)
            else:
                return {'success': False, 'error': f'ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {target}'}
            
            logger.info(f"âœ… å‰Šé™¤æˆåŠŸ: {target}")
            return {'success': True, 'message': f'å‰Šé™¤å®Œäº†: {target}'}
        except Exception as e:
            return {'success': False, 'error': f'å‰Šé™¤å¤±æ•—: {e}'}
    
    async def _directory_create(self, task: Dict) -> Dict:
        """ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ"""
        dir_path = task.get('directory', task.get('path', ''))
        
        if not dir_path:
            return {'success': False, 'error': 'ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
            logger.info(f"âœ… ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆæˆåŠŸ: {dir_path}")
            return {'success': True, 'message': f'ä½œæˆå®Œäº†: {dir_path}'}
        except Exception as e:
            return {'success': False, 'error': f'ä½œæˆå¤±æ•—: {e}'}
    
    async def _execute_generic_command_task(self, task: Dict) -> Dict:
        """
        æ±ç”¨ã‚³ãƒãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ”§ æ±ç”¨ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ")
            
            command = task.get('command', '')
            if not command:
                return {
                    'success': False,
                    'error': 'ã‚³ãƒãƒ³ãƒ‰ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            timeout = task.get('timeout', self.default_timeout)
            cwd = task.get('cwd', None)
            
            # ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä½¿ç”¨
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            else:
                result = await self._direct_command_execution(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ æ±ç”¨ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _direct_command_execution(
        self,
        command: str,
        cwd: Optional[str] = None,
        timeout: float = 60.0
    ) -> Dict:
        """
        ã‚³ãƒãƒ³ãƒ‰ã‚’ç›´æ¥å®Ÿè¡Œï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        
        Args:
            command: å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
            cwd: ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            timeout: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info(f"ğŸ”§ ã‚³ãƒãƒ³ãƒ‰ç›´æ¥å®Ÿè¡Œ: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                return {
                    'success': False,
                    'error': f'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)'
                }
            
            returncode = process.returncode
            stdout_text = stdout.decode('utf-8') if stdout else ''
            stderr_text = stderr.decode('utf-8') if stderr else ''
            
            if returncode == 0:
                logger.info(f"âœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡ŒæˆåŠŸ")
                return {
                    'success': True,
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
            else:
                logger.error(f"âŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œå¤±æ•— (ã‚³ãƒ¼ãƒ‰: {returncode})")
                return {
                    'success': False,
                    'error': f'ã‚³ãƒãƒ³ãƒ‰å¤±æ•— (ã‚³ãƒ¼ãƒ‰: {returncode})',
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
        
        except Exception as e:
            logger.error(f"âŒ ã‚³ãƒãƒ³ãƒ‰ç›´æ¥å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#tas__init__.py
"""
task_executor ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åˆæœŸåŒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®å°‚é–€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’çµ±åˆç®¡ç†

ãƒ•ã‚¡ã‚¤ãƒ«å: task_executor/tas__init__.py
ä½¿ç”¨æ–¹æ³•: from task_executor.tas__init__ import *
"""

# æ—¢å­˜ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆå¤‰æ›´ä¸è¦ï¼‰
try:
    from .task_executor_content import ContentTaskExecutor as LegacyContentExecutor
    HAS_LEGACY_CONTENT = True
except ImportError:
    HAS_LEGACY_CONTENT = False
    LegacyContentExecutor = None

try:
    from .task_executor_ma import MATaskExecutor as LegacyMAExecutor
    HAS_LEGACY_MA = True
except ImportError:
    HAS_LEGACY_MA = False
    LegacyMAExecutor = None

# æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
try:
    from .content_task_executor import ContentTaskExecutor
    HAS_CONTENT_EXECUTOR = True
except ImportError:
    HAS_CONTENT_EXECUTOR = False
    ContentTaskExecutor = None

try:
    from .system_cli_executor import SystemCLIExecutor
    HAS_CLI_EXECUTOR = True
except ImportError:
    HAS_CLI_EXECUTOR = False
    SystemCLIExecutor = None

try:
    from .task_coordinator import TaskCoordinator
    HAS_COORDINATOR = True
except ImportError:
    HAS_COORDINATOR = False
    TaskCoordinator = None

try:
    from .workflow_executor import WorkflowExecutor
    HAS_WORKFLOW_EXECUTOR = True
except ImportError:
    HAS_WORKFLOW_EXECUTOR = False
    WorkflowExecutor = None

# ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±
__version__ = '2.0.0'
__all__ = [
    # æ—¢å­˜
    'LegacyContentExecutor',
    'LegacyMAExecutor',
    # æ–°è¦
    'ContentTaskExecutor',
    'SystemCLIExecutor',
    'TaskCoordinator',
    'WorkflowExecutor',
    # ãƒ•ãƒ©ã‚°
    'HAS_LEGACY_CONTENT',
    'HAS_LEGACY_MA',
    'HAS_CONTENT_EXECUTOR',
    'HAS_CLI_EXECUTOR',
    'HAS_COORDINATOR',
    'HAS_WORKFLOW_EXECUTOR'
]

# åˆ©ç”¨å¯èƒ½ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒ­ã‚°å‡ºåŠ›
import logging
logger = logging.getLogger(__name__)

logger.info("=" * 60)
logger.info("ğŸ“¦ task_executor ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åˆæœŸåŒ– (tas__init__)")
logger.info("=" * 60)

if HAS_LEGACY_CONTENT:
    logger.info("âœ… æ—¢å­˜ task_executor_content åˆ©ç”¨å¯èƒ½")
else:
    logger.info("âš ï¸ task_executor_content æœªæ¤œå‡º")

if HAS_LEGACY_MA:
    logger.info("âœ… æ—¢å­˜ task_executor_ma åˆ©ç”¨å¯èƒ½")
else:
    logger.info("âš ï¸ task_executor_ma æœªæ¤œå‡º")

if HAS_CONTENT_EXECUTOR:
    logger.info("âœ… æ–°è¦ ContentTaskExecutor åˆ©ç”¨å¯èƒ½")
else:
    logger.info("â„¹ï¸ ContentTaskExecutor æœªé…ç½®ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")

if HAS_CLI_EXECUTOR:
    logger.info("âœ… æ–°è¦ SystemCLIExecutor åˆ©ç”¨å¯èƒ½")
else:
    logger.info("â„¹ï¸ SystemCLIExecutor æœªé…ç½®ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")

if HAS_COORDINATOR:
    logger.info("âœ… æ–°è¦ TaskCoordinator åˆ©ç”¨å¯èƒ½")
else:
    logger.info("â„¹ï¸ TaskCoordinator æœªé…ç½®ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")

if HAS_WORKFLOW_EXECUTOR:
    logger.info("âœ… æ–°è¦ WorkflowExecutor åˆ©ç”¨å¯èƒ½")
else:
    logger.info("â„¹ï¸ WorkflowExecutor æœªé…ç½®ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")

logger.info("=" * 60)


# ========================================
# ä¾¿åˆ©é–¢æ•°: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
# ========================================

def load_all_modules():
    """
    åˆ©ç”¨å¯èƒ½ãªå…¨ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¾æ›¸å½¢å¼ã§è¿”ã™
    
    Returns:
        Dict: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‚’ã‚­ãƒ¼ã€ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å€¤ã¨ã™ã‚‹è¾æ›¸
    """
    modules = {}
    
    if HAS_LEGACY_CONTENT:
        modules['legacy_content'] = LegacyContentExecutor
    if HAS_LEGACY_MA:
        modules['legacy_ma'] = LegacyMAExecutor
    if HAS_CONTENT_EXECUTOR:
        modules['content'] = ContentTaskExecutor
    if HAS_CLI_EXECUTOR:
        modules['cli'] = SystemCLIExecutor
    if HAS_COORDINATOR:
        modules['coordinator'] = TaskCoordinator
    if HAS_WORKFLOW_EXECUTOR:
        modules['workflow'] = WorkflowExecutor
    
    return modules


def get_available_modules():
    """
    åˆ©ç”¨å¯èƒ½ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ãƒªã‚¹ãƒˆã‚’è¿”ã™
    
    Returns:
        List[str]: åˆ©ç”¨å¯èƒ½ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã®ãƒªã‚¹ãƒˆ
    """
    available = []
    
    if HAS_LEGACY_CONTENT:
        available.append('legacy_content')
    if HAS_LEGACY_MA:
        available.append('legacy_ma')
    if HAS_CONTENT_EXECUTOR:
        available.append('content')
    if HAS_CLI_EXECUTOR:
        available.append('cli')
    if HAS_COORDINATOR:
        available.append('coordinator')
    if HAS_WORKFLOW_EXECUTOR:
        available.append('workflow')
    
    return available


def print_module_status():
    """
    ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆ©ç”¨å¯èƒ½çŠ¶æ³ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›
    """
    print("\n" + "=" * 60)
    print("ğŸ“¦ task_executor ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çŠ¶æ³")
    print("=" * 60)
    
    modules_status = [
        ("æ—¢å­˜ task_executor_content", HAS_LEGACY_CONTENT),
        ("æ—¢å­˜ task_executor_ma", HAS_LEGACY_MA),
        ("æ–°è¦ ContentTaskExecutor", HAS_CONTENT_EXECUTOR),
        ("æ–°è¦ SystemCLIExecutor", HAS_CLI_EXECUTOR),
        ("æ–°è¦ TaskCoordinator", HAS_COORDINATOR),
        ("æ–°è¦ WorkflowExecutor", HAS_WORKFLOW_EXECUTOR)
    ]
    
    for name, available in modules_status:
        status = "âœ… åˆ©ç”¨å¯èƒ½" if available else "âŒ æœªé…ç½®"
        print(f"{name}: {status}")
    
    print("=" * 60 + "\n")

#task_coordinator.py
"""
task_coordinator.py - ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®çµ±åˆèª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼
æ—¢å­˜ã®TaskExecutorã‚’è£œå®Œã—ã€ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ã¨çµæœé›†ç´„ã‚’æ‹…å½“
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

# æ—¢å­˜ã®TaskExecutor
from task_executor import TaskExecutor

# å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆæ–°è¦ï¼‰
try:
    from content_task_executor import ContentTaskExecutor
    HAS_CONTENT_EXECUTOR = True
except ImportError:
    HAS_CONTENT_EXECUTOR = False
    ContentTaskExecutor = None

try:
    from system_cli_executor import SystemCLIExecutor
    HAS_CLI_EXECUTOR = True
except ImportError:
    HAS_CLI_EXECUTOR = False
    SystemCLIExecutor = None

try:
    from workflow_executor import WorkflowExecutor
    HAS_WORKFLOW_EXECUTOR = True
except ImportError:
    HAS_WORKFLOW_EXECUTOR = False
    WorkflowExecutor = None

logger = logging.getLogger(__name__)


class TaskCoordinator:
    """
    ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®çµ±åˆèª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼
    
    æ—¢å­˜ã®TaskExecutorã‚’æ‹¡å¼µã—ã€å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®
    ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘ã¨çµæœé›†ç´„ã‚’è¡Œã†
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            task_executor: æ—¢å­˜ã®TaskExecutorã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            'total_executed': 0,
            'content_tasks': 0,
            'cli_tasks': 0,
            'workflow_tasks': 0,
            'fallback_tasks': 0,
            'success': 0,
            'failed': 0
        }
        
        logger.info("=" * 60)
        logger.info("ğŸ¯ TaskCoordinator åˆæœŸåŒ–ä¸­...")
        logger.info("=" * 60)
        
        # å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–
        self._initialize_specialized_executors()
        
        logger.info("=" * 60)
        logger.info("âœ… TaskCoordinator åˆæœŸåŒ–å®Œäº†")
        logger.info("=" * 60)
    
    def _initialize_specialized_executors(self):
        """å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–"""
        
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if HAS_CONTENT_EXECUTOR and ContentTaskExecutor:
            try:
                self.content_executor = ContentTaskExecutor(
                    browser_controller=self.browser,
                    sheets_manager=self.sheets_manager
                )
                logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ ContentTaskExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                self.content_executor = None
        else:
            logger.info("â„¹ï¸ ContentTaskExecutor ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆæ—¢å­˜å®Ÿè£…ã‚’ä½¿ç”¨ï¼‰")
            self.content_executor = None
        
        # CLIã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if HAS_CLI_EXECUTOR and SystemCLIExecutor:
            try:
                self.cli_executor = SystemCLIExecutor(
                    sheets_manager=self.sheets_manager
                )
                logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ SystemCLIExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                self.cli_executor = None
        else:
            logger.info("â„¹ï¸ SystemCLIExecutor ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.cli_executor = None
        
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
            try:
                self.workflow_executor = WorkflowExecutor(
                    task_executor=self.task_executor,
                    sheets_manager=self.sheets_manager,
                    browser_controller=self.browser
                )
                logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ WorkflowExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                self.workflow_executor = None
        else:
            logger.info("â„¹ï¸ WorkflowExecutor ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.workflow_executor = None
            
    def determine_executor_type(self, task: Dict) -> str:
        """
        ã‚¿ã‚¹ã‚¯ã«æœ€é©ãªå®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ¤å®š
            
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
                
        Returns:
            str: å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ— ('content', 'cli', 'workflow', 'review', 'fallback')
        """
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
            
        # ========================================
        # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯åˆ¤å®šï¼ˆæœ€å„ªå…ˆ - æ–°è¦è¿½åŠ ï¼‰
        # ========================================
        if role == 'review' or 'ãƒ¬ãƒ“ãƒ¥ãƒ¼' in description or 'review' in description:
            return 'review'
        # ========================================
            
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
        workflow_keywords = [
            'å¤šè¨€èª', 'ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—', 'ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£',
            'ã‚·ãƒ¼ã‚±ãƒ³ã‚¹', 'ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³', 'ãƒã‚§ãƒ¼ãƒ³'
        ]
        if any(kw in description for kw in workflow_keywords):
            return 'workflow'
            
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
        content_keywords = [
            'è¨˜äº‹', 'ç”Ÿæˆ', 'åŸ·ç­†', 'ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°', 
            'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', 'ai', 'gemini', 'deepseek',
            'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ', 'æŠ½å‡º'
        ]
        if any(kw in description for kw in content_keywords):
            return 'content'
            
        # CLIã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
        cli_keywords = [
            'wp-cli', 'acf', 'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ', 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ',
            'ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ', 'ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¤ãƒ³ãƒ•ãƒ©'
        ]
        if any(kw in description for kw in cli_keywords):
            return 'cli'
            
        # ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹åˆ¤å®š
        if role in ['content', 'writer', 'seo']:
            return 'content'
        elif role in ['dev', 'system', 'admin']:
            return 'cli'
            
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        return 'fallback'
    
    async def execute_task_coordinated(self, task: Dict) -> Dict:
        """
        ã‚¿ã‚¹ã‚¯ã‚’é©åˆ‡ãªå®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æŒ¯ã‚Šåˆ†ã‘ã¦å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        self.stats['total_executed'] += 1
        
        try:
            # å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            executor_type = self.determine_executor_type(task)
            
            logger.info("=" * 60)
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘: {task_id}")
            logger.info(f"å®Ÿè¡Œã‚¿ã‚¤ãƒ—: {executor_type.upper()}")
            logger.info("=" * 60)
            
            result = None
            
            # ========================================
            # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆæ–°è¦è¿½åŠ ï¼‰
            # ========================================
            if executor_type == 'review':
                logger.info("ğŸ” ReviewAgent ã§å®Ÿè¡Œ")
                
                # TaskExecutorçµŒç”±ã§review_agentã‚’å®Ÿè¡Œ
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'review',
                    'message': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œå®Œäº†' if success else 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œå¤±æ•—'
                }
            # ========================================
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
            elif executor_type == 'workflow' and self.workflow_executor:
                logger.info("ğŸ”„ WorkflowExecutor ã§å®Ÿè¡Œ")
                self.stats['workflow_tasks'] += 1
                result = await self.workflow_executor.execute_workflow_task(task)
            
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå®Ÿè¡Œ
            elif executor_type == 'content' and self.content_executor:
                logger.info("âœï¸ ContentTaskExecutor ã§å®Ÿè¡Œ")
                self.stats['content_tasks'] += 1
                result = await self.content_executor.execute_content_task(task)
            
            # CLIã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
            elif executor_type == 'cli' and self.cli_executor:
                logger.info("âš™ï¸ SystemCLIExecutor ã§å®Ÿè¡Œ")
                self.stats['cli_tasks'] += 1
                result = await self.cli_executor.execute_cli_task(task)
            
            # æ—¢å­˜å®Ÿè£…ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            else:
                logger.info("ğŸ”™ æ—¢å­˜ TaskExecutor ã§å®Ÿè¡Œï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰")
                self.stats['fallback_tasks'] += 1
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'fallback',
                    'message': 'æ—¢å­˜å®Ÿè£…ã§å®Ÿè¡Œå®Œäº†'
                }
            
            # çµ±è¨ˆæ›´æ–°
            if result and result.get('success'):
                self.stats['success'] += 1
            else:
                self.stats['failed'] += 1
            
            # å®Ÿè¡Œæƒ…å ±ã‚’çµæœã«è¿½åŠ 
            if result:
                result['executor_type'] = executor_type
                result['coordinated_execution'] = True
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª¿æ•´ã‚¨ãƒ©ãƒ¼: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª¿æ•´ã‚¨ãƒ©ãƒ¼: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
    
    async def run_all_tasks_coordinated(
        self,
        auto_continue: bool = False,
        enable_review: bool = True
    ):
        """
        å…¨ã‚¿ã‚¹ã‚¯ã‚’èª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼çµŒç”±ã§å®Ÿè¡Œ
        
        Args:
            auto_continue: è‡ªå‹•ç¶™ç¶šãƒ•ãƒ©ã‚°
            enable_review: ãƒ¬ãƒ“ãƒ¥ãƒ¼æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°
        """
        logger.info("\n" + "=" * 60)
        logger.info("ğŸš€ ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œé–‹å§‹")
        logger.info("=" * 60)
        
        try:
            iteration = 0
            max_iterations = self.task_executor.max_iterations
            
            while iteration < max_iterations:
                iteration += 1
                
                logger.info(f"\n{'=' * 60}")
                logger.info(f"åå¾© {iteration}/{max_iterations}")
                logger.info(f"{'=' * 60}")
                
                # ä¿ç•™ä¸­ã‚¿ã‚¹ã‚¯ã®èª­ã¿è¾¼ã¿
                pending_tasks = await self.task_executor.load_pending_tasks()
                
                if not pending_tasks:
                    logger.info("âœ… å…¨ã‚¿ã‚¹ã‚¯å®Œäº†ã¾ãŸã¯ä¿ç•™ã‚¿ã‚¹ã‚¯ãªã—")
                    break
                
                logger.info(f"ğŸ“‹ å®Ÿè¡Œäºˆå®šã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
                
                # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ«ãƒ¼ãƒ—
                for task in pending_tasks:
                    task_id = task.get('task_id', 'UNKNOWN')
                    
                    try:
                        logger.info(f"\n{'â”€' * 60}")
                        logger.info(f"ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_id}")
                        logger.info(f"{'â”€' * 60}")
                        
                        # èª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼çµŒç”±ã§å®Ÿè¡Œ
                        result = await self.execute_task_coordinated(task)
                        
                        if result and result.get('success'):
                            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ")
                        else:
                            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•—")
                        
                        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªï¼ˆè‡ªå‹•ç¶™ç¶šã§ãªã„å ´åˆï¼‰
                        if not auto_continue:
                            continue_task = input(
                                f"\næ¬¡ã®ã‚¿ã‚¹ã‚¯ã«é€²ã¿ã¾ã™ã‹? "
                                f"(y/n/a=ä»¥é™å…¨ã¦å®Ÿè¡Œ): "
                            ).lower()
                            
                            if continue_task == 'n':
                                logger.info("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                                return
                            elif continue_task == 'a':
                                auto_continue = True
                                logger.info("è‡ªå‹•å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ")
                        
                        await asyncio.sleep(2)
                        
                    except KeyboardInterrupt:
                        logger.warning("â¸ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                        raise
                    
                    except Exception as e:
                        logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼")
                        ErrorHandler.log_error(e, f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­")
                        
                        if not auto_continue:
                            cont = input(
                                f"\nâš ï¸ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç¶šè¡Œã—ã¾ã™ã‹? (y/n): "
                            ).lower()
                            if cont != 'y':
                                logger.info("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                                break
            
            # æœ€çµ‚çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆ
            self._print_coordination_report()
            
        except KeyboardInterrupt:
            logger.warning("\nâ¸ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
            self._print_coordination_report()
            raise
        
        except Exception as e:
            logger.error("âŒ ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œå…¨ä½“ã§é‡å¤§ã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, "TaskCoordinator.run_all_tasks_coordinated")
            self._print_coordination_report()
            raise
    
    def _print_coordination_report(self):
        """ã‚¿ã‚¹ã‚¯èª¿æ•´ã®çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆã‚’å‡ºåŠ›"""
        logger.info("\n" + "=" * 60)
        logger.info("ğŸ“Š ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œãƒ¬ãƒãƒ¼ãƒˆ")
        logger.info("=" * 60)
        logger.info(f"ç·å®Ÿè¡Œæ•°: {self.stats['total_executed']}")
        logger.info(f"  - ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯: {self.stats['content_tasks']}")
        logger.info(f"  - CLIã‚¿ã‚¹ã‚¯: {self.stats['cli_tasks']}")
        logger.info(f"  - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯: {self.stats['workflow_tasks']}")
        logger.info(f"  - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: {self.stats['fallback_tasks']}")
        logger.info(f"æˆåŠŸ: {self.stats['success']}")
        logger.info(f"å¤±æ•—: {self.stats['failed']}")
        logger.info("=" * 60)
        
        # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        print("\n" + "=" * 60)
        print("ğŸ“Š ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œãƒ¬ãƒãƒ¼ãƒˆ")
        print("=" * 60)
        print(f"ç·å®Ÿè¡Œæ•°: {self.stats['total_executed']}")
        print(f"  - ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯: {self.stats['content_tasks']}")
        print(f"  - CLIã‚¿ã‚¹ã‚¯: {self.stats['cli_tasks']}")
        print(f"  - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯: {self.stats['workflow_tasks']}")
        print(f"  - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: {self.stats['fallback_tasks']}")
        print(f"æˆåŠŸ: {self.stats['success']}")
        print(f"å¤±æ•—: {self.stats['failed']}")
        print("=" * 60 + "\n")
    
    def get_stats(self) -> Dict:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        return self.stats.copy()

#task_executor - ã‚³ãƒ”ãƒ¼.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
from config_utils import ErrorHandler, config

# ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====
from sheets_manager import GoogleSheetsManager

# ===== ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("âš ï¸ error_handler_enhancedæœªæ¤œå‡ºï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")

# ===== åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPressé€£æºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼(ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆ)"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            sheets_manager: GoogleSheetsManager ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
            max_iterations: æœ€å¤§åå¾©å›æ•°
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: æœ€å¤§åå¾©å›æ•° = {self.max_iterations}")
        
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’è‡ªå‹•åˆæœŸåŒ–
        self._initialize_agents()
        
        # === åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ– ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # è¨˜äº‹ç”Ÿæˆå°‚ç”¨ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
                
                # M&Aå°‚ç”¨ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("âœ… MATaskExecutor åˆæœŸåŒ–å®Œäº†")
                
                logger.info("="*60)
                logger.info("åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–å®Œäº†")
                logger.info("  - ContentTaskExecutor (è¨˜äº‹ç”Ÿæˆå°‚ç”¨)")
                logger.info("  - MATaskExecutor (M&A/ä¼æ¥­æ¤œç´¢å°‚ç”¨)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"âš ï¸ åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–å¤±æ•—: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("âš ï¸ åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.content_executor = None
            self.ma_executor = None
        
        # === WordPressé–‹ç™ºå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ– ===
        logger.info("\n" + "="*60)
        logger.info("ğŸ”§ WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        logger.info("="*60)
        
        # WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_dev) ã®åˆæœŸåŒ–
        self.wp_dev_agent = None
        try:
            from wordpress.wp_dev import WordPressDevAgent
            
            if self.browser:
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_dev'] = self.wp_dev_agent
                logger.info("âœ… WordPressDevAgent (wp_dev) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æœªåˆæœŸåŒ–ã®ãŸã‚ wp_dev ã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ wordpress/wp_dev.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã¯æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ wp_dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        # WordPressè¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_design) ã®åˆæœŸåŒ–
        self.wp_design_agent = None
        try:
            from wordpress.wp_design import WordPressDesignAgent
            
            if self.browser:
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_design'] = self.wp_design_agent
                logger.info("âœ… WordPressDesignAgent (wp_design) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æœªåˆæœŸåŒ–ã®ãŸã‚ wp_design ã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ wordpress/wp_design.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯ã¯æ¨™æº– design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ wp_design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        logger.info("="*60)
        logger.info("WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        if self.wp_dev_agent:
            logger.info("  - WordPressDevAgent (ã‚«ã‚¹ã‚¿ãƒ é–‹ç™º)")
        if self.wp_design_agent:
            logger.info("  - WordPressDesignAgent (ãƒ†ãƒ¼ãƒ/CSS)")
        logger.info("="*60)

        # ========================================
        # ğŸ“¦ æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆï¼ˆ__init__ãƒ¡ã‚½ãƒƒãƒ‰å†…ã«è¿½åŠ ï¼‰
        # ========================================

        logger.info("\n" + "="*60)
        logger.info("ğŸ“¦ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆãƒã‚§ãƒƒã‚¯")
        logger.info("="*60)

        # task_executor.tas__init__ ã‹ã‚‰æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        try:
            from task_executor.tas__init__ import (
                TaskCoordinator,
                ContentTaskExecutor as NewContentExecutor,
                SystemCLIExecutor,
                WorkflowExecutor,
                HAS_COORDINATOR,
                HAS_CONTENT_EXECUTOR,
                HAS_CLI_EXECUTOR,
                HAS_WORKFLOW_EXECUTOR,
                print_module_status
            )
            
            # TaskCoordinator ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_COORDINATOR:
                try:
                    logger.info("âœ… TaskCoordinator åˆ©ç”¨å¯èƒ½")
                    self._has_coordinator = True
                except Exception as e:
                    logger.warning(f"âš ï¸ TaskCoordinator åˆæœŸåŒ–ã‚¹ã‚­ãƒƒãƒ—: {e}")
                    self._has_coordinator = False
            else:
                logger.info("â„¹ï¸ TaskCoordinator ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")
                self._has_coordinator = False
            
            # æ–°è¦ ContentTaskExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_CONTENT_EXECUTOR and NewContentExecutor:
                try:
                    self.new_content_executor = NewContentExecutor(
                        browser_controller=self.browser,
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("âœ… æ–°è¦ ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ æ–°è¦ ContentTaskExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.new_content_executor = None
            else:
                logger.info("â„¹ï¸ æ–°è¦ ContentTaskExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.new_content_executor = None
            
            # SystemCLIExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_CLI_EXECUTOR and SystemCLIExecutor:
                try:
                    self.cli_executor = SystemCLIExecutor(
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ SystemCLIExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.cli_executor = None
            else:
                logger.info("â„¹ï¸ SystemCLIExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.cli_executor = None
            
            # WorkflowExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
                try:
                    self.workflow_executor = WorkflowExecutor(
                        task_executor=self,
                        sheets_manager=self.sheets_manager,
                        browser_controller=self.browser
                    )
                    logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ WorkflowExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.workflow_executor = None
            else:
                logger.info("â„¹ï¸ WorkflowExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.workflow_executor = None
            
            logger.info("="*60)
            logger.info("æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆå®Œäº†")
            logger.info("="*60)

        except ImportError as e:
            logger.info("="*60)
            logger.info("â„¹ï¸ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æœªé…ç½®ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã®ã¿ä½¿ç”¨ï¼‰")
            logger.info(f"è©³ç´°: {e}")
            logger.info("="*60)
            self._has_coordinator = False
            self.new_content_executor = None
            self.cli_executor = None
            self.workflow_executor = None

    def _initialize_agents(self):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è‡ªå‹•åˆæœŸåŒ–"""
        logger.info("ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å¤–éƒ¨ã‹ã‚‰ register_agent() ã§ç™»éŒ²ã•ã‚Œã‚‹
        logger.info("ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")

    def register_agent(self, role: str, agent):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.agents[role] = agent
        logger.info(f"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

    def register_review_agent(self, review_agent):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.review_agent = review_agent
        logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
    
    def register_review_agent(self, review_agent):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.review_agent = review_agent
        logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

    async def execute_task_with_extensions(self, task: Dict) -> bool:
        """
        æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ãŸã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
        
        æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯å„ªå…ˆçš„ã«ä½¿ç”¨ã—ã€
        ãã†ã§ãªã‘ã‚Œã°æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            # CLIã‚¿ã‚¹ã‚¯åˆ¤å®š
            if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ']):
                logger.info(f"ğŸ”§ SystemCLIExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
                result = await self.cli_executor.execute_cli_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯åˆ¤å®š
            if self.workflow_executor and any(kw in description for kw in ['å¤šè¨€èª', 'ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£', 'ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—']):
                logger.info(f"ğŸ”„ WorkflowExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
                result = await self.workflow_executor.execute_workflow_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            logger.info(f"ğŸ”™ æ—¢å­˜å®Ÿè£…ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
            return await self.execute_task(task)
        
        except Exception as e:
            logger.error(f"âŒ æ‹¡å¼µå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
            # ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return await self.execute_task(task)

    async def load_pending_tasks(self) -> List[Dict]:
        """ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info("ğŸ“‹ ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("ğŸ“­ pm_tasksã‚·ãƒ¼ãƒˆã«ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                return []
            
            # statusãŒ'pending'ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"ğŸ“Š ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
            
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... ä»– {len(pending_tasks)-3}ä»¶")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return []

    async def update_task_status(self, task: Dict, status: str, error_message: str = None) -> bool:
        """ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ï¼ˆéåŒæœŸã‚¨ãƒ©ãƒ¼ä¿®æ­£ç‰ˆï¼‰"""
        try:
            task_id = task.get('task_id')
            
            if error_message:
                logger.info(f"ã‚¿ã‚¹ã‚¯ {task_id} ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°: {status} - ã‚¨ãƒ©ãƒ¼: {error_message}")
            else:
                logger.info(f"ã‚¿ã‚¹ã‚¯ {task_id} ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°: {status}")
            
            # éåŒæœŸé–¢æ•°ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦é©åˆ‡ã«å‘¼ã³å‡ºã™
            update_method = self.sheets_manager.update_task_status
            
            import inspect
            if inspect.iscoroutinefunction(update_method):
                result = await update_method(task_id, status)
            else:
                result = update_method(task_id, status)
            
            if result is None:
                logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã®çµæœãŒNoneã§ã™ - ã‚¿ã‚¹ã‚¯ {task_id}")
                return True
                
            return bool(result)
            
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å¤±æ•—ï¼ˆç¶šè¡Œï¼‰: {e}")
            return False

# ========================================
# ğŸ¯ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆè¿½åŠ éƒ¨åˆ†ï¼‰
# ========================================


async def run_all_tasks(self) -> Dict[str, Any]:
    """
    å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆï¼‰
        
    ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—ã—ã€
    é †æ¬¡å®Ÿè¡Œã—ã¦ã„ãã¾ã™ã€‚
        
    Returns:
        Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
            {
                'total': ç·ã‚¿ã‚¹ã‚¯æ•°,
                'success': æˆåŠŸæ•°,
                'failed': å¤±æ•—æ•°,
                'skipped': ã‚¹ã‚­ãƒƒãƒ—æ•°,
                'results': å„ã‚¿ã‚¹ã‚¯ã®çµæœãƒªã‚¹ãƒˆ
            }
    """
    logger.info("\n" + "="*80)
    logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
    logger.info("="*80 + "\n")
        
    # å®Ÿè¡Œçµæœã‚’æ ¼ç´
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'skipped': 0,
        'results': [],
        'start_time': datetime.now(),
        'end_time': None
    }
        
    try:
        # 1. ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        logger.info("ğŸ“‹ ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
        pending_tasks = await self.load_pending_tasks()
            
        if not pending_tasks:
            logger.info("ğŸ“­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            logger.info("ğŸ’¡ ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã® 'pm_tasks' ã‚·ãƒ¼ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            logger.info("   - ã‚¿ã‚¹ã‚¯ãŒå­˜åœ¨ã™ã‚‹ã‹")
            logger.info("   - statusåˆ—ãŒ 'pending' ã«ãªã£ã¦ã„ã‚‹ã‹")
            summary['end_time'] = datetime.now()
            return summary
            
        summary['total'] = len(pending_tasks)
        logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            
        # ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’è¡¨ç¤º
        logger.info(f"ğŸ‘¥ ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {list(self.agents.keys())}")
        logger.info("")
            
        # 2. å„ã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡å®Ÿè¡Œ
        for index, task in enumerate(pending_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
                
            # åå¾©å›æ•°ãƒã‚§ãƒƒã‚¯
            self.current_iteration += 1
            if self.current_iteration > self.max_iterations:
                logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•° ({self.max_iterations}) ã«åˆ°é”")
                logger.warning(f"æ®‹ã‚Š {summary['total'] - index + 1} ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                summary['skipped'] = summary['total'] - index + 1
                break
                
            logger.info(f"\n{'â”€'*80}")
            logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
            logger.info(f"{'â”€'*80}")
                
            try:
                # æ‹¡å¼µæ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
                if hasattr(self, 'execute_task_with_extensions'):
                    success = await self.execute_task_with_extensions(task)
                else:
                    # æ‹¡å¼µæ©Ÿèƒ½ãŒãªã„å ´åˆã¯æ¨™æº–ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
                    success = await self.execute_task(task)
                    
                # çµæœã‚’è¨˜éŒ²
                task_result = {
                    'task_id': task_id,
                    'success': success,
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                if success:
                    summary['success'] += 1
                    logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                else:
                    summary['failed'] += 1
                    logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                    
                # ã‚¿ã‚¹ã‚¯é–“ã«å°‘ã—å¾…æ©Ÿï¼ˆè² è·è»½æ¸›ï¼‰
                await asyncio.sleep(1)
                    
            except Exception as e:
                summary['failed'] += 1
                error_msg = f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­ã®ã‚¨ãƒ©ãƒ¼: {str(e)}"
                logger.error(f"âŒ {error_msg}")
                ErrorHandler.log_error(e, f"run_all_tasks - task {task_id}")
                    
                # ã‚¨ãƒ©ãƒ¼ã§ã‚‚ã‚¿ã‚¹ã‚¯çµæœã‚’è¨˜éŒ²
                task_result = {
                    'task_id': task_id,
                    'success': False,
                    'error': str(e),
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                # ç¶™ç¶šã™ã‚‹ã‹åˆ¤æ–­ï¼ˆé‡å¤§ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ä¸­æ–­ï¼‰
                if "critical" in str(e).lower():
                    logger.error("ğŸš¨ é‡å¤§ã‚¨ãƒ©ãƒ¼ã®ãŸã‚å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã™")
                    summary['skipped'] = summary['total'] - index
                    break
            
        # 3. å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼ã‚’è¡¨ç¤º
        summary['end_time'] = datetime.now()
        elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
        logger.info("\n" + "="*80)
        logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº† - å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼")
        logger.info("="*80)
        logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
        logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
        logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
        logger.info(f"  â­ï¸  ã‚¹ã‚­ãƒƒãƒ—:  {summary['skipped']:>3}ä»¶")
        logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
        logger.info("="*80 + "\n")
            
        # æˆåŠŸç‡ã‚’è¨ˆç®—
        if summary['total'] > 0:
            success_rate = (summary['success'] / summary['total']) * 100
            logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
                
            if success_rate >= 80:
                logger.info("ğŸ‰ è‰¯å¥½ãªå®Ÿè¡Œçµæœã§ã™ï¼")
            elif success_rate >= 50:
                logger.info("âš ï¸ ã„ãã¤ã‹ã®ã‚¿ã‚¹ã‚¯ã§å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã™")
            else:
                logger.warning("ğŸš¨ å¤šãã®ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—ã—ã¦ã„ã¾ã™ã€‚è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            
        return summary
            
    except Exception as e:
        logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã«äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, "run_all_tasks")
        summary['end_time'] = datetime.now()
        return summary
        
    finally:
        # æœ€çµ‚çš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
        logger.info("\nğŸ§¹ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå¾Œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—...")
        self.current_iteration = 0  # åå¾©ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        logger.info("âœ… ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†\n")

async def run_tasks_by_agent(self, agent_role: str) -> Dict[str, Any]:
    """
    ç‰¹å®šã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ‹…å½“ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’å®Ÿè¡Œ
        
    Args:
        agent_role: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«åï¼ˆä¾‹: 'dev', 'design', 'review'ï¼‰
            
    Returns:
        Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
    """
    logger.info(f"\nğŸ¯ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_role}' ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™\n")
        
    summary = {
        'agent': agent_role,
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # å…¨ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        all_tasks = await self.load_pending_tasks()
            
        # æŒ‡å®šã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ‹…å½“ã®ã‚¿ã‚¹ã‚¯ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿
        agent_tasks = [
            task for task in all_tasks 
            if task.get('required_role', task.get('assigned_to', '')).lower() == agent_role.lower()
        ]
            
        if not agent_tasks:
            logger.info(f"ğŸ“­ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_role}' ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            return summary
            
        summary['total'] = len(agent_tasks)
        logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡: {summary['total']}ä»¶\n")
            
        # ã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡å®Ÿè¡Œ
        for index, task in enumerate(agent_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
            logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                
            if hasattr(self, 'execute_task_with_extensions'):
                success = await self.execute_task_with_extensions(task)
            else:
                success = await self.execute_task(task)
                
            task_result = {
                'task_id': task_id,
                'success': success
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
            else:
                summary['failed'] += 1
                
            await asyncio.sleep(1)
            
        logger.info(f"\nâœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_role}' ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
        logger.info(f"æˆåŠŸ: {summary['success']}/{summary['total']}\n")
            
        return summary
            
    except Exception as e:
        logger.error(f"âŒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, f"run_tasks_by_agent({agent_role})")
        return summary

async def retry_failed_tasks(self, max_retries: int = 3) -> Dict[str, Any]:
    """
    å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯ã‚’å†è©¦è¡Œ
        
    Args:
        max_retries: æœ€å¤§å†è©¦è¡Œå›æ•°
            
    Returns:
        Dict: å†è©¦è¡Œçµæœã‚µãƒãƒªãƒ¼
    """
    logger.info(f"\nğŸ”„ å¤±æ•—ã‚¿ã‚¹ã‚¯ã®å†è©¦è¡Œã‚’é–‹å§‹ï¼ˆæœ€å¤§{max_retries}å›ï¼‰\n")
        
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # å¤±æ•—ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        all_tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
        failed_tasks = [
            task for task in all_tasks 
            if task.get('status', '').lower() == 'failed'
        ]
            
        if not failed_tasks:
            logger.info("ğŸ“­ å†è©¦è¡Œã™ã¹ãå¤±æ•—ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            return summary
            
        summary['total'] = len(failed_tasks)
        logger.info(f"ğŸ“Š å†è©¦è¡Œå¯¾è±¡: {summary['total']}ä»¶\n")
            
        for task in failed_tasks:
            task_id = task.get('task_id', 'UNKNOWN')
            retry_count = 0
            success = False
                
            while retry_count < max_retries and not success:
                retry_count += 1
                logger.info(f"ğŸ”„ ã‚¿ã‚¹ã‚¯ {task_id} - å†è©¦è¡Œ {retry_count}/{max_retries}")
                    
                if hasattr(self, 'execute_task_with_extensions'):
                    success = await self.execute_task_with_extensions(task)
                else:
                    success = await self.execute_task(task)
                    
                if not success and retry_count < max_retries:
                    wait_time = retry_count * 2  # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                    logger.info(f"â³ {wait_time}ç§’å¾…æ©Ÿã—ã¦ã‹ã‚‰å†è©¦è¡Œ...")
                    await asyncio.sleep(wait_time)
                
            task_result = {
                'task_id': task_id,
                'success': success,
                'retries': retry_count
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} å†è©¦è¡ŒæˆåŠŸ")
            else:
                summary['failed'] += 1
                logger.warning(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} {max_retries}å›ã®å†è©¦è¡Œå¾Œã‚‚å¤±æ•—")
            
        logger.info(f"\nğŸ“Š å†è©¦è¡Œå®Œäº†: æˆåŠŸ {summary['success']}/{summary['total']}\n")
        return summary
            
    except Exception as e:
        logger.error(f"âŒ å†è©¦è¡Œå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, "retry_failed_tasks")
        return summary

async def execute_task(self, task: Dict) -> bool:
    """
    å€‹åˆ¥ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆï¼‰
        
    Args:
        task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
    Returns:
        bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
    """
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '')
    assigned_to = task.get('assigned_to', '')
        
    try:
        logger.info(f"\n{'='*60}")
        logger.info(f"ğŸ¯ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
        logger.info(f"ğŸ“ å†…å®¹: {description}")
        logger.info(f"ğŸ‘¤ æ‹…å½“: {assigned_to}")
        logger.info(f"{'='*60}\n")
            
        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’'in_progress'ã«æ›´æ–°
        await self.update_task_status(task, 'in_progress')
            
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        if assigned_to not in self.agents:
            error_msg = f"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{assigned_to}' ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“"
            logger.error(f"âŒ {error_msg}")
            await self.update_task_status(task, 'failed', error_msg)
            return False
            
        # æ‹…å½“ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å–å¾—
        agent = self.agents[assigned_to]
            
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã•ã›ã‚‹
        result = await agent.execute(task)
            
        # çµæœã‚’åˆ¤å®š
        if result and result.get('success'):
            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} å®Œäº†")
            await self.update_task_status(task, 'completed')
            return True
        else:
            error_msg = result.get('error', 'å®Ÿè¡Œå¤±æ•—') if result else 'å®Ÿè¡Œå¤±æ•—'
            logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•—: {error_msg}")
            await self.update_task_status(task, 'failed', error_msg)
            return False
                
    except Exception as e:
        error_msg = f"ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼: {str(e)}"
        logger.error(f"âŒ {error_msg}")
        ErrorHandler.log_error(e, f"execute_task({task_id})")
        await self.update_task_status(task, 'failed', error_msg)
        return False

async def run_all_tasks(self) -> Dict[str, Any]:
    """
    å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆï¼‰
        
    ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—ã—ã€
    é †æ¬¡å®Ÿè¡Œã—ã¦ã„ãã¾ã™ã€‚
        
    Returns:
        Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
            {
                'total': ç·ã‚¿ã‚¹ã‚¯æ•°,
                'success': æˆåŠŸæ•°,
                'failed': å¤±æ•—æ•°,
                'skipped': ã‚¹ã‚­ãƒƒãƒ—æ•°,
                'results': å„ã‚¿ã‚¹ã‚¯ã®çµæœãƒªã‚¹ãƒˆ
            }
    """
    logger.info("\n" + "="*80)
    logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
    logger.info("="*80 + "\n")
        
    # å®Ÿè¡Œçµæœã‚’æ ¼ç´
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'skipped': 0,
        'results': [],
        'start_time': datetime.now(),
        'end_time': None
    }
        
    try:
        # 1. ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        pending_tasks = await self.load_pending_tasks()
            
        if not pending_tasks:
            logger.info("ğŸ“­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            summary['end_time'] = datetime.now()
            return summary
            
        summary['total'] = len(pending_tasks)
        logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            
        # 2. å„ã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡å®Ÿè¡Œ
        for index, task in enumerate(pending_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
                
            # åå¾©å›æ•°ãƒã‚§ãƒƒã‚¯
            self.current_iteration += 1
            if self.current_iteration > self.max_iterations:
                logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•° ({self.max_iterations}) ã«åˆ°é”")
                logger.warning(f"æ®‹ã‚Š {summary['total'] - index + 1} ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                summary['skipped'] = summary['total'] - index + 1
                break
                
            logger.info(f"\n{'â”€'*80}")
            logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
            logger.info(f"{'â”€'*80}")
                
            try:
                # æ‹¡å¼µæ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
                success = await self.execute_task_with_extensions(task)
                    
                # çµæœã‚’è¨˜éŒ²
                task_result = {
                    'task_id': task_id,
                    'success': success,
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                if success:
                    summary['success'] += 1
                    logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                else:
                    summary['failed'] += 1
                    logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                    
                # ã‚¿ã‚¹ã‚¯é–“ã«å°‘ã—å¾…æ©Ÿï¼ˆè² è·è»½æ¸›ï¼‰
                await asyncio.sleep(1)
                    
            except Exception as e:
                summary['failed'] += 1
                error_msg = f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­ã®ã‚¨ãƒ©ãƒ¼: {str(e)}"
                logger.error(f"âŒ {error_msg}")
                ErrorHandler.log_error(e, f"run_all_tasks - task {task_id}")
                    
                # ã‚¨ãƒ©ãƒ¼ã§ã‚‚ã‚¿ã‚¹ã‚¯çµæœã‚’è¨˜éŒ²
                task_result = {
                    'task_id': task_id,
                    'success': False,
                    'error': str(e),
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                # ç¶™ç¶šã™ã‚‹ã‹åˆ¤æ–­ï¼ˆé‡å¤§ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ä¸­æ–­ï¼‰
                if "critical" in str(e).lower():
                    logger.error("ğŸš¨ é‡å¤§ã‚¨ãƒ©ãƒ¼ã®ãŸã‚å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã™")
                    summary['skipped'] = summary['total'] - index
                    break
            
        # 3. å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼ã‚’è¡¨ç¤º
        summary['end_time'] = datetime.now()
        elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
        logger.info("\n" + "="*80)
        logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº† - å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼")
        logger.info("="*80)
        logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
        logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
        logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
        logger.info(f"  â­ï¸  ã‚¹ã‚­ãƒƒãƒ—:  {summary['skipped']:>3}ä»¶")
        logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
        logger.info("="*80 + "\n")
            
        # æˆåŠŸç‡ã‚’è¨ˆç®—
        if summary['total'] > 0:
            success_rate = (summary['success'] / summary['total']) * 100
            logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
                
            if success_rate >= 80:
                logger.info("ğŸ‰ è‰¯å¥½ãªå®Ÿè¡Œçµæœã§ã™ï¼")
            elif success_rate >= 50:
                logger.info("âš ï¸ ã„ãã¤ã‹ã®ã‚¿ã‚¹ã‚¯ã§å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã™")
            else:
                logger.warning("ğŸš¨ å¤šãã®ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—ã—ã¦ã„ã¾ã™ã€‚è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            
        return summary
            
    except Exception as e:
        logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã«äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, "run_all_tasks")
        summary['end_time'] = datetime.now()
        return summary
        
    finally:
        # æœ€çµ‚çš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
        logger.info("\nğŸ§¹ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå¾Œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—...")
        self.current_iteration = 0  # åå¾©ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
        logger.info("âœ… ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†\n")

async def run_tasks_by_agent(self, agent_role: str) -> Dict[str, Any]:
    """
    ç‰¹å®šã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ‹…å½“ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’å®Ÿè¡Œ
        
    Args:
        agent_role: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«åï¼ˆä¾‹: 'dev', 'design', 'review'ï¼‰
            
    Returns:
        Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
    """
    logger.info(f"\nğŸ¯ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_role}' ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™\n")
        
    summary = {
        'agent': agent_role,
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # å…¨ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        all_tasks = await self.load_pending_tasks()
            
        # æŒ‡å®šã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ‹…å½“ã®ã‚¿ã‚¹ã‚¯ã®ã¿ãƒ•ã‚£ãƒ«ã‚¿
        agent_tasks = [
            task for task in all_tasks 
            if task.get('assigned_to', '').lower() == agent_role.lower()
        ]
            
        if not agent_tasks:
            logger.info(f"ğŸ“­ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_role}' ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            return summary
            
        summary['total'] = len(agent_tasks)
        logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡: {summary['total']}ä»¶\n")
            
        # ã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡å®Ÿè¡Œ
        for index, task in enumerate(agent_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
            logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                
            success = await self.execute_task_with_extensions(task)
                
            task_result = {
                'task_id': task_id,
                'success': success
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
            else:
                summary['failed'] += 1
                
            await asyncio.sleep(1)
            
        logger.info(f"\nâœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_role}' ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
        logger.info(f"æˆåŠŸ: {summary['success']}/{summary['total']}\n")
            
        return summary
            
    except Exception as e:
        logger.error(f"âŒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, f"run_tasks_by_agent({agent_role})")
        return summary

async def retry_failed_tasks(self, max_retries: int = 3) -> Dict[str, Any]:
    """
    å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯ã‚’å†è©¦è¡Œ
        
    Args:
        max_retries: æœ€å¤§å†è©¦è¡Œå›æ•°
            
    Returns:
        Dict: å†è©¦è¡Œçµæœã‚µãƒãƒªãƒ¼
    """
    logger.info(f"\nğŸ”„ å¤±æ•—ã‚¿ã‚¹ã‚¯ã®å†è©¦è¡Œã‚’é–‹å§‹ï¼ˆæœ€å¤§{max_retries}å›ï¼‰\n")
        
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'results': []
    }
        
    try:
        # å¤±æ•—ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        all_tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
        failed_tasks = [
            task for task in all_tasks 
            if task.get('status', '').lower() == 'failed'
        ]
            
        if not failed_tasks:
            logger.info("ğŸ“­ å†è©¦è¡Œã™ã¹ãå¤±æ•—ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            return summary
            
        summary['total'] = len(failed_tasks)
        logger.info(f"ğŸ“Š å†è©¦è¡Œå¯¾è±¡: {summary['total']}ä»¶\n")
            
        for task in failed_tasks:
            task_id = task.get('task_id', 'UNKNOWN')
            retry_count = 0
            success = False
                
            while retry_count < max_retries and not success:
                retry_count += 1
                logger.info(f"ğŸ”„ ã‚¿ã‚¹ã‚¯ {task_id} - å†è©¦è¡Œ {retry_count}/{max_retries}")
                    
                success = await self.execute_task_with_extensions(task)
                    
                if not success and retry_count < max_retries:
                    wait_time = retry_count * 2  # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                    logger.info(f"â³ {wait_time}ç§’å¾…æ©Ÿã—ã¦ã‹ã‚‰å†è©¦è¡Œ...")
                    await asyncio.sleep(wait_time)
                
            task_result = {
                'task_id': task_id,
                'success': success,
                'retries': retry_count
            }
            summary['results'].append(task_result)
                
            if success:
                summary['success'] += 1
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} å†è©¦è¡ŒæˆåŠŸ")
            else:
                summary['failed'] += 1
                logger.warning(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} {max_retries}å›ã®å†è©¦è¡Œå¾Œã‚‚å¤±æ•—")
            
        logger.info(f"\nğŸ“Š å†è©¦è¡Œå®Œäº†: æˆåŠŸ {summary['success']}/{summary['total']}\n")
        return summary
            
    except Exception as e:
        logger.error(f"âŒ å†è©¦è¡Œå‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, "retry_failed_tasks")
        return summary

# ========================================
# ğŸ“¦ æ‹¡å¼µå®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³è¿½åŠ ï¼‰
# ========================================

def execute_task_with_extensions(self, task: Dict) -> bool:
    """
    æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ãŸã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
    
    æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯å„ªå…ˆçš„ã«ä½¿ç”¨ã—ã€
    ãã†ã§ãªã‘ã‚Œã°æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    
    Args:
        task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
    Returns:
        bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
    """
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '').lower()
    
    try:
        # CLIã‚¿ã‚¹ã‚¯åˆ¤å®š
        if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ']):
            logger.info(f"ğŸ”§ SystemCLIExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
            import asyncio
            result = asyncio.run(self.cli_executor.execute_cli_task(task))
            return result.get('success', False) if isinstance(result, dict) else bool(result)
        
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯åˆ¤å®š
        if self.workflow_executor and any(kw in description for kw in ['å¤šè¨€èª', 'ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£', 'ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—']):
            logger.info(f"ğŸ”„ WorkflowExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
            import asyncio
            result = asyncio.run(self.workflow_executor.execute_workflow_task(task))
            return result.get('success', False) if isinstance(result, dict) else bool(result)
        
        # æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        logger.info(f"ğŸ”™ æ—¢å­˜å®Ÿè£…ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
        import asyncio
        return asyncio.run(self.execute_task(task))
    
    except Exception as e:
        logger.error(f"âŒ æ‹¡å¼µå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
        # ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        import asyncio
        return asyncio.run(self.execute_task(task))

# ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’TaskExecutorã‚¯ãƒ©ã‚¹ã«è¿½åŠ 
# TaskExecutor.execute_task_with_extensions = execute_task_with_extensions


# ========================================
# ä½¿ç”¨ä¾‹ï¼ˆmain.py ã‚„èµ·å‹•ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼‰
# ========================================

"""
# æ—¢å­˜ã®ä½¿ã„æ–¹ï¼ˆå¤‰æ›´ä¸è¦ï¼‰
executor = TaskExecutor(sheets_manager, browser_controller)
await executor.execute_task(task)

# æ‹¡å¼µæ©Ÿèƒ½ã‚’ä½¿ã†å ´åˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
if hasattr(executor, '_has_coordinator') and executor._has_coordinator:
    from task_executor.tas__init__ import TaskCoordinator
    
    coordinator = TaskCoordinator(
        task_executor=executor,
        sheets_manager=sheets_manager,
        browser_controller=browser_controller
    )
    
    await coordinator.run_all_tasks_coordinated()
else:
    # æ—¢å­˜å®Ÿè£…
    await executor.run_all_tasks()
"""
# ========================================
# ğŸš¨ ç·Šæ€¥ãƒ‘ãƒƒãƒ: run_all_tasks ã®è¿½åŠ 
# ========================================

# TaskExecutor ã‚¯ãƒ©ã‚¹ã®å®šç¾©ãŒçµ‚ã‚ã£ãŸå¾Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ«å°¾ã«ä»¥ä¸‹ã‚’è¿½åŠ 

def patch_task_executor():
    """TaskExecutor ã« run_all_tasks ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‹•çš„ã«è¿½åŠ """
    import inspect
    from datetime import datetime
    
    async def run_all_tasks(self) -> Dict[str, Any]:
        """å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œï¼ˆå‹•çš„ãƒ‘ãƒƒãƒç‰ˆï¼‰"""
        logger.info("\n" + "="*80)
        logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™ï¼ˆå‹•çš„ãƒ‘ãƒƒãƒç‰ˆï¼‰")
        logger.info("="*80 + "\n")
        
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
        
        try:
            # ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
            logger.info("ğŸ“‹ ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            
            # load_pending_tasks ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
            if hasattr(self, 'load_pending_tasks'):
                pending_tasks = await self.load_pending_tasks()
            else:
                logger.error("âŒ load_pending_tasks ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return summary
            
            if not pending_tasks:
                logger.info("ğŸ“­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                logger.info("ğŸ’¡ ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã® 'pm_tasks' ã‚·ãƒ¼ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                summary['end_time'] = datetime.now()
                return summary
            
            summary['total'] = len(pending_tasks)
            logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            
            # å„ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                logger.info(f"\n{'â”€'*80}")
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                logger.info(f"{'â”€'*80}")
                
                try:
                    # execute_task ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
                    if hasattr(self, 'execute_task'):
                        success = await self.execute_task(task)
                    elif hasattr(self, 'execute_task_with_extensions'):
                        success = await self.execute_task_with_extensions(task)
                    else:
                        logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                        success = False
                    
                    if success:
                        summary['success'] += 1
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•—")
                    
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¨ãƒ©ãƒ¼: {e}")
            
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
            logger.info("\n" + "="*80)
            logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            logger.info("="*80)
            logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
            logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
            logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
            logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
            logger.info("="*80 + "\n")
            
            return summary
            
        except Exception as e:
            logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            summary['end_time'] = datetime.now()
            return summary
    
    # TaskExecutor ã‚¯ãƒ©ã‚¹ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‹•çš„ã«è¿½åŠ 
    TaskExecutor.run_all_tasks = run_all_tasks
    logger.info("âœ… TaskExecutor ã« run_all_tasks ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‹•çš„ã«è¿½åŠ ã—ã¾ã—ãŸ")

# ãƒ‘ãƒƒãƒã‚’é©ç”¨
try:
    patch_task_executor()
except Exception as e:
    logger.error(f"âŒ ãƒ‘ãƒƒãƒé©ç”¨ã‚¨ãƒ©ãƒ¼: {e}")

#task_executor.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
from config_utils import ErrorHandler, config

# ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====
from sheets_manager import GoogleSheetsManager

# ===== ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("âš ï¸ error_handler_enhancedæœªæ¤œå‡ºï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")

# ===== åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPressé€£æºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼(ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆ)"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            sheets_manager: GoogleSheetsManager ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
            max_iterations: æœ€å¤§åå¾©å›æ•°
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: æœ€å¤§åå¾©å›æ•° = {self.max_iterations}")
        
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’è‡ªå‹•åˆæœŸåŒ–
        self._initialize_agents()
        
        # === åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ– ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # è¨˜äº‹ç”Ÿæˆå°‚ç”¨ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
                
                # M&Aå°‚ç”¨ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("âœ… MATaskExecutor åˆæœŸåŒ–å®Œäº†")
                
                logger.info("="*60)
                logger.info("åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–å®Œäº†")
                logger.info("  - ContentTaskExecutor (è¨˜äº‹ç”Ÿæˆå°‚ç”¨)")
                logger.info("  - MATaskExecutor (M&A/ä¼æ¥­æ¤œç´¢å°‚ç”¨)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"âš ï¸ åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–å¤±æ•—: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("âš ï¸ åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.content_executor = None
            self.ma_executor = None
        
        # === WordPressé–‹ç™ºå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ– ===
        logger.info("\n" + "="*60)
        logger.info("ğŸ”§ WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        logger.info("="*60)
        
        # WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_dev) ã®åˆæœŸåŒ–
        self.wp_dev_agent = None
        try:
            from wordpress.wp_dev import WordPressDevAgent
            
            if self.browser:
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_dev'] = self.wp_dev_agent
                logger.info("âœ… WordPressDevAgent (wp_dev) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æœªåˆæœŸåŒ–ã®ãŸã‚ wp_dev ã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ wordpress/wp_dev.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã¯æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ wp_dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        # WordPressè¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_design) ã®åˆæœŸåŒ–
        self.wp_design_agent = None
        try:
            from wordpress.wp_design import WordPressDesignAgent
            
            if self.browser:
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_design'] = self.wp_design_agent
                logger.info("âœ… WordPressDesignAgent (wp_design) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æœªåˆæœŸåŒ–ã®ãŸã‚ wp_design ã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ wordpress/wp_design.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯ã¯æ¨™æº– design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ wp_design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        logger.info("="*60)
        logger.info("WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        if self.wp_dev_agent:
            logger.info("  - WordPressDevAgent (ã‚«ã‚¹ã‚¿ãƒ é–‹ç™º)")
        if self.wp_design_agent:
            logger.info("  - WordPressDesignAgent (ãƒ†ãƒ¼ãƒ/CSS)")
        logger.info("="*60)
        

        # ========================================
        # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆæ–°è¦è¿½åŠ ï¼‰
        # ========================================
        
        logger.info("\n" + "="*60)
        logger.info("ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        logger.info("="*60)
        
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (review) ã®åˆæœŸåŒ–
        self.review_agent_instance = None
        try:
            from review_agent import ReviewAgent
            
            if self.browser:
                self.review_agent_instance = ReviewAgent(self.browser)
                if hasattr(self.review_agent_instance, 'sheets_manager'):
                    self.review_agent_instance.sheets_manager = self.sheets_manager
                
                self.agents['review'] = self.review_agent_instance
                logger.info("âœ… ReviewAgent (review) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©æœªåˆæœŸåŒ–ã®ãŸã‚ review ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ review_agent.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã¯æ¨™æº–å‡¦ç†ã§ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ review ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        logger.info("="*60)
        if self.review_agent_instance:
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
            logger.info("  - ReviewAgent (å“è³ªãƒã‚§ãƒƒã‚¯ãƒ»ä»•æ§˜ç¢ºèª)")
        else:
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
        logger.info("="*60)

        # ========================================
        # ğŸ“¦ æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆï¼ˆ__init__ãƒ¡ã‚½ãƒƒãƒ‰å†…ã«è¿½åŠ ï¼‰
        # ========================================

        logger.info("\n" + "="*60)
        logger.info("ğŸ“¦ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆãƒã‚§ãƒƒã‚¯")
        logger.info("="*60)

        # task_executor.tas__init__ ã‹ã‚‰æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        try:
            from task_executor.tas__init__ import (
                TaskCoordinator,
                ContentTaskExecutor as NewContentExecutor,
                SystemCLIExecutor,
                WorkflowExecutor,
                HAS_COORDINATOR,
                HAS_CONTENT_EXECUTOR,
                HAS_CLI_EXECUTOR,
                HAS_WORKFLOW_EXECUTOR,
                print_module_status
            )
            
            # TaskCoordinator ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_COORDINATOR:
                try:
                    logger.info("âœ… TaskCoordinator åˆ©ç”¨å¯èƒ½")
                    self._has_coordinator = True
                except Exception as e:
                    logger.warning(f"âš ï¸ TaskCoordinator åˆæœŸåŒ–ã‚¹ã‚­ãƒƒãƒ—: {e}")
                    self._has_coordinator = False
            else:
                logger.info("â„¹ï¸ TaskCoordinator ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")
                self._has_coordinator = False
            
            # æ–°è¦ ContentTaskExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_CONTENT_EXECUTOR and NewContentExecutor:
                try:
                    self.new_content_executor = NewContentExecutor(
                        browser_controller=self.browser,
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("âœ… æ–°è¦ ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ æ–°è¦ ContentTaskExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.new_content_executor = None
            else:
                logger.info("â„¹ï¸ æ–°è¦ ContentTaskExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.new_content_executor = None
            
            # SystemCLIExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_CLI_EXECUTOR and SystemCLIExecutor:
                try:
                    self.cli_executor = SystemCLIExecutor(
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ SystemCLIExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.cli_executor = None
            else:
                logger.info("â„¹ï¸ SystemCLIExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.cli_executor = None
            
            # WorkflowExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
                try:
                    self.workflow_executor = WorkflowExecutor(
                        task_executor=self,
                        sheets_manager=self.sheets_manager,
                        browser_controller=self.browser
                    )
                    logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ WorkflowExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.workflow_executor = None
            else:
                logger.info("â„¹ï¸ WorkflowExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.workflow_executor = None
            
            logger.info("="*60)
            logger.info("æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆå®Œäº†")
            logger.info("="*60)

        except ImportError as e:
            logger.info("="*60)
            logger.info("â„¹ï¸ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æœªé…ç½®ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã®ã¿ä½¿ç”¨ï¼‰")
            logger.info(f"è©³ç´°: {e}")
            logger.info("="*60)
            self._has_coordinator = False
            self.new_content_executor = None
            self.cli_executor = None
            self.workflow_executor = None

    def _initialize_agents(self):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è‡ªå‹•åˆæœŸåŒ–"""
        logger.info("ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å¤–éƒ¨ã‹ã‚‰ register_agent() ã§ç™»éŒ²ã•ã‚Œã‚‹
        logger.info("ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")

    def register_agent(self, role: str, agent):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.agents[role] = agent
        logger.info(f"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

    def register_review_agent(self, review_agent):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.review_agent = review_agent
        logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

    async def execute_task_with_extensions(self, task: Dict) -> bool:
        """
        æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ãŸã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
        
        æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯å„ªå…ˆçš„ã«ä½¿ç”¨ã—ã€
        ãã†ã§ãªã‘ã‚Œã°æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            # CLIã‚¿ã‚¹ã‚¯åˆ¤å®š
            if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ']):
                logger.info(f"ğŸ”§ SystemCLIExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
                result = await self.cli_executor.execute_cli_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯åˆ¤å®š
            if self.workflow_executor and any(kw in description for kw in ['å¤šè¨€èª', 'ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£', 'ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—']):
                logger.info(f"ğŸ”„ WorkflowExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
                result = await self.workflow_executor.execute_workflow_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            logger.info(f"ğŸ”™ æ—¢å­˜å®Ÿè£…ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
            return await self.execute_task(task)
        
        except Exception as e:
            logger.error(f"âŒ æ‹¡å¼µå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
            # ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return await self.execute_task(task)

    async def load_pending_tasks(self) -> List[Dict]:
        """ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info("ğŸ“‹ ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("ğŸ“­ pm_tasksã‚·ãƒ¼ãƒˆã«ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                return []
            
            # statusãŒ'pending'ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"ğŸ“Š ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
            
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... ä»– {len(pending_tasks)-3}ä»¶")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return []

    async def update_task_status(self, task: Dict, status: str, **kwargs):
        """
        ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ï¼ˆå¼•æ•°çµ±ä¸€ç‰ˆï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            status: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ('completed', 'failed', ãªã©)
            **kwargs: ãã®ä»–ã®å¼•æ•°ï¼ˆerrorãªã©ï¼‰
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å–å¾—
            error_msg = kwargs.get('error', '')
            
            logger.info(f"ğŸ’¬ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°: {status}")
            if error_msg:
                logger.info(f"   ã‚¨ãƒ©ãƒ¼: {error_msg}")
            
            # ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒã‚ã‚‹å ´åˆã®ã¿æ›´æ–°
            if self.sheets_manager:
                try:
                    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ã«æ›¸ãè¾¼ã¿
                    row = task.get('_row_index')
                    if row:
                        self.sheets_manager.ws.update_cell(row, 11, status)
                        
                        # ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚‹å ´åˆã¯ãƒ¡ãƒ¢åˆ—ã«æ›¸ãè¾¼ã¿
                        if error_msg and status == 'failed':
                            self.sheets_manager.ws.update_cell(row, 12, f"ã‚¨ãƒ©ãƒ¼: {error_msg}")
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚·ãƒ¼ãƒˆæ›´æ–°å¤±æ•—: {e}")
            
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    async def execute_task(self, task: Dict) -> bool:
        """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰"""
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            print(f"\n{'='*70}")
            print(f"ğŸ¯ ã‚¿ã‚¹ã‚¯: {task_id}")
            print(f"èª¬æ˜: {task.get('description', 'N/A')[:50]}...")
            print(f"{'='*70}\n")
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            await self.update_task_status(task, 'in_progress')
            
            role = task['required_role'].lower()
            
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
            task_timeout = 180.0
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—
            agent = self.agents.get(role)
            
            if not agent:
                logger.error(f"âŒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                await self.update_task_status(task, 'failed', error=f'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²: {role}')
                return False
            
            # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆexecute ã¾ãŸã¯ process_taskï¼‰
            result = None
            
            try:
                if hasattr(agent, 'execute'):
                    logger.info(f"å®Ÿè¡Œ: {role}.execute()")
                    result = await asyncio.wait_for(
                        agent.execute(task),
                        timeout=task_timeout
                    )
                elif hasattr(agent, 'process_task'):
                    logger.info(f"å®Ÿè¡Œ: {role}.process_task()")
                    result = await asyncio.wait_for(
                        agent.process_task(task),
                        timeout=task_timeout
                    )
                else:
                    logger.error(f"âŒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ã«execute/process_taskãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“")
                    await self.update_task_status(task, 'failed', error='ãƒ¡ã‚½ãƒƒãƒ‰ä¸åœ¨')
                    return False
                
            except asyncio.TimeoutError:
                logger.error(f"â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {task_id}")
                await self.update_task_status(task, 'failed', error='ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ')
                return False
            
            # çµæœåˆ¤å®š
            if result and result.get('success'):
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
                await self.update_task_status(task, 'completed')
                
                # çµæœä¿å­˜
                try:
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"âš ï¸ çµæœä¿å­˜å¤±æ•—: {e}")
                
                
                # ========================================
                # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯è‡ªå‹•ç”Ÿæˆï¼ˆæ–°è¦è¿½åŠ ï¼‰
                # ========================================
                try:
                    await self._generate_review_task_if_needed(task, result)
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
                # ========================================
                                
                return True
            else:
                error = result.get('error', 'ä¸æ˜') if result else 'çµæœãªã—'
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {error}")
                await self.update_task_status(task, 'failed', error=error)
                return False
        
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            try:
                await self.update_task_status(task, 'failed', error=str(e))
            except:
                pass
            
            return False
    
    def _determine_task_type_safe(self, task: Dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆã‚»ãƒ¼ãƒ•ç‰ˆï¼‰"""
        try:
            if HAS_TASK_ROUTER and task_router:
                return task_router.determine_task_type(task)
        except:
            pass
        
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆ¤å®š
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
        
        if any(kw in description for kw in ['è¦ä»¶å®šç¾©', 'requirements', 'wordpress']):
            return 'requirements'
        elif role in ['ma', 'content', 'review']:
            return role
        else:
            return 'default'
    
    async def _fallback_generic_task(self, task: Dict) -> Dict:
        """æ±ç”¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†"""
        logger.warning(f"âš ï¸ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸åœ¨ - æ±ç”¨å‡¦ç†")
        
        return {
            'success': True,
            'message': 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å®Œäº†',
            'summary': f'ã‚¿ã‚¹ã‚¯ {task.get("task_id")} ã‚’æ±ç”¨å‡¦ç†ã§å®Œäº†'
        }

    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œ"""
        logger.info("\n" + "="*80)
        logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
        logger.info("="*80 + "\n")
            
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
            
        try:
            logger.info("ğŸ“‹ ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            pending_tasks = await self.load_pending_tasks()
                
            if not pending_tasks:
                logger.info("ğŸ“­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                summary['end_time'] = datetime.now()
                return summary
                
            summary['total'] = len(pending_tasks)
            logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            logger.info(f"ğŸ‘¥ ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {list(self.agents.keys())}\n")
                
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                    
                self.current_iteration += 1
                if self.current_iteration > self.max_iterations:
                    logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•° ({self.max_iterations}) ã«åˆ°é”")
                    summary['skipped'] = summary['total'] - index + 1
                    break
                    
                logger.info(f"\n{'â”€'*80}")
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                logger.info(f"{'â”€'*80}")
                    
                try:
                    success = await self.execute_task(task)
                        
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                        
                    if success:
                        summary['success'] += 1
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                        
                    await asyncio.sleep(1)
                        
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¨ãƒ©ãƒ¼: {e}")
                
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
                
            logger.info("\n" + "="*80)
            logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            logger.info("="*80)
            logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
            logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
            logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
            logger.info(f"  â­ï¸  ã‚¹ã‚­ãƒƒãƒ—:  {summary['skipped']:>3}ä»¶")
            logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
            logger.info("="*80 + "\n")
                
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
                
            return summary
                
        except Exception as e:
            logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "run_all_tasks")
            summary['end_time'] = datetime.now()
            return summary
            
        finally:
            logger.info("\nğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—...")
            self.current_iteration = 0
            logger.info("âœ… å®Œäº†\n")
    
    async def _generate_review_task_if_needed(self, completed_task: Dict, result: Dict):
        """
        å®Œäº†ã‚¿ã‚¹ã‚¯ã«å¯¾ã—ã¦ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªå ´åˆã€è‡ªå‹•çš„ã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ
                
        Args:
            completed_task: å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯æƒ…å ±
            result: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œçµæœ
        """
        task_id = completed_task.get('task_id', 'UNKNOWN')
        role = completed_task.get('required_role', '').lower()
        description = completed_task.get('description', '').lower()
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        review_trigger_keywords = [
            'è¦ä»¶å®šç¾©', 'è©³ç´°è¨­è¨ˆ', 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—', 'acfè¨­è¨ˆ',
            'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ', 'ãƒ†ãƒ¼ãƒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º', 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™º',
            'requirements', 'design', 'template', 'custom post type'
        ]
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªãƒ­ãƒ¼ãƒ«
        review_trigger_roles = ['dev', 'wp_dev', 'design', 'wp_design']
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ç”Ÿæˆæ¡ä»¶ãƒã‚§ãƒƒã‚¯
        should_create_review = False
                
        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯
        if any(keyword in description for keyword in review_trigger_keywords):
            should_create_review = True
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {task_id} ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚“ã§ã„ã¾ã™")
                
        # ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯
        if role in review_trigger_roles:
            should_create_review = True
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {task_id} ã®ãƒ­ãƒ¼ãƒ« '{role}' ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã§ã™")
                
        # ã‚¿ã‚¹ã‚¯çµæœã«é‡è¦ãªã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆãŒã‚ã‚‹å ´åˆ
        if result.get('output_path') or result.get('created_files'):
            should_create_review = True
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {task_id} ã¯æˆæœç‰©ã‚’ç”Ÿæˆã—ã¾ã—ãŸ")
                
        if not should_create_review:
            logger.debug(f"ã‚¿ã‚¹ã‚¯ {task_id} ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸è¦ã¨åˆ¤æ–­")
            return
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®ç”Ÿæˆ
        try:
            logger.info(f"ğŸ” ã‚¿ã‚¹ã‚¯ {task_id} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆä¸­...")
                    
            # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®èª¬æ˜æ–‡ç”Ÿæˆ
            review_description = f"ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€‘ID:{task_id} ({completed_task.get('description', '')[:30]}...) ã®æˆæœç‰©ãƒ¬ãƒ“ãƒ¥ãƒ¼"
                    
            # æ–°ã—ã„ã‚¿ã‚¹ã‚¯IDã®ç”Ÿæˆ
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            review_task_id = f"REVIEW_{task_id}_{timestamp}"
                    
            # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿
            review_task_data = {
                'task_id': review_task_id,
                'description': review_description,
                'required_role': 'review',  # â† é‡è¦: ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æŒ‡å®š
                'status': 'pending',
                'priority': 'high',
                'parent_task_id': task_id,  # å…ƒã‚¿ã‚¹ã‚¯ã¸ã®å‚ç…§
                'target_output': result.get('output_path', ''),
                'created_at': timestamp
            }
                    
            # Google Sheetsã«è¿½åŠ 
            if self.sheets_manager:
                try:
                    # pm_tasksã‚·ãƒ¼ãƒˆã«æ–°è¦è¡Œã‚’è¿½åŠ 
                    new_row = [
                        review_task_id,
                        review_description,
                        'review',  # required_role
                        'high',    # priority
                        'pending', # status
                        '',        # assigned_to
                        '',        # started_at
                        '',        # completed_at
                        task_id,   # parent_task_id
                        result.get('output_path', ''),  # target_output
                        '',        # result
                        f'å…ƒã‚¿ã‚¹ã‚¯: {task_id}'  # memo
                    ]
                            
                    # ã‚·ãƒ¼ãƒˆã«è¿½åŠ 
                    ws = self.sheets_manager.ws
                    ws.append_row(new_row)
                            
                    logger.info(f"âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ {review_task_id} ã‚’ç”Ÿæˆã—ã¾ã—ãŸ")
                    logger.info(f"   å¯¾è±¡: {task_id}")
                    logger.info(f"   èª¬æ˜: {review_description}")
                            
                except Exception as e:
                    logger.error(f"âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®ã‚·ãƒ¼ãƒˆè¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            else:
                logger.warning("âš ï¸ sheets_manager ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
                        
        except Exception as e:
            logger.error(f"âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
    
    

#task_executor_content.py
"""
task_executor_content.py
è¨˜äº‹ç”Ÿæˆå°‚ç”¨ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
task_executor.pyã‹ã‚‰åˆ†é›¢
"""
import logging
from typing import Dict, List
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯å°‚ç”¨ã®å®Ÿè¡Œã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, agents: Dict):
        self.agents = agents
    
    async def execute_writer_task(self, task: Dict, role: str) -> Dict:
        """è¨€èªåˆ¥ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯æƒ…å ±ã®æŠ½å‡º ===
        task_language = task.get('language')
        polylang_lang = task.get('polylang_lang')
        
        # === ãƒ‘ãƒ¼ãƒˆ2: å®Ÿè¡Œé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
        logger.info("â”Œ" + "â”€"*58 + "â”")
        logger.info(f"â”‚ âœï¸ ãƒ©ã‚¤ã‚¿ãƒ¼AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­ ({role})")
        logger.info("â”œ" + "â”€"*58 + "â”¤")
        logger.info(f"â”‚ è¨€èª: {task_language}")
        logger.info(f"â”‚ Polylang: {polylang_lang}")
        logger.info("â””" + "â”€"*58 + "â”˜")
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é¸æŠã¨å®Ÿè¡Œ ===
        if role == 'writer' or role == 'content':
            # === ãƒ‘ãƒ¼ãƒˆ3-1: æ±ç”¨ãƒ©ã‚¤ã‚¿ãƒ¼ã®å‡¦ç† ===
            logger.info("ğŸ“ æ±ç”¨ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’ä½¿ç”¨(å¾Œæ–¹äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰)")
            agent = self.agents.get('writer')
            if not agent:
                logger.error("âŒ writerã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'writer ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            result = await agent.process_task(task)
        else:
            # === ãƒ‘ãƒ¼ãƒˆ3-2: è¨€èªåˆ¥ãƒ©ã‚¤ã‚¿ãƒ¼ã®å‡¦ç† ===
            agent = self.agents.get(role)
            if not agent:
                logger.error(f"âŒ {role}ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': f'æœªå¯¾å¿œã®è¨€èªãƒ©ã‚¤ã‚¿ãƒ¼: {role}'
                }
            
            # === ãƒ‘ãƒ¼ãƒˆ3-3: è¨€èªç¢ºèª ===
            if task_language and hasattr(agent, 'get_language_code'):
                if agent.get_language_code() != task_language:
                    logger.warning(f"âš ï¸ è¨€èªä¸ä¸€è‡´: ã‚¿ã‚¹ã‚¯={task_language}, ãƒ©ã‚¤ã‚¿ãƒ¼={agent.get_language_code()}")
            
            result = await agent.process_task(task)
        
        # === ãƒ‘ãƒ¼ãƒˆ4: çµæœã®å‡¦ç† ===
        if result.get('success'):
            logger.info(f"âœ… ãƒ©ã‚¤ã‚¿ãƒ¼AI ({role}): ã‚¿ã‚¹ã‚¯å®Œäº†")
            # è¨€èªæƒ…å ±ã‚’è¿½åŠ 
            if hasattr(agent, 'get_language_code'):
                result['language'] = agent.get_language_code()
                result['polylang_lang'] = polylang_lang or agent.get_language_code()
        else:
            logger.error(f"âŒ ãƒ©ã‚¤ã‚¿ãƒ¼AI ({role}): å¤±æ•— - {result.get('error', 'ä¸æ˜')}")
        
        return result
    
    def display_suggested_tasks(self, suggested_tasks: List[Dict]):
        """ææ¡ˆã‚¿ã‚¹ã‚¯ã®è©³ç´°ã‚’è¡¨ç¤º"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
        print("\n" + "="*60)
        print("ææ¡ˆã‚¿ã‚¹ã‚¯è©³ç´°")
        print("="*60)

        # === ãƒ‘ãƒ¼ãƒˆ2: å„ã‚¿ã‚¹ã‚¯ã®è©³ç´°è¡¨ç¤º ===
        for i, task in enumerate(suggested_tasks, 1):
            # === ãƒ‘ãƒ¼ãƒˆ2-1: å„ªå…ˆåº¦ãƒãƒ¼ã‚¯ã®è¨­å®š ===
            priority_mark = {
                'high': 'ğŸ”´[é«˜]',
                'medium': 'ğŸŸ¡[ä¸­]', 
                'low': 'ğŸŸ¢[ä½]'
            }.get(task.get('priority', 'medium'), 'âšª[ä¸­]')
        
            # === ãƒ‘ãƒ¼ãƒˆ2-2: å½¹å‰²ãƒ©ãƒ™ãƒ«ã®è¨­å®š ===
            role_label = {
                'design': 'ğŸ“[è¨­è¨ˆ]',
                'dev': 'ğŸ’»[é–‹ç™º]',
                'ui': 'ğŸ¨[UI]',
                'review': 'âœ…[ãƒ¬ãƒ“ãƒ¥ãƒ¼]',
                'wordpress': 'ğŸŒ[WordPress]',
                'writer': 'âœï¸[ãƒ©ã‚¤ã‚¿ãƒ¼]',
                'writer_ja': 'ğŸ‡¯ğŸ‡µ[æ—¥æœ¬èª]',
                'writer_en': 'ğŸ‡¬ğŸ‡§[è‹±èª]',
                'writer_ru': 'ğŸ‡·ğŸ‡º[ãƒ­ã‚·ã‚¢èª]',
                'content': 'ğŸ“„[ã‚³ãƒ³ãƒ†ãƒ³ãƒ„]'
            }.get(task.get('required_role', 'dev'), 'ğŸ“‹[ã‚¿ã‚¹ã‚¯]')
        
            # === ãƒ‘ãƒ¼ãƒˆ2-3: ã‚¿ã‚¹ã‚¯æƒ…å ±ã®è¡¨ç¤º ===
            print(f"\n{i}. {priority_mark} {role_label} {task.get('description', 'N/A')}")
            print(f"   ç†ç”±: {task.get('reasoning', 'N/A')}")
            print(f"   æ‹…å½“: {task.get('required_role', 'dev')}")
            print(f"   å„ªå…ˆåº¦: {task.get('priority', 'medium')}")

        # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ•ãƒƒã‚¿ãƒ¼è¡¨ç¤º ===
        print("="*60)
    
    async def edit_suggested_tasks(self, suggested_tasks: List[Dict]) -> List[Dict]:
        """ææ¡ˆã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å¤‰æ•°åˆæœŸåŒ– ===
            edited_tasks = []
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å„ã‚¿ã‚¹ã‚¯ã®ç·¨é›†ãƒ«ãƒ¼ãƒ— ===
            for i, task in enumerate(suggested_tasks, 1):
                # === ãƒ‘ãƒ¼ãƒˆ2-1: ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯æƒ…å ±è¡¨ç¤º ===
                print(f"\n--- ã‚¿ã‚¹ã‚¯ {i}/{len(suggested_tasks)} ã®ç·¨é›† ---")
                print(f"ç¾åœ¨ã®å†…å®¹:")
                print(f"  èª¬æ˜: {task.get('description', '')}")
                print(f"  æ‹…å½“: {task.get('required_role', 'dev')}")
                print(f"  å„ªå…ˆåº¦: {task.get('priority', 'medium')}")
                print(f"  ç†ç”±: {task.get('reasoning', '')}")
            
                # === ãƒ‘ãƒ¼ãƒˆ2-2: ç·¨é›†ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¡¨ç¤º ===
                print(f"\nç·¨é›†ã‚ªãƒ—ã‚·ãƒ§ãƒ³:")
                print("  (d)èª¬æ˜ã‚’å¤‰æ›´ / (r)æ‹…å½“ã‚’å¤‰æ›´ / (p)å„ªå…ˆåº¦ã‚’å¤‰æ›´ / (e)ç†ç”±ã‚’å¤‰æ›´")
                print("  (s)ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ— / (k)ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ä¿æŒ / (q)ç·¨é›†ã‚’çµ‚äº†")
            
                # === ãƒ‘ãƒ¼ãƒˆ2-3: ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®å–å¾— ===
                edit_choice = input("é¸æŠ: ").lower()
            
                # === ãƒ‘ãƒ¼ãƒˆ2-4: å„é¸æŠè‚¢ã®å‡¦ç† ===
                if edit_choice == 'd':
                    # èª¬æ˜å¤‰æ›´
                    new_desc = input("æ–°ã—ã„èª¬æ˜: ").strip()
                    if new_desc:
                        task['description'] = new_desc
                    edited_tasks.append(task)
                
                elif edit_choice == 'r':
                    # æ‹…å½“å¤‰æ›´
                    print("åˆ©ç”¨å¯èƒ½ãªæ‹…å½“:")
                    print("  design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                    new_role = input("æ–°ã—ã„æ‹…å½“: ").strip()
                    valid_roles = ['design', 'dev', 'ui', 'review', 'wordpress', 'writer', 
                                'writer_ja', 'writer_en', 'writer_ru', 'writer_uz', 
                                'writer_zh', 'writer_ko', 'writer_tr', 'plugin', 'content']
                    if new_role in valid_roles:
                        task['required_role'] = new_role
                    else:
                        print("ç„¡åŠ¹ãªæ‹…å½“ã§ã™ã€‚å¤‰æ›´ã—ã¾ã›ã‚“ã€‚")
                    edited_tasks.append(task)
                
                elif edit_choice == 'p':
                    # å„ªå…ˆåº¦å¤‰æ›´
                    print("å„ªå…ˆåº¦: high, medium, low")
                    new_priority = input("æ–°ã—ã„å„ªå…ˆåº¦: ").strip()
                    if new_priority in ['high', 'medium', 'low']:
                        task['priority'] = new_priority
                    else:
                        print("ç„¡åŠ¹ãªå„ªå…ˆåº¦ã§ã™ã€‚å¤‰æ›´ã—ã¾ã›ã‚“ã€‚")
                    edited_tasks.append(task)
                
                elif edit_choice == 'e':
                    # ç†ç”±å¤‰æ›´
                    new_reason = input("æ–°ã—ã„ç†ç”±: ").strip()
                    if new_reason:
                        task['reasoning'] = new_reason
                    edited_tasks.append(task)
                
                elif edit_choice == 's':
                    # ã‚¹ã‚­ãƒƒãƒ—
                    print(f"ã‚¿ã‚¹ã‚¯ {i} ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
                    continue
                
                elif edit_choice == 'k':
                    # ä¿æŒ
                    edited_tasks.append(task)
                    print(f"ã‚¿ã‚¹ã‚¯ {i} ã‚’ãã®ã¾ã¾ä¿æŒã—ã¾ã—ãŸ")
                
                elif edit_choice == 'q':
                    # ç·¨é›†çµ‚äº†
                    print("ç·¨é›†ã‚’çµ‚äº†ã—ã¾ã™")
                    break
                
                else:
                    # ä¸æ­£ãªå…¥åŠ›
                    print("ä¸æ­£ãªå…¥åŠ›ã§ã™ã€‚ã‚¿ã‚¹ã‚¯ã‚’ãã®ã¾ã¾ä¿æŒã—ã¾ã™ã€‚")
                    edited_tasks.append(task)
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ç·¨é›†çµæœã®è¡¨ç¤º ===
            if edited_tasks:
                print(f"\nç·¨é›†å¾Œã®ã‚¿ã‚¹ã‚¯ ({len(edited_tasks)}ä»¶):")
                self.display_suggested_tasks(edited_tasks)
            
            return edited_tasks
        
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ4: ä¾‹å¤–å‡¦ç† ===
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ç·¨é›†")
            return suggested_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """æ‰‹å‹•ã§ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å¤‰æ•°åˆæœŸåŒ– ===
            manual_tasks = []
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ä½œæˆé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
            print("\n" + "="*60)
            print("æ‰‹å‹•ã‚¿ã‚¹ã‚¯ä½œæˆ")
            print("="*60)
            print("æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’æ‰‹å‹•ã§ä½œæˆã—ã¾ã™ã€‚")
            print("ç©ºã®èª¬æ˜ã§çµ‚äº†ã—ã¾ã™ã€‚")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ä½œæˆãƒ«ãƒ¼ãƒ— ===
            while True:
                # === ãƒ‘ãƒ¼ãƒˆ3-1: ã‚¿ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
                print(f"\n--- ã‚¿ã‚¹ã‚¯ {len(manual_tasks) + 1} ---")
                
                # === ãƒ‘ãƒ¼ãƒˆ3-2: ã‚¿ã‚¹ã‚¯èª¬æ˜ã®å…¥åŠ› ===
                description = input("ã‚¿ã‚¹ã‚¯èª¬æ˜: ").strip()
                if not description:
                    break
                    
                # === ãƒ‘ãƒ¼ãƒˆ3-3: æ‹…å½“ã®å…¥åŠ› ===
                print("åˆ©ç”¨å¯èƒ½ãªæ‹…å½“: design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                role = input("æ‹…å½“ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: dev): ").strip() or "dev"
                
                # === ãƒ‘ãƒ¼ãƒˆ3-4: å„ªå…ˆåº¦ã®å…¥åŠ› ===
                print("å„ªå…ˆåº¦: high, medium, low")
                priority = input("å„ªå…ˆåº¦ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: medium): ").strip() or "medium"
                
                # === ãƒ‘ãƒ¼ãƒˆ3-5: ç†ç”±ã®å…¥åŠ› ===
                reasoning = input("ç†ç”±: ").strip()
                
                # === ãƒ‘ãƒ¼ãƒˆ3-6: ã‚¿ã‚¹ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ ===
                task = {
                    'description': description,
                    'required_role': role,
                    'priority': priority,
                    'reasoning': reasoning
                }
                
                # === ãƒ‘ãƒ¼ãƒˆ3-7: ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã¸ã®è¿½åŠ  ===
                manual_tasks.append(task)
                print(f"ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ãŸ (åˆè¨ˆ: {len(manual_tasks)}ä»¶)")
                
                # === ãƒ‘ãƒ¼ãƒˆ3-8: ç¶™ç¶šç¢ºèª ===
                more = input("ã•ã‚‰ã«ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã™ã‹? (y/n): ").lower()
                if more != 'y':
                    break
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ä½œæˆçµæœã®è¡¨ç¤º ===
            if manual_tasks:
                print(f"\nä½œæˆã—ãŸã‚¿ã‚¹ã‚¯ ({len(manual_tasks)}ä»¶):")
                self.display_suggested_tasks(manual_tasks)
                
            return manual_tasks
            
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ5: ä¾‹å¤–å‡¦ç† ===
            ErrorHandler.log_error(e, "æ‰‹å‹•ã‚¿ã‚¹ã‚¯ä½œæˆ")
            return []

#task_executor_ma.py
"""
task_executor_ma.py
M&A/ä¼æ¥­æ¤œç´¢å°‚ç”¨ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆå®Œå…¨ç‰ˆï¼‰
task_executor.pyã‹ã‚‰åˆ†é›¢
"""
import asyncio
import logging
from typing import Dict, Optional, Any, List
from datetime import datetime
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class MATaskExecutor:
    """M&A/ä¼æ¥­æ¤œç´¢ã‚¿ã‚¹ã‚¯å°‚ç”¨ã®å®Ÿè¡Œã‚¯ãƒ©ã‚¹"""

    def __init__(self, sheets_manager, browser, max_iterations: int = 30):
        """
        MATaskExecutorã®åˆæœŸåŒ–
    
        Args:
            sheets_manager: Google Sheetsãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
            browser: ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
            max_iterations: æœ€å¤§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ30ï¼‰
        """
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¨­å®š ===
        self.sheets_manager = sheets_manager
        self.browser = browser
        self.max_iterations = max_iterations
        self.agents = {}  # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¾æ›¸ã‚’ç©ºã§åˆæœŸåŒ–
        self.review_agent = None  # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç”¨ã®å±æ€§
    
        logger.info(f"MATaskExecutor initialized (max_iterations={max_iterations})")
    
    # === è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²æ©Ÿèƒ½ ===
    def register_agent(self, agent_name: str, agent):
        """
        ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²
        
        Args:
            agent_name: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåï¼ˆä¾‹: 'wordpress', 'plugin'ï¼‰
            agent: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.agents[agent_name] = agent
        logger.info(f"âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_name}' ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²ãƒ¡ã‚½ãƒƒãƒ‰
    # ========================================
    def register_review_agent(self, review_agent):
        """
        ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²
        
        Args:
            review_agent: ReviewAgentã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.review_agent = review_agent
        self.agents['review'] = review_agent  # agentsãƒ‡ã‚£ã‚¯ã‚·ãƒ§ãƒŠãƒªã«ã‚‚ç™»éŒ²
        logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
    # ========================================
    async def load_pending_tasks(self):
        """
        ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€
        
        Returns:
            List[Dict]: pendingã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
        """
        try:
            logger.info("ğŸ“‹ ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("ğŸ”­ pm_tasksã‚·ãƒ¼ãƒˆã«ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                return []
            
            # statusãŒ'pending'ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"ğŸ“Š ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
            return pending_tasks
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return []
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
    # ========================================
    async def execute_task(self, task: Dict) -> bool:
        """
        ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆåŸºæœ¬çš„ãªå®Ÿè£…ï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info(f"ğŸ¯ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            
            # M&Aã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ
            result = await self.execute_ma_task(task)
            
            if result and result.get('success'):
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
                return True
            else:
                error = result.get('error', 'ä¸æ˜') if result else 'çµæœãªã—'
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {error}")
                return False
                
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
    # ========================================
    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """
        å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œ
        
        Args:
            auto_continue: è‡ªå‹•ç¶™ç¶šãƒ•ãƒ©ã‚°
            enable_review: ãƒ¬ãƒ“ãƒ¥ãƒ¼æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°
            
        Returns:
            Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
        """
        from datetime import datetime
        
        logger.info("\n" + "="*80)
        logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
        logger.info("="*80 + "\n")
        
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
        
        try:
            # ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿
            pending_tasks = await self.load_pending_tasks()
            
            if not pending_tasks:
                logger.info("ğŸ”­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                summary['end_time'] = datetime.now()
                return summary
            
            summary['total'] = len(pending_tasks)
            logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            
            # ã‚¿ã‚¹ã‚¯ã‚’é †ç•ªã«å®Ÿè¡Œ
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                
                logger.info(f"\n{'â”€'*80}")
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                logger.info(f"{'â”€'*80}")
                
                try:
                    success = await self.execute_task(task)
                    
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                    
                    if success:
                        summary['success'] += 1
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                    
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¨ãƒ©ãƒ¼: {e}")
            
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
            logger.info("\n" + "="*80)
            logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            logger.info("="*80)
            logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
            logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
            logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
            logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
            logger.info("="*80 + "\n")
            
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
            
            return summary
            
        except Exception as e:
            logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            summary['end_time'] = datetime.now()
            return summary

    async def execute_ma_task(self, task: Dict) -> Dict:
        """
        M&Aé–¢é€£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
    
        ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã‚’è§£æã—ã¦ã€é©åˆ‡ãªãƒ¡ã‚½ãƒƒãƒ‰ã«æŒ¯ã‚Šåˆ†ã‘ã‚‹
        """
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å®Ÿè¡Œé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
            logger.info("="*60)
            logger.info("ğŸ“Š M&Aæ¡ˆä»¶å‡¦ç†ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            logger.info("="*60)
        
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å†…å®¹ã®è§£æ ===
            description = task.get('description', '').lower()
            parameters = task.get('parameters', {})
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆ¤å®šï¼ˆæœ€ã‚‚ç¢ºå®Ÿï¼‰===
            if 'cpt_slug' in parameters or 'cpt_labels' in parameters:
                logger.info("â†’ Custom Post Typeä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_cpt_creation(task)
        
            elif 'acf_field_group_name' in parameters or 'acf_fields' in parameters:
                logger.info("â†’ ACFè¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy_slug' in parameters or 'taxonomy_labels' in parameters:
                logger.info("â†’ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_taxonomy_creation(task)
        
            elif 'facets' in parameters or 'facetwp' in description:
                logger.info("â†’ æ¤œç´¢æ©Ÿèƒ½è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_search_setup(task)
        
            elif 'role_slug' in parameters or 'role_name' in parameters:
                logger.info("â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_user_role_setup(task)
        
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®åˆ¤å®š ===
            elif 'custom post type' in description or 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—' in description:
                logger.info("â†’ Custom Post Typeä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®šï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰")
                return await self._execute_cpt_creation(task)
        
            elif 'acf' in description or 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰' in description:
                logger.info("â†’ ACFè¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®šï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy' in description or 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼' in description:
                logger.info("â†’ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®šï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰")
                return await self._execute_taxonomy_creation(task)
        
            elif 'm&aæ¡ˆä»¶' in description or 'ma_case' in description:
                logger.info("â†’ M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_ma_case_post(task)
        
            elif 'æ¤œç´¢' in description or 'search' in description:
                logger.info("â†’ æ¤œç´¢æ©Ÿèƒ½è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_search_setup(task)
        
            elif 'user role' in description or 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«' in description:
                logger.info("â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_user_role_setup(task)
        
            else:
                # === ãƒ‘ãƒ¼ãƒˆ5: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç† ===
                logger.info("â†’ æ±ç”¨WordPressã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                wp_agent = self.agents.get('wordpress')
                if wp_agent:
                    return await wp_agent.process_task(task)
                else:
                    return {
                        'success': False,
                        'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    }
    
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ6: ä¾‹å¤–å‡¦ç† ===
            ErrorHandler.log_error(e, "M&Aã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_cpt_creation(self, task: Dict) -> Dict:
        """Custom Post Typeä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€Custom Post Typeä½œæˆã€‘")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'cpt_slug': parameters.get('cpt_slug', 'ma_case'),
            'cpt_labels': parameters.get('cpt_labels', {
                'singular': 'M&Aæ¡ˆä»¶',
                'plural': 'M&Aæ¡ˆä»¶ä¸€è¦§'
            }),
            'cpt_supports': parameters.get('cpt_supports', ['title', 'editor', 'thumbnail', 'custom-fields']),
            'cpt_settings': parameters.get('cpt_settings', {
                'public': True,
                'has_archive': True,
                'show_in_rest': True,
                'menu_icon': 'dashicons-portfolio'
            })
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'configure_custom_post_type'):
            result = await wp_agent.configure_custom_post_type(task_params)
        else:
            logger.warning("configure_custom_post_type ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_acf_setup(self, task: Dict) -> Dict:
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã€‘")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'acf_field_group_name': parameters.get('acf_field_group_name', 'M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±'),
            'acf_fields': parameters.get('acf_fields', [
                {'name': 'case_id', 'type': 'text', 'label': 'æ¡ˆä»¶ID'},
                {'name': 'ma_scheme', 'type': 'select', 'label': 'M&Aã‚¹ã‚­ãƒ¼ãƒ '},
                {'name': 'desired_price', 'type': 'number', 'label': 'å¸Œæœ›ä¾¡æ ¼'},
                {'name': 'industry_category', 'type': 'taxonomy', 'label': 'æ¥­ç¨®'},
                {'name': 'region', 'type': 'taxonomy', 'label': 'åœ°åŸŸ'},
                {'name': 'established_year', 'type': 'number', 'label': 'è¨­ç«‹å¹´'},
                {'name': 'employees', 'type': 'number', 'label': 'å¾“æ¥­å“¡æ•°'},
            ]),
            'acf_location_rules': parameters.get('acf_location_rules', {
                'post_type': 'ma_case'
            })
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'configure_acf_fields'):
            result = await wp_agent.configure_acf_fields(task_params)
        else:
            logger.warning("configure_acf_fields ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_taxonomy_creation(self, task: Dict) -> Dict:
        """ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã€‘")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'taxonomy_slug': parameters.get('taxonomy_slug', 'industry_category'),
            'taxonomy_labels': parameters.get('taxonomy_labels', {
                'singular': 'æ¥­ç¨®',
                'plural': 'æ¥­ç¨®ä¸€è¦§'
            }),
            'taxonomy_post_types': parameters.get('taxonomy_post_types', ['ma_case']),
            'taxonomy_hierarchical': parameters.get('taxonomy_hierarchical', True)
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'configure_custom_taxonomy'):
            result = await wp_agent.configure_custom_taxonomy(task_params)
        else:
            logger.warning("configure_custom_taxonomy ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_ma_case_post(self, task: Dict) -> Dict:
        """M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€M&Aæ¡ˆä»¶æŠ•ç¨¿ã€‘")

        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            # === ãƒ‘ãƒ¼ãƒˆ1: WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²ã‚¨ãƒ©ãƒ¼ ===
            logger.error("âŒ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            logger.error("ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸€è¦§:")
            for agent_name in self.agents.keys():
                logger.error(f"  - {agent_name}")
        
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚test_tasks.pyã§ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'post_type': 'ma_case',
            'post_title': parameters.get('post_title', 'æ–°è¦M&Aæ¡ˆä»¶'),
            'post_content': parameters.get('post_content', ''),
            'acf_fields': parameters.get('acf_fields', {}),
            'polylang_lang': parameters.get('polylang_lang', 'ja'),
            'post_status': parameters.get('post_status', 'draft')
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'create_ma_case_post'):
            result = await wp_agent.create_ma_case_post(task_params)
        else:
            logger.warning("create_ma_case_post ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®æŠ•ç¨¿ä½œæˆ
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_search_setup(self, task: Dict) -> Dict:
        """æ¤œç´¢æ©Ÿèƒ½è¨­å®šã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€æ¤œç´¢æ©Ÿèƒ½è¨­å®šã€‘")

        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰ ===
        plugin_agent = self.agents.get('plugin')

        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒãªã„å ´åˆã€WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
        if not plugin_agent:
            logger.warning("âš ï¸ plugin ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç›´æ¥ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
            wp_agent = self.agents.get('wordpress')
            if wp_agent and hasattr(wp_agent, 'plugin_manager'):
                plugin_agent = wp_agent.plugin_manager
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰plugin_managerã‚’å–å¾—ã—ã¾ã—ãŸ")
            else:
                logger.error("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
                }
        
        parameters = task.get('parameters', {})
        
        # FacetWPè¨­å®šã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ
        task_params = {
            'plugin_name': 'facetwp',
            'action': 'configure',
            'facets': parameters.get('facets', [
                {
                    'name': 'æ¥­ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
                    'type': 'checkboxes',
                    'source': 'tax/industry_category'
                },
                {
                    'name': 'ä¾¡æ ¼å¸¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
                    'type': 'slider',
                    'source': 'cf/desired_price',
                    'min': 0,
                    'max': 1000000000,
                    'step': 10000000
                },
                {
                    'name': 'åœ°åŸŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
                    'type': 'dropdown',
                    'source': 'tax/region'
                }
            ])
        }
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(plugin_agent, 'configure_facetwp'):
            result = await plugin_agent.configure_facetwp(task_params)
        else:
            logger.warning("configure_facetwp ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await plugin_agent.change_plugin_settings(None, task)
        
        return result
    
    async def _execute_user_role_setup(self, task: Dict) -> Dict:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã€‘")
    
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰ ===
        plugin_agent = self.agents.get('plugin')
    
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒãªã„å ´åˆã€WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
        if not plugin_agent:
            logger.warning("âš ï¸ plugin ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç›´æ¥ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
            wp_agent = self.agents.get('wordpress')
            if wp_agent and hasattr(wp_agent, 'plugin_manager'):
                plugin_agent = wp_agent.plugin_manager
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰plugin_managerã‚’å–å¾—ã—ã¾ã—ãŸ")
            else:
                logger.error("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
                }
        
        parameters = task.get('parameters', {})
        
        # User Role Editorè¨­å®šã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ
        task_params = {
            'plugin_name': 'user-role-editor',
            'action': 'configure',
            'role_slug': parameters.get('role_slug', 'ma_partner'),
            'role_name': parameters.get('role_name', 'ææºãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼'),
            'capabilities': parameters.get('capabilities', {
                'read': True,
                'edit_posts': True,
                'delete_posts': True,
                'edit_published_posts': True,
                'publish_posts': False
            })
        }
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(plugin_agent, 'configure_user_roles'):
            result = await plugin_agent.configure_user_roles(None, task_params)
        else:
            logger.warning("configure_user_roles ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await plugin_agent.change_plugin_settings(None, task)
        
        return result
    
def validate_ma_task(self, task: Dict) -> tuple[bool, Optional[str]]:
    """
    M&Aã‚¿ã‚¹ã‚¯ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ¤œè¨¼
        
    Returns:
        (valid: bool, error_message: Optional[str])
    """
    try:
        parameters = task.get('parameters', {})
            
        # === ãƒ‘ãƒ¼ãƒˆ1: Custom Post Typeä½œæˆã®æ¤œè¨¼ ===
        if 'cpt_slug' in parameters:
            if not parameters['cpt_slug']:
                return False, "cpt_slugãŒç©ºã§ã™"
            if not parameters['cpt_slug'].replace('_', '').isalnum():
                return False, "cpt_slugã¯è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™"
            
        # === ãƒ‘ãƒ¼ãƒˆ2: ACFè¨­å®šã®æ¤œè¨¼ ===
        if 'acf_field_group_name' in parameters:
            if not parameters['acf_field_group_name']:
                return False, "acf_field_group_nameãŒç©ºã§ã™"
                
            acf_fields = parameters.get('acf_fields', [])
            if not isinstance(acf_fields, list):
                return False, "acf_fieldsã¯ãƒªã‚¹ãƒˆå½¢å¼ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™"
                
            for field in acf_fields:
                if 'name' not in field or 'type' not in field:
                    return False, "ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯nameã¨typeãŒå¿…è¦ã§ã™"
            
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã®æ¤œè¨¼ ===
        if 'taxonomy_slug' in parameters:
            if not parameters['taxonomy_slug']:
                return False, "taxonomy_slugãŒç©ºã§ã™"
            if not parameters['taxonomy_slug'].replace('_', '').isalnum():
                return False, "taxonomy_slugã¯è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™"
            
        # === ãƒ‘ãƒ¼ãƒˆ4: æ¤œè¨¼æˆåŠŸ ===
        return True, None
            
    except Exception as e:
        # === ãƒ‘ãƒ¼ãƒˆ5: æ¤œè¨¼ä¸­ã®ä¾‹å¤–å‡¦ç† ===
        return False, f"æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {str(e)}"

#test_tasks - ã‚³ãƒ”ãƒ¼.py
# test_tasks.py
"""
pm_tasksã‚·ãƒ¼ãƒˆã®æ—¢å­˜ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã™ã‚‹ãƒ‡ãƒãƒƒã‚°ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

ä½¿ã„æ–¹:
  python test_tasks.py                    # å…¨pending ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
  python test_tasks.py --task-id 5        # ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã®ã¿å®Ÿè¡Œ
  python test_tasks.py --role writer      # ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ
  python test_tasks.py --auto             # è‡ªå‹•å®Ÿè¡Œï¼ˆç¢ºèªãªã—ï¼‰
"""
import asyncio
import logging
import argparse
from pathlib import Path

from config_utils import config, ErrorHandler, PathManager
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from task_executor import TaskExecutor

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)


class TaskTester:
    """æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç”¨ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, spreadsheet_id: str, service_account_file: str = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.sheets_manager = None
        self.browser = None
        self.task_executor = None
    
    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–"""
        try:
            logger.info("="*60)
            logger.info("ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ã‚¿ãƒ¼ã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: Google Sheetsæ¥ç¶šã¨åŸºæœ¬è¨­å®šèª­ã¿è¾¼ã¿ ===
            logger.info("ğŸ“Š Google Sheetsæ¥ç¶šä¸­...")
            
            # Google Sheetsæ¥ç¶š
            self.sheets_manager = GoogleSheetsManager(
                self.spreadsheet_id, 
                self.service_account_file
            )
            
            # PC_IDã‚’å–å¾—ã—ã¦è¨­å®šã‚’èª­ã¿è¾¼ã¿
            pc_id = self.sheets_manager.get_current_pc_id()
            settings = self.sheets_manager.load_pc_settings(pc_id)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã¨ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®š ===
            logger.info("ğŸ“ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šä¸­...")
            
            # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š
            agent_output = settings.get('agent_output_folder')
            if not agent_output or agent_output.startswith('http'):
                download_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                download_folder.mkdir(exist_ok=True, parents=True)
            else:
                download_folder = PathManager.get_safe_path(agent_output)
            
            logger.info(f"å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {download_folder}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: BrowserControlleråˆæœŸåŒ– ===
            logger.info("ğŸŒ ãƒ–ãƒ©ã‚¦ã‚¶åˆæœŸåŒ–ä¸­...")
            
            # BrowserControllerã‚’åˆæœŸåŒ–
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            self.browser = BrowserController(
                download_folder, 
                mode='text', 
                service='google'
            )
            await self.browser.setup_browser()
            await self.browser.navigate_to_gemini()
            
            # === ãƒ‘ãƒ¼ãƒˆ4: TaskExecutoråˆæœŸåŒ– ===
            logger.info("âš™ï¸ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ä¸­...")
            
            # TaskExecutorã‚’åˆæœŸåŒ–
            self.task_executor = TaskExecutor(
                self.sheets_manager,
                self.browser,
                max_iterations=1  # ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã¯1å›ã®ã¿
            )
            
            # === ãƒ‘ãƒ¼ãƒˆ5: å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç™»éŒ² ===
            logger.info("ğŸ¤– ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²ä¸­...")
            
            # â˜…â˜…â˜… å„ç¨®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–ã¨ç™»éŒ² â˜…â˜…â˜…
            
            # 1. Design Agent
            try:
                from design_agent import DesignAgent
                design_agent = DesignAgent(self.browser)
                self.task_executor.register_agent('design', design_agent)
                logger.info("âœ… Design Agentç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ design_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # 2. Dev Agent
            try:
                from dev_agent import DevAgent
                dev_agent = DevAgent(self.browser)
                self.task_executor.register_agent('dev', dev_agent)
                logger.info("âœ… Dev Agentç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ dev_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # 3. Review Agent
            try:
                from review_agent import ReviewAgent
                review_agent = ReviewAgent()
                review_agent.browser = self.browser
                review_agent.sheets_manager = self.sheets_manager
                self.task_executor.register_review_agent(review_agent)
                logger.info("âœ… Review Agentç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ review_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # 4. Content Writer Agents
            try:
                from content_writer_agent import ContentWriterAgent
                content_writer = ContentWriterAgent(self.browser)
                self.task_executor.register_agent('writer', content_writer)
                self.task_executor.register_agent('content', content_writer)
                logger.info("âœ… Content Writer Agentç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ content_writer_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # 5. WordPress Agentï¼ˆé‡è¦ï¼ï¼‰
            logger.info("ğŸ—„ï¸ WordPress Agentè¨­å®šä¸­...")
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
            
            if wp_url and wp_user and wp_pass:
                try:
                    from wordpress.wp_agent import WordPressAgent
                    
                    wp_credentials = {
                        'wp_url': wp_url,
                        'wp_user': wp_user,
                        'wp_pass': wp_pass
                    }
                    
                    wordpress_agent = WordPressAgent(self.browser, wp_credentials)
                    wordpress_agent.sheets_manager = self.sheets_manager
                    
                    logger.info("WordPressã¸ã®ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œä¸­...")
                    wp_login_success = await wordpress_agent.initialize_wp_session()
                    
                    if wp_login_success:
                        self.task_executor.register_agent('wordpress', wordpress_agent)
                        logger.info("âœ… WordPress Agentç™»éŒ²å®Œäº†")
                    else:
                        logger.warning("âš ï¸ WordPressãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                        
                except Exception as e:
                    logger.error(f"WordPress AgentåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            else:
                logger.warning("âš ï¸ WordPressèªè¨¼æƒ…å ±ãŒæœªè¨­å®šã§ã™")
            
            logger.info("="*60)
            logger.info("âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            raise
    
    async def test_specific_task(self, task_id: str):
        """ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯æ¤œç´¢ ===
            logger.info(f"\n{'='*60}")
            logger.info(f"ã‚¿ã‚¹ã‚¯ID {task_id} ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
            logger.info(f"{'='*60}\n")
            
            # pm_tasksã‹ã‚‰è©²å½“ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
            tasks = await self.task_executor.load_pending_tasks()
            target_task = None
            
            for task in tasks:
                if str(task['task_id']) == str(task_id):
                    target_task = task
                    break
            
            if not target_task:
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ID {task_id} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆstatusãŒpendingã‹ç¢ºèªã—ã¦ãã ã•ã„ï¼‰")
                return False
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯æƒ…å ±è¡¨ç¤ºã¨ç¢ºèª ===
            # ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’è¡¨ç¤º
            self._display_task_info(target_task)
            
            # å®Ÿè¡Œç¢ºèª
            confirm = input("\nã“ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
            if confirm.lower() != 'y':
                logger.info("å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ")
                return False
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã¨çµæœå‡¦ç† ===
            # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
            success = await self.task_executor.execute_task(target_task)
            
            if success:
                logger.info(f"\nâœ… ã‚¿ã‚¹ã‚¯ {task_id} ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå®Œäº†")
            else:
                logger.error(f"\nâŒ ã‚¿ã‚¹ã‚¯ {task_id} ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå¤±æ•—")
            
            return success
            
        except Exception as e:
            ErrorHandler.log_error(e, f"ã‚¿ã‚¹ã‚¯ {task_id} ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
            return False
    
    async def test_tasks_by_role(self, role: str, auto: bool = False):
        """ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info(f"å½¹å‰² '{role}' ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
            logger.info(f"{'='*60}\n")
            
            # pm_tasksã‹ã‚‰è©²å½“ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
            all_tasks = await self.task_executor.load_pending_tasks()
            filtered_tasks = [t for t in all_tasks if t['required_role'].lower() == role.lower()]
            
            if not filtered_tasks:
                logger.error(f"âŒ å½¹å‰² '{role}' ã®pendingã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return
            
            logger.info(f"å¯¾è±¡ã‚¿ã‚¹ã‚¯: {len(filtered_tasks)}ä»¶\n")
            
            for i, task in enumerate(filtered_tasks, 1):
                logger.info(f"{i}. [{task['task_id']}] {task['description'][:80]}")
            
            if not auto:
                confirm = input(f"\nã“ã‚Œã‚‰ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
                if confirm.lower() != 'y':
                    logger.info("å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ")
                    return
            
            # ã‚¿ã‚¹ã‚¯ã‚’é †ç•ªã«å®Ÿè¡Œ
            completed = 0
            failed = 0
            
            for task in filtered_tasks:
                logger.info(f"\n{'='*60}")
                logger.info(f"ã‚¿ã‚¹ã‚¯ {task['task_id']} ã‚’å®Ÿè¡Œä¸­...")
                logger.info(f"{'='*60}")
                
                success = await self.task_executor.execute_task(task)
                
                if success:
                    completed += 1
                else:
                    failed += 1
                
                # æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¸ã®ç¢ºèª
                if not auto and task != filtered_tasks[-1]:
                    choice = input("\næ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: (c)ç¶šè¡Œ / (q)çµ‚äº†: ").lower()
                    if choice == 'q':
                        break
            
            # ã‚µãƒãƒªãƒ¼è¡¨ç¤º
            logger.info(f"\n{'='*60}")
            logger.info("ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå®Œäº†")
            logger.info(f"{'='*60}")
            logger.info(f"å®Œäº†: {completed}ä»¶")
            logger.info(f"å¤±æ•—: {failed}ä»¶")
            logger.info(f"{'='*60}")
            
        except Exception as e:
            ErrorHandler.log_error(e, f"å½¹å‰² '{role}' ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
    
    async def test_all_pending_tasks(self, auto: bool = False):
        """å…¨ã¦ã®pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info("å…¨pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
            logger.info(f"{'='*60}\n")
            
            # TaskExecutorã®é€šå¸¸å®Ÿè¡Œã‚’ä½¿ç”¨
            await self.task_executor.run_all_tasks(
                auto_continue=auto,
                enable_review=False  # ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼ãªã—
            )
            
        except Exception as e:
            ErrorHandler.log_error(e, "å…¨ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
    
    def _display_task_info(self, task: dict):
        """ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’è¡¨ç¤º"""
        print("\n" + "="*60)
        print("ã‚¿ã‚¹ã‚¯è©³ç´°")
        print("="*60)
        print(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}")
        print(f"èª¬æ˜: {task['description']}")
        print(f"æ‹…å½“: {task['required_role']}")
        print(f"å„ªå…ˆåº¦: {task['priority']}")
        print(f"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task['status']}")
        
        if 'language' in task:
            print(f"è¨€èª: {task['language']}")
        if 'polylang_lang' in task:
            print(f"Polylang: {task['polylang_lang']}")
        if 'source_task_id' in task:
            print(f"å…ƒè¨˜äº‹ã‚¿ã‚¹ã‚¯ID: {task['source_task_id']}")
        if 'post_action' in task:
            print(f"æŠ•ç¨¿ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {task['post_action']}")
        if 'post_status' in task:
            print(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task['post_status']}")
        
        print("="*60)
    
    async def cleanup(self):
        """ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.browser:
            await self.browser.cleanup()

async def run_all_tasks(
    self, 
    auto_continue: bool = True, 
    enable_review: bool = True
) -> Dict[str, Any]:
    """
    å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œ
        
    Args:
        auto_continue: è‡ªå‹•ç¶™ç¶šãƒ•ãƒ©ã‚°ï¼ˆFalseã®å ´åˆã€å„ã‚¿ã‚¹ã‚¯å¾Œã«ç¢ºèªï¼‰
        enable_review: ãƒ¬ãƒ“ãƒ¥ãƒ¼æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°
            
    Returns:
        Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
    """
    logger.info("\n" + "="*80)
    logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
    logger.info("="*80 + "\n")
        
    summary = {
        'total': 0,
        'success': 0,
        'failed': 0,
        'skipped': 0,
        'results': [],
        'start_time': datetime.now(),
        'end_time': None
    }
        
    try:
        # ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        logger.info("ğŸ“‹ ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
        pending_tasks = await self.load_pending_tasks()
            
        if not pending_tasks:
            logger.info("ğŸ“­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
            logger.info("ğŸ’¡ ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã® 'pm_tasks' ã‚·ãƒ¼ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            logger.info("   - ã‚¿ã‚¹ã‚¯ãŒå­˜åœ¨ã™ã‚‹ã‹")
            logger.info("   - statusåˆ—ãŒ 'pending' ã«ãªã£ã¦ã„ã‚‹ã‹")
            summary['end_time'] = datetime.now()
            return summary
            
        summary['total'] = len(pending_tasks)
        logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            
        # ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’è¡¨ç¤º
        logger.info(f"ğŸ‘¥ ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {list(self.agents.keys())}")
        logger.info("")
            
        # å„ã‚¿ã‚¹ã‚¯ã‚’é †æ¬¡å®Ÿè¡Œ
        for index, task in enumerate(pending_tasks, 1):
            task_id = task.get('task_id', 'UNKNOWN')
                
            # åå¾©å›æ•°ãƒã‚§ãƒƒã‚¯
            self.current_iteration += 1
            if self.current_iteration > self.max_iterations:
                logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•° ({self.max_iterations}) ã«åˆ°é”")
                logger.warning(f"æ®‹ã‚Š {summary['total'] - index + 1} ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                summary['skipped'] = summary['total'] - index + 1
                break
                
            logger.info(f"\n{'â”€'*80}")
            logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
            logger.info(f"{'â”€'*80}")
                
            try:
                success = await self.execute_task(task)
                    
                task_result = {
                    'task_id': task_id,
                    'success': success,
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                if success:
                    summary['success'] += 1
                    logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                        
                    # ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œï¼ˆæœ‰åŠ¹ãªå ´åˆï¼‰
                    if enable_review and self.review_agent and hasattr(self.review_agent, 'review_task'):
                        logger.info(f"ğŸ” ã‚¿ã‚¹ã‚¯ {task_id} ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­...")
                        try:
                            review_result = await self.review_agent.review_task(task)
                            if review_result and not review_result.get('approved', True):
                                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸åˆæ ¼")
                        except Exception as e:
                            logger.warning(f"âš ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
                else:
                    summary['failed'] += 1
                    logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                    
                # è‡ªå‹•ç¶™ç¶šã§ãªã„å ´åˆã€æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¸ã®ç¢ºèª
                if not auto_continue and index < summary['total']:
                    user_choice = input("\næ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: (c)ç¶šè¡Œ / (s)ã‚¹ã‚­ãƒƒãƒ— / (q)çµ‚äº†: ").lower()
                    if user_choice == 'q':
                        logger.info("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                        summary['skipped'] = summary['total'] - index
                        break
                    elif user_choice == 's':
                        logger.info("ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—")
                        continue
                    
                await asyncio.sleep(1)
                    
            except Exception as e:
                summary['failed'] += 1
                error_msg = f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­ã®ã‚¨ãƒ©ãƒ¼: {str(e)}"
                logger.error(f"âŒ {error_msg}")
                ErrorHandler.log_error(e, f"run_all_tasks - task {task_id}")
                    
                task_result = {
                    'task_id': task_id,
                    'success': False,
                    'error': str(e),
                    'index': index,
                    'timestamp': datetime.now()
                }
                summary['results'].append(task_result)
                    
                # ã‚¨ãƒ©ãƒ¼æ™‚ã®ç¶™ç¶šç¢ºèª
                if not auto_continue:
                    user_choice = input("\nã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ (y/n): ").lower()
                    if user_choice != 'y':
                        summary['skipped'] = summary['total'] - index
                        break
            
        # å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼ã‚’è¡¨ç¤º
        summary['end_time'] = datetime.now()
        elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
        logger.info("\n" + "="*80)
        logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº† - å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼")
        logger.info("="*80)
        logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
        logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
        logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
        logger.info(f"  â­ï¸  ã‚¹ã‚­ãƒƒãƒ—:  {summary['skipped']:>3}ä»¶")
        logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
        logger.info("="*80 + "\n")
            
        if summary['total'] > 0:
            success_rate = (summary['success'] / summary['total']) * 100
            logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
                
            if success_rate >= 80:
                logger.info("ğŸ‰ è‰¯å¥½ãªå®Ÿè¡Œçµæœã§ã™ï¼")
            elif success_rate >= 50:
                logger.info("âš ï¸ ã„ãã¤ã‹ã®ã‚¿ã‚¹ã‚¯ã§å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã™")
            else:
                logger.warning("ğŸš¨ å¤šãã®ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—ã—ã¦ã„ã¾ã™ã€‚è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            
        return summary
            
    except Exception as e:
        logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã«äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        ErrorHandler.log_error(e, "run_all_tasks")
        summary['end_time'] = datetime.now()
        return summary
        
    finally:
        logger.info("\nğŸ§¹ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå¾Œã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—...")
        self.current_iteration = 0
        logger.info("âœ… ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†\n")

async def main():
    parser = argparse.ArgumentParser(
        description='pm_tasksã®æ—¢å­˜ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  python test_tasks.py                    # å…¨pendingã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
  python test_tasks.py --task-id 5        # ã‚¿ã‚¹ã‚¯ID 5ã®ã¿å®Ÿè¡Œ
  python test_tasks.py --role writer      # writer ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ
  python test_tasks.py --role wordpress --auto  # wordpress ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•å®Ÿè¡Œ
        """
    )
    
    parser.add_argument('--task-id', type=str, help='ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã®ã¿å®Ÿè¡Œ')
    parser.add_argument('--role', type=str, help='ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ (design, dev, writer, wordpress, etc.)')
    parser.add_argument('--auto', action='store_true', help='è‡ªå‹•å®Ÿè¡Œï¼ˆç¢ºèªãªã—ï¼‰')
    parser.add_argument('--spreadsheet-id', type=str, help='ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDï¼ˆconfig.pyã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä¸Šæ›¸ãï¼‰')
    
    args = parser.parse_args()
    
    # ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
    spreadsheet_id = args.spreadsheet_id or config.SPREADSHEET_ID
    
    # service_account.json ã®ãƒ‘ã‚¹
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
    
    # TaskTesterã‚’åˆæœŸåŒ–
    tester = TaskTester(spreadsheet_id, service_account_file)
    
    try:
        await tester.initialize()
        
        # ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å®Ÿè¡Œ
        if args.task_id:
            # ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã‚’ãƒ†ã‚¹ãƒˆ
            await tester.test_specific_task(args.task_id)
        
        elif args.role:
            # ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆ
            await tester.test_tasks_by_role(args.role, auto=args.auto)
        
        else:
            # å…¨ã¦ã®pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆ
            await tester.test_all_pending_tasks(auto=args.auto)
        
    except KeyboardInterrupt:
        logger.info("\n\nâš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
    
    except Exception as e:
        logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        await tester.cleanup()
        logger.info("\nğŸ‘‹ ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ã‚¿ãƒ¼ã‚’çµ‚äº†ã—ã¾ã—ãŸ")


if __name__ == "__main__":
    asyncio.run(main())

#test_tasks.py
# test_tasks.py
"""
pm_tasksã‚·ãƒ¼ãƒˆã®æ—¢å­˜ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã™ã‚‹ãƒ‡ãƒãƒƒã‚°ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

ä½¿ã„æ–¹:
  python test_tasks.py                    # å…¨pending ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
  python test_tasks.py --task-id 5        # ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã®ã¿å®Ÿè¡Œ
  python test_tasks.py --role writer      # ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ
  python test_tasks.py --auto             # è‡ªå‹•å®Ÿè¡Œï¼ˆç¢ºèªãªã—ï¼‰
"""

import logging
import asyncio
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Any 

from config_utils import config, ErrorHandler, PathManager
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

# ãƒ­ã‚¬ãƒ¼è¨­å®š
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)s | %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# TaskExecutor ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®ç°¡ç´ åŒ–
try:
    # ã¾ãšãƒ¡ã‚¤ãƒ³ã®TaskExecutorã‚’è©¦ã™
    from task_executor.task_executor import TaskExecutor
    logger.info("âœ… ãƒ¡ã‚¤ãƒ³ TaskExecutor ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ")
except ImportError as e:
    logger.warning(f"âš ï¸ ãƒ¡ã‚¤ãƒ³ TaskExecutor ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
    try:
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: MATaskExecutor
        from task_executor.task_executor_ma import MATaskExecutor as TaskExecutor
        logger.info("âœ… MATaskExecutor ã‚’ TaskExecutor ã¨ã—ã¦ä½¿ç”¨")
    except ImportError as e:
        logger.warning(f"âš ï¸ MATaskExecutor ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
        try:
            # æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ContentTaskExecutor
            from task_executor.content_task_executor import ContentTaskExecutor as TaskExecutor
            logger.info("âœ… ContentTaskExecutor ã‚’ TaskExecutor ã¨ã—ã¦ä½¿ç”¨")
        except ImportError as e:
            logger.error(f"âŒ åˆ©ç”¨å¯èƒ½ãªTaskExecutorãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {e}")
            TaskExecutor = None

class TaskTester:
    """æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç”¨ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, spreadsheet_id: str, service_account_file: str = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.sheets_manager = None
        self.browser = None
        self.task_executor = None
    
    def safe_import_task_executor():
        """å®‰å…¨ãªTaskExecutorã‚¤ãƒ³ãƒãƒ¼ãƒˆé–¢æ•°"""
        import logging
        temp_logger = logging.getLogger(__name__)
        
        candidates = [
            # å„ªå…ˆé †ä½1: ãƒ¡ã‚¤ãƒ³TaskExecutor
            ('task_executor', 'TaskExecutor', 'ãƒ¡ã‚¤ãƒ³'),
            # å„ªå…ˆé †ä½2: MATaskExecutor
            ('task_executor.task_executor_ma', 'MATaskExecutor', 'M&A'),
            # å„ªå…ˆé †ä½3: ContentTaskExecutor
            ('task_executor.content_task_executor', 'ContentTaskExecutor', 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„'),
        ]
        
        for module_path, class_name, executor_type in candidates:
            try:
                module = __import__(module_path, fromlist=[class_name])
                executor_class = getattr(module, class_name)
                temp_logger.info(f"âœ… {executor_type} Executor ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: {class_name}")
                return executor_class
            except ImportError as e:
                temp_logger.debug(f"âš ï¸ {module_path}.{class_name} ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            except AttributeError as e:
                temp_logger.debug(f"âš ï¸ {module_path} ã« {class_name} ãŒã‚ã‚Šã¾ã›ã‚“: {e}")
        
        temp_logger.error("âŒ åˆ©ç”¨å¯èƒ½ãªTaskExecutorã‚¯ãƒ©ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return None
    
    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–"""
        try:
            logger.info("="*60)
            logger.info("ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ã‚¿ãƒ¼ã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
    
            # === ãƒ‘ãƒ¼ãƒˆ1: Google Sheetsæ¥ç¶šã¨åŸºæœ¬è¨­å®šèª­ã¿è¾¼ã¿ ===
            logger.info("ğŸ“Š Google Sheetsæ¥ç¶šä¸­...")
    
            # Google Sheetsæ¥ç¶š
            self.sheets_manager = GoogleSheetsManager(
                self.spreadsheet_id, 
                self.service_account_file
            )
    
            # PC_IDã‚’å–å¾—ã—ã¦è¨­å®šã‚’èª­ã¿è¾¼ã¿
            pc_id = self.sheets_manager.get_current_pc_id()
            settings = self.sheets_manager.load_pc_settings(pc_id)
    
            # === ãƒ‘ãƒ¼ãƒˆ2: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã¨ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®š ===
            logger.info("ğŸ“ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šä¸­...")
    
            # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š
            agent_output = settings.get('agent_output_folder')
            if not agent_output or agent_output.startswith('http'):
                download_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                download_folder.mkdir(exist_ok=True, parents=True)
            else:
                download_folder = PathManager.get_safe_path(agent_output)
    
            logger.info(f"å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {download_folder}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: BrowserControlleråˆæœŸåŒ– ===
            logger.info("ğŸŒ ãƒ–ãƒ©ã‚¦ã‚¶åˆæœŸåŒ–ä¸­...")
            
            # BrowserControllerã‚’åˆæœŸåŒ–
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
        
            self.browser = BrowserController(
                download_folder, 
                mode='text', 
                service='google'
            )
            await self.browser.setup_browser()
            await self.browser.navigate_to_gemini()
            
            def resolve_task_executor():
                """åˆ©ç”¨å¯èƒ½ãªTaskExecutorã‚’å‹•çš„ã«è§£æ±º"""
                available_executors = []

                # MATaskExecutorã®ç¢ºèª
                try:
                    from task_executor.task_executor_ma import MATaskExecutor
                    available_executors.append(('ma', MATaskExecutor))
                except ImportError:
                    pass

                # ContentTaskExecutorã®ç¢ºèª
                try:
                    from task_executor.content_task_executor import ContentTaskExecutor
                    available_executors.append(('content', ContentTaskExecutor))
                except ImportError:
                    pass

                # TaskCoordinatorã®ç¢ºèª
                try:
                    from task_executor.task_coordinator import TaskCoordinator
                    available_executors.append(('coordinator', TaskCoordinator))
                except ImportError:
                    pass

                if available_executors:
                    executor_type, executor_class = available_executors[0]
                    logger.info(f"âœ… {executor_type} Executor ã‚’ä½¿ç”¨: {executor_class.__name__}")
                    return executor_class
                else:
                    logger.error("âŒ åˆ©ç”¨å¯èƒ½ãªTaskExecutorãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return None

            # ========================================
            # === ãƒ‘ãƒ¼ãƒˆ4: TaskExecutoråˆæœŸåŒ–ï¼ˆçµ±ä¸€ç‰ˆï¼‰ ===
            # ========================================
            logger.info("âš™ï¸ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ä¸­...")

            # ã‚¹ãƒ†ãƒƒãƒ—1: åˆ©ç”¨å¯èƒ½ãªExecutorã‚’è§£æ±º
            executor_class = resolve_task_executor()

            # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
            if executor_class is None:
                # resolve_task_executorã§è¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€TaskExecutorã‚’è©¦ã™
                if TaskExecutor is None:
                    logger.error("âŒ TaskExecutor ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ")
                    return False
                executor_class = TaskExecutor
                logger.info("âš™ï¸ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®TaskExecutorã‚’ä½¿ç”¨ã—ã¾ã™")

            # ã‚¹ãƒ†ãƒƒãƒ—3: Executorã®åˆæœŸåŒ–
            logger.info(f"ğŸš€ {executor_class.__name__} ã‚’åˆæœŸåŒ–ä¸­...")
            self.task_executor = executor_class(
                self.sheets_manager,
                self.browser,
                max_iterations=30
            )

            # ã‚¹ãƒ†ãƒƒãƒ—4: Executorç¨®åˆ¥ã®åˆ¤å®šãƒ•ãƒ©ã‚°
            is_ma_executor = 'MATaskExecutor' in executor_class.__name__
            is_standard_executor = 'TaskExecutor' in executor_class.__name__ and not is_ma_executor

            logger.info(f"ğŸ“ ä½¿ç”¨ã™ã‚‹Executor: {executor_class.__name__}")
            logger.info(f"   - MATaskExecutor: {is_ma_executor}")
            logger.info(f"   - æ¨™æº–TaskExecutor: {is_standard_executor}")
        
            # === ãƒ‘ãƒ¼ãƒˆ5: å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç™»éŒ² ===
            logger.info("ğŸ¤– ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²ä¸­...")
                
            # â˜…â˜…â˜… å„ç¨®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–ã¨ç™»éŒ² â˜…â˜…â˜…
                
            # 1. Design Agent
            try:
                from design_agent import DesignAgent
                self.design_agent = DesignAgent(self.browser)
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('design', self.design_agent)
                logger.info("âœ… Design AgentåˆæœŸåŒ–å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ design_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                self.design_agent = None

            # 2. Dev Agent
            try:
                from dev_agent import DevAgent
                self.dev_agent = DevAgent(self.browser)
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('dev', self.dev_agent)
                logger.info("âœ… Dev AgentåˆæœŸåŒ–å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ dev_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                self.dev_agent = None

            # 3. Review Agent
            try:
                from review_agent import ReviewAgent
                self.review_agent = ReviewAgent()
                self.review_agent.browser = self.browser
                self.review_agent.sheets_manager = self.sheets_manager
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_review_agent(self.review_agent)
                logger.info("âœ… Review AgentåˆæœŸåŒ–å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ review_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                self.review_agent = None

            # 4. Content Writer Agents
            try:
                from content_writer_agent import ContentWriterAgent
                self.content_writer = ContentWriterAgent(self.browser)
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('writer', self.content_writer)
                    self.task_executor.register_agent('content', self.content_writer)
                logger.info("âœ… Content Writer AgentåˆæœŸåŒ–å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ content_writer_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                self.content_writer = None
                
            # ========================================
            # 5. WordPress Agentï¼ˆé‡è¦ï¼ï¼‰
            # ========================================
            logger.info("ğŸ—„ï¸ WordPress Agentè¨­å®šä¸­...")
            
            # èªè¨¼æƒ…å ±ã®å–å¾—ã¨ãƒ­ã‚°å‡ºåŠ›
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
            
            # âœ… ãƒ‡ãƒãƒƒã‚°ï¼šèªè¨¼æƒ…å ±ã®çŠ¶æ…‹ã‚’ç¢ºèª
            logger.info("="*60)
            logger.info("ğŸ“‹ WordPressèªè¨¼æƒ…å ±ãƒã‚§ãƒƒã‚¯:")
            logger.info("="*60)
            logger.info(f"   - wp_url: {'âœ… è¨­å®šæ¸ˆã¿' if wp_url else 'âŒ æœªè¨­å®š'} ({len(wp_url)} chars)")
            logger.info(f"   - wp_user: {'âœ… è¨­å®šæ¸ˆã¿' if wp_user else 'âŒ æœªè¨­å®š'}")
            logger.info(f"   - wp_pass: {'âœ… è¨­å®šæ¸ˆã¿' if wp_pass else 'âŒ æœªè¨­å®š'}")
            logger.info("="*60)

            # ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã¨ã—ã¦åˆæœŸåŒ–ï¼ˆé‡è¦ï¼ï¼‰
            self.wordpress_agent = None

            if wp_url and wp_user and wp_pass:
                try:
                    logger.info("ğŸ“¦ WordPressAgentã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­...")
                    from wordpress.wp_agent import WordPressAgent
            
                    wp_credentials = {
                        'wp_url': wp_url,
                        'wp_user': wp_user,
                        'wp_pass': wp_pass
                    }
            
                    # âœ… self.wordpress_agent ã¨ã—ã¦ä¿å­˜
                    logger.info("ğŸ”§ WordPressAgentã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆä¸­...")
                    self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
                    logger.info("âœ… WordPressAgentã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆå®Œäº†")
                    
                    self.wordpress_agent.sheets_manager = self.sheets_manager
                    logger.info("âœ… sheets_manager ã‚’è¨­å®š")
            
                    logger.info("ğŸ” WordPressã¸ã®ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œä¸­...")
                    wp_login_success = await self.wordpress_agent.initialize_wp_session()
            
                    if wp_login_success:
                        logger.info("âœ… WordPressãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                        # âœ… ä¸€æ—¦ç™»éŒ²ï¼ˆå¾Œã§å†ç™»éŒ²ã•ã‚Œã‚‹ï¼‰
                        if hasattr(self, 'task_executor') and self.task_executor:
                            self.task_executor.register_agent('wordpress', self.wordpress_agent)
                            logger.info("âœ… WordPressAgent ä¸€æ™‚ç™»éŒ²å®Œäº†")
                        logger.info("âœ… WordPress AgentåˆæœŸåŒ–å®Œäº†")
                    else:
                        logger.warning("âš ï¸ WordPressãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                        logger.warning("âš ï¸ ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã§ã‚‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä¿æŒã—ã¾ã™")
                        # âœ… ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—ã§ã‚‚ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ä¿æŒï¼ˆé‡è¦ï¼ï¼‰
                        # self.wordpress_agent = None  # â† ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
            
                except Exception as e:
                    logger.error("="*60)
                    logger.error(f"âŒ WordPress AgentåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
                    logger.error("="*60)
                    import traceback
                    logger.error(traceback.format_exc())
                    logger.error("âš ï¸ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’Noneã«è¨­å®šã—ã¾ã™")
                    self.wordpress_agent = None
            else:
                logger.warning("="*60)
                logger.warning("âš ï¸ WordPressèªè¨¼æƒ…å ±ãŒæœªè¨­å®šã§ã™")
                logger.warning(f"   - wp_url: {bool(wp_url)}")
                logger.warning(f"   - wp_user: {bool(wp_user)}")
                logger.warning(f"   - wp_pass: {bool(wp_pass)}")
                logger.warning("="*60)
                
            # ========================================
            # 6. WordPress Dev Agent
            # ========================================
            logger.info("ğŸ”§ WordPress Dev Agentè¨­å®šä¸­...")
            self.wp_dev_agent = None
                
            try:
                from wordpress.wp_dev import WordPressDevAgent
                    
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                    
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('wp_dev', self.wp_dev_agent)
                logger.info("âœ… WordPress Dev Agent (wp_dev) åˆæœŸåŒ–å®Œäº†")
            except ImportError as e:
                logger.warning(f"âš ï¸ wordpress/wp_dev.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
                logger.info("ğŸ’¡ wp_dev ã‚¿ã‚¹ã‚¯ã¯æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
            except Exception as e:
                logger.warning(f"âš ï¸ wp_dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
                
            # ========================================
            # 7. WordPress Design Agent
            # ========================================
            logger.info("ğŸ¨ WordPress Design Agentè¨­å®šä¸­...")
            self.wp_design_agent = None
                
            try:
                from wordpress.wp_design import WordPressDesignAgent
                    
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                    
                if hasattr(self, 'task_executor') and self.task_executor:
                    self.task_executor.register_agent('wp_design', self.wp_design_agent)
                logger.info("âœ… WordPress Design Agent (wp_design) åˆæœŸåŒ–å®Œäº†")
            except ImportError as e:
                logger.warning(f"âš ï¸ wordpress/wp_design.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
                logger.info("ğŸ’¡ wp_design ã‚¿ã‚¹ã‚¯ã¯æ¨™æº– design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
            except Exception as e:
                logger.warning(f"âš ï¸ wp_design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
                
            # ========================================
            # âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†ï¼ˆå…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å¾Œï¼‰
            # ========================================
            logger.info("="*60)
            logger.info("âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("="*60)
            
            # ========================================
            # âœ… ãƒ‡ãƒãƒƒã‚°ï¼šis_ma_executor ãƒ•ãƒ©ã‚°ã®ç¢ºèª
            # ========================================
            logger.info("\n" + "="*60)
            logger.info("ğŸ” ãƒ‡ãƒãƒƒã‚°æƒ…å ±")
            logger.info("="*60)
            logger.info(f"Executorç¨®åˆ¥: {executor_class.__name__}")
            logger.info(f"is_ma_executor ãƒ•ãƒ©ã‚°: {is_ma_executor}")
            logger.info(f"wordpress_agent å­˜åœ¨: {hasattr(self, 'wordpress_agent')}")
            if hasattr(self, 'wordpress_agent'):
                logger.info(f"wordpress_agent å€¤: {self.wordpress_agent}")
                if self.wordpress_agent:
                    logger.info(f"plugin_manager å­˜åœ¨: {hasattr(self.wordpress_agent, 'plugin_manager')}")
                    if hasattr(self.wordpress_agent, 'plugin_manager'):
                        logger.info(f"plugin_manager å€¤: {self.wordpress_agent.plugin_manager}")
            logger.info("="*60)

            # ========================================
            # âœ… é‡è¦ï¼šMATaskExecutorç”¨ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå†ç™»éŒ²
            # ========================================

            if is_ma_executor:
                logger.info("\n" + "="*60)
                logger.info("ğŸ”„ MATaskExecutorç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå†ç™»éŒ²ä¸­...")
                logger.info("="*60)
        
                # ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å¤‰æ•°ã‹ã‚‰åˆæœŸåŒ–æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åé›†
                agents_to_register = {}
        
                # design_agentã®ç™»éŒ²
                if hasattr(self, 'design_agent') and self.design_agent:
                    agents_to_register['design'] = self.design_agent
        
                # dev_agentã®ç™»éŒ²
                if hasattr(self, 'dev_agent') and self.dev_agent:
                    agents_to_register['dev'] = self.dev_agent
        
                # review_agentã®ç™»éŒ²
                if hasattr(self, 'review_agent') and self.review_agent:
                    agents_to_register['review'] = self.review_agent
        
                # content_writerã®ç™»éŒ²
                if hasattr(self, 'content_writer') and self.content_writer:
                    agents_to_register['writer'] = self.content_writer
                    agents_to_register['content'] = self.content_writer
        
                # ========================================
                # âœ… é‡è¦ï¼šwordpress_agentã®ç™»éŒ²ï¼ˆãƒ‡ãƒãƒƒã‚°å¼·åŒ–ï¼‰
                # ========================================
                logger.info("\nğŸ“‹ wordpress_agent ç™»éŒ²ãƒã‚§ãƒƒã‚¯:")
                logger.info(f"   - hasattr: {hasattr(self, 'wordpress_agent')}")
                if hasattr(self, 'wordpress_agent'):
                    logger.info(f"   - value: {self.wordpress_agent}")
                    logger.info(f"   - is None: {self.wordpress_agent is None}")
                
                if hasattr(self, 'wordpress_agent') and self.wordpress_agent:
                    agents_to_register['wordpress'] = self.wordpress_agent
                    logger.info("  âœ… wordpress_agent ã‚’å–å¾—")
            
                    # wordpressã‹ã‚‰æ´¾ç”Ÿã™ã‚‹ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚‚ç™»éŒ²
                    if hasattr(self.wordpress_agent, 'plugin_manager'):
                        logger.info(f"  ğŸ“¦ plugin_manager å­˜åœ¨ç¢ºèª: {self.wordpress_agent.plugin_manager is not None}")
                        if self.wordpress_agent.plugin_manager:
                            agents_to_register['plugin'] = self.wordpress_agent.plugin_manager
                            logger.info("  âœ… plugin_manager ã‚’å–å¾—")
                        else:
                            logger.error("  âŒ plugin_manager is None!")
                    else:
                        logger.error("  âŒ plugin_manager å±æ€§ãŒå­˜åœ¨ã—ã¾ã›ã‚“!")
                else:
                    logger.error("  âŒ wordpress_agent ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼")
                    if hasattr(self, 'wordpress_agent'):
                        logger.error(f"     wordpress_agent is None: {self.wordpress_agent is None}")
        
                # wp_dev_agentã®ç™»éŒ²
                if hasattr(self, 'wp_dev_agent') and self.wp_dev_agent:
                    agents_to_register['wp_dev'] = self.wp_dev_agent
                elif hasattr(self, 'dev_agent') and self.dev_agent:
                    agents_to_register['wp_dev'] = self.dev_agent
                    logger.info("  ğŸ”„ wp_dev â†’ dev ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
        
                # wp_design_agentã®ç™»éŒ²
                if hasattr(self, 'wp_design_agent') and self.wp_design_agent:
                    agents_to_register['wp_design'] = self.wp_design_agent
                elif hasattr(self, 'design_agent') and self.design_agent:
                    agents_to_register['wp_design'] = self.design_agent
                    logger.info("  ğŸ”„ wp_design â†’ design ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
        
                # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä¸€æ‹¬ç™»éŒ²
                logger.info("\nğŸ“ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å‡¦ç†:")
                for agent_name, agent_instance in agents_to_register.items():
                    try:
                        self.task_executor.register_agent(agent_name, agent_instance)
                        logger.info(f"  âœ… {agent_name:15s} ç™»éŒ²å®Œäº†")
                    except Exception as e:
                        logger.error(f"  âŒ {agent_name:15s} ç™»éŒ²å¤±æ•—: {e}")
        
                # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç‰¹åˆ¥ç™»éŒ²
                if hasattr(self, 'review_agent') and self.review_agent:
                    try:
                        self.task_executor.register_review_agent(self.review_agent)
                        logger.info(f"  âœ… {'review (å°‚ç”¨)':15s} ç™»éŒ²å®Œäº†")
                    except Exception as e:
                        logger.error(f"  âŒ review (å°‚ç”¨) ç™»éŒ²å¤±æ•—: {e}")
        
                logger.info("="*60)
                logger.info(f"MATaskExecutor ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†: {len(agents_to_register)}å€‹")
                logger.info("="*60)
        
                # ãƒ‡ãƒãƒƒã‚°ï¼šç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸€è¦§ã‚’è¡¨ç¤º
                logger.info("\nğŸ“‹ ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸€è¦§:")
                for agent_name in self.task_executor.agents.keys():
                    logger.info(f"  - {agent_name}")
                logger.info("")
            else:
                logger.warning("\nâš ï¸ MATaskExecutorã§ã¯ãªã„ãŸã‚ã€å†ç™»éŒ²å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                logger.warning(f"   Executorç¨®åˆ¥: {executor_class.__name__}")
                logger.warning(f"   is_ma_executor: {is_ma_executor}")
                    
            # ========================================
            # âœ… æœ€å¾Œã«return
            # ========================================
            return True
                
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            raise
    
    async def test_tasks_by_role(self, role: str, auto: bool = False):
        """ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info(f"å½¹å‰² '{role}' ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
            logger.info(f"{'='*60}\n")
            
            # pm_tasksã‹ã‚‰è©²å½“ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
            all_tasks = await self.task_executor.load_pending_tasks()
            filtered_tasks = [t for t in all_tasks if t['required_role'].lower() == role.lower()]
            
            if not filtered_tasks:
                logger.error(f"âŒ å½¹å‰² '{role}' ã®pendingã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return
            
            logger.info(f"å¯¾è±¡ã‚¿ã‚¹ã‚¯: {len(filtered_tasks)}ä»¶\n")
            
            for i, task in enumerate(filtered_tasks, 1):
                logger.info(f"{i}. [{task['task_id']}] {task['description'][:80]}")
            
            if not auto:
                confirm = input(f"\nã“ã‚Œã‚‰ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
                if confirm.lower() != 'y':
                    logger.info("å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ")
                    return
            
            # ã‚¿ã‚¹ã‚¯ã‚’é †ç•ªã«å®Ÿè¡Œ
            completed = 0
            failed = 0
            
            for task in filtered_tasks:
                logger.info(f"\n{'='*60}")
                logger.info(f"ã‚¿ã‚¹ã‚¯ {task['task_id']} ã‚’å®Ÿè¡Œä¸­...")
                logger.info(f"{'='*60}")
                
                success = await self.task_executor.execute_task(task)
                
                if success:
                    completed += 1
                else:
                    failed += 1
                
                # æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¸ã®ç¢ºèª
                if not auto and task != filtered_tasks[-1]:
                    choice = input("\næ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: (c)ç¶šè¡Œ / (q)çµ‚äº†: ").lower()
                    if choice == 'q':
                        break
            
            # ã‚µãƒãƒªãƒ¼è¡¨ç¤º
            logger.info(f"\n{'='*60}")
            logger.info("ãƒ†ã‚¹ãƒˆå®Ÿè¡Œå®Œäº†")
            logger.info(f"{'='*60}")
            logger.info(f"å®Œäº†: {completed}ä»¶")
            logger.info(f"å¤±æ•—: {failed}ä»¶")
            logger.info(f"{'='*60}")
            
        except Exception as e:
            ErrorHandler.log_error(e, f"å½¹å‰² '{role}' ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
    
    async def test_all_pending_tasks(self, auto: bool = False):
        """å…¨ã¦ã®pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        try:
            logger.info(f"\n{'='*60}")
            logger.info("å…¨pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
            logger.info(f"{'='*60}\n")
            
            # TaskExecutorã®é€šå¸¸å®Ÿè¡Œã‚’ä½¿ç”¨
            await self.task_executor.run_all_tasks(
                auto_continue=auto,
                enable_review=False  # ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼ãªã—
            )
            
        except Exception as e:
            ErrorHandler.log_error(e, "å…¨ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ")
    
    def _display_task_info(self, task: dict):
        """ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’è¡¨ç¤º"""
        print("\n" + "="*60)
        print("ã‚¿ã‚¹ã‚¯è©³ç´°")
        print("="*60)
        print(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}")
        print(f"èª¬æ˜: {task['description']}")
        print(f"æ‹…å½“: {task['required_role']}")
        print(f"å„ªå…ˆåº¦: {task['priority']}")
        print(f"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task['status']}")
        
        if 'language' in task:
            print(f"è¨€èª: {task['language']}")
        if 'polylang_lang' in task:
            print(f"Polylang: {task['polylang_lang']}")
        if 'source_task_id' in task:
            print(f"å…ƒè¨˜äº‹ã‚¿ã‚¹ã‚¯ID: {task['source_task_id']}")
        if 'post_action' in task:
            print(f"æŠ•ç¨¿ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {task['post_action']}")
        if 'post_status' in task:
            print(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task['post_status']}")
        
        print("="*60)
    
    async def cleanup(self):
        """ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.browser:
            await self.browser.cleanup()

async def main():
    parser = argparse.ArgumentParser(
        description='pm_tasksã®æ—¢å­˜ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ä¾‹:
  python test_tasks.py                    # å…¨pendingã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
  python test_tasks.py --task-id 5        # ã‚¿ã‚¹ã‚¯ID 5ã®ã¿å®Ÿè¡Œ
  python test_tasks.py --role writer      # writer ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ
  python test_tasks.py --role wordpress --auto  # wordpress ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•å®Ÿè¡Œ
        """
    )
    
    parser.add_argument('--task-id', type=str, help='ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã®ã¿å®Ÿè¡Œ')
    parser.add_argument('--role', type=str, help='ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ (design, dev, writer, wordpress, etc.)')
    parser.add_argument('--auto', action='store_true', help='è‡ªå‹•å®Ÿè¡Œï¼ˆç¢ºèªãªã—ï¼‰')
    parser.add_argument('--spreadsheet-id', type=str, help='ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDï¼ˆconfig.pyã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä¸Šæ›¸ãï¼‰')
    
    args = parser.parse_args()
    
    # ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID
    spreadsheet_id = args.spreadsheet_id or config.SPREADSHEET_ID
    
    # service_account.json ã®ãƒ‘ã‚¹
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
    
    # TaskTesterã‚’åˆæœŸåŒ–
    tester = TaskTester(spreadsheet_id, service_account_file)
    
    try:
        await tester.initialize()
        
        # ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦å®Ÿè¡Œ
        if args.task_id:
            # ç‰¹å®šã®ã‚¿ã‚¹ã‚¯IDã‚’ãƒ†ã‚¹ãƒˆ
            await tester.test_specific_task(args.task_id)
        
        elif args.role:
            # ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆ
            await tester.test_tasks_by_role(args.role, auto=args.auto)
        
        else:
            # å…¨ã¦ã®pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆ
            await tester.test_all_pending_tasks(auto=args.auto)
        
    except KeyboardInterrupt:
        logger.info("\n\nâš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
    
    except Exception as e:
        logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        await tester.cleanup()
        logger.info("\nğŸ‘‹ ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ã‚¿ãƒ¼ã‚’çµ‚äº†ã—ã¾ã—ãŸ")


if __name__ == "__main__":
    asyncio.run(main())

#workflow_executor.py
"""
workflow_executor.py - è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ãƒ»ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€£æºã‚¿ã‚¹ã‚¯ã‚’çµ±åˆç®¡ç†
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# è¨­å®š
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

# æ—¢å­˜ã®TaskExecutor
from task_executor import TaskExecutor

logger = logging.getLogger(__name__)


class WorkflowExecutor:
    """
    è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—ã€ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€£æºã€
    ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£ã‚µã‚¤ã‚¯ãƒ«ã€å¤šè¨€èªå±•é–‹ãªã©ã‚’çµ±åˆç®¡ç†
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            task_executor: æ—¢å­˜ã®TaskExecutorã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±è¨ˆ
        self.workflow_stats = {
            'total_workflows': 0,
            'completed': 0,
            'failed': 0,
            'partial_success': 0
        }
        
        logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
    
    async def execute_workflow_task(self, task: Dict) -> Dict:
        """
        ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        workflow_type = self._determine_workflow_type(task)
        
        self.workflow_stats['total_workflows'] += 1
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ”„ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info(f"ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—: {workflow_type}")
            logger.info("=" * 60)
            
            result = None
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ
            if workflow_type == 'multilingual':
                result = await self._execute_multilingual_workflow(task)
            elif workflow_type == 'review_cycle':
                result = await self._execute_review_cycle_workflow(task)
            elif workflow_type == 'sequential':
                result = await self._execute_sequential_workflow(task)
            elif workflow_type == 'parallel':
                result = await self._execute_parallel_workflow(task)
            elif workflow_type == 'conditional':
                result = await self._execute_conditional_workflow(task)
            else:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«å®Ÿè¡Œ
                result = await self._execute_sequential_workflow(task)
            
            # çµ±è¨ˆæ›´æ–°
            if result and result.get('success'):
                self.workflow_stats['completed'] += 1
            elif result and result.get('partial_success'):
                self.workflow_stats['partial_success'] += 1
            else:
                self.workflow_stats['failed'] += 1
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"WorkflowExecutor.execute_workflow_task({task_id})")
            self.workflow_stats['failed'] += 1
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_workflow_type(self, task: Dict) -> str:
        """
        ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—
        """
        description = task.get('description', '').lower()
        
        # å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['å¤šè¨€èª', 'ç¿»è¨³', 'multilingual', 'translation']):
            return 'multilingual'
        
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£', 'review cycle', 'iterative review']):
            return 'review_cycle'
        
        # ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['ä¸¦åˆ—', 'åŒæ™‚', 'parallel', 'concurrent']):
            return 'parallel'
        
        # æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['æ¡ä»¶', 'åˆ†å²', 'conditional', 'if-then']):
            return 'conditional'
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«
        return 'sequential'
    
    async def _execute_multilingual_workflow(self, task: Dict) -> Dict:
        """
        å¤šè¨€èªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆPolylangé€£æºå¼·åŒ–ç‰ˆï¼‰
            
        1. æ—¥æœ¬èªè¨˜äº‹ç”Ÿæˆ
        2. è‹±èªç¿»è¨³
        3. ãã®ä»–è¨€èªç¿»è¨³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        4. WordPresså¤šè¨€èªæŠ•ç¨¿ï¼ˆPolylangé€£æºï¼‰
            
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
                
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("ğŸŒ å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œï¼ˆPolylangé€£æºç‰ˆï¼‰")
                
            # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨€èªãƒªã‚¹ãƒˆ
            target_languages = task.get('target_languages', ['ja', 'en'])
            base_language = task.get('base_language', 'ja')
                
            # Polylangè¨€èªã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
            polylang_lang_codes = {
                'ja': 'ja',
                'en': 'en',
                'uz': 'uz_UZ',  # ã‚¦ã‚ºãƒ™ã‚¯èª
                'ru': 'ru_RU',  # ãƒ­ã‚·ã‚¢èª
                'tr': 'tr_TR',  # ãƒˆãƒ«ã‚³èª
                'zh': 'zh_CN',  # ä¸­å›½èª
                'ko': 'ko_KR'   # éŸ“å›½èª
            }
                
            results = {}
            contents = {}
            post_ids = {}  # æŠ•ç¨¿IDã‚’ä¿å­˜ï¼ˆPolylangé€£æºç”¨ï¼‰
                
            # ========================================
            # ã‚¹ãƒ†ãƒƒãƒ—1: åŸºæœ¬è¨€èªã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
            # ========================================
            logger.info(f"--- ã‚¹ãƒ†ãƒƒãƒ—1: {base_language} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ ---")
                
            base_task = {
                **task,
                'task_id': f"{task_id}_base_{base_language}",
                'language': base_language,
                'required_role': 'content'
            }
                
            base_result = await self.task_executor.execute_task(base_task)
                
            if not base_result:
                return {
                    'success': False,
                    'error': f'{base_language} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—'
                }
                
            results[base_language] = base_result
                
            # åŸºæœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å–å¾—
            base_content = ""
            if hasattr(base_result, 'get'):
                base_content = base_result.get('full_text', base_result.get('content', ''))
                
            contents[base_language] = base_content
                
            # ========================================
            # ã‚¹ãƒ†ãƒƒãƒ—2: ä»–è¨€èªã¸ã®ç¿»è¨³
            # ========================================
            for lang in target_languages:
                if lang == base_language:
                    continue
                    
                logger.info(f"--- ã‚¹ãƒ†ãƒƒãƒ—2-{lang}: {lang} ç¿»è¨³ ---")
                    
                translation_task = {
                    'task_id': f"{task_id}_translate_{lang}",
                    'description': f'{base_language}ã‹ã‚‰{lang}ã«ç¿»è¨³',
                    'prompt': f'ä»¥ä¸‹ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’{lang}ã«ç¿»è¨³ã—ã¦ãã ã•ã„:\n\n{base_content}',
                    'required_role': 'content',
                    'language': lang,
                    'source_language': base_language,
                    'target_language': lang,
                    'source_text': base_content
                }
                    
                translate_result = await self.task_executor.execute_task(translation_task)
                    
                results[lang] = translate_result
                    
                if translate_result and hasattr(translate_result, 'get'):
                    translated_content = translate_result.get('full_text', translate_result.get('content', ''))
                    contents[lang] = translated_content
                else:
                    logger.warning(f"âš ï¸ {lang} ç¿»è¨³å¤±æ•—")
                    
                await asyncio.sleep(2)
                
            # ========================================
            # ã‚¹ãƒ†ãƒƒãƒ—3: WordPresså¤šè¨€èªæŠ•ç¨¿ï¼ˆPolylangé€£æºå¼·åŒ–ç‰ˆï¼‰
            # ========================================
            if task.get('auto_publish', False):
                logger.info("--- ã‚¹ãƒ†ãƒƒãƒ—3: WordPresså¤šè¨€èªæŠ•ç¨¿ï¼ˆPolylangé€£æºï¼‰ ---")
                    
                # 3-1: åŸºæœ¬è¨€èªã®æŠ•ç¨¿ã‚’ä½œæˆ
                base_lang_code = polylang_lang_codes.get(base_language, base_language)
                base_wp_task = {
                    'task_id': f"{task_id}_publish_{base_language}",
                    'description': f'{base_language} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’WordPressã«æŠ•ç¨¿',
                    'required_role': 'wordpress',
                    'language': base_language,
                    'polylang_lang': base_lang_code,
                    'post_action': 'create',
                    'post_title': task.get('post_title', f'è¨˜äº‹_{base_language}'),
                    'post_content': contents.get(base_language, ''),
                    'post_status': 'draft'  # ä¸‹æ›¸ãã§ä½œæˆ
                }
                    
                base_publish_result = await self.task_executor.execute_task(base_wp_task)
                results[f'{base_language}_publish'] = base_publish_result
                    
                # æŠ•ç¨¿IDã‚’å–å¾—
                if base_publish_result and hasattr(base_publish_result, 'get'):
                    base_post_id = base_publish_result.get('post_id')
                    if base_post_id:
                        post_ids[base_language] = base_post_id
                        logger.info(f"âœ… {base_language} æŠ•ç¨¿ID: {base_post_id}")
                    
                await asyncio.sleep(2)
                    
                # 3-2: ç¿»è¨³æŠ•ç¨¿ã‚’ä½œæˆã—ã€Polylangã§é€£æº
                for lang, content in contents.items():
                    if lang == base_language or not content:
                        continue
                        
                    lang_code = polylang_lang_codes.get(lang, lang)
                        
                    wp_task = {
                        'task_id': f"{task_id}_publish_{lang}",
                        'description': f'{lang} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’WordPressã«æŠ•ç¨¿ï¼ˆPolylangé€£æºï¼‰',
                        'required_role': 'wordpress',
                        'language': lang,
                        'polylang_lang': lang_code,
                        'post_action': 'create',
                        'post_title': task.get('post_title', f'è¨˜äº‹_{lang}'),
                        'post_content': content,
                        'post_status': 'draft',
                        # ========================================
                        # ğŸ†• Polylangé€£æºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆæ–°è¦è¿½åŠ ï¼‰
                        # ========================================
                        'polylang_link_to': post_ids.get(base_language),  # åŸºæœ¬è¨€èªã®æŠ•ç¨¿IDã¨ãƒªãƒ³ã‚¯
                        'polylang_translation_group': task_id  # ç¿»è¨³ã‚°ãƒ«ãƒ¼ãƒ—ID
                    }
                        
                    publish_result = await self.task_executor.execute_task(wp_task)
                    results[f'{lang}_publish'] = publish_result
                        
                    # æŠ•ç¨¿IDã‚’å–å¾—
                    if publish_result and hasattr(publish_result, 'get'):
                        post_id = publish_result.get('post_id')
                        if post_id:
                            post_ids[lang] = post_id
                            logger.info(f"âœ… {lang} æŠ•ç¨¿ID: {post_id}")
                        
                    await asyncio.sleep(2)
                    
                # ========================================
                # ğŸ†• ã‚¹ãƒ†ãƒƒãƒ—3-3: Polylangç¿»è¨³ãƒªãƒ³ã‚¯ã®è¨­å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰
                # ========================================
                if len(post_ids) > 1:
                    logger.info("--- ã‚¹ãƒ†ãƒƒãƒ—3-3: Polylangç¿»è¨³ãƒªãƒ³ã‚¯è¨­å®š ---")
                        
                    polylang_link_task = {
                        'task_id': f"{task_id}_polylang_link",
                        'description': 'Polylangç¿»è¨³ãƒªãƒ³ã‚¯ã‚’è¨­å®š',
                        'required_role': 'wordpress',
                        'action': 'polylang_link_translations',
                        'post_ids': post_ids,  # {'ja': 123, 'en': 124, ...}
                        'translation_group': task_id
                    }
                        
                    link_result = await self.task_executor.execute_task(polylang_link_task)
                    results['polylang_link'] = link_result
                        
                    if link_result and hasattr(link_result, 'get') and link_result.get('success'):
                        logger.info("âœ… Polylangç¿»è¨³ãƒªãƒ³ã‚¯è¨­å®šå®Œäº†")
                    else:
                        logger.warning("âš ï¸ Polylangç¿»è¨³ãƒªãƒ³ã‚¯è¨­å®šå¤±æ•—ï¼ˆæ‰‹å‹•ã§è¨­å®šãŒå¿…è¦ï¼‰")
                
            # ========================================
            # çµæœé›†ç´„
            # ========================================
            success_count = sum(1 for r in results.values() if r and (r is True or (hasattr(r, 'get') and r.get('success'))))
            total_count = len(results)
                
            logger.info(f"âœ… å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Œäº†: {success_count}/{total_count} æˆåŠŸ")
                
            return {
                'success': success_count == total_count,
                'partial_success': success_count > 0 and success_count < total_count,
                'results': results,
                'contents': contents,
                'post_ids': post_ids,  # æŠ•ç¨¿IDæƒ…å ±ã‚’è¿½åŠ 
                'summary': f'{success_count}/{total_count} è¨€èªã§æˆåŠŸï¼ˆæŠ•ç¨¿æ•°: {len(post_ids)}ï¼‰',
                'full_text': '\n\n---\n\n'.join([f'[{lang}]\n{content}' for lang, content in contents.items()])
            }
            
        except Exception as e:
            logger.error(f"âŒ å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_multilingual_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_review_cycle_workflow(self, task: Dict) -> Dict:
        """
        ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        
        1. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
        2. ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
        3. ä¿®æ­£æŒ‡ç¤ºã«åŸºã¥ã„ã¦å†ç”Ÿæˆ
        4. æœ€çµ‚æ‰¿èªã¾ã§ç¹°ã‚Šè¿”ã—
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        max_iterations = task.get('max_review_iterations', 3)
        
        try:
            logger.info("ğŸ”„ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            
            iteration = 0
            current_content = None
            review_history = []
            
            while iteration < max_iterations:
                iteration += 1
                logger.info(f"--- ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ« {iteration}/{max_iterations} ---")
                
                # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆï¼ˆåˆå›ï¼‰ã¾ãŸã¯ä¿®æ­£ï¼ˆ2å›ç›®ä»¥é™ï¼‰
                if iteration == 1:
                    logger.info("åˆå›ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ")
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'required_role': 'content'
                    }
                else:
                    logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã«åŸºã¥ãä¿®æ­£")
                    last_review = review_history[-1]
                    feedback = last_review.get('feedback', '')
                    
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'prompt': f'{task.get("prompt", "")}\n\nå‰å›ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯:\n{feedback}\n\nä¸Šè¨˜ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’åæ˜ ã—ã¦ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚',
                        'required_role': 'content'
                    }
                
                content_result = await self.task_executor.execute_task(content_task)
                
                if not content_result:
                    logger.error("ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—")
                    break
                
                if hasattr(content_result, 'get'):
                    current_content = content_result.get('full_text', content_result.get('content', ''))
                else:
                    current_content = str(content_result)
                
                # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
                logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ")
                review_task = {
                    'task_id': f"{task_id}_review_v{iteration}",
                    'description': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ¬ãƒ“ãƒ¥ãƒ¼',
                    'required_role': 'review',
                    'review_target_task_id': f"{task_id}_content_v{iteration}",
                    'content_to_review': current_content
                }
                
                review_result = await self.task_executor.execute_task(review_task)
                
                if not review_result or not hasattr(review_result, 'get'):
                    logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œå¤±æ•— - ã‚µã‚¤ã‚¯ãƒ«çµ‚äº†")
                    break
                
                review_history.append(review_result)
                
                # ã‚¹ãƒ†ãƒƒãƒ—3: æ‰¿èªåˆ¤å®š
                approved = review_result.get('approved', False)
                
                if approved:
                    logger.info(f"âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼æ‰¿èª (åå¾©{iteration}å›)")
                    return {
                        'success': True,
                        'content': current_content,
                        'iterations': iteration,
                        'review_history': review_history,
                        'full_text': current_content,
                        'summary': f'{iteration}å›ã®åå¾©ã§æ‰¿èª'
                    }
                else:
                    logger.info(f"ğŸ”„ ä¿®æ­£ãŒå¿…è¦ - æ¬¡ã®åå¾©ã¸")
                    await asyncio.sleep(2)
            
            # æœ€å¤§åå¾©å›æ•°åˆ°é”
            logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•°({max_iterations})åˆ°é” - æœ€çµ‚ç‰ˆã‚’è¿”å´")
            
            return {
                'success': False,
                'partial_success': True,
                'content': current_content,
                'iterations': iteration,
                'review_history': review_history,
                'full_text': current_content,
                'summary': f'{iteration}å›åå¾©ã—ãŸãŒæ‰¿èªã•ã‚Œãš',
                'error': 'æœ€å¤§åå¾©å›æ•°åˆ°é”'
            }
        
        except Exception as e:
            logger.error(f"âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_review_cycle_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_sequential_workflow(self, task: Dict) -> Dict:
        """
        ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆé †æ¬¡å®Ÿè¡Œï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©ãªã— - å˜ä¸€ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ")
            result = await self.task_executor.execute_task(task)
            return {'success': bool(result), 'result': result}
        
        try:
            logger.info(f"ğŸ“‹ ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ ({len(steps)}ã‚¹ãƒ†ãƒƒãƒ—)")
            
            results = []
            accumulated_output = {}
            
            for i, step in enumerate(steps, 1):
                logger.info(f"--- ã‚¹ãƒ†ãƒƒãƒ— {i}/{len(steps)}: {step.get('description', 'N/A')} ---")
                
                # ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯æ§‹ç¯‰
                step_task = {
                    **task,
                    **step,  # ã‚¹ãƒ†ãƒƒãƒ—è¨­å®šã§ä¸Šæ›¸ã
                    'task_id': f"{task_id}_step{i}",
                }
                
                # å‰ã‚¹ãƒ†ãƒƒãƒ—ã®å‡ºåŠ›ã‚’å‚ç…§
                if step.get('use_previous_output') and accumulated_output:
                    prev_output = accumulated_output.get(f'step{i-1}', '')
                    if 'prompt' in step_task:
                        step_task['prompt'] = step_task['prompt'].replace(
                            '{previous_output}',
                            str(prev_output)
                        )
                
                # ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
                step_result = await self.task_executor.execute_task(step_task)
                
                results.append(step_result)
                accumulated_output[f'step{i}'] = step_result
                
                # å¤±æ•—æ™‚ã®å‡¦ç†
                if not step_result or (hasattr(step_result, 'get') and not step_result.get('success')):
                    if step.get('continue_on_failure', False):
                        logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—ã—ãŸãŒç¶™ç¶š")
                    else:
                        logger.error(f"âŒ ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•— - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä¸­æ–­")
                        return {
                            'success': False,
                            'error': f'ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—',
                            'completed_steps': i - 1,
                            'results': results
                        }
                
                logger.info(f"âœ… ã‚¹ãƒ†ãƒƒãƒ— {i} å®Œäº†")
                await asyncio.sleep(1)
            
            logger.info(f"âœ… å…¨ {len(steps)} ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†")
            
            return {
                'success': True,
                'steps_completed': len(steps),
                'results': results,
                'accumulated_output': accumulated_output,
                'full_text': str(accumulated_output)
            }
        
        except Exception as e:
            logger.error(f"âŒ ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_sequential_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_parallel_workflow(self, task: Dict) -> Dict:
        """
        ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆè¤‡æ•°ã‚¿ã‚¹ã‚¯åŒæ™‚å®Ÿè¡Œï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        parallel_tasks = task.get('parallel_tasks', [])
        
        if not parallel_tasks:
            logger.warning("ä¸¦åˆ—ã‚¿ã‚¹ã‚¯å®šç¾©ãªã—")
            return {'success': False, 'error': 'ä¸¦åˆ—ã‚¿ã‚¹ã‚¯ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            logger.info(f"âš¡ ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ ({len(parallel_tasks)}ã‚¿ã‚¹ã‚¯)")
            
            # ä¸¦åˆ—ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆæ§‹ç¯‰
            coroutines = []
            for i, parallel_task in enumerate(parallel_tasks, 1):
                parallel_task_config = {
                    **task,
                    **parallel_task,
                    'task_id': f"{task_id}_parallel{i}"
                }
                coroutines.append(
                    self.task_executor.execute_task(parallel_task_config)
                )
            
            # ä¸¦åˆ—å®Ÿè¡Œ
            results = await asyncio.gather(*coroutines, return_exceptions=True)
            
            # çµæœåˆ†æ
            success_count = sum(
                1 for r in results 
                if r and not isinstance(r, Exception) and (r is True or (hasattr(r, 'get') and r.get('success')))
            )
            
            logger.info(f"âœ… ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Œäº†: {success_count}/{len(results)} æˆåŠŸ")
            
            return {
                'success': success_count == len(results),
                'partial_success': success_count > 0 and success_count < len(results),
                'results': results,
                'summary': f'{success_count}/{len(results)} ã‚¿ã‚¹ã‚¯æˆåŠŸ'
            }
        
        except Exception as e:
            logger.error(f"âŒ ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_parallel_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_conditional_workflow(self, task: Dict) -> Dict:
        """
        æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("ğŸ”€ æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            
            # æ¡ä»¶è©•ä¾¡ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
            condition_task = task.get('condition_task')
            if not condition_task:
                return {'success': False, 'error': 'æ¡ä»¶ã‚¿ã‚¹ã‚¯ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“'}
            
            condition_result = await self.task_executor.execute_task(condition_task)
            
            # æ¡ä»¶è©•ä¾¡
            condition_met = self._evaluate_condition(condition_result, task.get('condition'))
            
            # åˆ†å²å®Ÿè¡Œ
            if condition_met:
                logger.info("âœ… æ¡ä»¶æˆç«‹ - thenåˆ†å²å®Ÿè¡Œ")
                then_task = task.get('then_task')
                if then_task:
                    result = await self.task_executor.execute_task(then_task)
                    return {'success': True, 'branch': 'then', 'result': result}
            else:
                logger.info("âŒ æ¡ä»¶ä¸æˆç«‹ - elseåˆ†å²å®Ÿè¡Œ")
                else_task = task.get('else_task')
                if else_task:
                    result = await self.task_executor.execute_task(else_task)
                    return {'success': True, 'branch': 'else', 'result': result}
            
            return {'success': True, 'branch': 'none'}
        
        except Exception as e:
            logger.error(f"âŒ æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_conditional_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _evaluate_condition(self, result: Any, condition: Dict) -> bool:
        """
        æ¡ä»¶ã‚’è©•ä¾¡
        
        Args:
            result: è©•ä¾¡å¯¾è±¡ã®çµæœ
            condition: æ¡ä»¶å®šç¾©è¾æ›¸
            
        Returns:
            bool: æ¡ä»¶æˆç«‹ãƒ•ãƒ©ã‚°
        """
        if not condition:
            return True
        
        condition_type = condition.get('type', 'success')
        
        if condition_type == 'success':
            return result and (result is True or (hasattr(result, 'get') and result.get('success')))
        elif condition_type == 'contains':
            target_text = condition.get('text', '')
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return target_text.lower() in content.lower()
        elif condition_type == 'length':
            min_length = condition.get('min_length', 0)
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return len(content) >= min_length
        
        return False
    
    def get_workflow_stats(self) -> Dict:
        """ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        return self.workflow_stats.copy()

#wp_acf_agent.py
"""
WordPress ACFè¨­è¨ˆãƒ»è¨­å®šã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressACFAgent:
    """ACFè¨­è¨ˆãƒ»è¨­å®šå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """ACFã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        # å®Ÿè£…ï¼ˆwp_cpt_agent.py ã¨åŒæ§˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        return {
            'success': True,
            'message': 'ACFè¨­å®šå®Œäº†ï¼ˆå®Ÿè£…ä¸­ï¼‰',
            'task_id': task.get('task_id')
        }
        
"""
å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³ä¾‹
ï¼ˆwp_acf_agent.py, wp_cpt_agent.py ãªã©ã«é©ç”¨ï¼‰

âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¿®æ­£å‰ï¼‰
âœ… å®‰å…¨ãªãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¿®æ­£å¾Œï¼‰
"""

# ========================================
# âŒ ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³1: æ¡ä»¶åˆ†å²å¤–ã§ã®å¤‰æ•°å‚ç…§
# ========================================

# --- ä¿®æ­£å‰ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿï¼‰ ---
async def save_generated_code_BAD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """âŒ ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™"""
    
    # æ¡ä»¶åˆ†å²å†…ã§ã®ã¿å¤‰æ•°ã‚’å®šç¾©
    if output_type == 'php':
        php_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        json_filename = f"acf_{task_id}.json"
    
    # ã“ã“ã§å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã¨ã€æ¡ä»¶ã«åˆè‡´ã—ãªã‹ã£ãŸå ´åˆã«ã‚¨ãƒ©ãƒ¼ï¼
    # UnboundLocalError: cannot access local variable 'php_filename' where it is not associated with a value
    await self.browser.save_text_to_file(content, php_filename)  # âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿç®‡æ‰€


# --- ä¿®æ­£å¾Œï¼ˆå®‰å…¨ï¼‰ ---
async def save_generated_code_GOOD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """âœ… ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å®‰å…¨ã§ã™"""
    
    # === æ–¹æ³•1: æœ€åˆã«å¤‰æ•°ã‚’åˆæœŸåŒ– ===
    final_filename = None  # æœ€åˆã«åˆæœŸåŒ–ï¼ˆé‡è¦ï¼ï¼‰
    
    if output_type == 'php':
        final_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        final_filename = f"acf_{task_id}.json"
    else:
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®šï¼ˆã©ã®æ¡ä»¶ã«ã‚‚åˆè‡´ã—ãªã„å ´åˆï¼‰
        final_filename = f"output_{task_id}.txt"
    
    # å®‰å…¨ã«å‚ç…§å¯èƒ½
    if final_filename:
        await self.browser.save_text_to_file(content, final_filename)
    else:
        logger.error("âŒ ãƒ•ã‚¡ã‚¤ãƒ«åãŒæ±ºå®šã§ãã¾ã›ã‚“ã§ã—ãŸ")


# ========================================
# âŒ ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³2: è¤‡é›‘ãªæ¡ä»¶åˆ†å²
# ========================================

# --- ä¿®æ­£å‰ï¼ˆã‚¨ãƒ©ãƒ¼ãƒªã‚¹ã‚¯é«˜ï¼‰ ---
async def process_and_save_BAD(self, task: dict, generated_content: str):
    """âŒ è¤‡é›‘ãªæ¡ä»¶ã§ã‚¨ãƒ©ãƒ¼ãƒªã‚¹ã‚¯ãŒé«˜ã„"""
    
    task_type = task.get('type')
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = 'ma_case_template.php'
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = 'acf_fields.json'
    
    # ä¸Šè¨˜ã®æ¡ä»¶ã«åˆè‡´ã—ãªã„å ´åˆã€output_filenameãŒæœªå®šç¾©ï¼
    save_result = await self._save_file(output_filename, generated_content)  # âŒ ã‚¨ãƒ©ãƒ¼


# --- ä¿®æ­£å¾Œï¼ˆå®‰å…¨ï¼‰ ---
async def process_and_save_GOOD(self, task: dict, generated_content: str):
    """âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§å®‰å…¨ã«å‡¦ç†"""
    
    task_type = task.get('type')
    task_id = task.get('task_id', 'unknown')
    
    # === ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æœ€åˆã«è¨­å®š ===
    output_filename = f"output_{task_id}.txt"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = f"ma_case_template_{task_id}.php"
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = f"acf_fields_{task_id}.json"
    
    # å¸¸ã«output_filenameãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§å®‰å…¨
    save_result = await self._save_file(output_filename, generated_content)  # âœ… å®‰å…¨


# ========================================
# âœ… æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³: è¦ªã‚¯ãƒ©ã‚¹ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨
# ========================================

class WordPressACFAgent:
    """ACFè¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆä¿®æ­£ä¾‹ï¼‰"""
    
    def __init__(self, browser, output_folder, parent_agent=None):
        self.browser = browser
        self.output_folder = output_folder
        self.parent_agent = parent_agent  # è¦ªã®WordPressDevAgentã¸ã®å‚ç…§
    
    async def execute(self, task: dict):
        """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ"""
        task_id = task.get('task_id', 'unknown')
        
        try:
            # AIã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
            generated_content = await self._generate_acf_fields(task)
            
            # === æ¨å¥¨: è¦ªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®‰å…¨ãªãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ä½¿ç”¨ ===
            if self.parent_agent and hasattr(self.parent_agent, 'safe_save_code_file'):
                save_result = await self.parent_agent.safe_save_code_file(
                    content=generated_content,
                    task_id=task_id,
                    file_type='json',  # or 'php'
                    custom_filename=None  # è‡ªå‹•ç”Ÿæˆ
                )
                
                if save_result['success']:
                    logger.info(f"âœ… ä¿å­˜æˆåŠŸ: {save_result['filepath']}")
                    return {
                        'success': True,
                        'output_file': save_result['filepath']
                    }
                else:
                    logger.error(f"âŒ ä¿å­˜å¤±æ•—: {save_result['error']}")
                    return {
                        'success': False,
                        'error': save_result['error']
                    }
            else:
                # === ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è‡ªå‰ã§å®‰å…¨ã«å‡¦ç† ===
                return await self._safe_save_fallback(task_id, generated_content)
        
        except Exception as e:
            logger.error(f"âŒ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _safe_save_fallback(self, task_id: str, content: str):
        """å®‰å…¨ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¿å­˜"""
        # å¤‰æ•°ã‚’æœ€åˆã«åˆæœŸåŒ–
        filename = None
        saved_path = None
        
        try:
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åæ±ºå®š
            filename = f"acf_output_{task_id}_{timestamp}.json"
            output_path = self.output_folder / filename
            
            # ä¿å­˜å®Ÿè¡Œ
            if hasattr(self.browser, 'save_text_to_file'):
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
            else:
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                saved_path = str(output_path)
            
            return {
                'success': True,
                'output_file': saved_path
            }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}"
            }


# ========================================
# ğŸ”§ å®Ÿéš›ã®ä¿®æ­£æ‰‹é †ï¼ˆå„å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§å®Ÿè¡Œï¼‰
# ========================================

"""
1. wordpress/wp_dev/__init__.py ã‚’ç¢ºèªã—ã€è¦ªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å‚ç…§ã‚’æ¸¡ã™:

   from .wp_acf_agent import WordPressACFAgent
   
   # åˆæœŸåŒ–æ™‚ã«è¦ªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ¸¡ã™
   def create_agents(browser, output_folder, parent):
       acf_agent = WordPressACFAgent(
           browser, 
           output_folder,
           parent_agent=parent  # è¿½åŠ 
       )
       return acf_agent

2. å„å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆwp_acf_agent.py ãªã©ï¼‰å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ¢ã™:
   
   æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:
   - "filename" + "if" ã¾ãŸã¯ "elif"
   - "save" + "file"
   - ".php" ã¾ãŸã¯ ".json"

3. ä¸Šè¨˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã£ã¦ä¿®æ­£:
   
   ä¿®æ­£å‰:
   ```python
   if condition:
       php_filename = "something.php"
   
   await save(php_filename)  # âŒ ã‚¨ãƒ©ãƒ¼
   ```
   
   ä¿®æ­£å¾Œ:
   ```python
   php_filename = None  # æœ€åˆã«åˆæœŸåŒ–
   
   if condition:
       php_filename = "something.php"
   else:
       php_filename = "default.txt"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
   
   if php_filename:
       await save(php_filename)  # âœ… å®‰å…¨
   ```

4. ã¾ãŸã¯ã€è¦ªã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨:
   
   ```python
   result = await self.parent_agent.safe_save_code_file(
       content=generated_code,
       task_id=task_id,
       file_type='php'
   )
   ```
"""

#wp_agent.py
""" wp_agent.py WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ - ãƒ¡ã‚¤ãƒ³ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼"""
import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path
from playwright.async_api import Page

from config_utils import ErrorHandler
from browser_controller import BrowserController

from .wp_auth import WordPressAuth
from .wp_post_editor import WordPressPostEditor
from .wp_post_creator import WordPressPostCreator
from .wp_plugin_manager import WordPressPluginManager
from .wp_settings_manager import WordPressSettingsManager
from .wp_tester import WordPressTester
from .wp_utils import TaskTypeAnalyzer

logger = logging.getLogger(__name__)


    # === ä¿®æ­£é–‹å§‹: WordPressAgentã‚¯ãƒ©ã‚¹ã«è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã‚’è¿½åŠ  ===

class WordPressAgent:
    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            wp_credentials: WordPress èªè¨¼æƒ…å ±
                - wp_url: ã‚µã‚¤ãƒˆURL
                - wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
                - wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.is_logged_in = False
        
        # WordPress å°‚ç”¨ãƒšãƒ¼ã‚¸ï¼ˆæ–°ã—ã„ã‚¿ãƒ–ï¼‰
        self.wp_page = None
        
        # èªè¨¼æƒ…å ±ã®å–å¾—
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        self.wp_user = self.wp_credentials.get('wp_user', '')
        self.wp_pass = self.wp_credentials.get('wp_pass', '')
        
        # WordPress èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if self.wp_url and self.wp_user and self.wp_pass:
            self.auth = WordPressAuth(
                browser_controller=self.browser,
                wp_url=self.wp_url,
                wp_user=self.wp_user,
                wp_pass=self.wp_pass
            )
        else:
            logger.warning("âš ï¸ WordPress èªè¨¼æƒ…å ±ãŒä¸å®Œå…¨ã§ã™")
            self.auth = None
        
        # ========================================
        # âœ… ã“ã“ã«è¿½åŠ ï¼šã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        # ========================================
        
        # ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆå¾Œã§å¤–éƒ¨ã‹ã‚‰è¨­å®šã•ã‚Œã‚‹ï¼‰
        self.sheets_manager = None
        
        # æŠ•ç¨¿ç·¨é›†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        self.post_editor = WordPressPostEditor(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressPostEditor åˆæœŸåŒ–å®Œäº†")
        
        # æŠ•ç¨¿ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        self.post_creator = WordPressPostCreator(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressPostCreator åˆæœŸåŒ–å®Œäº†")
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        self.plugin_manager = WordPressPluginManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressPluginManager åˆæœŸåŒ–å®Œäº†")
        
        # è¨­å®šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        self.settings_manager = WordPressSettingsManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressSettingsManager åˆæœŸåŒ–å®Œäº†")
        
        # ãƒ†ã‚¹ã‚¿ãƒ¼
        self.tester = WordPressTester(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressTester åˆæœŸåŒ–å®Œäº†")
        
        logger.info("="*60)
        logger.info("WordPressAgent å…¨ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        logger.info("="*60)
    async def initialize_wp_session(self) -> bool:
        """
        WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
            
        æ”¹å–„ç‚¹:
        1. æ–°ã—ã„ã‚¿ãƒ–ä½œæˆï¼ˆGemini ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¨ã¯å®Œå…¨ç‹¬ç«‹ï¼‰
        2. ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨ + ç®¡ç†ç”»é¢ã¸ã®å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        3. ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®å³æ ¼ãªæ¤œè¨¼
        4. å¤±æ•—æ™‚ã®æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            
        Returns:
            bool: åˆæœŸåŒ–æˆåŠŸæ™‚ True
        """
        try:
            logger.info("="*60)
            logger.info("ğŸ” WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
                
            # âœ… Phase 1: æ–°ã—ã„ã‚¿ãƒ–ã‚’ä½œæˆ
            if not self.browser.context:
                logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            self.wp_page = await self.browser.context.new_page()
            logger.info("âœ… WordPress å°‚ç”¨ã‚¿ãƒ–ã‚’ä½œæˆã—ã¾ã—ãŸ")
                
            # âœ… Phase 2: èªè¨¼æƒ…å ±ã®æ¤œè¨¼
            if not self.auth:
                logger.error("âŒ WordPress èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            # âœ… Phase 3: ãƒ­ã‚°ã‚¤ãƒ³å®Ÿè¡Œï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            logger.info("ğŸ”„ WordPressèªè¨¼ã‚’å®Ÿè¡Œä¸­...")
            login_success = await self.auth.login(self.wp_page)
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("âœ… WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†")
                logger.info("  èªè¨¼æ–¹æ³•: ã‚¯ãƒƒã‚­ãƒ¼ or æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³")
                logger.info("  ãƒšãƒ¼ã‚¸URL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("âŒ WordPress ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                logger.error("  åŸå› : èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                logger.error("  å¯¾ç­–: èªè¨¼æƒ…å ±ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                logger.error("="*60)
                    
                # ãƒ‡ãƒãƒƒã‚°ç”¨: å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("ğŸ“¸ ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def ensure_logged_in(self) -> bool:
        """
        ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿è¨¼
    
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã¾ãŸã¯ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        if self.is_logged_in and self.wp_page:
            # å®šæœŸçš„ã«ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            if await self.auth._verify_login_status(self.wp_page):
                return True
    
        # ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„å ´åˆã¯å†åˆæœŸåŒ–
        logger.info("ğŸ”„ WordPress å†ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œã—ã¾ã™")
        return await self.initialize_wp_session()
    
    async def _try_cookie_login(self, wp_url: str) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ãŸãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œ"""
        try:
            if not wp_url:
                logger.warning("âš ï¸ WordPress URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
        
            # WordPressã‚¯ãƒƒã‚­ãƒ¼ã‚’ãƒ­ãƒ¼ãƒ‰
            cookie_loaded = await self.browser.load_wordpress_cookies(wp_url)
            if not cookie_loaded:
                return False
        
            # ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            admin_url = f"{wp_url.rstrip('/')}/wp-admin/"
            await self.browser.page.goto(admin_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°ãƒã‚§ãƒƒã‚¯
            return await self._verify_wordpress_login_status()
        
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¯ãƒƒã‚­ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def _verify_wordpress_login_status(self) -> bool:
        """WordPressãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°æ¤œè¨¼"""
        try:
            page = self.browser.page
        
            # è¤‡æ•°ã®æ–¹æ³•ã§ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            checks = []
        
            # 1. ç®¡ç†ãƒãƒ¼ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('ç®¡ç†ãƒãƒ¼', bool(admin_bar)))
        
            # 2. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¦ç´ ãƒã‚§ãƒƒã‚¯
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰', bool(dashboard)))
        
            # 3. ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®ä¸åœ¨ãƒã‚§ãƒƒã‚¯
            login_form = await page.query_selector('#loginform')
            checks.append(('ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ä¸åœ¨', not bool(login_form)))
        
            # 4. URLãƒã‚§ãƒƒã‚¯ï¼ˆãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ï¼‰
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('ç®¡ç†ãƒšãƒ¼ã‚¸URL', is_admin_page))
        
            # çµæœã®é›†è¨ˆ
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
        
            logger.info(f"ğŸ” ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼: {total_passed}/4 åˆæ ¼")
            if total_passed >= 3:  # 4ã¤ã®ã†ã¡3ã¤ä»¥ä¸Šåˆæ ¼ãªã‚‰ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ
                logger.info(f"  åˆæ ¼é …ç›®: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  ä¸åˆæ ¼é …ç›®ãŒå¤šã™ãã¾ã™")
                return False
            
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def _manual_wordpress_login(self) -> bool:
        """æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³"""
        try:
            wp_url = self.wp_credentials.get('wp_url', '')
            wp_user = self.wp_credentials.get('wp_user', '')
            wp_pass = self.wp_credentials.get('wp_pass', '')
        
            if not all([wp_url, wp_user, wp_pass]):
                logger.error("âŒ WordPressèªè¨¼æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
                return False
        
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            login_url = f"{wp_url.rstrip('/')}/wp-login.php"
            await self.browser.page.goto(login_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›
            user_field = await self.browser.page.query_selector('#user_login')
            if user_field:
                await user_field.fill(wp_user)
                logger.info("âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›å®Œäº†")
            else:
                logger.error("âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›
            pass_field = await self.browser.page.query_selector('#user_pass')
            if pass_field:
                await pass_field.fill(wp_pass)
                logger.info("âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›å®Œäº†")
            else:
                logger.error("âŒ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
            login_button = await self.browser.page.query_selector('#wp-submit')
            if login_button:
                await login_button.click()
                logger.info("âœ… ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯")
            else:
                logger.error("âŒ ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾…æ©Ÿ
            await self.browser.page.wait_for_load_state('networkidle')
            await asyncio.sleep(3)
        
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸç¢ºèª
            if await self._verify_wordpress_login_status():
                logger.info("âœ… æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                return True
            else:
                logger.error("âŒ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•— - èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                return False
            
        except Exception as e:
            logger.error(f"âŒ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def ensure_logged_in(self) -> bool:
        """ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿è¨¼"""
        if self.is_logged_in:
            return True
    
        # å®šæœŸçš„ã«ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
        if await self._verify_wordpress_login_status():
            self.is_logged_in = True
            return True
    
        # ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„å ´åˆã¯å†åˆæœŸåŒ–
        return await self.initialize_wp_session()
       
    async def process_task(self, task: Dict) -> Dict:
        """WordPressã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            # ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            if not await self.ensure_logged_in():
                return {
                    'success': False,
                    'error': 'WordPress ã«ãƒ­ã‚°ã‚¤ãƒ³ã§ãã¾ã›ã‚“ã§ã—ãŸ'
                }
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹ ===
            logger.info("="*60)
            logger.info("WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹")
            logger.info(f"ã‚¿ã‚¹ã‚¯: {task['description']}")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼è¨­å®š ===
            self.post_editor.sheets_manager = self.sheets_manager
            self.post_creator.sheets_manager = self.sheets_manager
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—è§£æ ===
            task_type = TaskTypeAnalyzer.analyze(task['description'])
            logger.info(f"è§£æã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—: {task_type}")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‡¦ç†å®Ÿè¡Œ ===
            result = await self._execute_task_by_type(task, task_type)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressã‚¿ã‚¹ã‚¯å‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_task_by_type(self, task: Dict, task_type: str) -> Dict:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦é©åˆ‡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å‡¦ç†ã‚’å§”è­²"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–¢é€£ã‚¿ã‚¹ã‚¯ ===
            if task_type == 'plugin_install':
                result = await self.plugin_manager.install_plugin(self.wp_page, task)
            elif task_type == 'plugin_settings':
                result = await self.plugin_manager.change_plugin_settings(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: æŠ•ç¨¿é–¢é€£ã‚¿ã‚¹ã‚¯ ===
            elif task_type == 'edit_post':
                result = await self.post_editor.edit_post(self.wp_page, task)
            elif task_type == 'content_create':
                result = await self.post_creator.create_post(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: è¨­å®šé–¢é€£ã‚¿ã‚¹ã‚¯ ===
            elif task_type == 'theme_change':
                result = await self.settings_manager.change_theme(self.wp_page, task)
            elif task_type == 'setting_change':
                result = await self.settings_manager.change_settings(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ ===
            elif task_type == 'test_functionality':
                result = await self.tester.test_functionality(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ãã®ä»–ã®ã‚¿ã‚¹ã‚¯ ===
            else:
                result = await self._generic_execution(task)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }

    async def create_post(self, page: Page, task: Dict) -> Dict:
        """æ–°è¦æŠ•ç¨¿ã‚’ä½œæˆï¼ˆpost_statuså¯¾å¿œç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾— ===
            post_status = task.get('post_status', 'draft')
            post_action = task.get('post_action', 'create')
        
            logger.info(f"WordPressæŠ•ç¨¿ä½œæˆ:")
            logger.info(f"  ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {post_action}")
            logger.info(f"  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}")
        
            # === ãƒ‘ãƒ¼ãƒˆ2: è¨˜äº‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¨­å®š ===
            # ï¼ˆæ—¢å­˜ã®è¨˜äº‹å–å¾—ãƒ»ã‚¿ã‚¤ãƒˆãƒ«ãƒ»æœ¬æ–‡è¨­å®šå‡¦ç†ï¼‰
            article_title = "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒˆãƒ«"  # å®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªå€¤ã‚’è¨­å®š
            polylang_lang = "ja"
            language = "æ—¥æœ¬èª"
            article_body = ""
            screenshot_path = None
        
            # === ãƒ‘ãƒ¼ãƒˆ3: æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸå‡¦ç† ===
            status_result = await self._handle_post_status(page, post_status, post_action)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: çµæœã‚µãƒãƒªãƒ¼æ§‹ç¯‰ ===
            summary = self._build_create_summary(
                article_title, polylang_lang, language, 
                len(article_body), post_status, status_result['message']
            )
        
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'action': post_action,
                'screenshot': screenshot_path
            }
        
        except Exception as e:
            logger.error(f"âŒ WordPressæŠ•ç¨¿ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _handle_post_status(self, page: Page, post_status: str, post_action: str) -> Dict:
        """æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸä¿å­˜/å…¬é–‹å‡¦ç†"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ä¸‹æ›¸ãä¿å­˜ã®å ´åˆ ===
            if post_status == 'draft' or post_action == 'create':
                logger.info("\nã€ä¸‹æ›¸ãä¿å­˜ä¸­...ã€‘")
                saved = await self._save_draft(page)
            
                if saved:
                    logger.info("âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†")
                    return {'success': True, 'message': 'ä¸‹æ›¸ãä¿å­˜'}
                else:
                    logger.warning("âš ï¸ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                    return {'success': False, 'message': 'ä¿å­˜ç¢ºèªæ¨å¥¨'}
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å…¬é–‹ã®å ´åˆ ===
            elif post_status == 'publish' or post_action == 'publish':
                logger.info("\nã€è¨˜äº‹ã‚’å…¬é–‹ä¸­...ã€‘")
                published = await self._publish_post(page)
            
                if published:
                    logger.info("âœ… è¨˜äº‹å…¬é–‹å®Œäº†")
                    return {'success': True, 'message': 'å…¬é–‹å®Œäº†'}
                else:
                    logger.warning("âš ï¸ å…¬é–‹ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                    return {'success': False, 'message': 'å…¬é–‹ç¢ºèªæ¨å¥¨'}
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å ´åˆ ===
            else:
                logger.info(f"\nã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ã€‘")
                saved = await self._save_draft(page)
                return {
                    'success': saved, 
                    'message': f'ä¿å­˜å®Œäº†ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ï¼‰'
                }
        
        except Exception as e:
            logger.error(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'message': f'ã‚¨ãƒ©ãƒ¼: {str(e)}'}


    async def _publish_post(self, page: Page) -> bool:
        """æŠ•ç¨¿ã‚’å…¬é–‹"""
        # === ãƒ‘ãƒ¼ãƒˆ1: å…¬é–‹ãƒœã‚¿ãƒ³ã‚»ãƒ¬ã‚¯ã‚¿å®šç¾© ===
        publish_selectors = [
            'button:has-text("å…¬é–‹")',
            'button[aria-label="å…¬é–‹"]',
            '.editor-post-publish-button',
            'button.editor-post-publish-button__button'
        ]
    
        logger.debug("å…¬é–‹ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
    
        # === ãƒ‘ãƒ¼ãƒˆ2: å…¬é–‹ãƒœã‚¿ãƒ³æ¢ç´¢ãƒ«ãƒ¼ãƒ— ===
        for i, selector in enumerate(publish_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(publish_selectors)}: {selector}")
            try:
                publish_button = await page.query_selector(selector)
                if not publish_button:
                    continue
                    
                # === ãƒ‘ãƒ¼ãƒˆ3: ãƒœã‚¿ãƒ³çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ ===
                is_visible = await publish_button.is_visible()
                is_disabled = await publish_button.is_disabled() if is_visible else True
            
                logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === ãƒ‘ãƒ¼ãƒˆ4: å…¬é–‹ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ ===
                    await publish_button.click()
                    await page.wait_for_timeout(2000)
                
                    # === ãƒ‘ãƒ¼ãƒˆ5: ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç† ===
                    try:
                        confirm_button = await page.query_selector('button:has-text("å…¬é–‹")')
                        if confirm_button and await confirm_button.is_visible():
                            await confirm_button.click()
                            await page.wait_for_timeout(3000)
                    except:
                        pass
                
                    logger.info("âœ… å…¬é–‹ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                    return True
                    
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
    
        logger.warning("âŒ å…¬é–‹ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False


    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ä¿å­˜ãƒœã‚¿ãƒ³ã‚»ãƒ¬ã‚¯ã‚¿å®šç¾© ===
        save_selectors = [
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
    
        logger.debug("ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
    
        # === ãƒ‘ãƒ¼ãƒˆ2: ä¿å­˜ãƒœã‚¿ãƒ³æ¢ç´¢ãƒ«ãƒ¼ãƒ— ===
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if not save_button:
                    continue
                    
                # === ãƒ‘ãƒ¼ãƒˆ3: ãƒœã‚¿ãƒ³çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ ===
                is_visible = await save_button.is_visible()
                is_disabled = await save_button.is_disabled() if is_visible else True
            
                logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === ãƒ‘ãƒ¼ãƒˆ4: ä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ ===
                    await save_button.click()
                    await page.wait_for_timeout(4000)
                    logger.info("âœ… ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                    return True
                    
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
    
        logger.warning("âŒ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False


    def _build_create_summary(self, title: str, polylang_lang: str, 
                             language: str, content_length: int, 
                             post_status: str, status_message: str) -> str:
        """æ–°è¦æŠ•ç¨¿ä½œæˆã®ã‚µãƒãƒªãƒ¼ã‚’æ§‹ç¯‰"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒãƒªãƒ¼è¡Œã®æ§‹ç¯‰ ===
        summary_lines = []
        summary_lines.append("ã€WordPressæŠ•ç¨¿å®Œäº†ã€‘")
        summary_lines.append(f"ã‚¿ã‚¤ãƒˆãƒ«: {title}")
        summary_lines.append(f"è¨€èª: {language}")
        summary_lines.append(f"Polylangè¨­å®š: {polylang_lang}")
        summary_lines.append(f"æœ¬æ–‡: {content_length}æ–‡å­—ï¼ˆHTMLå½¢å¼ï¼‰")
        summary_lines.append(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}")
        summary_lines.append(f"âœ… {status_message}")
    
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚µãƒãƒªãƒ¼æ–‡å­—åˆ—ã®çµåˆ ===
        return '\n'.join(summary_lines)
    
    
    async def _generic_execution(self, task: Dict) -> Dict:
        """æ±ç”¨çš„ãªã‚¿ã‚¹ã‚¯å®Ÿè¡Œ(Geminiã«ç¢ºèªã—ãªãŒã‚‰å®Ÿè¡Œ)"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å®Ÿè¡Œé–‹å§‹ ===
            logger.info("æ±ç”¨ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: Geminiãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ ===
            gemini_prompt = self._build_gemini_prompt(task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: Geminiã«é€ä¿¡ ===
            await self.browser.send_prompt(gemini_prompt)
            await self.browser.wait_for_text_generation(max_wait=120)
            response = await self.browser.extract_latest_text_response()
            
            logger.info("Geminiã‹ã‚‰å®Ÿè¡Œæ‰‹é †ã‚’å–å¾—ã—ã¾ã—ãŸ")
            logger.info(f"æ‰‹é †:\n{response[:500]}...")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: çµæœè¿”å´ ===
            return self._build_generic_result(task, response)
            
        except Exception as e:
            ErrorHandler.log_error(e, "æ±ç”¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }

    def _build_gemini_prompt(self, task: Dict) -> str:
        """Geminiç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        return f"""
        WordPressã§ä»¥ä¸‹ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ãŸã„ã§ã™:

        ã€ã‚¿ã‚¹ã‚¯ã€‘
        {task['description']}

        ã€WordPressæƒ…å ±ã€‘
        - URL: {self.wp_url}
        - ç®¡ç†ç”»é¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿

        ã€è³ªå•ã€‘
        ã“ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®å…·ä½“çš„ãªæ‰‹é †ã‚’ã€WordPressç®¡ç†ç”»é¢ã®æ“ä½œã¨ã—ã¦æ•™ãˆã¦ãã ã•ã„ã€‚

        ä»¥ä¸‹ã®å½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„:
        1. ç§»å‹•ã™ã‚‹ãƒšãƒ¼ã‚¸ã®URL(ç›¸å¯¾ãƒ‘ã‚¹)
        2. ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯å…¥åŠ›ã™ã‚‹è¦ç´ ã®ã‚»ãƒ¬ã‚¯ã‚¿
        3. å…¥åŠ›ã™ã‚‹å€¤
        4. ç¢ºèªã™ã¹ããƒã‚¤ãƒ³ãƒˆ

        ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã§ãã‚‹ã ã‘å…·ä½“çš„ã«(id, class, nameå±æ€§ãªã©)ã€‚
        """

    def _build_generic_result(self, task: Dict, response: str) -> Dict:
        """æ±ç”¨å®Ÿè¡Œã®çµæœã‚’æ§‹ç¯‰"""
        logger.info("âš ï¸ å®Ÿéš›ã®å®Ÿè¡Œã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': 'Geminiã‹ã‚‰å®Ÿè¡Œæ‰‹é †ã‚’å–å¾—ã—ã¾ã—ãŸã€‚æ‰‹é †ã‚’ç¢ºèªã—ã¦å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚',
            'full_text': f'ã€ã‚¿ã‚¹ã‚¯ã€‘\n{task["description"]}\n\nã€å®Ÿè¡Œæ‰‹é †ã€‘\n{response}'
        }
    
    async def cleanup(self):
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚º ===
        if self.wp_page:
            await self.wp_page.close()
            logger.info("WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã—ãŸ")


# === è¿½åŠ æ©Ÿèƒ½ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆåˆ†å‰²æ¸ˆã¿ï¼‰ ===

    async def configure_acf_fields(self, task_params: Dict) -> Dict:
        """Advanced Custom Fieldsã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¨­å®š"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾— ===
            field_group_name = task_params.get('acf_field_group_name')
            fields = task_params.get('acf_fields', [])
            location_rules = task_params.get('acf_location_rules', {})
            
            logger.info(f"ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— '{field_group_name}' ã‚’è¨­å®šä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ACFç”»é¢ç§»å‹• ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/edit.php?post_type=acf-field-group")
            await self.wp_page.wait_for_timeout(2000)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: æ–°è¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—è¿½åŠ  ===
            await self._click_acf_add_new_button()
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åå…¥åŠ› ===
            await self._input_acf_field_group_name(field_group_name)
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã¨çµæœè¿”å´ ===
            return await self._build_acf_result(field_group_name, fields, location_rules)
            
        except Exception as e:
            logger.error(f"ACFè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _click_acf_add_new_button(self):
        """ACFæ–°è¦è¿½åŠ ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯"""
        add_button_selectors = [
            'a.page-title-action:has-text("æ–°è¦è¿½åŠ ")',
            'a:has-text("Add New")',
            '.page-title-action'
        ]
        
        for selector in add_button_selectors:
            try:
                add_button = await self.wp_page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await self.wp_page.wait_for_timeout(3000)
                    break
            except:
                continue

    async def _input_acf_field_group_name(self, field_group_name: str):
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›"""
        title_input = await self.wp_page.query_selector('#title')
        if title_input:
            await title_input.fill(field_group_name)
            logger.info(f"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›: {field_group_name}")

    async def _build_acf_result(self, field_group_name: str, fields: list, location_rules: dict) -> Dict:
        """ACFè¨­å®šçµæœã‚’æ§‹ç¯‰"""
        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
        screenshot_path = f"acf_setup_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("âš ï¸ ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è©³ç´°è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': f'ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— "{field_group_name}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'field_group_name': field_group_name,
            'fields_count': len(fields),
            'screenshot': screenshot_path,
            'full_text': f'ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—è¨­å®š\nåå‰: {field_group_name}\nãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: {len(fields)}\nâ€»ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }

    # ï¼ˆä»–ã®è¿½åŠ æ©Ÿèƒ½ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚åŒæ§˜ã«åˆ†å‰²ã€‚ä»¥ä¸‹ã¯ä¸€éƒ¨ã®ã¿è¡¨ç¤ºï¼‰

    async def configure_custom_post_type(self, task_params: Dict) -> Dict:
        """Custom Post Type UIã§ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾— ===
            cpt_slug = task_params.get('cpt_slug')
            cpt_labels = task_params.get('cpt_labels', {})
            cpt_supports = task_params.get('cpt_supports', [])
            cpt_settings = task_params.get('cpt_settings', {})
            
            logger.info(f"ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— '{cpt_slug}' ã‚’ä½œæˆä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: CPT UIç”»é¢ç§»å‹• ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_post_types")
            await self.wp_page.wait_for_timeout(3000)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: åŸºæœ¬æƒ…å ±å…¥åŠ› ===
            await self._input_cpt_basic_info(cpt_slug, cpt_labels)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: çµæœæ§‹ç¯‰ ===
            return await self._build_cpt_result(cpt_slug, cpt_labels)
            
        except Exception as e:
            logger.error(f"Custom Post Typeä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _input_cpt_basic_info(self, cpt_slug: str, cpt_labels: dict):
        """CPTåŸºæœ¬æƒ…å ±ã‚’å…¥åŠ›"""
        # Post Type Slugå…¥åŠ›
        slug_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[name]"]')
        if slug_input:
            await slug_input.fill(cpt_slug)
            logger.info(f"ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {cpt_slug}")
        
        # Plural Labelå…¥åŠ›
        plural_label = cpt_labels.get('plural', cpt_slug)
        plural_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[label]"]')
        if plural_input:
            await plural_input.fill(plural_label)
            logger.info(f"è¤‡æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {plural_label}")
        
        # Singular Labelå…¥åŠ›
        singular_label = cpt_labels.get('singular', cpt_slug)
        singular_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[singular_label]"]')
        if singular_input:
            await singular_input.fill(singular_label)
            logger.info(f"å˜æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {singular_label}")

    async def _build_cpt_result(self, cpt_slug: str, cpt_labels: dict) -> Dict:
        """CPTä½œæˆçµæœã‚’æ§‹ç¯‰"""
        screenshot_path = f"cpt_creation_{cpt_slug}_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("âš ï¸ è©³ç´°è¨­å®šã¨Supportsè¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': f'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— "{cpt_slug}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'cpt_slug': cpt_slug,
            'cpt_labels': cpt_labels,
            'screenshot': screenshot_path,
            'full_text': f'Custom Post Typeä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {cpt_slug}\nãƒ©ãƒ™ãƒ«: {cpt_labels}\nâ€»Supportsè¨­å®šç­‰ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }


    # === 3. ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆæ©Ÿèƒ½ ===
    async def configure_custom_taxonomy(self, task_params: Dict) -> Dict:
        """
        Custom Post Type UIã§ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚’ä½œæˆ
        
        Parameters:
            taxonomy_slug: str - ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚¹ãƒ©ãƒƒã‚°
            taxonomy_labels: dict - ãƒ©ãƒ™ãƒ«è¨­å®š
            taxonomy_post_types: list - ç´ã¥ã‘ã‚‹æŠ•ç¨¿ã‚¿ã‚¤ãƒ—
            taxonomy_hierarchical: bool - éšå±¤æ§‹é€ ã®æœ‰ç„¡
        """
        try:
            taxonomy_slug = task_params.get('taxonomy_slug')
            taxonomy_labels = task_params.get('taxonomy_labels', {})
            taxonomy_post_types = task_params.get('taxonomy_post_types', [])
            taxonomy_hierarchical = task_params.get('taxonomy_hierarchical', True)
            
            logger.info(f"ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ '{taxonomy_slug}' ã‚’ä½œæˆä¸­...")
            
            # 1 Custom Post Type UI - Taxonomiesç”»é¢ã«ç§»å‹•
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_taxonomies")
            await self.wp_page.wait_for_timeout(3000)
            
            # 2 Taxonomy Slugå…¥åŠ›
            slug_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[name]"]')
            if slug_input:
                await slug_input.fill(taxonomy_slug)
                logger.info(f"ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {taxonomy_slug}")
            
            # 3 Plural Labelå…¥åŠ›
            plural_label = taxonomy_labels.get('plural', taxonomy_slug)
            plural_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[label]"]')
            if plural_input:
                await plural_input.fill(plural_label)
                logger.info(f"è¤‡æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {plural_label}")
            
            # 4 Singular Labelå…¥åŠ›
            singular_label = taxonomy_labels.get('singular', taxonomy_slug)
            singular_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[singular_label]"]')
            if singular_input:
                await singular_input.fill(singular_label)
                logger.info(f"å˜æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {singular_label}")
            
            # 5 ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"taxonomy_creation_{taxonomy_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("âš ï¸ Attach to Post Typesã¨éšå±¤è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': f'ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ "{taxonomy_slug}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'taxonomy_slug': taxonomy_slug,
                'taxonomy_labels': taxonomy_labels,
                'screenshot': screenshot_path,
                'full_text': f'Custom Taxonomyä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {taxonomy_slug}\nãƒ©ãƒ™ãƒ«: {taxonomy_labels}\nâ€»æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç´ä»˜ã‘ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
            }
            
        except Exception as e:
            logger.error(f"ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 4. M&Aæ¡ˆä»¶æŠ•ç¨¿æ©Ÿèƒ½ï¼ˆACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãï¼‰ ===
    async def create_ma_case_post(self, task_params: Dict) -> Dict:
        """
        M&Aæ¡ˆä»¶ã‚’ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãã§æŠ•ç¨¿
        
        Parameters:
            post_title: str - æŠ•ç¨¿ã‚¿ã‚¤ãƒˆãƒ«
            post_content: str - æœ¬æ–‡
            acf_fields: dict - ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤
            polylang_lang: str - è¨€èªè¨­å®š
            post_status: str - æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
        """
        try:
            post_title = task_params.get('post_title')
            post_content = task_params.get('post_content', '')
            acf_fields = task_params.get('acf_fields', {})
            polylang_lang = task_params.get('polylang_lang', 'ja')
            post_status = task_params.get('post_status', 'draft')
            
            logger.info(f"M&Aæ¡ˆä»¶æŠ•ç¨¿: {post_title}")
            
            # 1 æ–°è¦æŠ•ç¨¿ç”»é¢ã«ç§»å‹•ï¼ˆma_caseæŠ•ç¨¿ã‚¿ã‚¤ãƒ—ï¼‰
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post-new.php?post_type=ma_case")
            await self.wp_page.wait_for_timeout(5000)
            
            # 2 ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
            await self._input_title(self.wp_page, post_title)
            
            # 3 æœ¬æ–‡å…¥åŠ›ï¼ˆã‚ã‚‹å ´åˆï¼‰
            if post_content:
                await self._input_content(self.wp_page, post_content)
            
            # 4 ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ã‚’å…¥åŠ›
            logger.info("ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ã‚’å…¥åŠ›ä¸­...")
            for field_name, field_value in acf_fields.items():
                try:
                    # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‹ã‚‰ã‚»ãƒ¬ã‚¯ã‚¿ã‚’æ¨æ¸¬
                    field_selector = f'input[name="acf[{field_name}]"]'
                    field_input = await self.wp_page.query_selector(field_selector)
                    
                    if field_input:
                        await field_input.fill(str(field_value))
                        logger.info(f"  {field_name}: {field_value}")
                    else:
                        logger.warning(f"  ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                except Exception as e:
                    logger.warning(f"  ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field_name}' å…¥åŠ›ã‚¨ãƒ©ãƒ¼: {e}")
            
            # 5 Polylangè¨€èªè¨­å®š
            await self._set_polylang_language(self.wp_page, polylang_lang)
            
            # 6 ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"ma_case_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            # 7 ä¿å­˜ã¾ãŸã¯å…¬é–‹
            if post_status == 'draft':
                saved = await self._save_draft(self.wp_page)
                status_message = "ä¸‹æ›¸ãä¿å­˜å®Œäº†" if saved else "ä¿å­˜ç¢ºèªæ¨å¥¨"
            elif post_status == 'publish':
                published = await self._publish_post(self.wp_page)
                status_message = "å…¬é–‹å®Œäº†" if published else "å…¬é–‹ç¢ºèªæ¨å¥¨"
            else:
                saved = await self._save_draft(self.wp_page)
                status_message = f"ä¿å­˜å®Œäº†ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ï¼‰"
            
            summary = f"""ã€M&Aæ¡ˆä»¶æŠ•ç¨¿å®Œäº†ã€‘
    ã‚¿ã‚¤ãƒˆãƒ«: {post_title}
    è¨€èª: {polylang_lang}
    ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: {len(acf_fields)}ä»¶
    æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}
    âœ… {status_message}"""
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'acf_fields_count': len(acf_fields),
                'screenshot': screenshot_path,
                'full_text': summary
            }
            
        except Exception as e:
            logger.error(f"M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 5. Polylangç¿»è¨³é€£æºæ©Ÿèƒ½ ===
    async def link_polylang_translations(self, original_post_id: int, translated_post_id: int, lang_code: str) -> Dict:
        """
        Polylangã§æŠ•ç¨¿åŒå£«ã‚’ç¿»è¨³é–¢ä¿‚ã¨ã—ã¦é€£æº
        
        Parameters:
            original_post_id: int - å…ƒã®æŠ•ç¨¿ID
            translated_post_id: int - ç¿»è¨³å…ˆã®æŠ•ç¨¿ID
            lang_code: str - ç¿»è¨³å…ˆã®è¨€èªã‚³ãƒ¼ãƒ‰
        """
        try:
            logger.info(f"Polylangç¿»è¨³é€£æº: {original_post_id} â†’ {translated_post_id} ({lang_code})")
            
            # å…ƒã®æŠ•ç¨¿ã®ç·¨é›†ç”»é¢ã‚’é–‹ã
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post.php?post={original_post_id}&action=edit")
            await self.wp_page.wait_for_timeout(3000)
            
            # Polylangè¨€èªãƒ¡ã‚¿ãƒœãƒƒã‚¯ã‚¹ã§+ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            logger.info("Polylangè¨€èªè¨­å®šãƒ¡ã‚¿ãƒœãƒƒã‚¯ã‚¹ã‚’æ“ä½œä¸­...")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"polylang_link_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("âš ï¸ Polylangç¿»è¨³é€£æºã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': f'æŠ•ç¨¿ID {original_post_id} ã®ç·¨é›†ç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚Polylangè¨­å®šã§æŠ•ç¨¿ID {translated_post_id} ã‚’é€£æºã—ã¦ãã ã•ã„ã€‚',
                'original_post_id': original_post_id,
                'translated_post_id': translated_post_id,
                'lang_code': lang_code,
                'screenshot': screenshot_path,
                'full_text': f'Polylangç¿»è¨³é€£æº\nå…ƒæŠ•ç¨¿ID: {original_post_id}\nç¿»è¨³å…ˆID: {translated_post_id}\nè¨€èª: {lang_code}\nâ€»æ‰‹å‹•ã§é€£æºã‚’å®Œäº†ã—ã¦ãã ã•ã„'
            }
            
        except Exception as e:
            logger.error(f"Polylangç¿»è¨³é€£æºã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _calculate_dynamic_timeout(self, text_content: str) -> int:
        """å‹•çš„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨ˆç®— - WPå‡¦ç†å¯¾å¿œ"""
        base_timeout = 120
            
        # æ—¢å­˜ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        long_task_keywords = [
            'è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ', 'å®Ÿè£…'
        ]
            
        # === æ–°è¦è¿½åŠ : WordPresså°‚ç”¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ ===
        wp_long_task_keywords = [
            'FacetWP', 'Relevanssi', 'ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰',
            'WP-CLI', 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç§»è¡Œ', 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€æ‹¬',
            'ACF Pro ãƒ©ã‚¤ã‚»ãƒ³ã‚¹', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åŒæœŸ'
        ]
            
        # é€šå¸¸ã®é•·æ™‚é–“ã‚¿ã‚¹ã‚¯
        if any(kw in text_content for kw in long_task_keywords):
            base_timeout = 300
            
        # === WPç‰¹åŒ–ã®è¶…é•·æ™‚é–“ã‚¿ã‚¹ã‚¯ ===
        if any(kw in text_content for kw in wp_long_task_keywords):
            base_timeout = 600  # 10åˆ†
            logger.info(f"â±ï¸ config WPé•·æ™‚é–“å‡¦ç†ã‚’æ¤œå‡º - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {base_timeout}ç§’")
        
        async def cleanup(self):
            """WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
            if self.wp_page:
                try:
                    await self.wp_page.close()
                    logger.info("WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ WordPress ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚ºã‚¨ãƒ©ãƒ¼: {e}")
            
        return base_timeout
            

#wp_auth.py
"""WordPressèªè¨¼ãƒ»ãƒ­ã‚°ã‚¤ãƒ³ç®¡ç†ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰"""
import asyncio
import logging
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressAuth:
    """WordPressèªè¨¼ç®¡ç†ï¼ˆBrowserControllerçµ±åˆç‰ˆ + ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰"""
    
    def __init__(self, browser_controller, wp_url: str, wp_user: str, wp_pass: str):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            wp_url: WordPress ã‚µã‚¤ãƒˆURL
            wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
            wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        """
        self.browser = browser_controller
        self.wp_url = wp_url.rstrip('/')
        self.wp_user = wp_user
        self.wp_pass = wp_pass
    
    async def login(self, page: Page) -> bool:
        """
        WordPressã«ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ç‰ˆï¼‰
        
        æ”¹å–„ç‚¹:
        1. ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨å¾Œã«å¿…ãšç®¡ç†ç”»é¢URLã¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        2. ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã®å³æ ¼åŒ–
        3. å¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¼·åŒ–
        
        Args:
            page: Playwright Page ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        try:
            logger.info("="*60)
            logger.info("WordPress: ãƒ­ã‚°ã‚¤ãƒ³é–‹å§‹ï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰")
            logger.info(f"URL: {self.wp_url}")
            logger.info("="*60)
            
            # âœ… Phase 1: ã‚¯ãƒƒã‚­ãƒ¼ã§ã®ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œ
            cookies_loaded = await self.browser.load_wordpress_cookies(self.wp_url)
            
            if cookies_loaded:
                logger.info("âœ… WordPress ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
                
                # âœ… é‡è¦: ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨å¾Œã«ç®¡ç†ç”»é¢ã«å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
                admin_url = f"{self.wp_url}/wp-admin/"
                logger.info(f"ğŸ”„ ç®¡ç†ç”»é¢ã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ä¸­: {admin_url}")
                
                try:
                    await page.goto(admin_url, timeout=30000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)  # ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¢ºç«‹ã‚’å¾…æ©Ÿ
                    
                    # âœ… Phase 2: ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’å³æ ¼ã«æ¤œè¨¼
                    if await self._verify_login_status(page):
                        logger.info("âœ… ã‚¯ãƒƒã‚­ãƒ¼èªè¨¼æˆåŠŸ - æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿")
                        
                        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜
                        screenshot_path = f"wp_cookie_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                        await page.screenshot(path=screenshot_path)
                        logger.info(f"ğŸ“¸ ã‚¯ãƒƒã‚­ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ: {screenshot_path}")
                        
                        return True
                    else:
                        logger.warning("âš ï¸ ã‚¯ãƒƒã‚­ãƒ¼èªè¨¼å¤±æ•— - æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™")
                        
                except Exception as nav_error:
                    logger.warning(f"âš ï¸ ç®¡ç†ç”»é¢ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {nav_error}")
            
            # âœ… Phase 3: ã‚¯ãƒƒã‚­ãƒ¼èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã¯æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³
            return await self.manual_login(page)
                
        except Exception as e:
            logger.error(f"âŒ ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³
            return await self.manual_login(page)
    
    async def manual_login(self, page: Page) -> bool:
        """
        æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ–¹å¼ï¼‰
        
        Args:
            page: Playwright Page ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        try:
            logger.info("ğŸ” æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            login_url = f"{self.wp_url}/wp-login.php"
            await page.goto(login_url, timeout=30000, wait_until="domcontentloaded")
            await asyncio.sleep(2)
            
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›
            user_field = await page.query_selector('#user_login')
            if not user_field:
                logger.error("âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            await user_field.fill(self.wp_user)
            await asyncio.sleep(0.5)
            logger.info("âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›å®Œäº†")
            
            # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›
            pass_field = await page.query_selector('#user_pass')
            if not pass_field:
                logger.error("âŒ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            await pass_field.fill(self.wp_pass)
            await asyncio.sleep(0.5)
            logger.info("âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›å®Œäº†")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            login_button = await page.query_selector('#wp-submit')
            if not login_button:
                logger.error("âŒ ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            await login_button.click()
            await asyncio.sleep(5)
            logger.info("âœ… ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
            
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸç¢ºèª
            if await self._verify_login_status(page):
                logger.info("âœ… WordPressæ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                
                # âœ… ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã«ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜
                await self.browser.save_wordpress_cookies(self.wp_url)
                
                # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜
                screenshot_path = f"wp_manual_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                logger.info(f"ğŸ“¸ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ: {screenshot_path}")
                
                return True
            else:
                logger.error("âŒ WordPressãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                
                # å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                await page.screenshot(path="wp_login_failed.png")
                
                # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç¢ºèª
                error_element = await page.query_selector('#login_error')
                if error_element:
                    error_text = await error_element.text_content()
                    logger.error(f"ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_text}")
                
                return False
                
        except Exception as e:
            logger.error(f"âŒ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _verify_login_status(self, page: Page) -> bool:
        """
        WordPressãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°æ¤œè¨¼ï¼ˆå³æ ¼ç‰ˆï¼‰
        
        æ”¹å–„ç‚¹:
        1. URLç¢ºèªã‚’æœ€å„ªå…ˆ
        2. 4ã¤ã®ãƒã‚§ãƒƒã‚¯ã®ã†ã¡3ã¤ä»¥ä¸Šã§åˆæ ¼åˆ¤å®š
        3. å„ãƒã‚§ãƒƒã‚¯çµæœã‚’è©³ç´°ã«ãƒ­ã‚°å‡ºåŠ›
        
        Args:
            page: Playwright Page ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã®å ´åˆ True
        """
        try:
            checks = []
            
            # âœ… 1. URLç¢ºèªï¼ˆæœ€å„ªå…ˆï¼‰
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('ç®¡ç†ãƒšãƒ¼ã‚¸URL', is_admin_page))
            
            # âœ… 2. ç®¡ç†ãƒãƒ¼ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('ç®¡ç†ãƒãƒ¼', bool(admin_bar)))
            
            # âœ… 3. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¦ç´ ãƒã‚§ãƒƒã‚¯
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰', bool(dashboard)))
            
            # âœ… 4. ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®ä¸åœ¨ãƒã‚§ãƒƒã‚¯
            login_form = await page.query_selector('#loginform')
            checks.append(('ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ä¸åœ¨', not bool(login_form)))
            
            # çµæœã®é›†è¨ˆ
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
            
            logger.info(f"ğŸ” ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼: {total_passed}/4 åˆæ ¼")
            
            # âœ… è©³ç´°ãƒ­ã‚°å‡ºåŠ›
            for name, passed in checks:
                status = "âœ…" if passed else "âŒ"
                logger.info(f"  {status} {name}")
            
            if total_passed >= 3:  # 4ã¤ã®ã†ã¡3ã¤ä»¥ä¸Šåˆæ ¼ãªã‚‰ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ
                logger.info(f"  âœ… åˆæ ¼é …ç›®: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  âŒ ä¸åˆæ ¼ãŒå¤šã™ãã¾ã™ï¼ˆåˆæ ¼: {total_passed}/4ï¼‰")
                logger.warning(f"  ç¾åœ¨URL: {current_url}")
                return False
                
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False

#wp_cpt_agent.py
"""
WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    PROMPT_TEMPLATE = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€ã‚¿ã‚¹ã‚¯ã€‘
ä»¥ä¸‹ã®ä»•æ§˜ã§ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆã™ã‚‹PHPã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

{cpt_spec}

ã€å‡ºåŠ›è¦ä»¶ã€‘
1. å®Œå…¨ã«å‹•ä½œã™ã‚‹PHPã‚³ãƒ¼ãƒ‰
2. register_post_type() ã‚’ä½¿ç”¨
3. å¤šè¨€èªå¯¾å¿œï¼ˆPolylangäº’æ›ï¼‰
4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ã
5. ã‚³ãƒ¡ãƒ³ãƒˆä»˜ã

ã€å‡ºåŠ›å½¢å¼ã€‘
```php
<?php
/**
 * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_name}
 * ä½œæˆæ—¥: {date}
 */

function register_cpt_{cpt_slug}() {{
    // ã‚³ãƒ¼ãƒ‰å®Ÿè£…
}}
add_action('init', 'register_cpt_{cpt_slug}', 0);
å®Œå…¨ãªPHPã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
"""
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder

    async def execute(self, task: Dict) -> Dict:
        """CPTä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '')
        
        try:
            logger.info("ğŸ”§ ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆé–‹å§‹")
            
            # CPTä»•æ§˜ã‚’æŠ½å‡º
            cpt_spec = self._extract_cpt_spec(description)
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self.PROMPT_TEMPLATE.format(
                cpt_spec=cpt_spec,
                cpt_name=cpt_spec.get('name', 'N/A'),
                cpt_slug=cpt_spec.get('slug', 'custom_post'),
                date=datetime.now().strftime('%Y-%m-%d')
            )
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡
            await self.browser.send_prompt(prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                return {'success': False, 'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'}
            
            # å¿œç­”å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            # PHPä¿å­˜
            output_file = await self._save_php_code(response_text, cpt_spec['slug'], task_id)
            
            return {
                'success': True,
                'message': f'CPTä½œæˆå®Œäº†: {cpt_spec["slug"]}',
                'output_file': str(output_file),
                'cpt_slug': cpt_spec['slug'],
                'task_id': task_id
            }
            
        except Exception as e:
            logger.error(f"âŒ CPTä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e), 'task_id': task_id}

    def _extract_cpt_spec(self, description: str) -> Dict:
        """èª¬æ˜ã‹ã‚‰CPTä»•æ§˜ã‚’æŠ½å‡º"""
        # M&Aæ¡ˆä»¶ã®å ´åˆ
        if 'ma_case' in description.lower() or 'm&aæ¡ˆä»¶' in description:
            return {
                'slug': 'ma_case',
                'name': 'M&Aæ¡ˆä»¶',
                'singular': 'M&Aæ¡ˆä»¶',
                'plural': 'M&Aæ¡ˆä»¶ä¸€è¦§'
            }
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return {
            'slug': 'custom_post',
            'name': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿',
            'singular': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿',
            'plural': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ä¸€è¦§'
        }

    async def _save_php_code(self, code: str, slug: str, task_id: str) -> Path:
        """PHPã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"cpt_{slug}_{task_id}_{timestamp}.php"
        output_path = self.output_folder / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        logger.info(f"âœ… PHPä¿å­˜: {filename}")
        return output_path

#### 3-3. `wordpress/wp_dev/wp_taxonomy_agent.py`
"""
WordPressã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressTaxonomyAgent:
    """ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        # å®Ÿè£…ï¼ˆwp_cpt_agent.py ã¨åŒæ§˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        return {
            'success': True,
            'message': 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆå®Œäº†ï¼ˆå®Ÿè£…ä¸­ï¼‰',
            'task_id': task.get('task_id')
        }

#wp_design.py
# task_executor.py ã® execute_task ãƒ¡ã‚½ãƒƒãƒ‰å†…ã«è¿½åŠ 

async def execute_task(self, task: Dict) -> bool:
    """å˜ä¸€ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆWordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå¯¾å¿œç‰ˆï¼‰"""
    task_id = task.get('task_id', 'UNKNOWN')
    
    try:
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯é–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
        # ============================================================
        print("\n" + "ğŸ“·"*40)
        print("=" * 80)
        print(f"ğŸ¯ ã‚¿ã‚¹ã‚¯é–‹å§‹: {task_id}")
        print("=" * 80)
        print(f"ğŸ“ å†…å®¹: {task['description'][:70]}...")
        print(f"ğŸ‘¤ æ‹…å½“ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {task['required_role'].upper()}")
        
        # ... ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šã®æ—¢å­˜ã‚³ãƒ¼ãƒ‰ ...
        
        print("=" * 80)
        print("ğŸ“·"*40 + "\n")
        
        logger.info(f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œé–‹å§‹")
        
        # ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’'in_progress'ã«æ›´æ–°
        try:
            await self.update_task_status(task, 'in_progress')
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å¤±æ•—ï¼ˆç¶šè¡Œï¼‰: {e}")
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š ===
        # ============================================================
        role = task['required_role'].lower()
        
        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒãƒƒãƒ—
        timeout_map = {
            'ma': 300.0,
            'content': 240.0,
            'review': 180.0,
            'wordpress': 300.0,
            'wp_design': 300.0,  # WordPressè¨­è¨ˆ
            'wp_dev': 300.0,     # WordPressé–‹ç™º
            'default': 180.0
        }
        
        # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
        task_type = 'default'
        if HAS_TASK_ROUTER and task_router:
            try:
                task_type = task_router.determine_task_type(task)
                logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®š: {task_type}")
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šå¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†: {e}")
        
        task_timeout = timeout_map.get(task_type, timeout_map.get(role, 180.0))
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæŒ¯ã‚Šåˆ†ã‘ï¼‰ ===
        # ============================================================
        result = None
        
        try:
            # --- 3-1: WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¤å®šï¼ˆæœ€å„ªå…ˆï¼‰ ---
            if role == 'wp_design':
                logger.info("="*60)
                logger.info("ğŸ¨ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
                logger.info("="*60)
                task_coro = self._execute_wp_design_task(task)
            
            elif role == 'wp_dev':
                logger.info("="*60)
                logger.info("ğŸ’» WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
                logger.info("="*60)
                task_coro = self._execute_wp_dev_task(task)
            
            # --- 3-2: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ãƒ™ãƒ¼ã‚¹ã®åˆ†å² ---
            elif task_type == 'ma' and self.ma_executor:
                logger.info("="*60)
                logger.info("ğŸ“Š M&A/ä¼æ¥­æ¤œç´¢ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                logger.info("="*60)
                task_coro = self.ma_executor.execute_ma_task(task)
            
            elif task_type == 'content' and self.content_executor:
                logger.info("="*60)
                logger.info("âœï¸ è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                logger.info("="*60)
                task_coro = self.content_executor.execute_writer_task(task, role)
            
            elif task_type == 'review':
                logger.info("="*60)
                logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                logger.info("="*60)
                task_coro = self._execute_review_task(task)
            
            # --- 3-3: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ­ãƒ¼ãƒ«åˆ†å² ---
            else:
                logger.info("="*60)
                logger.info(f"ğŸ“‹ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¹ã‚¯ ({role}) ã¨ã—ã¦å‡¦ç†")
                logger.info("="*60)
                
                if role == 'design':
                    task_coro = self._execute_design_task(task)
                elif role == 'dev':
                    task_coro = self._execute_dev_task(task)
                elif role == 'ui':
                    task_coro = self._execute_ui_task(task)
                elif role == 'wordpress':
                    task_coro = self._execute_wordpress_task(task)
                elif role == 'plugin':
                    task_coro = self._execute_plugin_task(task)
                else:
                    # æœªç™»éŒ²ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
                    agent = self.agents.get(role)
                    if not agent:
                        logger.warning(f"æ‹…å½“ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                        await self.update_task_status(task, 'skipped', error=f"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²")
                        return False
                    task_coro = agent.process_task(task)
            
            # --- 3-4: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§å®Ÿè¡Œ ---
            if HAS_ENHANCED_HANDLER:
                result = await EnhancedErrorHandler.timeout_wrapper(
                    task_coro,
                    timeout=task_timeout,
                    context=f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œ"
                )
            else:
                result = await asyncio.wait_for(task_coro, timeout=task_timeout)
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ===
        # ============================================================
        except asyncio.TimeoutError:
            logger.error("="*60)
            logger.error(f"â±ï¸ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{task_timeout}ç§’ï¼‰")
            logger.error("="*60)
            
            await self.update_task_status(
                task, 
                'failed', 
                error=f'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{task_timeout}ç§’ï¼‰'
            )
            
            print("\n" + "ğŸ“·"*40)
            print("=" * 80)
            print(f"â±ï¸ ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {task_id}")
            print(f"åˆ¶é™æ™‚é–“: {task_timeout}ç§’")
            print("=" * 80)
            print("ğŸ“·"*40 + "\n")
            
            return False
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ5: ä¸€èˆ¬çš„ãªä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ===
        # ============================================================
        except Exception as e:
            logger.error("="*60)
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­ã«ä¾‹å¤–ç™ºç”Ÿ")
            logger.error(f"ã‚¨ãƒ©ãƒ¼: {str(e)}")
            logger.error("="*60)
            
            if HAS_ENHANCED_HANDLER:
                EnhancedErrorHandler.log_error_with_context(
                    e, 
                    f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œ"
                )
            
            await self.update_task_status(task, 'failed', error=str(e))
            
            print("\n" + "ğŸ“·"*40)
            print("=" * 80)
            print(f"ğŸ’¥ ã‚¿ã‚¹ã‚¯ä¾‹å¤–: {task_id}")
            print(f"ä¾‹å¤–: {str(e)}")
            print("=" * 80)
            print("ğŸ“·"*40 + "\n")
            
            return False
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ6: å®Ÿè¡Œçµæœã®å‡¦ç†ï¼ˆæˆåŠŸæ™‚ï¼‰ ===
        # ============================================================
        if result and result.get('success'):
            logger.info("="*60)
            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡ŒæˆåŠŸ")
            logger.info("="*60)
            
            # --- 6-1: çµæœä¿å­˜ ---
            try:
                await self.update_task_status(task, 'completed')
                await self.save_task_output(task, result)
            except Exception as e:
                logger.warning(f"âš ï¸ çµæœä¿å­˜å¤±æ•—ï¼ˆã‚¿ã‚¹ã‚¯è‡ªä½“ã¯æˆåŠŸï¼‰: {e}")
            
            # --- 6-2: ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã§ãƒã‚§ãƒƒã‚¯ ---
            if self.review_agent and role != 'review' and task_type != 'review':
                try:
                    logger.info("="*60)
                    logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã§ãƒã‚§ãƒƒã‚¯ã‚’é–‹å§‹")
                    logger.info("="*60)
                    
                    if HAS_ENHANCED_HANDLER:
                        await EnhancedErrorHandler.timeout_wrapper(
                            self.perform_review_and_add_tasks(task, result),
                            timeout=120.0,
                            context=f"ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆã‚¿ã‚¹ã‚¯ {task_id}ï¼‰"
                        )
                    else:
                        await asyncio.wait_for(
                            self.perform_review_and_add_tasks(task, result),
                            timeout=120.0
                        )
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼å¤±æ•—ï¼ˆç„¡è¦–ï¼‰: {e}")
            
            # --- 6-3: æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º ---
            print("\n" + "ğŸ“·"*40)
            print("=" * 80)
            print(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
            print(f"ã‚¿ã‚¤ãƒ—: {task_type.upper()}")
            print(f"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: æˆåŠŸ")
            print("=" * 80)
            print("ğŸ“·"*40 + "\n")
            
            return True
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ7: å®Ÿè¡Œçµæœã®å‡¦ç†ï¼ˆå¤±æ•—æ™‚ï¼‰ ===
        # ============================================================
        else:
            error_msg = result.get('error', 'ä¸æ˜') if result else 'çµæœãªã—'
            logger.error("="*60)
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œå¤±æ•—")
            logger.error(f"ã‚¨ãƒ©ãƒ¼: {error_msg}")
            logger.error("="*60)
            
            await self.update_task_status(task, 'failed', error=error_msg)
            
            print("\n" + "ğŸ“·"*40)
            print("=" * 80)
            print(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {task_id}")
            print(f"ã‚¿ã‚¤ãƒ—: {task_type.upper()}")
            print(f"ã‚¨ãƒ©ãƒ¼: {error_msg}")
            print("=" * 80)
            print("ğŸ“·"*40 + "\n")
            
            return False
    
    # ============================================================
    # === ãƒ‘ãƒ¼ãƒˆ8: æœ€å¤–å±¤ã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ===
    # ============================================================
    except Exception as e:
        logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å‡¦ç†å…¨ä½“ã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼")
        
        if HAS_ENHANCED_HANDLER:
            EnhancedErrorHandler.log_error_with_context(
                e, 
                f"ã‚¿ã‚¹ã‚¯ {task_id} å…¨ä½“å‡¦ç†"
            )
        else:
            ErrorHandler.log_error(e, f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œ")
        
        try:
            await self.update_task_status(task, 'failed', error=str(e))
        except:
            pass
        
        print("\n" + "ğŸ“·"*40)
        print("=" * 80)
        print(f"ğŸ’¥ ã‚¿ã‚¹ã‚¯é‡å¤§ã‚¨ãƒ©ãƒ¼: {task_id}")
        print(f"ä¾‹å¤–: {str(e)}")
        print("=" * 80)
        print("ğŸ“·"*40 + "\n")
        
        return False


async def _execute_wp_design_task(self, task: Dict) -> Dict:
    """WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
    logger.info("â”Œ" + "â”€"*58 + "â”")
    logger.info("â”‚ ğŸ¨ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
    logger.info("â”œ" + "â”€"*58 + "â”¤")
    logger.info(f"â”‚ ã‚¿ã‚¹ã‚¯: {task.get('description', 'N/A')[:50]}")
    logger.info("â””" + "â”€"*58 + "â”˜")
    
    try:
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾— ===
        agent = self.agents.get('wp_design')
        if not agent:
            logger.error("âŒ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return {
                'success': False,
                'error': 'wp_design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }

        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ ===
        result = await agent.process_task(task)
        
        # === ãƒ‘ãƒ¼ãƒˆ3: çµæœãƒ­ã‚°å‡ºåŠ› ===
        if result.get('success'):
            logger.info("âœ… WordPressè¨­è¨ˆAI: ã‚¿ã‚¹ã‚¯å®Œäº†")
        else:
            logger.error(f"âŒ WordPressè¨­è¨ˆAI: å¤±æ•— - {result.get('error', 'ä¸æ˜')}")
        
        return result
        
    except Exception as e:
        ErrorHandler.log_error(e, "WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
        logger.error(f"âŒ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ä¾‹å¤–ç™ºç”Ÿ - {str(e)}")
        return {
            'success': False,
            'error': f'WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}'
        }


async def _execute_wp_dev_task(self, task: Dict) -> Dict:
    """WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
    logger.info("â”Œ" + "â”€"*58 + "â”")
    logger.info("â”‚ ğŸ’» WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
    logger.info("â”œ" + "â”€"*58 + "â”¤")
    logger.info(f"â”‚ ã‚¿ã‚¹ã‚¯: {task.get('description', 'N/A')[:50]}")
    logger.info("â””" + "â”€"*58 + "â”˜")
    
    try:
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾— ===
        agent = self.agents.get('wp_dev')
        if not agent:
            logger.error("âŒ WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return {
                'success': False,
                'error': 'wp_dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ ===
        result = await agent.process_task(task)
        
        # === ãƒ‘ãƒ¼ãƒˆ3: çµæœãƒ­ã‚°å‡ºåŠ› ===
        if result.get('success'):
            logger.info("âœ… WordPressé–‹ç™ºAI: ã‚¿ã‚¹ã‚¯å®Œäº†")
        else:
            logger.error(f"âŒ WordPressé–‹ç™ºAI: å¤±æ•— - {result.get('error', 'ä¸æ˜')}")
        
        return result
        
    except Exception as e:
        ErrorHandler.log_error(e, "WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
        logger.error(f"âŒ WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ä¾‹å¤–ç™ºç”Ÿ - {str(e)}")
        return {
            'success': False,
            'error': f'WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}'
        }

#wp_dev.py
"""
WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ãƒ«ãƒ¼ã‚¿ãƒ¼ï¼ˆå®Œå…¨å‹•ä½œç‰ˆï¼‰
"""

import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class WordPressDevAgent:
    """WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ãƒ«ãƒ¼ã‚¿ãƒ¼ï¼ˆå®Œå…¨å‹•ä½œç‰ˆï¼‰"""
    
    def __init__(self, browser, output_folder: Path = None):
        self.browser = browser
        self.output_folder = output_folder or Path('./outputs/wordpress')
        self.output_folder.mkdir(parents=True, exist_ok=True)
        
        # å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        self._init_specialized_agents()
        
        logger.info("âœ… WordPressDevAgent åˆæœŸåŒ–å®Œäº†")
    
    def _init_specialized_agents(self):
        """å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–"""
        try:
            from wordpress.wp_dev import (
                WordPressRequirementsAgent,
                WordPressCPTAgent,
                WordPressTaxonomyAgent,
                WordPressACFAgent
            )
            
            self.requirements_agent = WordPressRequirementsAgent(
                self.browser, 
                self.output_folder
            )
            self.cpt_agent = WordPressCPTAgent(self.browser, self.output_folder)
            self.taxonomy_agent = WordPressTaxonomyAgent(self.browser, self.output_folder)
            self.acf_agent = WordPressACFAgent(self.browser, self.output_folder)
            
            logger.info("âœ… å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
            
        except ImportError as e:
            logger.warning(f"âš ï¸ ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            self.requirements_agent = None
            self.cpt_agent = None
            self.taxonomy_agent = None
            self.acf_agent = None
    
    async def execute(self, task: Dict) -> Dict:
        """
        execute ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆï¼‰
        ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®äº’æ›æ€§ã®ãŸã‚
        """
        return await self.process_task(task)
    
    async def process_task(self, task: Dict) -> Dict:
        """
        process_task ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆï¼‰
        å®Ÿéš›ã®ã‚¿ã‚¹ã‚¯å‡¦ç†
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            logger.info(f"ğŸ”§ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯: {task_id}")
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            task_type = self._determine_task_type(description)
            logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—: {task_type}")
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«æŒ¯ã‚Šåˆ†ã‘
            if task_type == 'requirements':
                if self.requirements_agent:
                    return await self.requirements_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'cpt':
                if self.cpt_agent:
                    return await self.cpt_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'taxonomy':
                if self.taxonomy_agent:
                    return await self.taxonomy_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'acf':
                if self.acf_agent:
                    return await self.acf_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                return await self._fallback_execution(task)
        
        except Exception as e:
            logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return {
                'success': False,
                'error': str(e),
                'task_id': task_id
            }
    
    def _determine_task_type(self, description: str) -> str:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆæŸ”è»Ÿç‰ˆï¼‰"""
        # è¦ä»¶å®šç¾©ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        requirements_patterns = [
            'è¦ä»¶å®šç¾©', 'requirements', 'ä»•æ§˜æ›¸', 'è¨­è¨ˆæ›¸',
            'ãƒãƒ¼ã‚¿ãƒ«', 'cocoon', 'polylang', 'å¤šè¨€èª',
            'm&a', 'ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³', 'wordpress'
        ]
        
        if any(kw in description for kw in requirements_patterns):
            return 'requirements'
        
        # CPT
        if any(kw in description for kw in ['cpt', 'custom post type', 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿', 'ma_case']):
            return 'cpt'
        
        # ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼
        if any(kw in description for kw in ['taxonomy', 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼', 'ã‚«ãƒ†ã‚´ãƒª', 'industry']):
            return 'taxonomy'
        
        # ACF
        if any(kw in description for kw in ['acf', 'advanced custom fields', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰']):
            return 'acf'
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return 'requirements'
    
    async def _fallback_execution(self, task: Dict) -> Dict:
        """ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ"""
        logger.warning("âš ï¸ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸åœ¨ - Geminiã§ç›´æ¥å®Ÿè¡Œ")
        
        try:
            prompt = f"""WordPressã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

{task.get('description', '')}

ç°¡æ½”ã«å®Ÿè£…æ–¹æ³•ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚"""
            
            await self.browser.send_prompt(prompt)
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if success:
                response = await self.browser.extract_latest_text_response()
                return {
                    'success': True,
                    'message': 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œå®Œäº†',
                    'summary': response[:300] if response else 'N/A',
                    'full_text': response or ''
                }
            else:
                return {
                    'success': False,
                    'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

#wp_plugin_manager.py
"""wp_plugin_manager.py_WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†"""
import logging
import asyncio
from typing import Dict, List, Optional, Any
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

from .wp_utils import PluginNameExtractor

logger = logging.getLogger(__name__)


class WordPressPluginManager:
    """WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†æ©Ÿèƒ½"""

    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            wp_credentials: WordPress èªè¨¼æƒ…å ±
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        
        logger.info(f"WordPressPluginManager åˆæœŸåŒ–: {self.wp_url}")

        # ========================================
        # âœ… ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        # ========================================
            
        # ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆå¾Œã§å¤–éƒ¨ã‹ã‚‰è¨­å®šã•ã‚Œã‚‹ï¼‰
        self.sheets_manager = None
            
        # æŠ•ç¨¿ç·¨é›†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        try:
            self.post_editor = WordPressPostEditor(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("âœ… WordPressPostEditor åˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            logger.error(f"âŒ WordPressPostEditor åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.post_editor = None
            
        # æŠ•ç¨¿ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        try:
            self.post_creator = WordPressPostCreator(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("âœ… WordPressPostCreator åˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            logger.error(f"âŒ WordPressPostCreator åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.post_creator = None
            
        # ========================================
        # âœ… é‡è¦ï¼šãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆä¿®æ­£ç‰ˆï¼‰
        # ========================================
        try:
            self.plugin_manager = WordPressPluginManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("âœ… WordPressPluginManager åˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            logger.error(f"âŒ WordPressPluginManager åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.plugin_manager = None
            
        # è¨­å®šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        try:
            self.settings_manager = WordPressSettingsManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("âœ… WordPressSettingsManager åˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            logger.error(f"âŒ WordPressSettingsManager åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.settings_manager = None
            
        # ãƒ†ã‚¹ã‚¿ãƒ¼
        try:
            self.tester = WordPressTester(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("âœ… WordPressTester åˆæœŸåŒ–å®Œäº†")
        except Exception as e:
            logger.error(f"âŒ WordPressTester åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.tester = None
            
        logger.info("="*60)
        logger.info("WordPressAgent å…¨ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        logger.info("="*60)
        
    async def install_plugin(self, page: Page, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«"""
        try:
            logger.info("ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’å®Ÿè¡Œä¸­...")
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/plugin-install.php")
            await page.wait_for_timeout(2000)
            
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º
            plugin_name = PluginNameExtractor.extract(task['description'])
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢
            search_box = await page.query_selector('#search-plugins')
            if search_box:
                await search_box.fill(plugin_name)
                await page.keyboard.press('Enter')
                await page.wait_for_timeout(4000)
                
                logger.info(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢å®Œäº†: {plugin_name}")
                
                # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨æœ‰åŠ¹åŒ–
                installed, status = await self._install_and_activate(page)
                
                # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                screenshot_path = f"wp_plugin_{datetime.now().strftime('%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                
                if installed:
                    return {
                        'success': True,
                        'summary': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ "{plugin_name}" ã‚’{status}',
                        'screenshot': screenshot_path,
                        'full_text': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‡¦ç†å®Œäº†\nåå‰: {plugin_name}\nã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
                    }
                else:
                    return {
                        'success': True,
                        'summary': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ "{plugin_name}" ã‚’æ¤œç´¢ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
                        'screenshot': screenshot_path,
                        'full_text': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢: {plugin_name}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}\nâ€»ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸãŸã‚æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
                    }
            else:
                return {
                    'success': False,
                    'error': 'æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _install_and_activate(self, page: Page) -> tuple[bool, str]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»æœ‰åŠ¹åŒ–"""
        install_selectors = [
            'a.install-now:has-text("ä»Šã™ãã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«")',
            '.plugin-card-top a.install-now',
            'a[data-slug]:has-text("ä»Šã™ãã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«")',
        ]
        
        for selector in install_selectors:
            try:
                install_button = await page.query_selector(selector)
                if install_button and await install_button.is_visible():
                    logger.info(f"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯: {selector}")
                    await install_button.click()
                    
                    # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†ã‚’å¾…ã¤
                    await page.wait_for_timeout(5000)
                    
                    # æœ‰åŠ¹åŒ–ãƒœã‚¿ãƒ³ã‚’æ¢ã™
                    activate_button = await page.query_selector('a:has-text("æœ‰åŠ¹åŒ–")')
                    if activate_button:
                        logger.info("æœ‰åŠ¹åŒ–ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
                        await activate_button.click()
                        await page.wait_for_timeout(3000)
                        logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨æœ‰åŠ¹åŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ")
                        return True, "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»æœ‰åŠ¹åŒ–å®Œäº†"
                    else:
                        logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸ(æœ‰åŠ¹åŒ–ã¯æ‰‹å‹•)")
                        return True, "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†(æœ‰åŠ¹åŒ–ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„)"
            except Exception as e:
                logger.warning(f"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«è©¦è¡Œã‚¨ãƒ©ãƒ¼ ({selector}): {e}")
                continue
        
        return False, "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¤±æ•—"
    
    async def change_plugin_settings(self, page: Page, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚’å¤‰æ›´"""
        try:
            logger.info("ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šå¤‰æ›´ã‚’å®Ÿè¡Œä¸­...")
            
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º
            plugin_name = PluginNameExtractor.extract(task['description'])
            logger.info(f"å¯¾è±¡ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugin_name}")
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€è¦§ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/plugins.php")
            await page.wait_for_timeout(3000)
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨­å®šãƒªãƒ³ã‚¯ã‚’æ¢ã™
            settings_found = await self._navigate_to_settings(page, plugin_name)
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"wp_plugin_settings_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            if settings_found:
                return {
                    'success': True,
                    'summary': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€Œ{plugin_name}ã€ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚æ‰‹å‹•ã§è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
                    'screenshot': screenshot_path,
                    'full_text': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šç”»é¢è¡¨ç¤º\nãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugin_name}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}\nâ€»è¨­å®šå¤‰æ›´ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
                }
            else:
                return {
                    'success': False,
                    'error': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€Œ{plugin_name}ã€ã®è¨­å®šç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ',
                    'screenshot': screenshot_path
                }
                
        except Exception as e:
            logger.error(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šå¤‰æ›´ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    # wp_plugin_manager.py ã® WordPressPluginManager ã‚¯ãƒ©ã‚¹ã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 

    # === 1. FacetWPè¨­å®šæ©Ÿèƒ½ ===
    async def configure_facetwp(self, page: Page, task_params: Dict) -> Dict:
        """
        FacetWP çµã‚Šè¾¼ã¿æ¤œç´¢ã®è¨­å®šï¼ˆå®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯å¼·åŒ–ç‰ˆï¼‰
            
        Parameters:
            facets: list - ãƒ•ã‚¡ã‚»ãƒƒãƒˆè¨­å®šã®ãƒªã‚¹ãƒˆ
                - name: ãƒ•ã‚¡ã‚»ãƒƒãƒˆå
                - type: ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¿ã‚¤ãƒ— (checkboxes, slider, dropdownãªã©)
                - source: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ (tax/ã‚«ãƒ†ã‚´ãƒªå, cf/ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å)
        """
        try:
            facets = task_params.get('facets', [])
                
            logger.info("FacetWPè¨­å®šã‚’é–‹å§‹...")
            logger.info(f"è¨­å®šã™ã‚‹ãƒ•ã‚¡ã‚»ãƒƒãƒˆæ•°: {len(facets)}ä»¶")
                
            # FacetWPè¨­å®šç”»é¢ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=facetwp-settings")
            await page.wait_for_timeout(3000)
                
            # ========================================
            # ğŸ†• ãƒ•ã‚¡ã‚»ãƒƒãƒˆè‡ªå‹•è¿½åŠ ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæ–°è¦å®Ÿè£…ï¼‰
            # ========================================
            created_facets = []
                
            for i, facet in enumerate(facets, 1):
                try:
                    logger.info(f"ãƒ•ã‚¡ã‚»ãƒƒãƒˆ {i}/{len(facets)}: {facet.get('name')} ã‚’ä½œæˆä¸­...")
                        
                    # "Add New" ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
                    add_new_selectors = [
                        'a.facetwp-add:has-text("Add New")',
                        'button:has-text("Add New")',
                        '.facetwp-add-facet'
                    ]
                        
                    for selector in add_new_selectors:
                        try:
                            add_button = await page.query_selector(selector)
                            if add_button and await add_button.is_visible():
                                await add_button.click()
                                await page.wait_for_timeout(1500)
                                logger.info("âœ… Add Newãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
                                break
                        except:
                            continue
                        
                    # ãƒ•ã‚¡ã‚»ãƒƒãƒˆåã‚’å…¥åŠ›
                    name_input = await page.query_selector('input[name="facet_label"]')
                    if name_input:
                        await name_input.fill(facet.get('name', ''))
                        logger.info(f"  ãƒ•ã‚¡ã‚»ãƒƒãƒˆå: {facet.get('name')}")
                        
                    # ãƒ•ã‚¡ã‚»ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’é¸æŠ
                    type_select = await page.query_selector('select[name="facet_type"]')
                    if type_select:
                        await type_select.select_option(facet.get('type', 'checkboxes'))
                        logger.info(f"  ã‚¿ã‚¤ãƒ—: {facet.get('type')}")
                        
                    # ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‚’è¨­å®š
                    source = facet.get('source', '')
                    if source.startswith('tax/'):
                        # ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚½ãƒ¼ã‚¹
                        taxonomy_name = source.replace('tax/', '')
                        source_select = await page.query_selector('select[name="facet_source"]')
                        if source_select:
                            await source_select.select_option('tax')
                            await page.wait_for_timeout(500)
                            
                        # ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚’é¸æŠ
                        taxonomy_select = await page.query_selector('select[name="facet_source_taxonomy"]')
                        if taxonomy_select:
                            await taxonomy_select.select_option(taxonomy_name)
                            logger.info(f"  ã‚½ãƒ¼ã‚¹: Taxonomy - {taxonomy_name}")
                        
                    elif source.startswith('cf/'):
                        # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚½ãƒ¼ã‚¹
                        field_name = source.replace('cf/', '')
                        source_select = await page.query_selector('select[name="facet_source"]')
                        if source_select:
                            await source_select.select_option('cf')
                            await page.wait_for_timeout(500)
                            
                        # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’å…¥åŠ›
                        field_input = await page.query_selector('input[name="facet_source_custom_field"]')
                        if field_input:
                            await field_input.fill(field_name)
                            logger.info(f"  ã‚½ãƒ¼ã‚¹: Custom Field - {field_name}")
                        
                    # ä¿å­˜ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
                    save_selectors = [
                        'button.facetwp-save:has-text("Save")',
                        'button:has-text("Save Changes")',
                        'input[type="submit"][value="Save"]'
                    ]
                        
                    for selector in save_selectors:
                        try:
                            save_button = await page.query_selector(selector)
                            if save_button and await save_button.is_visible():
                                await save_button.click()
                                await page.wait_for_timeout(2000)
                                logger.info(f"âœ… ãƒ•ã‚¡ã‚»ãƒƒãƒˆ '{facet.get('name')}' ã‚’ä¿å­˜")
                                created_facets.append(facet.get('name'))
                                break
                        except:
                            continue
                        
                    await page.wait_for_timeout(1000)
                        
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒ•ã‚¡ã‚»ãƒƒãƒˆ {i} ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
                    continue
                
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            from datetime import datetime
            screenshot_path = f"facetwp_setup_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
                
            # çµæœã‚µãƒãƒªãƒ¼
            summary_lines = ["ã€FacetWPè¨­å®šå®Œäº†ã€‘"]
            summary_lines.append(f"ä½œæˆæˆåŠŸ: {len(created_facets)}/{len(facets)}ä»¶")
            for name in created_facets:
                summary_lines.append(f"  âœ“ {name}")
                
            if len(created_facets) < len(facets):
                summary_lines.append("\nâš ï¸ ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚»ãƒƒãƒˆã¯æ‰‹å‹•ã§ç¢ºèªãŒå¿…è¦ã§ã™")
                
            summary = '\n'.join(summary_lines)
                
            return {
                'success': len(created_facets) > 0,
                'summary': summary,
                'facets_created': created_facets,
                'facets_count': len(facets),
                'screenshot': screenshot_path,
                'full_text': f'{summary}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"FacetWPè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    # === 2. User Role Editorè¨­å®šæ©Ÿèƒ½ ===
    async def configure_user_roles(self, page: Page, task_params: Dict) -> Dict:
        """
        User Role Editorã§ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ«ã‚’ä½œæˆ
    
        Parameters:
            role_slug: str - ãƒ­ãƒ¼ãƒ«ã‚¹ãƒ©ãƒƒã‚°
            role_name: str - ãƒ­ãƒ¼ãƒ«è¡¨ç¤ºå
            capabilities: dict - æ¨©é™è¨­å®š
        """
        try:
            role_slug = task_params.get('role_slug')
            role_name = task_params.get('role_name')
            capabilities = task_params.get('capabilities', {})
        
            logger.info(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ« '{role_name}' ã‚’ä½œæˆä¸­...")
        
            # User Role Editorç”»é¢ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/users.php?page=users-user-role-editor-php")
            await page.wait_for_timeout(3000)
        
            # Add Roleãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            add_role_selectors = [
                'button:has-text("Add Role")',
                'input[value="Add Role"]',
                '#ure_add_role_button'
            ]
        
            for selector in add_role_selectors:
                try:
                    add_button = await page.query_selector(selector)
                    if add_button and await add_button.is_visible():
                        await add_button.click()
                        await page.wait_for_timeout(2000)
                        break
                except:
                    continue
        
            # Role slugå…¥åŠ›
            slug_input = await page.query_selector('#user_role_id')
            if slug_input:
                await slug_input.fill(role_slug)
                logger.info(f"ãƒ­ãƒ¼ãƒ«ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {role_slug}")
        
            # Role nameå…¥åŠ›
            name_input = await page.query_selector('#user_role_name')
            if name_input:
                await name_input.fill(role_name)
                logger.info(f"ãƒ­ãƒ¼ãƒ«åã‚’å…¥åŠ›: {role_name}")
        
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            from datetime import datetime
            screenshot_path = f"user_role_{role_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("âš ï¸ æ¨©é™ï¼ˆCapabilitiesï¼‰ã®è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
            return {
                'success': True,
                'summary': f'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ« "{role_name}" ã®ä½œæˆç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'role_slug': role_slug,
                'role_name': role_name,
                'screenshot': screenshot_path,
                'full_text': f'User Roleä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {role_slug}\nè¡¨ç¤ºå: {role_name}\nâ€»æ¨©é™è¨­å®šã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
            }
        
        except Exception as e:
            logger.error(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 3. Wordfence Securityè¨­å®šæ©Ÿèƒ½ ===
    async def configure_wordfence(self, page: Page, task_params: Dict) -> Dict:
        """
        Wordfence Security ã®åŸºæœ¬è¨­å®š
    
        Parameters:
            firewall_mode: str - ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰ï¼ˆlearning, enabledï¼‰
            scan_schedule: str - ã‚¹ã‚­ãƒ£ãƒ³ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
            two_factor_auth: bool - 2FAæœ‰åŠ¹åŒ–
        """
        try:
            firewall_mode = task_params.get('firewall_mode', 'enabled')
            scan_schedule = task_params.get('scan_schedule', 'daily')
            two_factor_auth = task_params.get('two_factor_auth', True)
        
            logger.info("Wordfence Securityè¨­å®šã‚’é–‹å§‹...")
        
            # Wordfenceç”»é¢ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/admin.php?page=Wordfence")
            await page.wait_for_timeout(3000)
        
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            from datetime import datetime
            screenshot_path = f"wordfence_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("âš ï¸ Wordfenceã®è©³ç´°è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
            summary = f"""ã€Wordfence Securityè¨­å®šã€‘
    ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰: {firewall_mode}
    ã‚¹ã‚­ãƒ£ãƒ³ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«: {scan_schedule}
    2FA: {'æœ‰åŠ¹' if two_factor_auth else 'ç„¡åŠ¹'}
    â€»æ‰‹å‹•ã§è¨­å®šã‚’å®Œäº†ã—ã¦ãã ã•ã„"""
        
            return {
                'success': True,
                'summary': 'Wordfenceè¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"Wordfenceè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 4. WP Rocketè¨­å®šæ©Ÿèƒ½ ===
    async def configure_wp_rocket(self, page: Page, task_params: Dict) -> Dict:
        """
        WP Rocket ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨­å®š
    
        Parameters:
            cache_options: dict - ã‚­ãƒ£ãƒƒã‚·ãƒ¥è¨­å®š
            optimization: dict - æœ€é©åŒ–è¨­å®š
        """
        try:
            cache_options = task_params.get('cache_options', {})
            optimization = task_params.get('optimization', {})
        
            logger.info("WP Rocketè¨­å®šã‚’é–‹å§‹...")
        
            # WP Rocketè¨­å®šç”»é¢ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=wprocket")
            await page.wait_for_timeout(3000)
        
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            from datetime import datetime
            screenshot_path = f"wp_rocket_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("âš ï¸ WP Rocketã®è©³ç´°è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
            summary = """ã€WP Rocketè¨­å®šã€‘
    æ¨å¥¨è¨­å®š:
    - Mobile Cache: æœ‰åŠ¹
    - User Cache: æœ‰åŠ¹
    - Minify CSS/JS: æœ‰åŠ¹
    - Combine CSS/JS: æœ‰åŠ¹
    â€»æ‰‹å‹•ã§è¨­å®šã‚’å®Œäº†ã—ã¦ãã ã•ã„"""
        
            return {
                'success': True,
                'summary': 'WP Rocketè¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"WP Rocketè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 5. Relevanssiè¨­å®šæ©Ÿèƒ½ ===
    async def configure_relevanssi(self, page: Page, task_params: Dict) -> Dict:
        """
        Relevanssi é«˜åº¦ãªæ¤œç´¢ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨­å®š
    
        Parameters:
            index_fields: list - ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
            search_settings: dict - æ¤œç´¢è¨­å®š
        """
        try:
            index_fields = task_params.get('index_fields', [])
            search_settings = task_params.get('search_settings', {})
        
            logger.info("Relevanssiè¨­å®šã‚’é–‹å§‹...")
        
            # Relevanssiè¨­å®šç”»é¢ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=relevanssi/relevanssi.php")
            await page.wait_for_timeout(3000)
        
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            from datetime import datetime
            screenshot_path = f"relevanssi_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
        
            logger.info("âš ï¸ Relevanssiã®è©³ç´°è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
            summary = f"""ã€Relevanssiè¨­å®šã€‘
    ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: {len(index_fields)}ä»¶
    æ¨å¥¨è¨­å®š:
    - Custom fields: ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’è¿½åŠ 
    - Build Index: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹ç¯‰å®Ÿè¡Œ
    - Weightè¨­å®š: Title=é«˜, Content=ä¸­, Custom fields=ä¸­
    â€»æ‰‹å‹•ã§è¨­å®šã‚’å®Œäº†ã—ã¦ãã ã•ã„"""
        
            return {
                'success': True,
                'summary': 'Relevanssiè¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"Relevanssiè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 6. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€æ‹¬è¨­å®šæ©Ÿèƒ½ ===
    async def bulk_configure_plugins(self, page: Page, plugin_configs: List[Dict]) -> Dict:
        """
        è¤‡æ•°ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ä¸€æ‹¬ã§è¨­å®š
    
        Parameters:
            plugin_configs: list - ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã®ãƒªã‚¹ãƒˆ
        """
        try:
            results = []
        
            for i, config in enumerate(plugin_configs, 1):
                plugin_name = config.get('plugin_name')
                logger.info(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®š {i}/{len(plugin_configs)}: {plugin_name}")
            
                if plugin_name == 'facetwp':
                    result = await self.configure_facetwp(page, config)
                elif plugin_name == 'user-role-editor':
                    result = await self.configure_user_roles(page, config)
                elif plugin_name == 'wordfence':
                    result = await self.configure_wordfence(page, config)
                elif plugin_name == 'wp-rocket':
                    result = await self.configure_wp_rocket(page, config)
                elif plugin_name == 'relevanssi':
                    result = await self.configure_relevanssi(page, config)
                else:
                    result = {'success': False, 'error': f'æœªå¯¾å¿œã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugin_name}'}
            
                results.append({'plugin': plugin_name, 'result': result})
        
            successful = sum(1 for r in results if r['result'].get('success'))
        
            return {
                'success': successful > 0,
                'summary': f'{successful}/{len(plugin_configs)}ä»¶ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚’å®Œäº†',
                'results': results
            }
        
        except Exception as e:
            logger.error(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€æ‹¬è¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _navigate_to_settings(self, page: Page, plugin_name: str) -> bool:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šç”»é¢ã¸ç§»å‹•"""
        settings_selectors = [
            f'tr:has-text("{plugin_name}") .settings a',
            f'a:has-text("{plugin_name}è¨­å®š")',
            '.plugin-action-buttons a:has-text("è¨­å®š")'
        ]
        
        for selector in settings_selectors:
            try:
                settings_link = await page.query_selector(selector)
                if settings_link and await settings_link.is_visible():
                    await settings_link.click()
                    await page.wait_for_timeout(3000)
                    logger.info(f"âœ… {plugin_name}ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸ")
                    return True
            except:
                continue
        
        return False

#wp_post_creator.py
"""WordPressæŠ•ç¨¿ä½œæˆ"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostCreator:
    """WordPressæŠ•ç¨¿ä½œæˆæ©Ÿèƒ½"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
    
    async def create_post(self, page: Page, task: Dict) -> Dict:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„(æŠ•ç¨¿/ãƒšãƒ¼ã‚¸)ã‚’ä½œæˆ"""
        try:
            logger.info("ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚’å®Ÿè¡Œä¸­...")
            
            # task_idã‚’æŠ½å‡º
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            post_content = None
            post_title = f"AIæŠ•ç¨¿_{datetime.now().strftime('%Y%m%d_%H%M')}"
            
            if target_task_id:
                logger.info(f"task_id {target_task_id} ã®è¨˜äº‹å†…å®¹ã‚’ä½¿ç”¨")
                post_content = await TaskContentFetcher.get_task_content(
                    self.sheets_manager, target_task_id
                )
                
                if post_content:
                    # ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡º(æœ€åˆã®è¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«ã¨ã™ã‚‹)
                    lines = post_content.split('\n')
                    if lines:
                        post_title = lines[0].strip()[:100]
                        # æœ¬æ–‡ã¯2è¡Œç›®ä»¥é™
                        post_content = '\n'.join(lines[1:]).strip()
            
            if not post_content:
                # ã‚¿ã‚¹ã‚¯ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’ç›´æ¥æŠ½å‡º
                title_match = re.search(r'ã‚¿ã‚¤ãƒˆãƒ«[ã€€\s]*(.+?)[\næœ¬æ–‡]', task['description'])
                content_match = re.search(r'æœ¬æ–‡[ã€€\s]*(.+?)[\nã€]', task['description'])
                
                post_title = title_match.group(1).strip() if title_match else post_title
                post_content = content_match.group(1).strip() if content_match else "è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„"
            
            logger.info(f"æŠ•ç¨¿å†…å®¹: ã‚¿ã‚¤ãƒˆãƒ«='{post_title}', æœ¬æ–‡='{post_content[:50]}...'")
            
            # æ–°è¦æŠ•ç¨¿ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/post-new.php")
            await page.wait_for_timeout(4000)
            
            # ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
            title_filled = await self._fill_title(page, post_title)
            
            # æœ¬æ–‡å…¥åŠ›
            content_filled = await self._fill_content(page, post_content)
            
            # Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«è¨­å®š
            await self._set_polylang_language(page)
            
            # ä¸‹æ›¸ãä¿å­˜
            saved = await self._save_draft(page)
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"wp_post_saved_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            
            if saved:
                return {
                    'success': True,
                    'summary': f'æŠ•ç¨¿ã‚’ä¸‹æ›¸ãä¿å­˜ã—ã¾ã—ãŸã€‚ã‚¿ã‚¤ãƒˆãƒ«: {post_title}',
                    'screenshot': screenshot_path,
                    'full_text': f'æŠ•ç¨¿ä½œæˆå®Œäº†\nã‚¿ã‚¤ãƒˆãƒ«: {post_title}\næœ¬æ–‡: {post_content[:200]}...\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
                }
            else:
                return {
                    'success': True,
                    'summary': f'æŠ•ç¨¿ã‚’ä½œæˆã—ã¾ã—ãŸ(ä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸãŸã‚æ‰‹å‹•ç¢ºèªãŒå¿…è¦)',
                    'screenshot': screenshot_path,
                    'full_text': f'æŠ•ç¨¿ä½œæˆ\nã‚¿ã‚¤ãƒˆãƒ«: {post_title}\næœ¬æ–‡: {post_content[:200]}...\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
                }
                
        except Exception as e:
            logger.error(f"ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _fill_title(self, page: Page, title: str) -> bool:
        """ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ "]',
            'textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]',
            '#post-title-0'
        ]
        
        for selector in title_selectors:
            try:
                title_input = await page.query_selector(selector)
                if title_input and await title_input.is_visible():
                    await title_input.click()
                    await page.wait_for_timeout(500)
                    await title_input.fill(title)
                    await page.wait_for_timeout(1000)
                    logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›å®Œäº†: {title}")
                    return True
            except:
                continue
        
        logger.warning("ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return False
    
    # wp_post_creator.py ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    async def _fill_html_content(self, page: Page, html_content: str) -> bool:
        """HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’Gutenbergã‚¨ãƒ‡ã‚£ã‚¿ã«æŒ¿å…¥"""
        try:
            logger.info("HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æŒ¿å…¥ä¸­...")
        
            # ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ 
            await page.keyboard.press('/')
            await page.wait_for_timeout(1000)
            await page.keyboard.type('html')
            await page.wait_for_timeout(1000)
            await page.keyboard.press('Enter')
            await page.wait_for_timeout(2000)
        
            # HTMLå…¥åŠ›ã‚¨ãƒªã‚¢ã‚’è¦‹ã¤ã‘ã‚‹
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]'
            ]
        
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input and await html_input.is_visible():
                        await html_input.click()
                        await page.wait_for_timeout(500)
                        await html_input.fill(html_content)
                        await page.wait_for_timeout(1000)
                        logger.info("âœ… HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„æŒ¿å…¥å®Œäº†")
                        return True
                except Exception as e:
                    logger.debug(f"HTMLå…¥åŠ›è©¦è¡Œã‚¨ãƒ©ãƒ¼ ({selector}): {e}")
                    continue
        
            return False
        
        except Exception as e:
            logger.error(f"HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„æŒ¿å…¥ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def _fill_content(self, page: Page, content: str) -> bool:
        """æœ¬æ–‡å…¥åŠ›"""
        # Tabã‚­ãƒ¼ã§æœ¬æ–‡ã‚¨ãƒªã‚¢ã«ç§»å‹•
        await page.keyboard.press('Tab')
        await page.wait_for_timeout(500)
        
        content_selectors = [
            'p[data-title="æ®µè½"]',
            '.block-editor-default-block-appender__content',
            '[aria-label="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ "]',
            '.wp-block-paragraph'
        ]
        
        for selector in content_selectors:
            try:
                content_area = await page.query_selector(selector)
                if content_area:
                    await content_area.click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content)
                    await page.wait_for_timeout(1000)
                    logger.info("âœ… æœ¬æ–‡å…¥åŠ›å®Œäº†")
                    return True
            except:
                continue
        
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å˜ç´”ã«Tabã‚­ãƒ¼å¾Œã«å…¥åŠ›
        await page.keyboard.type(content)
        await page.wait_for_timeout(1000)
        logger.info("âœ… æœ¬æ–‡å…¥åŠ›å®Œäº†(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)")
        return True
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«è¨­å®šï¼ˆwp_post_editor.pyã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylangè¨€èªè¨­å®šã‚»ãƒ¬ã‚¯ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        # æ—¥æœ¬èªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ¢ã™
                        options = await lang_select.inner_text()
                        logger.debug(f"  â†’ åˆ©ç”¨å¯èƒ½ãªè¨€èª: {options[:100]}")
                        
                        # è¤‡æ•°ã®æ—¥æœ¬èªè¡¨è¨˜ã‚’è©¦ã™
                        japanese_labels = ['æ—¥æœ¬èª', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"âœ… Polylangè¨€èªè¨­å®šæˆåŠŸ: {label}")
                                
                                # ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç†
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ Polylangè¨€èªè¨­å®šè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‡¦ç†ï¼ˆwp_post_editor.pyã¨åŒã˜ï¼‰"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("ã¯ã„")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("âœ… ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§OKã‚’ã‚¯ãƒªãƒƒã‚¯")
                        return
            except:
                continue
    
    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        save_selectors = [
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            '.editor-post-save-draft'
        ]
        
        for selector in save_selectors:
            try:
                save_button = await page.query_selector(selector)
                if save_button and await save_button.is_visible():
                    is_disabled = await save_button.is_disabled()
                    if not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(3000)
                        logger.info("âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†")
                        return True
            except:
                continue
        
        return False

#wp_post_editor.py
"""WordPressæŠ•ç¨¿ç·¨é›†ï¼ˆè¶…å …ç‰¢ç‰ˆãƒ»è©³ç´°ãƒ­ã‚°ä»˜ãï¼‰"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostEditor:
    """WordPressæŠ•ç¨¿ç·¨é›†æ©Ÿèƒ½ï¼ˆè¶…å …ç‰¢ç‰ˆï¼‰"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
        self.debug_screenshots = []  # ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¸€è¦§
    
    async def edit_post(self, page: Page, task: Dict) -> Dict:
        """æ—¢å­˜ã®æŠ•ç¨¿ã‚’ç·¨é›†ï¼ˆã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºæ”¹å–„ç‰ˆï¼‰"""
        try:
            logger.info("="*80)
            logger.info("ã€ã‚¹ãƒ†ãƒƒãƒ—1/10ã€‘æŠ•ç¨¿ç·¨é›†ã‚¿ã‚¹ã‚¯é–‹å§‹")
            logger.info("="*80)
            
            # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚¿ã‚¹ã‚¯å†…å®¹ã®è§£æ - æ”¹å–„ç‰ˆ
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—2/10ã€‘ã‚¿ã‚¹ã‚¯å†…å®¹ã‚’è§£æä¸­...")
            
            # è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡º
            search_title = ""
            description = task['description']
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ã€Œã€ã§å›²ã¾ã‚ŒãŸã‚¿ã‚¤ãƒˆãƒ«
            title_patterns = [
                r'[ã€Œã€](.+?)[ã€ã€].*ã®ä¸‹æ›¸ãä¿å­˜',
                r'ã‚¿ã‚¤ãƒˆãƒ«[ã€€\s]*[ã€Œã€](.+?)[ã€ã€]',
                r'æŠ•ç¨¿[ã€€\s]*[ã€Œã€](.+?)[ã€ã€]',
                r'[ã€Œã€](AIæŠ•ç¨¿)[ã€ã€]'  # æ˜ç¤ºçš„ã«ã€ŒAIæŠ•ç¨¿ã€ã‚’æ¢ã™
            ]
            
            for pattern in title_patterns:
                match = re.search(pattern, description)
                if match:
                    search_title = match.group(1)
                    logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºæˆåŠŸï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³: {pattern}ï¼‰: {search_title}")
                    break
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: ç‰¹å®šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰åˆ¤æ–­
            if not search_title:
                if 'AIæŠ•ç¨¿' in description:
                    search_title = 'AIæŠ•ç¨¿'
                    logger.info(f"âœ… ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«æ¨æ¸¬: {search_title}")
            
            if not search_title:
                logger.warning("âš ï¸ ã‚¿ã‚¤ãƒˆãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
                search_title = "AIæŠ•ç¨¿"
            
            logger.info(f"ğŸ” æ¤œç´¢ã‚¿ã‚¤ãƒˆãƒ«: {search_title}")
            
            # ã‚¹ãƒ†ãƒƒãƒ—2: task_idã®æŠ½å‡º
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—3/10ã€‘æ›¸ãæ›ãˆå…ƒè¨˜äº‹ã®task_idã‚’æŠ½å‡ºä¸­...")
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            
            if target_task_id:
                logger.info(f"âœ… task_idæŠ½å‡ºæˆåŠŸ: {target_task_id}")
            else:
                logger.error("âŒ task_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'task_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚¿ã‚¹ã‚¯èª¬æ˜ã«task_idã‚’å«ã‚ã¦ãã ã•ã„ã€‚'
                }
            
            # ã‚¹ãƒ†ãƒƒãƒ—3: è¨˜äº‹å†…å®¹ã®å–å¾—
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—4/10ã€‘Google Drive/ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰è¨˜äº‹å†…å®¹ã‚’å–å¾—ä¸­...")
            logger.info(f"å¯¾è±¡: task_id={target_task_id}")
            
            replacement_content = await TaskContentFetcher.get_task_content(
                self.sheets_manager, target_task_id
            )
            
            if not replacement_content:
                logger.error(f"âŒ task_id {target_task_id} ã®è¨˜äº‹å†…å®¹ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
                return {
                    'success': False,
                    'error': f'task_id {target_task_id} ã®è¨˜äº‹å†…å®¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
                }
            
            logger.info(f"âœ… è¨˜äº‹å†…å®¹å–å¾—æˆåŠŸ: {len(replacement_content)}æ–‡å­—")
            logger.info(f"å…ˆé ­200æ–‡å­—:\n{replacement_content[:200]}...")
            
            # ã‚¹ãƒ†ãƒƒãƒ—3.5: ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—4.5/10ã€‘è¨˜äº‹ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢ä¸­...")
            article_title, article_body = self._extract_title_and_body(replacement_content)
            
            logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«: {article_title}")
            logger.info(f"âœ… æœ¬æ–‡: {len(article_body)}æ–‡å­—")
            
            # ã‚¹ãƒ†ãƒƒãƒ—4: æŠ•ç¨¿ä¸€è¦§ãƒšãƒ¼ã‚¸ã¸ç§»å‹•
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—5/10ã€‘WordPressæŠ•ç¨¿ä¸€è¦§ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ä¸­...")
            await page.goto(f"{self.wp_url}/wp-admin/edit.php", timeout=30000)
            await page.wait_for_timeout(3000)
            
            screenshot_path = await self._save_screenshot(page, "01_post_list")
            logger.info(f"âœ… æŠ•ç¨¿ä¸€è¦§ãƒšãƒ¼ã‚¸åˆ°é”: {screenshot_path}")
            
            # ã‚¹ãƒ†ãƒƒãƒ—5: ã‚¿ã‚¤ãƒˆãƒ«æ¤œç´¢
            if search_title:
                logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—6/10ã€‘ã‚¿ã‚¤ãƒˆãƒ« '{search_title}' ã§æ¤œç´¢ä¸­...")
                search_success = await self._search_post(page, search_title)
                
                if search_success:
                    logger.info("âœ… æ¤œç´¢å®Ÿè¡ŒæˆåŠŸ")
                    screenshot_path = await self._save_screenshot(page, "02_search_result")
                else:
                    logger.warning("âš ï¸ æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
            # ã‚¹ãƒ†ãƒƒãƒ—6: æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ç§»å‹•
            logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—7/10ã€‘æŠ•ç¨¿ '{search_title}' ã®ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ä¸­...")
            post_found, post_id = await self._navigate_to_edit_page(page, search_title)
            
            if not post_found:
                logger.error(f"âŒ æŠ•ç¨¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ: {search_title}")
                screenshot_path = await self._save_screenshot(page, "03_post_not_found")
                return {
                    'success': False,
                    'error': f'ã‚¿ã‚¤ãƒˆãƒ«ã€Œ{search_title}ã€ã®æŠ•ç¨¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ',
                    'screenshot': screenshot_path,
                    'debug_screenshots': self.debug_screenshots
                }
            
            logger.info(f"âœ… æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸åˆ°é”: æŠ•ç¨¿ID={post_id}")
            screenshot_path = await self._save_screenshot(page, "04_edit_page")
            
            # ã‚¹ãƒ†ãƒƒãƒ—7.5: ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´
            if article_title != search_title:
                logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—7.5/10ã€‘æŠ•ç¨¿ã‚¿ã‚¤ãƒˆãƒ«ã‚’ '{article_title}' ã«å¤‰æ›´ä¸­...")
                title_changed = await self._change_title(page, article_title)
                
                if title_changed:
                    logger.info("âœ… ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´å®Œäº†")
                else:
                    logger.warning("âš ï¸ ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ")
                
                screenshot_path = await self._save_screenshot(page, "04b_after_title_change")
            
            # ã‚¹ãƒ†ãƒƒãƒ—7: Polylangè¨€èªè¨­å®š
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—8/10ã€‘Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«å¤‰æ›´ä¸­...")
            language_changed = await self._set_polylang_language(page)
            
            if language_changed:
                logger.info("âœ… Polylangè¨€èªè¨­å®šå®Œäº†: æ—¥æœ¬èª")
            else:
                logger.warning("âš ï¸ Polylangè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
            screenshot_path = await self._save_screenshot(page, "05_after_language")
            
            # ã‚¹ãƒ†ãƒƒãƒ—8: è¨˜äº‹å†…å®¹ã®æ›¸ãæ›ãˆ
            logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—9/10ã€‘è¨˜äº‹å†…å®¹ã‚’æ›¸ãæ›ãˆä¸­... ({len(article_body)}æ–‡å­—)")
            
            # ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›
            article_html = self._convert_markdown_to_html(article_body)
            logger.info(f"  ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³â†’HTMLå¤‰æ›: {len(article_html)}æ–‡å­—")
            
            content_replaced = await self._replace_content(page, article_html)
            
            if content_replaced:
                logger.info("âœ… è¨˜äº‹å†…å®¹ã®æ›¸ãæ›ãˆå®Œäº†")
            else:
                logger.error("âŒ è¨˜äº‹å†…å®¹ã®æ›¸ãæ›ãˆã«å¤±æ•—ã—ã¾ã—ãŸ")
            
            screenshot_path = await self._save_screenshot(page, "06_after_content")
            
            # ã‚¹ãƒ†ãƒƒãƒ—9: ä¸‹æ›¸ãä¿å­˜
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—10/10ã€‘ä¸‹æ›¸ãä¿å­˜ä¸­...")
            saved = await self._save_draft(page)
            
            if saved:
                logger.info("âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†")
            else:
                logger.warning("âš ï¸ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
            # æœ€çµ‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = await self._save_screenshot(page, "07_final")
            
            # çµæœã‚µãƒãƒªãƒ¼
            logger.info("\n" + "="*80)
            logger.info("ã€å®Œäº†ã€‘æŠ•ç¨¿ç·¨é›†ã‚¿ã‚¹ã‚¯çµ‚äº†")
            logger.info("="*80)
            
            result_summary = self._build_summary(
                search_title, post_id, article_title, language_changed, 
                len(article_body), saved
            )
            summary_text = '\n'.join(result_summary)
            
            logger.info("\nã€æœ€çµ‚çµæœã€‘")
            logger.info(summary_text)
            
            return {
                'success': True,
                'summary': summary_text,
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots,
                'full_text': f'{summary_text}\n\nã€ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã€‘\n' + '\n'.join([f'- {s}' for s in self.debug_screenshots])
            }
                
        except Exception as e:
            logger.error(f"âŒ æŠ•ç¨¿ç·¨é›†ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            
            screenshot_path = await self._save_screenshot(page, "ERROR")
            
            return {
                'success': False,
                'error': str(e),
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots
            }
    
    async def _save_screenshot(self, page: Page, name: str) -> str:
        """ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜"""
        try:
            timestamp = datetime.now().strftime('%H%M%S')
            screenshot_path = f"wp_debug_{name}_{timestamp}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            self.debug_screenshots.append(screenshot_path)
            logger.debug(f"ğŸ“¸ ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜: {screenshot_path}")
            return screenshot_path
        except Exception as e:
            logger.warning(f"ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜å¤±æ•—: {e}")
            return ""
    
    async def _search_post(self, page: Page, search_title: str) -> bool:
        """æŠ•ç¨¿ã‚’æ¤œç´¢"""
        search_box_selectors = [
            '#post-search-input',
            'input[name="s"]',
            'input[type="search"]',
            '.search-box input'
        ]
        
        for i, selector in enumerate(search_box_selectors, 1):
            try:
                logger.debug(f"æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹è©¦è¡Œ {i}/{len(search_box_selectors)}: {selector}")
                search_box = await page.query_selector(selector)
                
                if search_box:
                    is_visible = await search_box.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        await search_box.fill(search_title)
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Enter')
                        await page.wait_for_timeout(3000)
                        logger.info(f"âœ… æ¤œç´¢å®Ÿè¡ŒæˆåŠŸ: ã‚»ãƒ¬ã‚¯ã‚¿={selector}")
                        return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
    
    # wp_post_editor.py ã® _extract_title_and_body ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£

    def _extract_title_and_body(self, content: str) -> tuple[str, str]:
        """
        è¨˜äº‹ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡ºï¼ˆHTMLå¯¾å¿œå¼·åŒ–ç‰ˆï¼‰
        """
        try:
            logger.info(f"ã€è¨˜äº‹å†…å®¹è§£æé–‹å§‹ã€‘æ–‡å­—æ•°: {len(content)}")
                
            # HTMLå½¢å¼ã®å ´åˆã¯HTMLCleanerã‚’ä½¿ç”¨
            if '<h1' in content or '<div' in content or '<p>' in content:
                logger.info("âœ… HTMLå½¢å¼ã®è¨˜äº‹ã‚’æ¤œå‡º - HTMLCleanerã‚’ä½¿ç”¨")
                    
                # HTMLCleanerã§ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
                from .wp_utils import HTMLCleaner
                title, body = HTMLCleaner.prepare_html_for_wordpress(content)
                    
                logger.info(f"âœ… HTMLå‡¦ç†å®Œäº†: ã‚¿ã‚¤ãƒˆãƒ«='{title}', æœ¬æ–‡={len(body)}æ–‡å­—")
                return title, body
                
            # Markdownå½¢å¼ã®å‡¦ç†ï¼ˆæ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
            lines = content.split('\n')
            title = ""
            body_lines = []
                
            for i, line in enumerate(lines):
                line_stripped = line.strip()
                    
                # æœ€åˆã® # ã§å§‹ã¾ã‚‹è¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«ã¨ã™ã‚‹
                if line_stripped.startswith('# ') and not title:
                    title = line_stripped[2:].strip()
                    logger.info(f"âœ… Markdownã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡º: {title}")
                    continue
                    
                # ã‚¿ã‚¤ãƒˆãƒ«ãŒè¦‹ã¤ã‹ã£ãŸå¾Œã®è¡Œã‚’æœ¬æ–‡ã¨ã™ã‚‹
                if title:
                    body_lines.append(line)
                # ã‚¿ã‚¤ãƒˆãƒ«ãŒè¦‹ã¤ã‹ã‚‹å‰ã®éç©ºè¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«å€™è£œã¨ã™ã‚‹
                elif line_stripped and not title:
                    title = line_stripped[:100]
                    logger.info(f"âœ… æœ€åˆã®è¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«ã¨ã—ã¦ä½¿ç”¨: {title}")

            if title:
                body = '\n'.join(body_lines).strip() if body_lines else content
                logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«ãƒ»æœ¬æ–‡åˆ†é›¢å®Œäº†: ã‚¿ã‚¤ãƒˆãƒ«={title[:30]}..., æœ¬æ–‡={len(body)}æ–‡å­—")
                return title, body

            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            logger.warning("âŒ ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
            return "AIæŠ•ç¨¿_è‡ªå‹•ç”Ÿæˆ", content

        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return "AIæŠ•ç¨¿_ã‚¨ãƒ©ãƒ¼", content
    
    async def _change_title(self, page: Page, new_title: str) -> bool:
        """æŠ•ç¨¿ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ "]',
            'textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]',
            '#post-title-0',
            '.wp-block-post-title'
        ]
        
        logger.debug("ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›æ¬„ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(title_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(title_selectors)}: {selector}")
            try:
                title_input = await page.query_selector(selector)
                if title_input:
                    is_visible = await title_input.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        # æ—¢å­˜ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’ã‚¯ãƒªã‚¢
                        await title_input.click()
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Control+A')
                        await page.wait_for_timeout(300)
                        
                        # æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›
                        await page.keyboard.type(new_title)
                        await page.wait_for_timeout(1000)
                        
                        logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´æˆåŠŸ: {new_title}")
                        return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    def _convert_markdown_to_html(self, markdown_text: str) -> str:
        """
        ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›
        
        å¯¾å¿œï¼š
        - ## è¦‹å‡ºã— â†’ <h2>è¦‹å‡ºã—</h2>
        - ### è¦‹å‡ºã— â†’ <h3>è¦‹å‡ºã—</h3>
        - **å¤ªå­—** â†’ <strong>å¤ªå­—</strong>
        - *æ–œä½“* â†’ <em>æ–œä½“</em>
        """
        try:
            import re
            
            html_lines = []
            lines = markdown_text.split('\n')
            
            for line in lines:
                # è¦‹å‡ºã—ã®å¤‰æ›
                if line.strip().startswith('### '):
                    # H3
                    text = line.strip()[4:]
                    html_lines.append(f'<h3>{text}</h3>')
                elif line.strip().startswith('## '):
                    # H2
                    text = line.strip()[3:]
                    html_lines.append(f'<h2>{text}</h2>')
                elif line.strip().startswith('# '):
                    # H1ï¼ˆé€šå¸¸ã¯ã‚¿ã‚¤ãƒˆãƒ«ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                    text = line.strip()[2:]
                    html_lines.append(f'<h1>{text}</h1>')
                else:
                    # æœ¬æ–‡ã®å¤‰æ›
                    converted_line = line
                    
                    # **å¤ªå­—** â†’ <strong>å¤ªå­—</strong>
                    converted_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', converted_line)
                    
                    # *æ–œä½“* â†’ <em>æ–œä½“</em>
                    converted_line = re.sub(r'\*(.+?)\*', r'<em>\1</em>', converted_line)
                    
                    # æ®µè½ã‚¿ã‚°ã§å›²ã‚€ï¼ˆç©ºè¡Œã§ãªã„å ´åˆï¼‰
                    if converted_line.strip():
                        html_lines.append(f'<p>{converted_line}</p>')
                    else:
                        html_lines.append('')
            
            html_content = '\n'.join(html_lines)
            
            logger.info(f"ã€ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³â†’HTMLå¤‰æ›å®Œäº†ã€‘")
            logger.info(f"  å…ƒ: {len(markdown_text)}æ–‡å­—")
            logger.info(f"  å¤‰æ›å¾Œ: {len(html_content)}æ–‡å­—")
            
            return html_content
            
        except Exception as e:
            logger.warning(f"ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å¤‰æ›ã‚¨ãƒ©ãƒ¼: {e}")
            return markdown_text
    
    async def _replace_content(self, page: Page, content: str, is_html: bool = False) -> bool:
        """è¨˜äº‹å†…å®¹ã‚’ç½®æ›ï¼ˆGutenbergãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œç‰ˆï¼‰"""
        logger.info("è¨˜äº‹ã‚¨ãƒ‡ã‚£ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        if is_html:
            logger.info("HTMLå½¢å¼ã®ãŸã‚ã€Gutenbergãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦æŒ¿å…¥ã—ã¾ã™")
            return await self._insert_as_gutenberg_blocks(page, content)
        
        # é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã®å ´åˆ
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  â†’ {len(content_blocks)}å€‹ã®è¦ç´ ç™ºè¦‹")
                    
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"âœ… è¨˜äº‹å†…å®¹æ›¸ãæ›ãˆæˆåŠŸ: {len(content)}æ–‡å­—")
                    return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.error("âŒ ã™ã¹ã¦ã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—")
        return False
    
    async def _insert_as_gutenberg_blocks(self, page: Page, html_content: str) -> bool:
        """HTMLã‚’ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦æŒ¿å…¥ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
        try:
            logger.info("ã€ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯æŒ¿å…¥é–‹å§‹ã€‘")
            
            # æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‰Šé™¤
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—1: æ—¢å­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‰Šé™¤")
            await self._clear_all_blocks_simple(page)
            
            # ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ 
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—2: ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ")
            
            # æ–¹æ³•1: /html ã§æ¤œç´¢
            try:
                await page.keyboard.press('/')
                await page.wait_for_timeout(500)
                await page.keyboard.type('html')
                await page.wait_for_timeout(1000)
                await page.keyboard.press('Enter')
                await page.wait_for_timeout(1000)
                logger.info("  â†’ /html ã§æ¤œç´¢æˆåŠŸ")
            except Exception as e:
                logger.debug(f"  æ–¹æ³•1å¤±æ•—: {e}")
                
                # æ–¹æ³•2: ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ ãƒœã‚¿ãƒ³ã‹ã‚‰
                try:
                    await page.click('button[aria-label="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ "]', timeout=3000)
                    await page.wait_for_timeout(500)
                    await page.type('input[placeholder*="æ¤œç´¢"]', 'html')
                    await page.wait_for_timeout(1000)
                    await page.click('button:has-text("ã‚«ã‚¹ã‚¿ãƒ HTML")', timeout=3000)
                    await page.wait_for_timeout(1000)
                    logger.info("  â†’ ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ ãƒœã‚¿ãƒ³ã‹ã‚‰æˆåŠŸ")
                except Exception as e2:
                    logger.debug(f"  æ–¹æ³•2å¤±æ•—: {e2}")
            
            # HTMLã‚³ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ã‚’è¦‹ã¤ã‘ã¦è²¼ã‚Šä»˜ã‘
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—3: HTMLã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘")
            
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]',
                'textarea.components-textarea-control__input'
            ]
            
            pasted = False
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input:
                        is_visible = await html_input.is_visible()
                        if is_visible:
                            await html_input.click()
                            await page.wait_for_timeout(500)
                            
                            # HTMLã‚’è²¼ã‚Šä»˜ã‘
                            await html_input.fill(html_content)
                            await page.wait_for_timeout(1000)
                            
                            logger.info(f"  âœ… HTMLè²¼ã‚Šä»˜ã‘æˆåŠŸ: {len(html_content)}æ–‡å­—")
                            pasted = True
                            break
                except Exception as e:
                    logger.debug(f"  {selector} ã‚¨ãƒ©ãƒ¼: {e}")
                    continue
            
            if not pasted:
                logger.warning("  âš ï¸ HTMLå…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                return False
            
            # ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆï¼ˆè¦‹ãŸç›®ã‚’ç¢ºèªï¼‰
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—4: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ")
            try:
                # ã€Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€ãƒœã‚¿ãƒ³ã‚’æ¢ã™
                preview_button = await page.query_selector('button:has-text("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼")')
                if preview_button:
                    await preview_button.click()
                    await page.wait_for_timeout(1000)
                    logger.info("  âœ… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º")
            except Exception as e:
                logger.debug(f"  ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼: {e}")
            
            logger.info(f"âœ… ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯æŒ¿å…¥å®Œäº†")
            return True
            
        except Exception as e:
            logger.error(f"âŒ ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯æŒ¿å…¥ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def _clear_all_blocks_simple(self, page: Page) -> bool:
        """æ—¢å­˜ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç°¡æ˜“çš„ã«å‰Šé™¤"""
        try:
            # Ctrl+A ã§å…¨é¸æŠ â†’ Backspace ã§å‰Šé™¤
            await page.keyboard.press('Control+A')
            await page.wait_for_timeout(500)
            await page.keyboard.press('Backspace')
            await page.wait_for_timeout(1000)
            
            logger.info("  âœ… æ—¢å­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å‰Šé™¤å®Œäº†")
            return True
            
        except Exception as e:
            logger.debug(f"  æ—¢å­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å‰Šé™¤ã‚¨ãƒ©ãƒ¼: {e}")
            return False
        
        logger.warning("âŒ ã™ã¹ã¦ã®æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—")
        return False
    
    async def _navigate_to_edit_page(self, page: Page, search_title: str) -> tuple[bool, Optional[str]]:
        """æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ç§»å‹•"""
        logger.info("æŠ•ç¨¿ãƒªãƒ³ã‚¯ã‚’æ¢ç´¢ä¸­...")
        
        # æ–¹æ³•1: ã‚¿ã‚¤ãƒˆãƒ«ãƒªãƒ³ã‚¯ã‹ã‚‰ç›´æ¥ç·¨é›†URL
        logger.debug("ã€æ–¹æ³•1ã€‘ã‚¿ã‚¤ãƒˆãƒ«ãƒªãƒ³ã‚¯ã‹ã‚‰ç·¨é›†URLã‚’å–å¾—")
        try:
            # è¤‡æ•°ã®ã‚»ãƒ¬ã‚¯ã‚¿ã‚’è©¦è¡Œ
            title_selectors = [
                f'a.row-title:has-text("{search_title}")',
                f'td.title a:has-text("{search_title}")',
                f'.row-title:has-text("{search_title}")'
            ]
            
            for i, selector in enumerate(title_selectors, 1):
                logger.debug(f"  è©¦è¡Œ {i}/{len(title_selectors)}: {selector}")
                try:
                    title_link = await page.query_selector(selector)
                    if title_link:
                        href = await title_link.get_attribute('href')
                        if href:
                            post_id_match = re.search(r'post=(\d+)', href)
                            if post_id_match:
                                post_id = post_id_match.group(1)
                                edit_url = f"{self.wp_url}/wp-admin/post.php?post={post_id}&action=edit"
                                logger.info(f"âœ… ç·¨é›†URLæ§‹ç¯‰æˆåŠŸ: æŠ•ç¨¿ID={post_id}")
                                
                                await page.goto(edit_url, timeout=30000)
                                await page.wait_for_timeout(4000)
                                
                                return True, post_id
                except Exception as e:
                    logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                    continue
        except Exception as e:
            logger.debug(f"æ–¹æ³•1å¤±æ•—: {e}")
        
        # æ–¹æ³•2: ç·¨é›†ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯
        logger.debug("ã€æ–¹æ³•2ã€‘ç·¨é›†ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯")
        edit_link_selectors = [
            f'tr:has-text("{search_title}") .row-actions .edit a',
            f'a.row-title:has-text("{search_title}")',
            '.row-actions .edit a',
            f'tr:has(a:has-text("{search_title}")) .edit a'
        ]
        
        for i, selector in enumerate(edit_link_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(edit_link_selectors)}: {selector}")
            try:
                edit_link = await page.query_selector(selector)
                if edit_link:
                    is_visible = await edit_link.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        await edit_link.click()
                        await page.wait_for_timeout(5000)
                        
                        # URLã‹ã‚‰æŠ•ç¨¿IDã‚’å–å¾—
                        current_url = page.url
                        post_id_match = re.search(r'post=(\d+)', current_url)
                        post_id = post_id_match.group(1) if post_id_match else "ä¸æ˜"
                        
                        logger.info(f"âœ… ç·¨é›†ãƒªãƒ³ã‚¯ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ: æŠ•ç¨¿ID={post_id}")
                        return True, post_id
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        # æ–¹æ³•3: æœ€åˆã®æŠ•ç¨¿ã‚’é–‹ãï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        logger.debug("ã€æ–¹æ³•3ã€‘æœ€åˆã®æŠ•ç¨¿ã‚’é–‹ãï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰")
        try:
            first_edit_link = await page.query_selector('.row-actions .edit a')
            if first_edit_link:
                await first_edit_link.click()
                await page.wait_for_timeout(4000)
                logger.warning("âš ï¸ æœ€åˆã®æŠ•ç¨¿ã‚’é–‹ãã¾ã—ãŸï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰")
                return True, "ä¸æ˜"
        except Exception as e:
            logger.debug(f"æ–¹æ³•3å¤±æ•—: {e}")
        
        logger.error("âŒ ã™ã¹ã¦ã®æ–¹æ³•ã§æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ã®ç§»å‹•ã«å¤±æ•—")
        return False, None
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«è¨­å®š"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylangè¨€èªè¨­å®šã‚»ãƒ¬ã‚¯ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        # æ—¥æœ¬èªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ¢ã™
                        options = await lang_select.inner_text()
                        logger.debug(f"  â†’ åˆ©ç”¨å¯èƒ½ãªè¨€èª: {options[:100]}")
                        
                        # è¤‡æ•°ã®æ—¥æœ¬èªè¡¨è¨˜ã‚’è©¦ã™
                        japanese_labels = ['æ—¥æœ¬èª', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"âœ… Polylangè¨€èªè¨­å®šæˆåŠŸ: {label}")
                                
                                # ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç†
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ Polylangè¨€èªè¨­å®šè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‡¦ç†"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("ã¯ã„")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("âœ… ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§OKã‚’ã‚¯ãƒªãƒƒã‚¯")
                        return
            except:
                continue
    
    async def _replace_content(self, page: Page, content: str) -> bool:
        """è¨˜äº‹å†…å®¹ã‚’ç½®æ›"""
        logger.info("è¨˜äº‹ã‚¨ãƒ‡ã‚£ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        # Gutenbergã‚¨ãƒ‡ã‚£ã‚¿ã®ã‚»ãƒ¬ã‚¯ã‚¿
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
            '.editor-post-text-editor',
            'textarea.editor-post-text-editor',
            '#content'  # ã‚¯ãƒ©ã‚·ãƒƒã‚¯ã‚¨ãƒ‡ã‚£ã‚¿
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  â†’ {len(content_blocks)}å€‹ã®è¦ç´ ç™ºè¦‹")
                    
                    # æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    logger.debug("  â†’ ã‚¯ãƒªãƒƒã‚¯å®Œäº†")
                    
                    # å…¨é¸æŠã—ã¦å‰Šé™¤
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    logger.debug("  â†’ æ—¢å­˜å†…å®¹å‰Šé™¤å®Œäº†")
                    
                    # æ–°ã—ã„å†…å®¹ã‚’å…¥åŠ›
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"âœ… è¨˜äº‹å†…å®¹æ›¸ãæ›ãˆæˆåŠŸ: {len(content)}æ–‡å­—")
                    return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.error("âŒ ã™ã¹ã¦ã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—")
        return False
    
    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        save_selectors = [
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
        
        logger.debug("ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if save_button:
                    is_visible = await save_button.is_visible()
                    is_disabled = await save_button.is_disabled() if is_visible else True
                    
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
                    
                    if is_visible and not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(4000)
                        logger.info("âœ… ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                        return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    def _build_summary(self, old_title: str, post_id: str, new_title: str, 
                      lang_changed: bool, content_length: int, saved: bool) -> list:
        """çµæœã‚µãƒãƒªãƒ¼ã‚’æ§‹ç¯‰"""
        result_summary = []
        result_summary.append(f"ã€æŠ•ç¨¿ç·¨é›†å®Œäº†ã€‘")
        result_summary.append(f"å…ƒã®ã‚¿ã‚¤ãƒˆãƒ«: {old_title}")
        
        if new_title != old_title:
            result_summary.append(f"æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«: {new_title}")
        
        result_summary.append(f"æŠ•ç¨¿ID: {post_id}")
        result_summary.append("")
        
        if lang_changed:
            result_summary.append("âœ… Polylangè¨€èªè¨­å®š: æ—¥æœ¬èª")
        else:
            result_summary.append("âš ï¸ Polylangè¨€èªè¨­å®š: ã‚¹ã‚­ãƒƒãƒ—")
        
        result_summary.append(f"âœ… è¨˜äº‹å†…å®¹æ›¸ãæ›ãˆ: {content_length}æ–‡å­—ï¼ˆHTMLå¤‰æ›æ¸ˆã¿ï¼‰")
        
        if saved:
            result_summary.append("âœ… ä¸‹æ›¸ãä¿å­˜: å®Œäº†")
        else:
            result_summary.append("âš ï¸ ä¸‹æ›¸ãä¿å­˜: ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ‰‹å‹•ç¢ºèªæ¨å¥¨ï¼‰")
        
        return result_summary

#wp_requirements_agent.py
"""
WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ»æ¤œè¨¼ãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œå‚™
"""

import asyncio
import logging
from typing import Dict, Optional, List
from pathlib import Path
from datetime import datetime
import json
import re

logger = logging.getLogger(__name__)


class WordPressRequirementsAgent:
    """WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    
    # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¯é•·ã„ã®ã§ç°¡æ½”ç‰ˆã«å¤‰æ›´
    PROMPT_TEMPLATE = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã€è¦ä»¶å®šç¾©ã®ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ãƒˆã®å®Œå…¨ãªè¦ä»¶å®šç¾©æ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã€‘
- **ã‚µã‚¤ãƒˆå**: ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³M&Aãƒãƒ¼ã‚¿ãƒ«
- **WordPressãƒ†ãƒ¼ãƒ**: Cocoonï¼ˆæ—¥æœ¬è£½é«˜æ©Ÿèƒ½ãƒ†ãƒ¼ãƒï¼‰
- **å¤šè¨€èª**: Polylangï¼ˆæ—¥è‹±éœ²ã‚¦ã‚ºä¸­éŸ“ãƒˆãƒ«ã‚³èªã®7è¨€èªï¼‰
- **ä¸»è¦ãƒ—ãƒ©ã‚°ã‚¤ãƒ³**: ACF PRO, FacetWP, Relevanssi, Wordfence, WP Rocket

ã€è¦ä»¶å®šç¾©æ›¸ã®æ§‹æˆã€‘
ä»¥ä¸‹ã®æ§‹é€ ã§**è©³ç´°ãªè¦ä»¶å®šç¾©æ›¸**ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

# 1.0 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
## 1.1 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå
## 1.2 ç›®çš„ãƒ»èƒŒæ™¯
## 1.3 å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼
## 1.4 æˆåŠŸæŒ‡æ¨™ï¼ˆKPIï¼‰

# 2.0 ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ
## 2.1 æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- WordPress 6.4+ã€Cocoonã€Polylang Proã€ACF PROã€FacetWPã€Relevanssi
## 2.2 ã‚µãƒ¼ãƒãƒ¼è¦ä»¶
- PHP 8.0+ã€MySQL 8.0+ã€ãƒ¡ãƒ¢ãƒª 512MB+
## 2.3 é–‹ç™ºãƒ»æœ¬ç•ªç’°å¢ƒ

# 3.0 æ©Ÿèƒ½è¦ä»¶
## 3.1 ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—
### 3.1.1 M&Aæ¡ˆä»¶ï¼ˆma_caseï¼‰
- supports: title, editor, thumbnail, custom-fields, excerpt
- taxonomies: industry_category, region, deal_type
### 3.1.2 ä¼æ¥­æƒ…å ±ï¼ˆcompanyï¼‰
### 3.1.3 ãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼ˆnewsï¼‰

## 3.2 ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼
### 3.2.1 æ¥­ç¨®åˆ†é¡ï¼ˆindustry_categoryï¼‰ - éšå±¤å‹
### 3.2.2 åœ°åŸŸï¼ˆregionï¼‰ - éšå±¤å‹
### 3.2.3 æ¡ˆä»¶ã‚¿ã‚¤ãƒ—ï¼ˆdeal_typeï¼‰ - ééšå±¤å‹

## 3.3 ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
### M&Aæ¡ˆä»¶ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ20å€‹å®šç¾©ï¼‰
1. case_idï¼ˆæ¡ˆä»¶IDï¼‰ - ãƒ†ã‚­ã‚¹ãƒˆã€å¿…é ˆ
2. ma_schemeï¼ˆM&Aã‚¹ã‚­ãƒ¼ãƒ ï¼‰ - ã‚»ãƒ¬ã‚¯ãƒˆã€å¿…é ˆ
3. desired_priceï¼ˆå¸Œæœ›ä¾¡æ ¼ï¼‰ - æ•°å€¤
4. established_yearï¼ˆè¨­ç«‹å¹´ï¼‰ - æ•°å€¤
5. employeesï¼ˆå¾“æ¥­å“¡æ•°ï¼‰ - æ•°å€¤
6. annual_revenueï¼ˆå¹´å•†ï¼‰ - æ•°å€¤
7. reason_for_saleï¼ˆå£²å´ç†ç”±ï¼‰ - ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢
8. confidential_levelï¼ˆæ©Ÿå¯†ãƒ¬ãƒ™ãƒ«ï¼‰ - ã‚»ãƒ¬ã‚¯ãƒˆ
9-20. ãã®ä»–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆå…·ä½“çš„ã«è¨˜è¼‰ï¼‰

## 3.4 æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆFacetWPï¼‰
- æ¥­ç¨®åˆ¥æ¤œç´¢ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰
- åœ°åŸŸåˆ¥æ¤œç´¢ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼‰
- ä¾¡æ ¼å¸¯æ¤œç´¢ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼‰
- æ¡ˆä»¶ã‚¿ã‚¤ãƒ—æ¤œç´¢ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰
- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢ï¼ˆRelevanssiï¼‰

## 3.5 å¤šè¨€èªæ©Ÿèƒ½ï¼ˆPolylangï¼‰
### è¨€èªè¨­å®š
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: æ—¥æœ¬èªï¼ˆjaï¼‰
- ç¿»è¨³è¨€èª: en, ru, uz, zh, ko, tr
### URLãƒãƒƒãƒ”ãƒ³ã‚°
æ—¥æœ¬èª: https://example.com/ma-cases/
è‹±èª: https://example.com/en/ma-cases/
ãƒ­ã‚·ã‚¢èª: https://example.com/ru/ma-cases/

## 3.6 ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†
### ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ«: ma_partner
- è‡ªèº«ã®ä½œæˆã—ãŸ ma_case ã®ã¿ç·¨é›†å¯èƒ½
- ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¡ˆä»¶ã¯é–²è¦§ãƒ»ç·¨é›†ä¸å¯

## 3.7 å•ã„åˆã‚ã›æ©Ÿèƒ½
- Contact Form 7
- å¤šè¨€èªå¯¾å¿œãƒ•ã‚©ãƒ¼ãƒ 

## 3.8 SEOå¯¾ç­–ï¼ˆCocoonæ´»ç”¨ï¼‰
- æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿è‡ªå‹•ç”Ÿæˆ
- OGPã‚¿ã‚°è¨­å®š
- ãƒ‘ãƒ³ããšãƒªã‚¹ãƒˆ

## 3.9 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆWordfenceï¼‰
- ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«: enabled
- ã‚¹ã‚­ãƒ£ãƒ³: é€±1å›

## 3.10 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼ˆWP Rocket + Cocoonï¼‰
- ãƒ¢ãƒã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥: æœ‰åŠ¹
- CSS/JSç¸®å°åŒ–: æœ‰åŠ¹

# 4.0 éæ©Ÿèƒ½è¦ä»¶
## 4.1 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿: 3ç§’ä»¥å†…
- PageSpeed Insights: 80ç‚¹ä»¥ä¸Š
## 4.2 å¯ç”¨æ€§
- ã‚µãƒ¼ãƒãƒ¼ç¨¼åƒç‡: 99.9%ä»¥ä¸Š
## 4.3 Pydanticãƒ¢ãƒ‡ãƒ«ç§»è¡Œè¨ˆç”»

# 5.0 ç”»é¢è¨­è¨ˆ
## 5.1 ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸
## 5.2 M&Aæ¡ˆä»¶ä¸€è¦§
## 5.3 M&Aæ¡ˆä»¶è©³ç´°

# 6.0 ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
## 6.1 ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—å®šç¾©ï¼ˆJSONï¼‰
```json
{
  "ma_case": {
    "labels": {
      "ja": "M&Aæ¡ˆä»¶",
      "en": "M&A Cases"
    },
    "supports": ["title", "editor", "thumbnail"],
    "taxonomies": ["industry_category", "region"],
    "has_archive": true
  }
}
6.2 ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—å®šç¾©ï¼ˆJSONï¼‰
json{
  "ma_case_fields": {
    "title": "M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±",
    "fields": [
      {
        "name": "case_id",
        "type": "text",
        "required": true
      }
    ]
  }
}
7.0 å®Ÿè£…è¨ˆç”»
ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬æ§‹ç¯‰ï¼ˆ1-2é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º2: æ©Ÿèƒ½å®Ÿè£…ï¼ˆ2-3é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º3: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç™»éŒ²ï¼ˆ1é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º4: ãƒ†ã‚¹ãƒˆãƒ»èª¿æ•´ï¼ˆ1é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º5: æœ¬ç•ªå…¬é–‹ï¼ˆ1é€±é–“ï¼‰
8.0 é‹ç”¨ä¿å®ˆ
å®šæœŸä½œæ¥­

WordPress/ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ›´æ–°ï¼ˆæœˆ1å›ï¼‰
ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºèªï¼ˆé€±1å›ï¼‰

9.0 ã‚³ã‚¹ãƒˆè¦‹ç©ã‚‚ã‚Š
åˆæœŸè²»ç”¨
æœˆé¡è²»ç”¨
10.0 ãƒªã‚¹ã‚¯ã¨å¯¾ç­–
æŠ€è¡“çš„ãƒªã‚¹ã‚¯
å¯¾ç­–

ã€å‡ºåŠ›è¦ä»¶ã€‘

ã™ã¹ã¦ã®ç« ç«‹ã¦ï¼ˆ1.0ï½10.0ï¼‰ã‚’å®Œå…¨ã«è¨˜è¼‰
JSONã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯å¿…ãšé–‰ã˜ã‚‹ï¼ˆ```ã§çµ‚äº†ï¼‰
å…·ä½“çš„ãªæ•°å€¤ãƒ»åç§°ã‚’è¨˜è¼‰
Cocoonã€Polylangã®æ©Ÿèƒ½ã‚’æ˜è¨˜
15,000æ–‡å­—ä»¥ä¸Šã‚’ç›®æ¨™

ãã‚Œã§ã¯ã€å®Œå…¨ãªè¦ä»¶å®šç¾©æ›¸ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # çµ±è¨ˆæƒ…å ±
    self.stats = {
        'total_attempts': 0,
        'successful': 0,
        'failed': 0
    }
    
    logger.info("âœ… WordPressRequirementsAgent åˆæœŸåŒ–å®Œäº†")
    logger.info(f"ğŸ“ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {self.output_folder}")

async def execute(self, task: Dict) -> Dict:
    """è¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    task_id = task.get('task_id', 'UNKNOWN')
    self.stats['total_attempts'] += 1
    
    try:
        logger.info("\n" + "="*70)
        logger.info("ğŸ“‹ WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆé–‹å§‹")
        logger.info(f"ã‚¿ã‚¹ã‚¯ID: {task_id}")
        logger.info("="*70 + "\n")
        
        # ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ–ãƒ©ã‚¦ã‚¶ç¢ºèª
        if not self._verify_browser():
            return self._create_error_result(task_id, 'ãƒ–ãƒ©ã‚¦ã‚¶ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“')
        
        # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡
        logger.info("ğŸ“¤ ã‚¹ãƒ†ãƒƒãƒ—1: Geminiã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
        if not await self._send_prompt():
            return self._create_error_result(task_id, 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å¤±æ•—')
        
        # ã‚¹ãƒ†ãƒƒãƒ—3: å¿œç­”å¾…æ©Ÿ
        logger.info("â±ï¸ ã‚¹ãƒ†ãƒƒãƒ—2: å¿œç­”å¾…æ©Ÿï¼ˆæœ€å¤§300ç§’ï¼‰")
        if not await self._wait_for_response():
            return self._create_error_result(task_id, 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ300ç§’ï¼‰')
        
        # ã‚¹ãƒ†ãƒƒãƒ—4: å¿œç­”å–å¾—
        logger.info("ğŸ“¥ ã‚¹ãƒ†ãƒƒãƒ—3: å¿œç­”å–å¾—")
        response_text = await self._extract_response()
        
        if not response_text:
            return self._create_error_result(task_id, 'å¿œç­”å–å¾—å¤±æ•—')
        
        # ã‚¹ãƒ†ãƒƒãƒ—5: å“è³ªæ¤œè¨¼
        logger.info("ğŸ” ã‚¹ãƒ†ãƒƒãƒ—4: å“è³ªæ¤œè¨¼")
        validation_result = self._validate_response(response_text)
        
        if not validation_result['valid']:
            logger.warning(f"âš ï¸ å“è³ªè­¦å‘Š: {validation_result['warnings']}")
        
        # ã‚¹ãƒ†ãƒƒãƒ—6: ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        logger.info("ğŸ’¾ ã‚¹ãƒ†ãƒƒãƒ—5: ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜")
        output_files = await self._save_requirements(response_text, task_id)
        
        # ã‚¹ãƒ†ãƒƒãƒ—7: æˆåŠŸçµæœã®ä½œæˆ
        self.stats['successful'] += 1
        
        logger.info("\n" + "="*70)
        logger.info("âœ… WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆå®Œäº†")
        logger.info(f"ğŸ“„ æ–‡å­—æ•°: {len(response_text):,}æ–‡å­—")
        logger.info(f"ğŸ“ ä¿å­˜ãƒ•ã‚¡ã‚¤ãƒ«: {len(output_files)}ä»¶")
        logger.info("="*70 + "\n")
        
        return {
            'success': True,
            'message': 'è¦ä»¶å®šç¾©æ›¸ä½œæˆå®Œäº†',
            'task_id': task_id,
            'content_length': len(response_text),
            'output_files': [str(f['path']) for f in output_files],
            'validation': validation_result,
            'summary': f'è¦ä»¶å®šç¾©æ›¸ä½œæˆå®Œäº†ï¼ˆ{len(response_text):,}æ–‡å­—ã€{len(output_files)}ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰',
            'full_text': response_text[:1000] + '...' if len(response_text) > 1000 else response_text
        }
        
    except Exception as e:
        self.stats['failed'] += 1
        logger.error(f"âŒ è¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return self._create_error_result(task_id, str(e))

def _verify_browser(self) -> bool:
    """ãƒ–ãƒ©ã‚¦ã‚¶ã®çŠ¶æ…‹ã‚’ç¢ºèª"""
    if not self.browser:
        logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return False
    
    if not hasattr(self.browser, 'send_prompt'):
        logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã« send_prompt ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“")
        return False
    
    logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç¢ºèª: OK")
    return True

async def _send_prompt(self) -> bool:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡"""
    try:
        await self.browser.send_prompt(self.PROMPT_TEMPLATE)
        logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å®Œäº†")
        return True
    except Exception as e:
        logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
        return False

async def _wait_for_response(self, max_wait: int = 300) -> bool:
    """å¿œç­”ã‚’å¾…æ©Ÿ"""
    try:
        success = await self.browser.wait_for_text_generation(max_wait=max_wait)
        if success:
            logger.info(f"âœ… å¿œç­”å¾…æ©Ÿå®Œäº†ï¼ˆ{max_wait}ç§’ä»¥å†…ï¼‰")
        else:
            logger.error(f"âŒ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
        return success
    except Exception as e:
        logger.error(f"âŒ å¿œç­”å¾…æ©Ÿã‚¨ãƒ©ãƒ¼: {e}")
        return False

async def _extract_response(self) -> Optional[str]:
    """å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º"""
    try:
        response_text = await self.browser.extract_latest_text_response()
        
        if response_text:
            logger.info(f"âœ… å¿œç­”å–å¾—: {len(response_text):,}æ–‡å­—")
        else:
            logger.error("âŒ å¿œç­”ãŒç©ºã§ã™")
        
        return response_text
    except Exception as e:
        logger.error(f"âŒ å¿œç­”æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
        return None

def _validate_response(self, text: str) -> Dict:
    """å¿œç­”ã®å“è³ªã‚’æ¤œè¨¼"""
    warnings = []
    
    # é•·ã•ãƒã‚§ãƒƒã‚¯
    if len(text) < 10000:
        warnings.append(f'æ–‡å­—æ•°ãŒå°‘ãªã„ï¼ˆ{len(text):,}æ–‡å­—ï¼‰')
    
    # ç« ç«‹ã¦ãƒã‚§ãƒƒã‚¯
    required_sections = [
        '1.0 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦',
        '2.0 ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ',
        '3.0 æ©Ÿèƒ½è¦ä»¶',
        '4.0 éæ©Ÿèƒ½è¦ä»¶',
        '5.0 ç”»é¢è¨­è¨ˆ',
        '6.0 ãƒ‡ãƒ¼ã‚¿æ§‹é€ ',
        '7.0 å®Ÿè£…è¨ˆç”»',
        '8.0 é‹ç”¨ä¿å®ˆ',
        '9.0 ã‚³ã‚¹ãƒˆè¦‹ç©ã‚‚ã‚Š',
        '10.0 ãƒªã‚¹ã‚¯ã¨å¯¾ç­–'
    ]
    
    missing_sections = [s for s in required_sections if s not in text]
    if missing_sections:
        warnings.append(f'æ¬ è½ã‚»ã‚¯ã‚·ãƒ§ãƒ³: {", ".join(missing_sections)}')
    
    # JSONãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯
    json_blocks = re.findall(r'```json', text)
    if len(json_blocks) < 2:
        warnings.append(f'JSONãƒ–ãƒ­ãƒƒã‚¯ãŒå°‘ãªã„ï¼ˆ{len(json_blocks)}å€‹ï¼‰')
    
    # Cocoonã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    if 'Cocoon' not in text and 'cocoon' not in text:
        warnings.append('Cocoonãƒ†ãƒ¼ãƒã®è¨˜è¿°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
    
    # Polylangã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    if 'Polylang' not in text and 'polylang' not in text:
        warnings.append('Polylangãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨˜è¿°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
    
    valid = len(warnings) == 0
    
    if valid:
        logger.info("âœ… å“è³ªæ¤œè¨¼: åˆæ ¼")
    else:
        logger.warning(f"âš ï¸ å“è³ªæ¤œè¨¼: è­¦å‘Šã‚ã‚Šï¼ˆ{len(warnings)}ä»¶ï¼‰")
        for w in warnings:
            logger.warning(f"  - {w}")
    
    return {
        'valid': valid,
        'warnings': warnings,
        'length': len(text),
        'sections_found': len(required_sections) - len(missing_sections),
        'sections_total': len(required_sections)
    }

async def _save_requirements(self, text: str, task_id: str) -> List[Dict]:
    """è¦ä»¶å®šç¾©æ›¸ã‚’ä¿å­˜"""
    output_files = []
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    try:
        # 1. ãƒ¡ã‚¤ãƒ³è¦ä»¶å®šç¾©æ›¸ï¼ˆMarkdownï¼‰
        doc_filename = f"requirements_wordpress_{task_id}_{timestamp}.md"
        doc_path = self.output_folder / doc_filename
        
        with open(doc_path, 'w', encoding='utf-8') as f:
            f.write(f"# WordPressè¦ä»¶å®šç¾©æ›¸ - ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³M&Aãƒãƒ¼ã‚¿ãƒ«\n\n")
            f.write(f"**ä½œæˆæ—¥æ™‚**: {datetime.now().strftime('%Yå¹´%mæœˆ%dæ—¥ %H:%M:%S')}\n")
            f.write(f"**ã‚¿ã‚¹ã‚¯ID**: {task_id}\n")
            f.write(f"**æ–‡å­—æ•°**: {len(text):,}æ–‡å­—\n\n")
            f.write("---\n\n")
            f.write(text)
        
        output_files.append({
            'type': 'è¦ä»¶å®šç¾©æ›¸ï¼ˆMarkdownï¼‰',
            'path': doc_path,
            'size': len(text)
        })
        logger.info(f"âœ… ä¿å­˜: {doc_filename} ({len(text):,}æ–‡å­—)")
        
        # 2. JSONæ§‹é€ ï¼ˆã‚‚ã—æŠ½å‡ºã§ãã‚Œã°ï¼‰
        json_data = self._extract_json_structures(text)
        if json_data:
            json_filename = f"data_structures_{task_id}_{timestamp}.json"
            json_path = self.output_folder / json_filename
            
            with open(json_path, 'w', encoding='utf-8') as f:
                json.dump(json_data, f, ensure_ascii=False, indent=2)
            
            output_files.append({
                'type': 'ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆJSONï¼‰',
                'path': json_path,
                'size': json_path.stat().st_size
            })
            logger.info(f"âœ… ä¿å­˜: {json_filename}")
        
        # 3. å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
        checklist_filename = f"checklist_{task_id}_{timestamp}.md"
        checklist_path = self.output_folder / checklist_filename
        
        checklist_content = self._generate_checklist()
        with open(checklist_path, 'w', encoding='utf-8') as f:
            f.write(checklist_content)
        
        output_files.append({
            'type': 'å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ',
            'path': checklist_path,
            'size': len(checklist_content)
        })
        logger.info(f"âœ… ä¿å­˜: {checklist_filename}")
        
        logger.info(f"âœ… åˆè¨ˆ {len(output_files)} ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å®Œäº†")
        return output_files
        
    except Exception as e:
        logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
        return output_files

def _extract_json_structures(self, text: str) -> Optional[Dict]:
    """JSONãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º"""
    try:
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        
        if not json_blocks:
            return None
        
        combined_data = {}
        for i, json_str in enumerate(json_blocks, 1):
            try:
                data = json.loads(json_str)
                combined_data[f"block_{i}"] = data
            except json.JSONDecodeError:
                logger.warning(f"âš ï¸ JSONãƒ–ãƒ­ãƒƒã‚¯ {i} ã®ãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—")
                continue
        
        return combined_data if combined_data else None
        
    except Exception as e:
        logger.warning(f"âš ï¸ JSONæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
        return None

def _generate_checklist(self) -> str:
    """å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ"""
    return """# WordPress M&Aãƒãƒ¼ã‚¿ãƒ« å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬æ§‹ç¯‰ âœ…

 WordPress 6.4+ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
 Cocoonãƒ†ãƒ¼ãƒ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»æœ‰åŠ¹åŒ–
 Polylang Pro ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»è¨­å®šï¼ˆ7è¨€èªï¼‰
 å¿…é ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

 Advanced Custom Fields PRO
 Custom Post Type UI
 FacetWP
 Relevanssi
 Wordfence Security
 WP Rocket
 Contact Form 7
 User Role Editor



ãƒ•ã‚§ãƒ¼ã‚º2: ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— ğŸ”§

 M&Aæ¡ˆä»¶ï¼ˆma_caseï¼‰ä½œæˆ

 ãƒ©ãƒ™ãƒ«è¨­å®šï¼ˆ7è¨€èªï¼‰
 ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½è¨­å®š
 ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®š


 ä¼æ¥­æƒ…å ±ï¼ˆcompanyï¼‰ä½œæˆ
 ãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼ˆnewsï¼‰ä½œæˆ

ãƒ•ã‚§ãƒ¼ã‚º3: ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ ğŸ·ï¸

 æ¥­ç¨®åˆ†é¡ï¼ˆindustry_categoryï¼‰ä½œæˆ - éšå±¤å‹
 åœ°åŸŸï¼ˆregionï¼‰ä½œæˆ - éšå±¤å‹
 æ¡ˆä»¶ã‚¿ã‚¤ãƒ—ï¼ˆdeal_typeï¼‰ä½œæˆ - ééšå±¤å‹
 Polylangç¿»è¨³è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º4: ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ğŸ“

 M&Aæ¡ˆä»¶ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ

 åŸºæœ¬æƒ…å ±ï¼ˆcase_id, ma_scheme, etc.ï¼‰
 è²¡å‹™æƒ…å ±ï¼ˆdesired_price, revenue, etc.ï¼‰
 é€£çµ¡å…ˆæƒ…å ±


 ä¼æ¥­æƒ…å ±ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ
 Polylangé€£æºè¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º5: æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ ğŸ”

 FacetWPè¨­å®š

 æ¥­ç¨®åˆ¥ãƒ•ã‚¡ã‚»ãƒƒãƒˆ
 åœ°åŸŸåˆ¥ãƒ•ã‚¡ã‚»ãƒƒãƒˆ
 ä¾¡æ ¼å¸¯ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
 æ¡ˆä»¶ã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ã‚»ãƒƒãƒˆ


 Relevanssiè¨­å®š

 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹ç¯‰
 ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ¤œç´¢è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º6: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»æœ€é©åŒ– ğŸ”’

 Wordfence Securityè¨­å®š

 ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«æœ‰åŠ¹åŒ–
 ã‚¹ã‚­ãƒ£ãƒ³ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š


 WP Rocketè¨­å®š

 ãƒ¢ãƒã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹åŒ–
 CSS/JSç¸®å°åŒ–


 Cocooné«˜é€ŸåŒ–è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º7: ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç† ğŸ‘¥

 ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ«ï¼ˆma_partnerï¼‰ä½œæˆ
 æ¨©é™è¨­å®š
 ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆãƒ»æ¤œè¨¼

ãƒ•ã‚§ãƒ¼ã‚º8: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç™»éŒ² ğŸ“„

 ã‚µãƒ³ãƒ—ãƒ«M&Aæ¡ˆä»¶ç™»éŒ²ï¼ˆå„è¨€èªï¼‰
 ã‚µãƒ³ãƒ—ãƒ«ä¼æ¥­æƒ…å ±ç™»éŒ²
 å›ºå®šãƒšãƒ¼ã‚¸ä½œæˆ
 ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º9: ãƒ†ã‚¹ãƒˆ ğŸ§ª

 å¤šè¨€èªè¡¨ç¤ºç¢ºèª
 æ¤œç´¢æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
 ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
 ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ãƒ†ã‚¹ãƒˆ
 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³

ãƒ•ã‚§ãƒ¼ã‚º10: æœ¬ç•ªå…¬é–‹ ğŸš€

 DNSè¨­å®š
 SSLè¨¼æ˜æ›¸è¨­å®š
 æœ¬ç•ªç’°å¢ƒç§»è¡Œ
 æœ€çµ‚ç¢ºèª


ä½œæˆæ—¥: {datetime}
ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.0
""".format(datetime=datetime.now().strftime('%Y-%m-%d %H:%M'))
def _create_error_result(self, task_id: str, error: str) -> Dict:
    """ã‚¨ãƒ©ãƒ¼çµæœã‚’ä½œæˆ"""
    logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼: {error}")
    
    return {
        'success': False,
        'error': error,
        'task_id': task_id,
        'stats': self.stats.copy()
    }

def get_stats(self) -> Dict:
    """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
    return self.stats.copy()



### 3. `wordpress/wp_dev/wp_cpt_agent.py`ï¼ˆå®Œå…¨ç‰ˆï¼‰

"""
WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """CPTä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    
    PROMPT_TEMPLATE = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€ã‚¿ã‚¹ã‚¯ã€‘
ä»¥ä¸‹ã®ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆã™ã‚‹PHPã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

**æŠ•ç¨¿ã‚¿ã‚¤ãƒ—æƒ…å ±**:
- ã‚¹ãƒ©ãƒƒã‚°: {cpt_slug}
- è¡¨ç¤ºåï¼ˆå˜æ•°ï¼‰: {cpt_singular}
- è¡¨ç¤ºåï¼ˆè¤‡æ•°ï¼‰: {cpt_plural}
- ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½: {supports}
- ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼: {taxonomies}

ã€è¦ä»¶ã€‘
1. `register_post_type()` ã‚’ä½¿ç”¨ã—ãŸå®Œå…¨ãªPHPã‚³ãƒ¼ãƒ‰
2. Polylangå¤šè¨€èªå¯¾å¿œ
3. REST APIå¯¾å¿œï¼ˆshow_in_rest: trueï¼‰
4. has_archive: true
5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ã
6. è©³ç´°ãªã‚³ãƒ¡ãƒ³ãƒˆä»˜ã

ã€å‡ºåŠ›å½¢å¼ã€‘
```php
<?php
/**
 * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_name}
 * ä½œæˆæ—¥: {date}
 * Polylangå¯¾å¿œ
 */

function register_cpt_{cpt_slug_clean}() {{
    $labels = array(
        'name' => __( '{cpt_plural}', 'textdomain' ),
        'singular_name' => __( '{cpt_singular}', 'textdomain' ),
        // ... ãã®ä»–ã®ãƒ©ãƒ™ãƒ«
    );
    
    $args = array(
        'labels' => $labels,
        'public' => true,
        'has_archive' => true,
        'show_in_rest' => true,
        'supports' => {supports_array},
        'taxonomies' => {taxonomies_array},
        // ... ãã®ä»–ã®è¨­å®š
    );
    
    register_post_type( '{cpt_slug}', $args );
}}
add_action( 'init', 'register_cpt_{cpt_slug_clean}', 0 );
?>
å®Œå…¨ã«å‹•ä½œã™ã‚‹PHPã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    logger.info("âœ… WordPressCPTAgent åˆæœŸåŒ–")

async def execute(self, task: Dict) -> Dict:
    """CPTä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '')
    
    try:
        logger.info("=" * 70)
        logger.info("ğŸ”§ ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆé–‹å§‹")
        logger.info("=" * 70)
        
        # CPTä»•æ§˜ã‚’æŠ½å‡º
        cpt_spec = self._extract_cpt_spec(description)
        logger.info(f"ğŸ“Š CPTä»•æ§˜: {cpt_spec['slug']}")
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
        prompt = self._build_prompt(cpt_spec)
        
        # Geminiã«é€ä¿¡
        await self.browser.send_prompt(prompt)
        
        # å¿œç­”å¾…æ©Ÿ
        success = await self.browser.wait_for_text_generation(max_wait=180)
        
        if not success:
            return {'success': False, 'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ', 'task_id': task_id}
        
        # å¿œç­”å–å¾—
        response_text = await self.browser.extract_latest_text_response()
        
        if not response_text:
            return {'success': False, 'error': 'å¿œç­”å–å¾—å¤±æ•—', 'task_id': task_id}
        
        # PHPä¿å­˜
        output_file = await self._save_php_code(response_text, cpt_spec, task_id)
        
        logger.info("=" * 70)
        logger.info("âœ… CPTä½œæˆå®Œäº†")
        logger.info("=" * 70)
        
        return {
            'success': True,
            'message': f'CPTä½œæˆå®Œäº†: {cpt_spec["slug"]}',
            'output_file': str(output_file),
            'cpt_slug': cpt_spec['slug'],
            'task_id': task_id,
            'summary': f'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— {cpt_spec["slug"]} ä½œæˆå®Œäº†'
        }
        
    except Exception as e:
        logger.error(f"âŒ CPTä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
        return {'success': False, 'error': str(e), 'task_id': task_id}

def _extract_cpt_spec(self, description: str) -> Dict:
    """èª¬æ˜ã‹ã‚‰CPTä»•æ§˜ã‚’æŠ½å‡º"""
    desc_lower = description.lower()
    
    # M&Aæ¡ˆä»¶
    if 'ma_case' in desc_lower or 'm&aæ¡ˆä»¶' in desc_lower:
        return {
            'slug': 'ma_case',
            'singular': 'M&Aæ¡ˆä»¶',
            'plural': 'M&Aæ¡ˆä»¶ä¸€è¦§',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields', 'excerpt'],
            'taxonomies': ['industry_category', 'region', 'deal_type']
        }
    
    # ä¼æ¥­æƒ…å ±
    elif 'company' in desc_lower or 'ä¼æ¥­æƒ…å ±' in desc_lower:
        return {
            'slug': 'company',
            'singular': 'ä¼æ¥­æƒ…å ±',
            'plural': 'ä¼æ¥­æƒ…å ±ä¸€è¦§',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields'],
            'taxonomies': ['industry_category', 'region']
        }
    
    # ãƒ‹ãƒ¥ãƒ¼ã‚¹
    elif 'news' in desc_lower or 'ãƒ‹ãƒ¥ãƒ¼ã‚¹' in desc_lower:
        return {
            'slug': 'news',
            'singular': 'ãƒ‹ãƒ¥ãƒ¼ã‚¹',
            'plural': 'ãƒ‹ãƒ¥ãƒ¼ã‚¹ä¸€è¦§',
            'supports': ['title', 'editor', 'thumbnail', 'excerpt'],
            'taxonomies': []
        }
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    return {
        'slug': 'custom_post',
        'singular': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿',
        'plural': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ä¸€è¦§',
        'supports': ['title', 'editor', 'thumbnail'],
        'taxonomies': []
    }

def _build_prompt(self, cpt_spec: Dict) -> str:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
    slug_clean = cpt_spec['slug'].replace('-', '_')
    
    return self.PROMPT_TEMPLATE.format(
        cpt_slug=cpt_spec['slug'],
        cpt_singular=cpt_spec['singular'],
        cpt_plural=cpt_spec['plural'],
        cpt_name=cpt_spec['singular'],
        cpt_slug_clean=slug_clean,
        supports=', '.join(cpt_spec['supports']),
        taxonomies=', '.join(cpt_spec['taxonomies']) if cpt_spec['taxonomies'] else 'ãªã—',
        supports_array=str(cpt_spec['supports']).replace("'", '"'),
        taxonomies_array=str(cpt_spec['taxonomies']).replace("'", '"'),
        date=datetime.now().strftime('%Y-%m-%d')
    )

async def _save_php_code(self, code: str, cpt_spec: Dict, task_id: str) -> Path:
    """PHPã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"cpt_{cpt_spec['slug']}_{task_id}_{timestamp}.php"
    output_path = self.output_folder / filename
    
    with open(output_path, 'w', encoding='utf-8') as f:
        # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ 
        f.write(f"<?php\n")
        f.write(f"/**\n")
        f.write(f" * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_spec['singular']}\n")
        f.write(f" * ã‚¹ãƒ©ãƒƒã‚°: {cpt_spec['slug']}\n")
        f.write(f" * ä½œæˆæ—¥: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f" */\n\n")
        
        # ã‚³ãƒ¼ãƒ‰æœ¬ä½“
        if '<?php' in code:
            # æ—¢ã«PHPã‚¿ã‚°ãŒã‚ã‚‹å ´åˆã¯ãã®ã¾ã¾
            f.write(code)
        else:
            # PHPã‚¿ã‚°ãŒãªã„å ´åˆã¯è¿½åŠ 
            f.write(code)
    
    logger.info(f"âœ… PHPä¿å­˜: {filename}")
    return output_path



#wp_settings_manager.py
"""WordPressè¨­å®šç®¡ç†"""
import logging
from datetime import datetime
from typing import Dict
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressSettingsManager:
    """WordPressè¨­å®šç®¡ç†æ©Ÿèƒ½"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
    
    async def change_settings(self, page: Page, task: Dict) -> Dict:
        """WordPressè¨­å®šã‚’å¤‰æ›´"""
        try:
            logger.info("è¨­å®šå¤‰æ›´ã‚’å®Ÿè¡Œä¸­...")
            
            # è¨­å®šãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php")
            await page.wait_for_timeout(2000)
            
            # ç¾åœ¨ã®è¨­å®šã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"wp_settings_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("âœ… è¨­å®šç”»é¢ã‚’ç¢ºèªã—ã¾ã—ãŸ")
            logger.info("âš ï¸ å®Ÿéš›ã®è¨­å®šå¤‰æ›´ã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': 'è¨­å®šç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚å¤‰æ›´å†…å®¹ã‚’ç¢ºèªã—ã¦æ‰‹å‹•ã§é©ç”¨ã—ã¦ãã ã•ã„ã€‚',
                'screenshot': screenshot_path,
                'full_text': f'è¨­å®šç¢ºèªå®Œäº†\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"è¨­å®šå¤‰æ›´ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def change_theme(self, page: Page, task: Dict) -> Dict:
        """ãƒ†ãƒ¼ãƒã‚’å¤‰æ›´"""
        try:
            logger.info("ãƒ†ãƒ¼ãƒå¤‰æ›´ã‚’å®Ÿè¡Œä¸­...")
            
            # ãƒ†ãƒ¼ãƒãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/themes.php")
            await page.wait_for_timeout(3000)
            
            # ç¾åœ¨ã®ãƒ†ãƒ¼ãƒã‚’ç¢ºèª
            screenshot_path = f"wp_themes_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("âœ… ãƒ†ãƒ¼ãƒç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ")
            logger.info("âš ï¸ å®Ÿéš›ã®ãƒ†ãƒ¼ãƒå¤‰æ›´ã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': 'ãƒ†ãƒ¼ãƒç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚å¤‰æ›´å†…å®¹ã‚’ç¢ºèªã—ã¦æ‰‹å‹•ã§é©ç”¨ã—ã¦ãã ã•ã„ã€‚',
                'screenshot': screenshot_path,
                'full_text': f'ãƒ†ãƒ¼ãƒç¢ºèªå®Œäº†\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"ãƒ†ãƒ¼ãƒå¤‰æ›´ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#wp_tester.py
"""WordPressãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ï¼ˆå“è³ªç®¡ç†å¼·åŒ–ç‰ˆï¼‰"""
import logging
import re
from datetime import datetime
from typing import Dict, List, Tuple
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressTester:
    """WordPressãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ï¼ˆå“è³ªç®¡ç†å¼·åŒ–ç‰ˆï¼‰"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
        self.test_frameworks = {
            'php': ['PHPUnit', 'Codeception', 'WP_UnitTestCase'],
            'javascript': ['Jest', 'Mocha', 'Chai', 'Cypress'],
            'wordpress': ['WP_UnitTestCase', 'WordPress PHPUnit']
        }
    
    async def test_functionality(self, page: Page, task: Dict) -> Dict:
        """æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆï¼ˆå“è³ªæ¤œè¨¼å¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info("ğŸ” æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œä¸­ï¼ˆå“è³ªæ¤œè¨¼ä»˜ãï¼‰...")
            
            test_results = []
            quality_issues = []
            
            # 1. ã‚µã‚¤ãƒˆã®è¡¨ç¤ºãƒ†ã‚¹ãƒˆ
            site_test_result = await self._test_site_accessibility(page)
            test_results.extend(site_test_result['results'])
            quality_issues.extend(site_test_result['quality_issues'])
            
            # 2. ç®¡ç†ç”»é¢ãƒ†ã‚¹ãƒˆ
            admin_test_result = await self._test_admin_access(page)
            test_results.extend(admin_test_result['results'])
            quality_issues.extend(admin_test_result['quality_issues'])
            
            # 3. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
            plugin_test_result = await self._test_plugins_status(page)
            test_results.extend(plugin_test_result['results'])
            quality_issues.extend(plugin_test_result['quality_issues'])
            
            # 4. ã‚³ãƒ¼ãƒ‰å“è³ªæ¤œè¨¼ï¼ˆã‚¿ã‚¹ã‚¯ã«ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã‚‹å ´åˆï¼‰
            if self._has_test_code(task):
                code_quality_result = await self._validate_test_code_quality(task)
                test_results.extend(code_quality_result['results'])
                quality_issues.extend(code_quality_result['quality_issues'])
            
            # ãƒ†ã‚¹ãƒˆçµæœã®é›†è¨ˆ
            summary = self._generate_test_summary(test_results, quality_issues)
            
            logger.info("\n" + "="*60)
            logger.info("ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼")
            logger.info("="*60)
            logger.info(summary)
            
            return {
                'success': len(quality_issues) == 0,
                'summary': summary[:500],
                'full_text': summary,
                'quality_issues': quality_issues,
                'test_results': test_results
            }
            
        except Exception as e:
            logger.error(f"âŒ æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _test_site_accessibility(self, page: Page) -> Dict:
        """ã‚µã‚¤ãƒˆã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"""
        results = []
        quality_issues = []
        
        try:
            # ã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹
            await page.goto(self.wp_url, wait_until='networkidle')
            await page.wait_for_timeout(3000)
            
            # ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«å–å¾—
            page_title = await page.title()
            results.append(f"âœ… ã‚µã‚¤ãƒˆè¡¨ç¤ºOK: {page_title}")
            
            # HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯
            response = await page.goto(self.wp_url)
            if response and response.status == 200:
                results.append("âœ… HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: 200 OK")
            else:
                quality_issues.append("âŒ HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒ200ã§ã¯ã‚ã‚Šã¾ã›ã‚“")
                results.append("âŒ HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¨ãƒ©ãƒ¼")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            timestamp = datetime.now().strftime('%H%M%S')
            site_screenshot = f"wp_site_{timestamp}.png"
            await page.screenshot(path=site_screenshot, full_page=True)
            results.append(f"ğŸ“¸ ã‚µã‚¤ãƒˆå…¨ä½“: {site_screenshot}")
            
            # ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿é€Ÿåº¦ãƒã‚§ãƒƒã‚¯
            load_time = await self._measure_page_load_time(page, self.wp_url)
            if load_time < 5000:  # 5ç§’ä»¥å†…
                results.append(f"âœ… ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿é€Ÿåº¦: {load_time}ms")
            else:
                quality_issues.append(f"âš ï¸ ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿ãŒé…ã„: {load_time}ms")
                results.append(f"âš ï¸ ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿é€Ÿåº¦: {load_time}ms")
            
        except Exception as e:
            quality_issues.append(f"âŒ ã‚µã‚¤ãƒˆã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
            results.append(f"âŒ ã‚µã‚¤ãƒˆã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_admin_access(self, page: Page) -> Dict:
        """ç®¡ç†ç”»é¢ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ"""
        results = []
        quality_issues = []
        
        try:
            # ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹
            admin_url = f"{self.wp_url}/wp-admin/"
            await page.goto(admin_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®å­˜åœ¨ç¢ºèª
            login_form = await page.query_selector('#loginform')
            if login_form:
                results.append("âœ… ç®¡ç†ç”»é¢ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ç¢ºèª")
            else:
                # æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
                admin_bar = await page.query_selector('#wpadminbar')
                if admin_bar:
                    results.append("âœ… ç®¡ç†ç”»é¢: æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿")
                else:
                    quality_issues.append("âŒ ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“")
                    results.append("âŒ ç®¡ç†ç”»é¢ã‚¢ã‚¯ã‚»ã‚¹å¤±æ•—")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            timestamp = datetime.now().strftime('%H%M%S')
            admin_screenshot = f"wp_admin_{timestamp}.png"
            await page.screenshot(path=admin_screenshot)
            results.append(f"ğŸ“¸ ç®¡ç†ç”»é¢: {admin_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"âŒ ç®¡ç†ç”»é¢ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
            results.append(f"âŒ ç®¡ç†ç”»é¢ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_plugins_status(self, page: Page) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚¹ãƒˆ"""
        results = []
        quality_issues = []
        
        try:
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ãªå ´åˆï¼‰
            plugins_url = f"{self.wp_url}/wp-admin/plugins.php"
            await page.goto(plugins_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‹ç¢ºèª
            page_title = await page.title()
            if 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³' in page_title or 'Plugins' in page_title:
                results.append("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€è¦§ãƒšãƒ¼ã‚¸ç¢ºèª")
                
                # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°ã‚’ãƒã‚§ãƒƒã‚¯
                active_plugins = await page.query_selector_all('.plugins .active')
                if len(active_plugins) > 0:
                    results.append(f"âœ… ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {len(active_plugins)}å€‹")
                else:
                    quality_issues.append("âš ï¸ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“")
                    results.append("âš ï¸ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: 0å€‹")
            else:
                quality_issues.append("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“")
                results.append("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚»ã‚¹å¤±æ•—")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            timestamp = datetime.now().strftime('%H%M%S')
            plugins_screenshot = f"wp_plugins_{timestamp}.png"
            await page.screenshot(path=plugins_screenshot)
            results.append(f"ğŸ“¸ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugins_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
            results.append(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _validate_test_code_quality(self, task: Dict) -> Dict:
        """ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å“è³ªæ¤œè¨¼"""
        results = []
        quality_issues = []
        
        try:
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º
            test_code = self._extract_test_code(task)
            
            if not test_code:
                results.append("â„¹ï¸ æ¤œè¨¼å¯¾è±¡ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãªã—")
                return {'results': results, 'quality_issues': quality_issues}
            
            # è¨€èªåˆ¥ã®å“è³ªæ¤œè¨¼
            if self._is_php_code(test_code):
                php_validation = self._validate_php_test_code(test_code)
                results.extend(php_validation['results'])
                quality_issues.extend(php_validation['quality_issues'])
            
            elif self._is_javascript_code(test_code):
                js_validation = self._validate_javascript_test_code(test_code)
                results.extend(js_validation['results'])
                quality_issues.extend(js_validation['quality_issues'])
            
            else:
                # ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ¤œè¨¼
                general_validation = self._validate_general_test_code(test_code)
                results.extend(general_validation['results'])
                quality_issues.extend(general_validation['quality_issues'])
            
        except Exception as e:
            quality_issues.append(f"âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {str(e)}")
            results.append(f"âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ¤œè¨¼å¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_php_test_code(self, code: str) -> Dict:
        """PHPãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼"""
        results = []
        quality_issues = []
        
        # PHPUnitã®åŸºæœ¬æ§‹é€ ãƒã‚§ãƒƒã‚¯
        if 'class' not in code and 'function' not in code:
            quality_issues.append("âŒ PHPãƒ†ã‚¹ãƒˆ: ã‚¯ãƒ©ã‚¹ã¾ãŸã¯é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            results.append("âŒ PHPãƒ†ã‚¹ãƒˆæ§‹é€ : ä¸å®Œå…¨")
        
        # ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        test_method_patterns = [
            r'function\s+test\w+',
            r'public\s+function\s+test\w+',
            r'public\s+function\s+test_\w+'
        ]
        
        has_test_methods = any(re.search(pattern, code) for pattern in test_method_patterns)
        if not has_test_methods:
            quality_issues.append("âŒ PHPãƒ†ã‚¹ãƒˆ: ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            results.append("âŒ PHPãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰: æœªå®šç¾©")
        else:
            results.append("âœ… PHPãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰: å®šç¾©æ¸ˆã¿")
        
        # ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        assertion_patterns = [
            r'\$this->assert',
            r'assertEquals',
            r'assertTrue',
            r'assertFalse',
            r'expectException'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("âŒ PHPãƒ†ã‚¹ãƒˆ: ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“")
            results.append("âŒ PHPãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: æœªå®šç¾©")
        else:
            results.append("âœ… PHPãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: å®šç¾©æ¸ˆã¿")
        
        # PHPUnitã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
        if 'PHPUnit' in code or 'use PHPUnit' in code:
            results.append("âœ… PHPUnitãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æ¤œå‡º")
        else:
            quality_issues.append("âš ï¸ PHPãƒ†ã‚¹ãƒˆ: PHPUnitãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒæ˜ç¤ºã•ã‚Œã¦ã„ã¾ã›ã‚“")
            results.append("âš ï¸ PHPUnitãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æœªæ¤œå‡º")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_javascript_test_code(self, code: str) -> Dict:
        """JavaScriptãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼"""
        results = []
        quality_issues = []
        
        # ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ãƒã‚§ãƒƒã‚¯
        frameworks = ['describe', 'it', 'test', 'expect']
        has_framework = any(framework in code for framework in frameworks)
        
        if not has_framework:
            quality_issues.append("âŒ JSãƒ†ã‚¹ãƒˆ: ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“")
            results.append("âŒ JSãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æœªæ¤œå‡º")
        else:
            results.append("âœ… JSãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æ¤œå‡º")
        
        # ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        assertion_patterns = [
            'expect',
            'assert',
            'should',
            'toBe',
            'toEqual'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("âŒ JSãƒ†ã‚¹ãƒˆ: ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“")
            results.append("âŒ JSãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: æœªå®šç¾©")
        else:
            results.append("âœ… JSãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: å®šç¾©æ¸ˆã¿")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_general_test_code(self, code: str) -> Dict:
        """ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼"""
        results = []
        quality_issues = []
        
        # ãƒ†ã‚¹ãƒˆé–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
        test_keywords = [
            'test', 'assert', 'expect', 'verify',
            'should', 'check', 'validate'
        ]
        
        has_test_keywords = any(keyword in code.lower() for keyword in test_keywords)
        if not has_test_keywords:
            quality_issues.append("âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰: ãƒ†ã‚¹ãƒˆé–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
            results.append("âŒ ãƒ†ã‚¹ãƒˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: ä¸è¶³")
        else:
            results.append("âœ… ãƒ†ã‚¹ãƒˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: æ¤œå‡º")
        
        # å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã®ã¿ã§ãªã„ã‹ï¼‰
        lines = code.split('\n')
        code_lines = [line for line in lines if line.strip() and not line.strip().startswith(('//', '#'))]
        
        if len(code_lines) < 3:
            quality_issues.append("âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰: å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
            results.append("âŒ å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰: ä¸è¶³")
        else:
            results.append("âœ… å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰: ååˆ†")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _has_test_code(self, task: Dict) -> bool:
        """ã‚¿ã‚¹ã‚¯ã«ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        description = task.get('description', '').lower()
        if any(keyword in description for keyword in ['test', 'ãƒ†ã‚¹ãƒˆ', 'testing']):
            return True
        
        # å‡ºåŠ›ã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ¢ã™
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        test_indicators = ['function test', 'class Test', '@Test', 'describe(', 'it(']
        combined_text = f"{output} {parameters}".lower()
        
        return any(indicator in combined_text for indicator in test_indicators)
    
    def _extract_test_code(self, task: Dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        # å‡ºåŠ›ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œç´¢
        code_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', output, re.DOTALL)
        if code_blocks:
            return '\n'.join(code_blocks)
        
        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º
        if '```' in parameters:
            param_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', parameters, re.DOTALL)
            if param_blocks:
                return '\n'.join(param_blocks)
        
        return output  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    
    def _is_php_code(self, code: str) -> bool:
        """PHPã‚³ãƒ¼ãƒ‰ã‹åˆ¤å®š"""
        php_indicators = ['<?php', 'function', 'class', '$this', '->']
        return any(indicator in code for indicator in php_indicators)
    
    def _is_javascript_code(self, code: str) -> bool:
        """JavaScriptã‚³ãƒ¼ãƒ‰ã‹åˆ¤å®š"""
        js_indicators = ['function', 'const', 'let', 'var', '=>', 'describe', 'it']
        return any(indicator in code for indicator in js_indicators)
    
    async def _measure_page_load_time(self, page: Page, url: str) -> float:
        """ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚é–“ã‚’è¨ˆæ¸¬"""
        try:
            start_time = datetime.now()
            await page.goto(url, wait_until='networkidle')
            end_time = datetime.now()
            return (end_time - start_time).total_seconds() * 1000  # ãƒŸãƒªç§’
        except:
            return 0
    
    def _generate_test_summary(self, test_results: List[str], quality_issues: List[str]) -> str:
        """ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼ã‚’ç”Ÿæˆ"""
        summary = []
        
        summary.append("ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼")
        summary.append("=" * 50)
        
        # ãƒ†ã‚¹ãƒˆçµæœ
        summary.append("\nâœ… æˆåŠŸãƒ†ã‚¹ãƒˆ:")
        success_tests = [r for r in test_results if 'âœ…' in r or 'OK' in r]
        for test in success_tests:
            summary.append(f"  â€¢ {test}")
        
        # å“è³ªå•é¡Œ
        if quality_issues:
            summary.append("\nâŒ å“è³ªå•é¡Œ:")
            for issue in quality_issues:
                summary.append(f"  â€¢ {issue}")
        else:
            summary.append("\nğŸ‰ å“è³ªå•é¡Œ: ãªã—")
        
        # çµ±è¨ˆ
        total_tests = len(test_results)
        success_count = len(success_tests)
        issue_count = len(quality_issues)
        
        summary.append("\nğŸ“ˆ çµ±è¨ˆ:")
        summary.append(f"  ç·ãƒ†ã‚¹ãƒˆæ•°: {total_tests}")
        summary.append(f"  æˆåŠŸãƒ†ã‚¹ãƒˆ: {success_count}")
        summary.append(f"  å“è³ªå•é¡Œ: {issue_count}")
        
        if total_tests > 0:
            success_rate = (success_count / total_tests) * 100
            summary.append(f"  æˆåŠŸç‡: {success_rate:.1f}%")
        
        return '\n'.join(summary)

#wp_utils.py
"""WordPressãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Google Driveå¯¾å¿œç‰ˆ)
ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€WordPressã‚¿ã‚¹ã‚¯ã®å‡¦ç†ã«å¿…è¦ãªå„ç¨®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
ä¸»ãªæ©Ÿèƒ½:
- ã‚¿ã‚¹ã‚¯å†…å®¹ã®å–å¾—ï¼ˆGoogle Driveã€JSONã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œï¼‰
- ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã®åˆ†æã¨åˆ¤å®š
- WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ»è¨­å®šç®¡ç†
- HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ»æœ€é©åŒ–
"""

import re
import logging
from typing import Optional, Tuple, Dict, List
from pathlib import Path
import json

# ãƒ­ã‚¬ãƒ¼ã®åˆæœŸåŒ–
logger = logging.getLogger(__name__)


# ============================================================================
# TaskContentFetcher: ã‚¿ã‚¹ã‚¯å†…å®¹å–å¾—ã‚¯ãƒ©ã‚¹
# ============================================================================

class TaskContentFetcher:
    """ã‚¿ã‚¹ã‚¯å†…å®¹å–å¾—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Google Driveå¯¾å¿œ)
    
    è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨˜äº‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›:
    1. Google Driveãƒªãƒ³ã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
    2. JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
    3. ãƒ­ãƒ¼ã‚«ãƒ«Markdownãƒ•ã‚¡ã‚¤ãƒ«
    4. task_logã‚·ãƒ¼ãƒˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    """
    
    @staticmethod
    def extract_task_id(description: str) -> Optional[int]:
        """èª¬æ˜æ–‡ã‹ã‚‰task_idã‚’æŠ½å‡º
        
        å¯¾å¿œå½¢å¼:
        - task_id 39
        - task id 39
        - ã‚¿ã‚¹ã‚¯ID 39
        
        Args:
            description: ã‚¿ã‚¹ã‚¯èª¬æ˜æ–‡
            
        Returns:
            æŠ½å‡ºã•ã‚ŒãŸtask_idã€è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯None
        """
        # è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§task_idã‚’æ¤œç´¢
        patterns = [
            r'task[_\s]+id[\sã€€]*(\d+)',  # task_id, task idå½¢å¼
            r'ã‚¿ã‚¹ã‚¯[\sã€€]*ID[\sã€€]*(\d+)',  # æ—¥æœ¬èªå½¢å¼
        ]
        
        for pattern in patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                task_id = int(match.group(1))
                logger.info(f"âœ… task_idæŠ½å‡º: {task_id}")
                return task_id
        
        logger.debug("task_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return None

    @staticmethod
    async def get_task_content(sheets_manager, task_id: int) -> Optional[str]:
        """æŒ‡å®šã•ã‚ŒãŸtask_idã®è¨˜äº‹å†…å®¹ã‚’å–å¾—(è¶…å …ç‰¢ç‰ˆ)
        
        å„ªå…ˆé †ä½:
        1. task_execution_log ã‚·ãƒ¼ãƒˆã® Google Drive ãƒªãƒ³ã‚¯(æœ€å„ªå…ˆ)
        2. task_execution_log ã‚·ãƒ¼ãƒˆã® output_data ã‚«ãƒ©ãƒ (JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹)
        3. task_execution_log ã‚·ãƒ¼ãƒˆã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        4. task_log ã‚·ãƒ¼ãƒˆ(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            task_id: ã‚¿ã‚¹ã‚¯ID
            
        Returns:
            è¨˜äº‹å†…å®¹(ãƒ†ã‚­ã‚¹ãƒˆ)ã€å¤±æ•—æ™‚ã¯None
        """
        try:
            logger.info("="*60)
            logger.info(f"ã€è¨˜äº‹å–å¾—é–‹å§‹ã€‘task_id={task_id}")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: sheets_managerã®æ¤œè¨¼ ===
            if not TaskContentFetcher._validate_sheets_manager(sheets_manager):
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã ===
            sheet = TaskContentFetcher._open_spreadsheet(sheets_manager)
            if not sheet:
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ3: task_execution_logã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹ ===
            logger.info("\nã€å„ªå…ˆåº¦1ã€‘task_execution_logã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã¾ã™")
            content = await TaskContentFetcher._get_from_execution_log(
                sheet, task_id, sheets_manager
            )
            
            if content:
                logger.info(f"âœ… è¨˜äº‹å–å¾—æˆåŠŸ: {len(content)}æ–‡å­—")
                return content
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ - task_logã‹ã‚‰å–å¾— ===
            logger.info("\nã€å„ªå…ˆåº¦2ã€‘task_logã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã¾ã™(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)")
            content = await TaskContentFetcher._get_from_task_log(
                sheet, task_id
            )
            
            if content:
                logger.info(f"âœ… è¨˜äº‹å–å¾—æˆåŠŸ(task_log): {len(content)}æ–‡å­—")
                return content
            
            logger.error("âŒ ã™ã¹ã¦ã®æ–¹æ³•ã§è¨˜äº‹å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
            return None
            
        except Exception as e:
            logger.error(f"âŒ task_id {task_id} ã®å†…å®¹å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _validate_sheets_manager(sheets_manager) -> bool:
        """sheets_managerã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            æ¤œè¨¼æˆåŠŸæ™‚Trueã€å¤±æ•—æ™‚False
        """
        if not sheets_manager:
            logger.error("âŒ sheets_managerãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        
        if not sheets_manager.gc:
            logger.error("âŒ Google Sheetsã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        
        logger.info("âœ… sheets_manageræ¤œè¨¼å®Œäº†")
        return True

    @staticmethod
    def _open_spreadsheet(sheets_manager):
        """ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å¤±æ•—æ™‚None
        """
        logger.info(f"ğŸ“Š ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã: {sheets_manager.spreadsheet_id}")
        try:
            sheet = sheets_manager.gc.open_by_key(sheets_manager.spreadsheet_id)
            logger.info("âœ… ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šæˆåŠŸ")
            return sheet
        except Exception as e:
            logger.error(f"âŒ ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šå¤±æ•—: {e}")
            return None

    @staticmethod
    async def _get_from_execution_log(sheet, task_id: int, sheets_manager) -> Optional[str]:
        """task_execution_log ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—(è¶…è©³ç´°ãƒ­ã‚°ç‰ˆ)
        
        å„ªå…ˆé †ä½:
        1. Google Driveãƒªãƒ³ã‚¯
        2. output_data(JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹)
        3. ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
        
        Args:
            sheet: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            task_id: ã‚¿ã‚¹ã‚¯ID
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆã‚’é–‹ã ===
            logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘1ã€‘task_execution_logã‚·ãƒ¼ãƒˆã‚’é–‹ã")
            try:
                execution_log_sheet = sheet.worksheet("task_execution_log")
                logger.info("âœ… task_execution_logã‚·ãƒ¼ãƒˆç™ºè¦‹")
            except Exception as e:
                logger.warning(f"âŒ task_execution_logã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {e}")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— ===
            logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘2ã€‘ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            execution_log_data = execution_log_sheet.get_all_values()
            
            if len(execution_log_data) == 0:
                logger.warning("âŒ task_execution_logã‚·ãƒ¼ãƒˆãŒç©ºã§ã™")
                return None
            
            logger.info(f"âœ… {len(execution_log_data)}è¡Œã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æã—ã¦ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š ===
            column_indices = TaskContentFetcher._parse_header_columns(execution_log_data[0])
            if column_indices['task_id_col'] is None:
                logger.warning("âŒ task_id ã‚«ãƒ©ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ4: å¯¾è±¡ã®task_idã‚’æ¤œç´¢ ===
            logger.debug(f"ã€åˆ‡ã‚Šåˆ†ã‘6ã€‘task_id={task_id}ã‚’æ¤œç´¢ä¸­...")
            for row_idx, row in enumerate(execution_log_data[1:], start=2):
                if len(row) <= column_indices['task_id_col']:
                    continue
                
                try:
                    task_id_in_row = int(row[column_indices['task_id_col']])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"âœ… task_id {task_id} ã‚’è¡Œ {row_idx} ã§ç™ºè¦‹")
                    logger.debug(f"è¡Œå†…å®¹: {row[:min(len(row), 10)]}...")
                    
                    # === ãƒ‘ãƒ¼ãƒˆ5: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨˜äº‹ã‚’å–å¾— ===
                    content = await TaskContentFetcher._fetch_content_from_sources(
                        row, column_indices, sheets_manager
                    )
                    
                    if content:
                        return content
                    
                    logger.warning(f"âŒ task_id {task_id} ã®ãƒ‡ãƒ¼ã‚¿ãŒã™ã¹ã¦ç©ºã§ã™")
                    return None
            
            logger.warning(f"âŒ task_id {task_id} ãŒ task_execution_log ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            return None
            
        except Exception as e:
            logger.error(f"âŒ task_execution_log ã‹ã‚‰ã®å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _parse_header_columns(headers: List[str]) -> Dict[str, Optional[int]]:
        """ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æã—ã¦ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š
        
        Args:
            headers: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã®ãƒªã‚¹ãƒˆ
            
        Returns:
            ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¾æ›¸
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘3ã€‘ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æ")
        logger.debug(f"ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
        
        column_indices = {
            'task_id_col': None,
            'output_data_col': None,
            'markdown_file_col': None,
            'drive_link_col': None
        }
        
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘4ã€‘ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š")
        for i, header in enumerate(headers):
            header_lower = header.lower().strip()
            
            if 'task_id' in header_lower or 'ã‚¿ã‚¹ã‚¯id' in header_lower:
                column_indices['task_id_col'] = i
                logger.debug(f"  â†’ task_idåˆ—: {i}")
            elif 'output_data' in header_lower or 'full_text' in header_lower or 'å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿' in header_lower or 'å‡ºåŠ›' in header_lower:
                column_indices['output_data_col'] = i
                logger.debug(f"  â†’ output_dataåˆ—: {i}")
            elif 'drive' in header_lower or 'link' in header_lower or 'url' in header_lower or 'ãƒªãƒ³ã‚¯' in header_lower:
                column_indices['drive_link_col'] = i
                logger.debug(f"  â†’ drive_linkåˆ—: {i}")
            elif 'markdown' in header_lower or 'file' in header_lower or 'ãƒ•ã‚¡ã‚¤ãƒ«' in header_lower:
                column_indices['markdown_file_col'] = i
                logger.debug(f"  â†’ markdownåˆ—: {i}")
        
        logger.debug(f"ã€åˆ‡ã‚Šåˆ†ã‘5ã€‘ã‚«ãƒ©ãƒ ç‰¹å®šçµæœ")
        for key, value in column_indices.items():
            logger.debug(f"  {key}: {value}")
        
        return column_indices

    @staticmethod
    async def _fetch_content_from_sources(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨˜äº‹å†…å®¹ã‚’å–å¾—ï¼ˆå„ªå…ˆé †ä½ä»˜ãï¼‰
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        # å„ªå…ˆåº¦1: Google Driveãƒªãƒ³ã‚¯
        content = await TaskContentFetcher._fetch_from_drive_link(
            row, column_indices, sheets_manager
        )
        if content:
            return content
        
        # å„ªå…ˆåº¦2: output_data(JSONãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ç›´æ¥ãƒ†ã‚­ã‚¹ãƒˆ)
        content = TaskContentFetcher._fetch_from_output_data(
            row, column_indices
        )
        if content:
            return content
        
        # å„ªå…ˆåº¦3: ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
        content = TaskContentFetcher._fetch_from_markdown_file(
            row, column_indices
        )
        if content:
            return content
        
        return None

    @staticmethod
    async def _fetch_from_drive_link(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """Google Driveãƒªãƒ³ã‚¯ã‹ã‚‰è¨˜äº‹ã‚’å–å¾—
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘7ã€‘Google Driveãƒªãƒ³ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯")
        drive_link_col = column_indices.get('drive_link_col')
        
        if drive_link_col is not None and len(row) > drive_link_col:
            drive_link = row[drive_link_col].strip()
            logger.debug(f"  drive_linkåˆ—ã®å€¤: '{drive_link}'")
            
            if drive_link and len(drive_link) > 0:
                logger.info(f"ğŸ”— Google Drive ãƒªãƒ³ã‚¯ã‚’ç™ºè¦‹")
                logger.debug(f"  URL: {drive_link[:80]}...")
                
                # Google Driveã‹ã‚‰èª­ã¿è¾¼ã¿
                logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘8ã€‘Google Driveã‹ã‚‰è¨˜äº‹ã‚’èª­ã¿è¾¼ã¿ä¸­...")
                content = sheets_manager.read_file_from_drive(drive_link)
                
                if content:
                    logger.info(f"âœ… Google Driveã‹ã‚‰è¨˜äº‹å–å¾—æˆåŠŸ")
                    logger.debug(f"  æ–‡å­—æ•°: {len(content)}")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
                    return content
                else:
                    logger.warning("âŒ Google Driveã‹ã‚‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—")
            else:
                logger.debug("  â†’ drive_linkåˆ—ãŒç©º")
        else:
            logger.debug("  â†’ drive_linkåˆ—ãªã—")
        
        return None

    @staticmethod
    def _fetch_from_output_data(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """output_dataã‚«ãƒ©ãƒ ã‹ã‚‰è¨˜äº‹ã‚’å–å¾—ï¼ˆJSONã¾ãŸã¯ç›´æ¥ãƒ†ã‚­ã‚¹ãƒˆï¼‰
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘9ã€‘output_dataã‚’ãƒã‚§ãƒƒã‚¯")
        output_data_col = column_indices.get('output_data_col')
        
        if output_data_col is not None and len(row) > output_data_col:
            output_data = row[output_data_col].strip()
            logger.debug(f"  output_dataåˆ—ã®é•·ã•: {len(output_data)}æ–‡å­—")
            
            if output_data and len(output_data) > 0:
                # JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                if output_data.endswith('.json'):
                    logger.info(f"  â†’ JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨åˆ¤å®š: {output_data}")
                    return TaskContentFetcher._read_json_file(output_data)
                else:
                    # é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦æ‰±ã†
                    logger.info(f"âœ… output_data ã‹ã‚‰è¨˜äº‹å–å¾—(ç›´æ¥)")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {output_data[:100]}...")
                    return output_data
            else:
                logger.debug("  â†’ output_dataåˆ—ãŒç©º")
        else:
            logger.debug("  â†’ output_dataåˆ—ãªã—")
        
        return None

    @staticmethod
    def _read_json_file(json_path_str: str) -> Optional[str]:
        """JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨˜äº‹ã‚’èª­ã¿è¾¼ã‚€
        
        Args:
            json_path_str: JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        json_path = Path(json_path_str)
        
        # çµ¶å¯¾ãƒ‘ã‚¹ã§ãªã„å ´åˆã€å€™è£œãƒ‘ã‚¹ã‚’è©¦ã™
        if not json_path.is_absolute():
            candidates = [
                Path.cwd() / json_path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / json_path.name,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / json_path.name,
            ]
            for candidate in candidates:
                if candidate.exists():
                    json_path = candidate
                    break
        
        if json_path.exists():
            logger.info(f"  â†’ JSONãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿: {json_path}")
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                # html_contentã‚’å–å¾—
                html_content = json_data.get('html_content', '')
                if html_content:
                    logger.info(f"âœ… JSONã‹ã‚‰HTMLè¨˜äº‹å–å¾—æˆåŠŸ: {len(html_content)}æ–‡å­—")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {html_content[:100]}...")
                    return html_content
                else:
                    logger.warning("âŒ JSONã«html_contentãŒã‚ã‚Šã¾ã›ã‚“")
            except Exception as e:
                logger.error(f"âŒ JSONãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
        else:
            logger.warning(f"âŒ JSONãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {json_path}")
        
        return None

    @staticmethod
    def _fetch_from_markdown_file(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨˜äº‹ã‚’å–å¾—
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘10ã€‘ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯")
        markdown_file_col = column_indices.get('markdown_file_col')
        
        if markdown_file_col is not None and len(row) > markdown_file_col:
            markdown_path = row[markdown_file_col]
            logger.debug(f"  markdownåˆ—ã®å€¤: '{markdown_path}'")
            
            if markdown_path and len(markdown_path.strip()) > 0:
                content = TaskContentFetcher._read_local_markdown_file(markdown_path)
                if content:
                    return content
            else:
                logger.debug("  â†’ markdownåˆ—ãŒç©º")
        else:
            logger.debug("  â†’ markdownåˆ—ãªã—")
        
        return None

    @staticmethod
    async def _get_from_task_log(sheet, task_id: int) -> Optional[str]:
        """task_log ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
        
        Args:
            sheet: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            task_id: ã‚¿ã‚¹ã‚¯ID
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        try:
            task_log_sheet = sheet.worksheet("task_log")
            task_log_data = task_log_sheet.get_all_values()
            
            if len(task_log_data) == 0:
                return None
            
            headers = task_log_data[0]
            
            # ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š
            task_id_col = None
            output_data_col = None
            
            for i, header in enumerate(headers):
                if 'task_id' in header.lower():
                    task_id_col = i
                elif 'output_data' in header.lower() or 'full_text' in header.lower():
                    output_data_col = i
            
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
            if task_id_col is None:
                task_id_col = 1
            
            if output_data_col is None:
                output_data_col = len(headers) - 1
            
            # task_idã‚’æ¤œç´¢
            for row_idx, row in enumerate(task_log_data[1:], start=2):
                if len(row) <= task_id_col:
                    continue
                
                try:
                    task_id_in_row = int(row[task_id_col])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"âœ… task_id {task_id} ã‚’ task_log ã®è¡Œ {row_idx} ã§ç™ºè¦‹")
                    
                    if output_data_col and len(row) > output_data_col:
                        full_text = row[output_data_col]
                        if full_text and len(full_text) > 0:
                            logger.info(f"âœ… task_log ã‹ã‚‰å–å¾— ({len(full_text)}æ–‡å­—)")
                            return full_text
            
            return None
            
        except Exception as e:
            logger.error(f"task_log ã‹ã‚‰ã®å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return None

    @staticmethod
    def _read_local_markdown_file(file_path: str) -> Optional[str]:
        """ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€(å¼·åŒ–ç‰ˆ)
        
        Args:
            file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            
        Returns:
            ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã€å¤±æ•—æ™‚None
        """
        try:
            logger.debug("ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€‘")
            logger.debug(f"  ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: {file_path}")
            
            path = Path(file_path.strip())
            
            # çµ¶å¯¾ãƒ‘ã‚¹ã®å ´åˆ
            if path.is_absolute():
                logger.debug("  â†’ çµ¶å¯¾ãƒ‘ã‚¹ã¨ã—ã¦å‡¦ç†")
                if path.exists():
                    logger.debug(f"  â†’ ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª: OK")
                    with open(path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: {len(content)}æ–‡å­—")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
                    
                    # ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
                    content = TaskContentFetcher._extract_title_and_body(content)
                    
                    return content
                else:
                    logger.warning(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {path}")
                    return None
            
            # ç›¸å¯¾ãƒ‘ã‚¹ã®å ´åˆã€å€™è£œãƒ‘ã‚¹ã‚’è©¦ã™
            logger.debug("  â†’ ç›¸å¯¾ãƒ‘ã‚¹ã¨ã—ã¦å‡¦ç†")
            candidates = [
                Path.cwd() / path,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "AI_Agent" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / path.name,
            ]
            
            logger.debug(f"  å€™è£œãƒ‘ã‚¹æ•°: {len(candidates)}")
            
            for i, candidate in enumerate(candidates, 1):
                logger.debug(f"  å€™è£œ{i}: {candidate}")
                if candidate.exists():
                    logger.info(f"  â†’ ãƒ•ã‚¡ã‚¤ãƒ«ç™ºè¦‹: {candidate}")
                    path = candidate
                    break
            
            if not path.exists():
                logger.warning(f"âŒ ã™ã¹ã¦ã®å€™è£œã§ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                for candidate in candidates:
                    logger.warning(f"  è©¦è¡Œ: {candidate}")
                return None
            
            logger.info(f"ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ä¸­: {path}")
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: {len(content)}æ–‡å­—")
            logger.debug(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
            
            # ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
            content = TaskContentFetcher._extract_title_and_body(content)
            
            return content
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    @staticmethod
    def _extract_title_and_body(content: str) -> str:
        """ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
        
        <!-- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ --> ã‚„ <!-- ã‚³ãƒ¡ãƒ³ãƒˆ --> ã‚’é™¤å»ã—ã€
        ã‚¿ã‚¤ãƒˆãƒ«(# ã§å§‹ã¾ã‚‹è¡Œ)ã¨æœ¬æ–‡ã®ã¿ã‚’æŠ½å‡º
        
        Args:
            content: å…ƒã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„
        """
        try:
            lines = content.split('\n')
            result_lines = []
            in_comment = False
            
            for line in lines:
                # HTMLã‚³ãƒ¡ãƒ³ãƒˆé–‹å§‹
                if '<!--' in line:
                    in_comment = True
                    continue
                
                # HTMLã‚³ãƒ¡ãƒ³ãƒˆçµ‚äº†
                if '-->' in line:
                    in_comment = False
                    continue
                
                # ã‚³ãƒ¡ãƒ³ãƒˆå†…ã¯ã‚¹ã‚­ãƒƒãƒ—
                if in_comment:
                    continue
                
                # ç©ºè¡ŒãŒé€£ç¶šã™ã‚‹å ´åˆã¯1ã¤ã ã‘ã«ã™ã‚‹
                if line.strip() == '':
                    if result_lines and result_lines[-1].strip() == '':
                        continue
                
                result_lines.append(line)
            
            # å…ˆé ­ã¨æœ«å°¾ã®ç©ºè¡Œã‚’å‰Šé™¤
            while result_lines and result_lines[0].strip() == '':
                result_lines.pop(0)
            
            while result_lines and result_lines[-1].strip() == '':
                result_lines.pop()
            
            cleaned_content = '\n'.join(result_lines)
            
            logger.debug(f"ã€è¨˜äº‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†ã€‘")
            logger.debug(f"  å…ƒã®æ–‡å­—æ•°: {len(content)}")
            logger.debug(f"  å‡¦ç†å¾Œã®æ–‡å­—æ•°: {len(cleaned_content)}")
            logger.debug(f"  å…ˆé ­100æ–‡å­—: {cleaned_content[:100]}...")
            
            return cleaned_content
            
        except Exception as e:
            logger.warning(f"è¨˜äº‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
            return content


# ============================================================================
# TaskTypeAnalyzer: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ†æã‚¯ãƒ©ã‚¹
# ============================================================================

class TaskTypeAnalyzer:
    """ã‚¿ã‚¹ã‚¯å†…å®¹ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
    
    ã‚¿ã‚¹ã‚¯ã®èª¬æ˜æ–‡ã‚’è§£æã—ã¦ã€é©åˆ‡ãªã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’è¿”ã™ã€‚
    """

    @staticmethod
    def analyze(description: str) -> str:
        """ã‚¿ã‚¹ã‚¯å†…å®¹ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            description: ã‚¿ã‚¹ã‚¯èª¬æ˜æ–‡
            
        Returns:
            ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—æ–‡å­—åˆ—
        """
        description_lower = description.lower()
        
        # æ–°ã—ã„åˆ¤å®šãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ 
        if 'polylang' in description_lower and 'è¨€èª' in description_lower:
            return 'edit_post'
        
        if 'æŠ•ç¨¿' in description and 'æ¢ã—ã¦' in description and (
            'å¤‰æ›´' in description or 'ç·¨é›†' in description or 'æ›¸ãæ›ãˆ' in description
        ):
            return 'edit_post'
        
        if 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³' in description and (
            'å¤‰æ›´' in description or 'è¨­å®š' in description
        ) and 'ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«' not in description:
            return 'plugin_settings'
        
        if 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³' in description and 'ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«' in description:
            return 'plugin_install'
        
        if 'ãƒ†ãƒ¼ãƒ' in description or 'theme' in description_lower:
            return 'theme_change'
        
        if 'è¨­å®š' in description or 'setting' in description_lower:
            return 'setting_change'
        
        if ('æŠ•ç¨¿' in description or 'è¨˜äº‹' in description or 'post' in description_lower) and (
            'ä½œæˆ' in description or 'ä¿å­˜' in description
        ):
            return 'content_create'
        
        if 'ãƒ†ã‚¹ãƒˆ' in description or 'test' in description_lower:
            return 'test_functionality'
        
        return 'generic'


# ============================================================================
# WordPressConfig: WordPressè¨­å®šã‚¯ãƒ©ã‚¹
# ============================================================================

class WordPressConfig:
    """WordPressè¨­å®šã‚¯ãƒ©ã‚¹
    
    WordPressé–¢é€£ã®è¨­å®šå€¤ã‚’ä¸€å…ƒç®¡ç†ã™ã‚‹ã€‚
    - WordPress URL
    - Polylangè¨€èªã‚³ãƒ¼ãƒ‰
    - ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—
    - æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
    - M&Aæ¡ˆä»¶ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    - FacetWPãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
    """
    
    # WordPress URLã®è¨­å®š(å®Ÿéš›ã®ã‚µã‚¤ãƒˆURLã«å¤‰æ›´ã—ã¦ãã ã•ã„)
    WORDPRESS_URL = "https://your-site.com"
    
    # Polylangè¨€èªã‚³ãƒ¼ãƒ‰å®šç¾©
    POLYLANG_LANGS = {
        'ja': 'ja',           # æ—¥æœ¬èª
        'en': 'en',           # è‹±èª
        'ru': 'ru',           # ãƒ­ã‚·ã‚¢èª
        'uz': 'uz_UZ',        # ã‚¦ã‚ºãƒ™ã‚¯èª
        'zh': 'zh_CN',        # ä¸­å›½èª(ç°¡ä½“å­—)
        'ko': 'ko_KR',        # éŸ“å›½èª
        'tr': 'tr_TR'         # ãƒˆãƒ«ã‚³èª
    }
    
    # ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—å®šç¾©
    ACF_FIELD_TYPES = {
        # ãƒ†ã‚­ã‚¹ãƒˆç³»
        'text': 'ãƒ†ã‚­ã‚¹ãƒˆ(1è¡Œ)',
        'textarea': 'ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢(è¤‡æ•°è¡Œ)',
        'number': 'æ•°å€¤',
        'email': 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹',
        'url': 'URL',
        'password': 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰',
        
        # é¸æŠç³»
        'select': 'ã‚»ãƒ¬ã‚¯ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼',
        'checkbox': 'ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹',
        'radio': 'ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³',
        'true_false': 'çœŸå½å€¤',
        
        # æ—¥ä»˜æ™‚åˆ»ç³»
        'date_picker': 'æ—¥ä»˜é¸æŠ',
        'date_time_picker': 'æ—¥ä»˜æ™‚åˆ»é¸æŠ',
        'time_picker': 'æ™‚åˆ»é¸æŠ',
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ç³»
        'file': 'ãƒ•ã‚¡ã‚¤ãƒ«',
        'image': 'ç”»åƒ',
        'gallery': 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼',
        
        # ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç³»
        'post_object': 'æŠ•ç¨¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ',
        'relationship': 'ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—',
        'taxonomy': 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼',
        'user': 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
        
        # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç³»
        'repeater': 'ãƒªãƒ”ãƒ¼ã‚¿ãƒ¼',
        'flexible_content': 'ãƒ•ãƒ¬ã‚­ã‚·ãƒ–ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„',
        'group': 'ã‚°ãƒ«ãƒ¼ãƒ—',
        
        # ãã®ä»–
        'wysiwyg': 'WYSIWYGã‚¨ãƒ‡ã‚£ã‚¿',
        'oembed': 'oEmbed',
        'google_map': 'Googleãƒãƒƒãƒ—',
        'color_picker': 'ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼'
    }
    
    # WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®šç¾©
    WORDPRESS_PLUGINS = {
        # å¿…é ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³
        'required': [
            {
                'name': 'Advanced Custom Fields PRO',
                'slug': 'advanced-custom-fields-pro',
                'version': '6.2+',
                'purpose': 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç®¡ç†',
                'priority': 'critical'
            },
            {
                'name': 'Custom Post Type UI',
                'slug': 'custom-post-type-ui',
                'version': '1.15+',
                'purpose': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç®¡ç†',
                'priority': 'critical'
            },
            {
                'name': 'Polylang Pro',
                'slug': 'polylang-pro',
                'version': '3.5+',
                'purpose': 'å¤šè¨€èªå¯¾å¿œ',
                'priority': 'critical'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(æ¤œç´¢å¼·åŒ–)
        'search': [
            {
                'name': 'FacetWP',
                'slug': 'facetwp',
                'purpose': 'çµã‚Šè¾¼ã¿æ¤œç´¢',
                'priority': 'high'
            },
            {
                'name': 'Relevanssi',
                'slug': 'relevanssi',
                'purpose': 'æ¤œç´¢ç²¾åº¦å‘ä¸Š',
                'priority': 'high'
            },
            {
                'name': 'SearchWP',
                'slug': 'searchwp',
                'purpose': 'æ¤œç´¢æ©Ÿèƒ½å¼·åŒ–',
                'priority': 'medium'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†)
        'user_management': [
            {
                'name': 'User Role Editor',
                'slug': 'user-role-editor',
                'purpose': 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ç®¡ç†',
                'priority': 'high'
            },
            {
                'name': 'Members',
                'slug': 'members',
                'purpose': 'æ¨©é™ç®¡ç†',
                'priority': 'medium'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
        'security': [
            {
                'name': 'Wordfence Security',
                'slug': 'wordfence',
                'purpose': 'ç·åˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£',
                'priority': 'high'
            },
            {
                'name': 'iThemes Security',
                'slug': 'ithemes-security-pro',
                'purpose': 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–',
                'priority': 'medium'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹)
        'performance': [
            {
                'name': 'WP Rocket',
                'slug': 'wp-rocket',
                'purpose': 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»æœ€é©åŒ–',
                'priority': 'high'
            },
            {
                'name': 'Autoptimize',
                'slug': 'autoptimize',
                'purpose': 'CSS/JSæœ€é©åŒ–',
                'priority': 'medium'
            }
        ]
    }
    
    # M&Aæ¡ˆä»¶ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š
    MA_CASE_DEFAULT_FIELDS = {
        'case_id': {
            'type': 'text',
            'label': 'æ¡ˆä»¶ID',
            'required': True
        },
        'ma_scheme': {
            'type': 'select',
            'label': 'M&Aã‚¹ã‚­ãƒ¼ãƒ ',
            'choices': ['æ ªå¼è­²æ¸¡', 'äº‹æ¥­è­²æ¸¡', 'åˆä½µ', 'ä¼šç¤¾åˆ†å‰²'],
            'required': True
        },
        'desired_price': {
            'type': 'number',
            'label': 'å¸Œæœ›ä¾¡æ ¼',
            'min': 0,
            'step': 1000000,
            'required': False
        },
        'industry_category': {
            'type': 'taxonomy',
            'label': 'æ¥­ç¨®',
            'taxonomy': 'industry_category',
            'required': True
        },
        'region': {
            'type': 'taxonomy',
            'label': 'åœ°åŸŸ',
            'taxonomy': 'region',
            'required': True
        },
        'established_year': {
            'type': 'number',
            'label': 'è¨­ç«‹å¹´',
            'min': 1900,
            'max': 2025,
            'required': False
        },
        'employees': {
            'type': 'number',
            'label': 'å¾“æ¥­å“¡æ•°',
            'min': 0,
            'required': False
        },
        'annual_revenue': {
            'type': 'number',
            'label': 'å¹´å•†',
            'min': 0,
            'required': False
        },
        'annual_profit': {
            'type': 'number',
            'label': 'å¹´é–“åˆ©ç›Š',
            'required': False
        },
        'reason_for_sale': {
            'type': 'textarea',
            'label': 'å£²å´ç†ç”±',
            'required': False
        },
        'strengths': {
            'type': 'textarea',
            'label': 'å¼·ã¿',
            'required': False
        }
    }
    
    # FacetWPãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
    FACETWP_DEFAULT_FACETS = [
        {
            'name': 'æ¥­ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'checkboxes',
            'source': 'tax/industry_category',
            'label': 'æ¥­ç¨®ã§çµã‚Šè¾¼ã‚€'
        },
        {
            'name': 'ä¾¡æ ¼å¸¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'slider',
            'source': 'cf/desired_price',
            'label': 'å¸Œæœ›ä¾¡æ ¼',
            'min': 0,
            'max': 1000000000,
            'step': 10000000,
            'format': 'Â¥{value}'
        },
        {
            'name': 'åœ°åŸŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'dropdown',
            'source': 'tax/region',
            'label': 'åœ°åŸŸã§çµã‚Šè¾¼ã‚€'
        },
        {
            'name': 'å¾“æ¥­å“¡æ•°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'slider',
            'source': 'cf/employees',
            'label': 'å¾“æ¥­å“¡æ•°',
            'min': 0,
            'max': 1000,
            'step': 10
        }
    ]


# ============================================================================
# TaskRouter: ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘ã‚¯ãƒ©ã‚¹
# ============================================================================

class TaskRouter:
    """ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã†ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹
    
    ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã‚’è§£æã—ã¦ã€é©åˆ‡ãªã‚¿ã‚¤ãƒ—(M&A/è¨˜äº‹ç”Ÿæˆ/ãƒ¬ãƒ“ãƒ¥ãƒ¼/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã‚’åˆ¤å®šã™ã‚‹ã€‚
    """
    
    # M&Aé–¢é€£ã®å¼·åŠ›ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    MA_STRONG_KEYWORDS = [
        'custom post type', 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—', 'cpt',
        'acfè¨­å®š', 'acf', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', 'custom field',
        'taxonomy', 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼', 'ã‚«ãƒ†ã‚´ãƒªä½œæˆ',
        'm&aæ¡ˆä»¶', 'ma_case', 'ma case',
        'ä¼æ¥­æ¤œç´¢', 'æ¡ˆä»¶ç®¡ç†', 'æ¡ˆä»¶æŠ•ç¨¿',
        'facetwp', 'facet', 'çµã‚Šè¾¼ã¿æ¤œç´¢',
        'user role', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«', 'æ¨©é™ç®¡ç†'
    ]
    
    # è¨˜äº‹ç”Ÿæˆé–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    CONTENT_KEYWORDS = [
        'è¨˜äº‹ä½œæˆ', 'è¨˜äº‹åŸ·ç­†', 'article', 'content creation',
        'ã€æ—¥æœ¬èªã€‘', 'ã€è‹±èªã€‘', 'ã€ãƒ­ã‚·ã‚¢èªã€‘', 'ã€ã‚¦ã‚ºãƒ™ã‚¯èªã€‘',
        'ã€ä¸­å›½èªã€‘', 'ã€éŸ“å›½èªã€‘', 'ã€ãƒˆãƒ«ã‚³èªã€‘',
        'ãƒ–ãƒ­ã‚°', 'blog post', 'seoè¨˜äº‹'
    ]
    
    # è¨˜äº‹ç”Ÿæˆç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    CONTENT_AGENTS = [
        'writer', 'writer_ja', 'writer_en', 'writer_ru',
        'writer_uz', 'writer_zh', 'writer_ko', 'writer_tr',
        'content'
    ]
    
    # M&Aé–¢é€£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚­ãƒ¼
    MA_PARAMETER_KEYS = [
        'cpt_slug', 'cpt_labels', 'cpt_supports',
        'acf_field_group_name', 'acf_fields', 'acf_location_rules',
        'taxonomy_slug', 'taxonomy_labels', 'taxonomy_post_types',
        'facets', 'role_slug', 'role_name'
    ]
    
    # è¨˜äº‹ç”Ÿæˆé–¢é€£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚­ãƒ¼
    CONTENT_PARAMETER_KEYS = [
        'language', 'polylang_lang', 'seo_keywords',
        'target_audience', 'target_url', 'article_type'
    ]
    
    @staticmethod
    def determine_task_type(task: dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            'ma' - M&A/ä¼æ¥­æ¤œç´¢ã‚¿ã‚¹ã‚¯
            'content' - è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯
            'review' - ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯
            'default' - ãã®ä»–ã®ã‚¿ã‚¹ã‚¯
        """
        description = task.get('description', '').lower()
        agent = task.get('required_role', '').lower()
        parameters = task.get('parameters', {})
        
        # 1. ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®åˆ¤å®š(æœ€å„ªå…ˆ)
        if agent == 'review' or 'review_target_task_id' in parameters:
            return 'review'
        
        # 2. M&Aé–¢é€£ã‚¿ã‚¹ã‚¯ã®åˆ¤å®š
        # 2-1. å¼·åŠ›ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°
        if any(keyword in description for keyword in TaskRouter.MA_STRONG_KEYWORDS):
            logger.debug(f"M&Aã‚¿ã‚¹ã‚¯åˆ¤å®š: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ")
            return 'ma'
        
        # 2-2. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆ¤å®š
        if any(key in parameters for key in TaskRouter.MA_PARAMETER_KEYS):
            logger.debug(f"M&Aã‚¿ã‚¹ã‚¯åˆ¤å®š: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒƒãƒ")
            return 'ma'
        
        # 2-3. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨èª¬æ˜ã®çµ„ã¿åˆã‚ã›
        if agent in ['wordpress', 'plugin']:
            # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ç‰¹å®šã®æ©Ÿèƒ½
            if any(word in description for word in ['è¨­å®š', 'ä½œæˆ', 'setup', 'configure']):
                logger.debug(f"M&Aã‚¿ã‚¹ã‚¯åˆ¤å®š: WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ+è¨­å®š")
                return 'ma'
        
        # 3. è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã®åˆ¤å®š
        # 3-1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¤å®š(æœ€ã‚‚ç¢ºå®Ÿ)
        if agent in TaskRouter.CONTENT_AGENTS:
            logger.debug(f"è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯åˆ¤å®š: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒãƒƒãƒ")
            return 'content'
        
        # 3-2. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆ¤å®š
        if any(key in parameters for key in TaskRouter.CONTENT_PARAMETER_KEYS):
            logger.debug(f"è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯åˆ¤å®š: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒƒãƒ")
            return 'content'
        
        # 3-3. ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ¤å®š
        if any(keyword in description for keyword in TaskRouter.CONTENT_KEYWORDS):
            logger.debug(f"è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯åˆ¤å®š: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ")
            return 'content'
        
        # 4. ãã®ä»–ã®ã‚¿ã‚¹ã‚¯
        logger.debug(f"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¹ã‚¯åˆ¤å®š")
        return 'default'
    
    @staticmethod
    def is_ma_task(task: dict) -> bool:
        """M&Aé–¢é€£ã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            M&Aã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        return TaskRouter.determine_task_type(task) == 'ma'
    
    @staticmethod
    def is_content_task(task: dict) -> bool:
        """è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        return TaskRouter.determine_task_type(task) == 'content'
    
    @staticmethod
    def is_review_task(task: dict) -> bool:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        return TaskRouter.determine_task_type(task) == 'review'


# ============================================================================
# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆ
# ============================================================================

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
wp_config = WordPressConfig()
task_router = TaskRouter()


# ============================================================================
# PluginNameExtractor: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åæŠ½å‡ºã‚¯ãƒ©ã‚¹
# ============================================================================

class PluginNameExtractor:
    """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º"""

    @staticmethod
    def extract(description: str) -> str:
        """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º
        
        Args:
            description: ã‚¿ã‚¹ã‚¯èª¬æ˜æ–‡
            
        Returns:
            æŠ½å‡ºã•ã‚ŒãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³å
        """
        # ã€Œã€ã€ã€ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã‚’æŠ½å‡º
        match = re.search(r'[ã€Œã€](.+?)[ã€ã€]', description)
        if match:
            return match.group(1)
        
        # è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯èª¬æ˜ã®å…ˆé ­50æ–‡å­—ã‚’è¿”ã™
        return description[:50]


# ============================================================================
# HTMLCleaner: HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã‚¯ãƒ©ã‚¹
# ============================================================================

class HTMLCleaner:
    """HTMLè¨˜äº‹ã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    
    WordPressæŠ•ç¨¿ç”¨ã«HTMLã‚’æœ€é©åŒ–ãƒ»ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã€‚
    - ä¸æ­£ãªãƒã‚¹ãƒˆã®ä¿®æ­£
    - WordPressã‚¯ãƒ©ã‚¹ã®è¿½åŠ 
    - Gutenbergãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œ
    - ã‚¿ã‚¤ãƒˆãƒ«ãƒ»æœ¬æ–‡ã®åˆ†é›¢
    """
        
    @staticmethod
    def clean_html_content(html_content: str) -> str:
        """HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚° - WordPressç”¨ã«æœ€é©åŒ–
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸHTML
        """
        try:
            logger.info("WordPressç”¨ã«HTMLã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ä¸­...")
            
            # åŸºæœ¬çš„ãªã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
            cleaned = html_content
            
            # 1. ä¸æ­£ãªãƒã‚¹ãƒˆã‚’ä¿®æ­£
            cleaned = re.sub(r'<p>\s*<div', '<div', cleaned)
            cleaned = re.sub(r'</div>\s*</p>', '</div>', cleaned)
            cleaned = re.sub(r'<p>\s*</p>', '', cleaned)
            
            # 2. é©åˆ‡ãªæ”¹è¡Œã‚’è¿½åŠ (èª­ã¿ã‚„ã™ã•ã®ãŸã‚)
            cleaned = re.sub(r'></(h1|h2|h3|h4|h5|h6|p|div|section|article)>', r'></\1>\n\n', cleaned)
            cleaned = re.sub(r'<(h1|h2|h3|h4|h5|h6|p|div|section|article)([^>]*)>', r'<\1\2>\n', cleaned)
            
            # 3. é€£ç¶šã™ã‚‹ç©ºç™½ã‚’å˜ä¸€ã‚¹ãƒšãƒ¼ã‚¹ã«
            cleaned = re.sub(r'\s+', ' ', cleaned)
            
            # 4. ã‚¿ã‚°é–“ã®ç©ºç™½ã‚’æ­£è¦åŒ–
            cleaned = re.sub(r'>\s+<', '> <', cleaned)
            
            # 5. WordPressç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            cleaned = HTMLCleaner._add_wordpress_classes(cleaned)
            
            # 6. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãªæ§‹é€ ã‚’ç¢ºèª
            lines = cleaned.split('\n')
            cleaned_lines = []
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                    
                # æ˜ã‚‰ã‹ã«ä¸æ­£ãªè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
                if line in ['<p><div', '</div></p>']:
                    continue
                    
                cleaned_lines.append(line)
            
            cleaned = '\n'.join(cleaned_lines)
            
            logger.info(f"HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°å®Œäº†: {len(html_content)} â†’ {len(cleaned)}æ–‡å­—")
            return cleaned
            
        except Exception as e:
            logger.error(f"HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
    
    @staticmethod
    def _add_wordpress_classes(html_content: str) -> str:
        """WordPressç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ã—ã¦ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            WordPressã‚¯ãƒ©ã‚¹ãŒè¿½åŠ ã•ã‚ŒãŸHTML
        """
        try:
            # è¦‹å‡ºã—ã«WordPressã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            html_content = re.sub(r'<h1([^>]*)>', r'<h1\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h2([^>]*)>', r'<h2\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h3([^>]*)>', r'<h3\1 class="wp-block-heading has-medium-font-size">', html_content)
            
            # æ®µè½ã«ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            html_content = re.sub(r'<p([^>]*)>', r'<p\1 class="wp-block-paragraph">', html_content)
            
            # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            html_content = re.sub(r'<section([^>]*)>', r'<section\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<article([^>]*)>', r'<article\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<div class="article-meta"', r'<div class="wp-block-group article-meta"', html_content)
            html_content = re.sub(r'<div class="intro"', r'<div class="wp-block-group intro"', html_content)
            html_content = re.sub(r'<div class="main-content"', r'<div class="wp-block-group main-content"', html_content)
            
            return html_content
            
        except Exception as e:
            logger.error(f"WordPressã‚¯ãƒ©ã‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
        
    @staticmethod
    def validate_html_structure(html_content: str) -> bool:
        """HTMLæ§‹é€ ã®åŸºæœ¬çš„ãªæ¤œè¨¼
        
        Args:
            html_content: æ¤œè¨¼ã™ã‚‹HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            æ§‹é€ ãŒæ­£ã—ã„å ´åˆTrue
        """
        try:
            # åŸºæœ¬çš„ãªã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
            open_tags = len(re.findall(r'<(\w+)[^>]*>', html_content))
            close_tags = len(re.findall(r'</(\w+)>', html_content))
                
            # divã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ç‰¹åˆ¥ã«ãƒã‚§ãƒƒã‚¯
            div_open = html_content.count('<div')
            div_close = html_content.count('</div>')
                
            logger.info(f"HTMLæ§‹é€ æ¤œè¨¼: ã‚¿ã‚°{open_tags}/{close_tags}, div{div_open}/{div_close}")
                
            # divã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ã‚‹ã‹
            if div_open != div_close:
                logger.warning(f"divã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ã¾ã›ã‚“: {div_open} != {div_close}")
                return False
                    
            return True
                
        except Exception as e:
            logger.error(f"HTMLæ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False
        
    @staticmethod
    def extract_title_from_html(html_content: str) -> Tuple[str, str]:
        """HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            (ã‚¿ã‚¤ãƒˆãƒ«, ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸHTMLæœ¬æ–‡)ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            logger.info("HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºä¸­...")
                
            # è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¤œç´¢
            title_patterns = [
                r'<h1[^>]*>(.*?)</h1>',
                r'<title[^>]*>(.*?)</title>',
                r'<h2[^>]*>(.*?)</h2>',
                r'<h3[^>]*>(.*?)</h3>'
            ]
                
            for pattern in title_patterns:
                match = re.search(pattern, html_content, re.IGNORECASE | re.DOTALL)
                if match:
                    title_html = match.group(1)
                    # HTMLã‚¿ã‚°ã‚’é™¤å»ã—ã¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’å–å¾—
                    title = re.sub(r'<[^>]+>', '', title_html).strip()
                        
                    if title and len(title) > 5:  # æœ€ä½5æ–‡å­—ä»¥ä¸Š
                        logger.info(f"âœ… HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºæˆåŠŸ: {title}")
                            
                        # ã‚¿ã‚¤ãƒˆãƒ«éƒ¨åˆ†ã‚’é™¤å»ã—ãŸæœ¬æ–‡ã‚’ä½œæˆ
                        body = re.sub(pattern, '', html_content, flags=re.IGNORECASE | re.DOTALL)
                        body = body.strip()
                            
                        # æœ¬æ–‡ã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
                        body = HTMLCleaner.clean_html_content(body)
                            
                        return title, body
                
            logger.warning("âŒ HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
            return "ã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜", HTMLCleaner.clean_html_content(html_content)
                
        except Exception as e:
            logger.error(f"HTMLã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return "ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºã‚¨ãƒ©ãƒ¼", html_content
        
    @staticmethod
    def prepare_html_for_wordpress(html_content: str) -> Tuple[str, str]:
        """WordPressç”¨ã«HTMLã‚’æº–å‚™(æ”¹å–„ç‰ˆ)
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            (ã‚¿ã‚¤ãƒˆãƒ«, WordPressç”¨HTMLæœ¬æ–‡)ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            logger.info("WordPressç”¨ã«HTMLã‚’æº–å‚™ä¸­...")
            
            # ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢
            title, body = HTMLCleaner.extract_title_from_html(html_content)
            
            # HTMLã‚’WordPressç”¨ã«æœ€é©åŒ–
            wp_html = HTMLCleaner._optimize_for_wordpress_gutenberg(body)
            
            logger.info(f"âœ… WordPressç”¨HTMLæº–å‚™å®Œäº†: ã‚¿ã‚¤ãƒˆãƒ«='{title}', æœ¬æ–‡={len(wp_html)}æ–‡å­—")
            return title, wp_html
            
        except Exception as e:
            logger.error(f"WordPressç”¨HTMLæº–å‚™ã‚¨ãƒ©ãƒ¼: {e}")
            return "HTMLå‡¦ç†ã‚¨ãƒ©ãƒ¼", html_content
        
    @staticmethod
    def _optimize_for_wordpress(html_content: str) -> str:
        """WordPressç”¨ã«HTMLã‚’æœ€é©åŒ–
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            æœ€é©åŒ–ã•ã‚ŒãŸHTML
        """
        try:
            optimized = html_content
                
            # 1. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãªã‚¿ã‚°ã‚’ç¶­æŒ
            # 2. ä¸æ­£ãªãƒã‚¹ãƒˆã‚’ä¿®æ­£
            optimized = re.sub(r'<p>\s*<(div|section|article)', r'<\1', optimized)
            optimized = re.sub(r'</(div|section|article)>\s*</p>', r'</\1>', optimized)
                
            # 3. ç©ºã®æ®µè½ã‚’å‰Šé™¤
            optimized = re.sub(r'<p>\s*</p>', '', optimized)
                
            # 4. é€£ç¶šã™ã‚‹æ”¹è¡Œã‚’æ•´ç†
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
                
            # 5. åŸºæœ¬çš„ãªHTMLæ§‹é€ ã‚’ç¢ºä¿
            if not optimized.strip().startswith('<'):
                optimized = f'<div class="article-content">\n{optimized}\n</div>'
                
            return optimized
                
        except Exception as e:
            logger.error(f"HTMLæœ€é©åŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
    
    @staticmethod
    def _optimize_for_wordpress_gutenberg(html_content: str) -> str:
        """Gutenbergã‚¨ãƒ‡ã‚£ã‚¿ç”¨ã«HTMLã‚’æœ€é©åŒ–
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            Gutenbergæœ€é©åŒ–ã•ã‚ŒãŸHTML
        """
        try:
            # ã¾ãšåŸºæœ¬ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
            optimized = HTMLCleaner.clean_html_content(html_content)
            
            # Gutenbergãƒ–ãƒ­ãƒƒã‚¯ç”¨ã®æ§‹é€ ã‚’è¿½åŠ 
            optimized = HTMLCleaner._wrap_in_gutenberg_blocks(optimized)
            
            # æœ€çµ‚çš„ãªæ”¹è¡Œèª¿æ•´
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
            optimized = optimized.strip()
            
            return optimized
            
        except Exception as e:
            logger.error(f"Gutenbergæœ€é©åŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
    
    @staticmethod
    def _wrap_in_gutenberg_blocks(html_content: str) -> str:
        """
        HTMLã‚’Gutenbergãƒ–ãƒ­ãƒƒã‚¯ã§ãƒ©ãƒƒãƒ—
        """
        try:
            blocks = []
            lines = html_content.split('\n')
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # è¦‹å‡ºã—ãƒ–ãƒ­ãƒƒã‚¯
                if line.startswith('<h1') or line.startswith('<h2') or line.startswith('<h3'):
                    blocks.append(f'<!-- wp:heading -->\n{line}\n<!-- /wp:heading -->')
                
                # æ®µè½ãƒ–ãƒ­ãƒƒã‚¯
                elif line.startswith('<p'):
                    blocks.append(f'<!-- wp:paragraph -->\n{line}\n<!-- /wp:paragraph -->')
                
                # ã‚°ãƒ«ãƒ¼ãƒ—ãƒ–ãƒ­ãƒƒã‚¯(ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€è¨˜äº‹ãƒ¡ã‚¿ãªã©)
                elif line.startswith('<section') or line.startswith('<article') or line.startswith('<div class="wp-block-group"'):
                    if line.startswith('</section') or line.startswith('</article') or line.startswith('</div'):
                        blocks.append(line)
                    else:
                        blocks.append(f'<!-- wp:group -->\n{line}')
                
                # ãã®ä»–ã®è¦ç´ 
                else:
                    blocks.append(line)
            
            # é–‰ã˜ã‚¿ã‚°ã®å‡¦ç†
            result = []
            for block in blocks:
                if any(tag in block for tag in ['</section>', '</article>', '</div>']):
                    result.append(f'{block}\n<!-- /wp:group -->')
                else:
                    result.append(block)
            
            return '\n\n'.join(result)
            
        except Exception as e:
            logger.error(f"Gutenbergãƒ–ãƒ­ãƒƒã‚¯ãƒ©ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
        
    @staticmethod
    def is_valid_html(html_content: str) -> bool:
        """
        HTMLãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
        """
        try:
            # åŸºæœ¬çš„ãªãƒã‚§ãƒƒã‚¯
            if not html_content or len(html_content.strip()) < 10:
                return False
                
            # HTMLã‚¿ã‚°ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯
            if '<' not in html_content or '>' not in html_content:
                return False
                
            # åŸºæœ¬çš„ãªã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
            return HTMLCleaner.validate_html_structure(html_content)
                
        except Exception as e:
            logger.error(f"HTMLæœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
            return False