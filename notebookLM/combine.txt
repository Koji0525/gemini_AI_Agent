#__init__.py
﻿# data_models/__init__.py
"""データモデルパッケージ"""
from .data_models import (
    ErrorSeverity,
    ErrorCategory,
    ErrorContextModel,
    BugFixTask,
    FixResult
)
__all__ = ['ErrorSeverity', 'ErrorCategory', 'ErrorContextModel', 'BugFixTask', 'FixResult']
__version__ = '1.0.0'

#auto_fix_agent.py
# auto_fix_agent.py
import asyncio
import ast
import tokenize
import logging
from pathlib import Path
from typing import Dict, List, Optional
import difflib

logger = logging.getLogger(__name__)

class AutoFixAgent:
    """自動修正エージェント"""
    
    FIX_SYSTEM_PROMPT = """あなたは優秀なPythonデバッグアシスタントです。

【あなたの役割】
- コマンド実行エラーを分析する
- 具体的な修正コードを提案する
- 修正の理由を説明する
- 完全な修正ファイルを提供する

【出力形式】
以下のJSON形式で出力してください：

```json
{
  "analysis": "エラーの原因分析",
  "fix_reason": "修正の理由",
  "fixed_code": "修正後の完全なコード",
  "changes": [
    {
      "file": "修正ファイル名",
      "line": 行番号,
      "original": "元のコード",
      "fixed": "修正後のコード",
      "reason": "修正理由"
    }
  ],
  "confidence": 0.8,
  "next_step": "次の実行コマンド"
}"""

#brower_cookie_and_session.py
# browser_cookie_and_session.py
"""クッキーとセッション管理クラス"""
import json
import time
from pathlib import Path
from typing import Optional, Dict, List
from playwright.async_api import BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class CookieSessionManager:
    """クッキーとセッションの管理を担当"""
    
    def __init__(self, context: BrowserContext, cookies_file: Path):
        self.context = context
        self.cookies_file = cookies_file
    
    async def save_cookies(self) -> None:
        """クッキーを保存（強化版）"""
        try:
            if not self.context or not self.cookies_file:
                logger.warning("クッキー保存: コンテキストまたはファイルパスがありません")
                return
            
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("保存するクッキーがありません")
                return
                
            with open(self.cookies_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"✅ クッキーを保存しました: {len(cookies)}個のクッキー")
            
        except Exception as e:
            ErrorHandler.log_error(e, "クッキー保存")
            logger.warning("クッキー保存に失敗しましたが続行します")

    async def load_cookies(self) -> bool:
        """クッキーを読み込み（強化版）"""
        try:
            if not self.cookies_file or not self.cookies_file.exists():
                logger.warning("クッキーファイルが存在しません")
                return False
                
            if not self.context:
                logger.warning("コンテキストが初期化されていません")
                return False
                
            with open(self.cookies_file, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
            
            if not cookies:
                logger.warning("クッキーファイルが空です")
                return False
                
            current_url = "https://gemini.google.com"  # デフォルトURL
            domain_cookies = []
            
            for cookie in cookies:
                if 'domain' in cookie and cookie['domain'].startswith('.'):
                    cookie['domain'] = cookie['domain'][1:]
                
                if 'expires' in cookie and cookie['expires'] < time.time():
                    continue
                    
                domain_cookies.append(cookie)
            
            if domain_cookies:
                await self.context.add_cookies(domain_cookies)
                logger.info(f"✅ クッキーを読み込みました: {len(domain_cookies)}個")
                return True
            else:
                logger.warning("有効なクッキーがありません")
                return False
                
        except Exception as e:
            ErrorHandler.log_error(e, "クッキー読み込み")
            return False
    
    async def check_google_login_status(self) -> bool:
        """Googleログイン状態をチェック（ページが必要な場合に実装）"""
        # このメソッドはページコンテキストが必要なため、
        # 必要に応じてAIChatAgentに移動またはここで実装
        logger.info("Googleログイン状態チェック（実装予定）")
        return False

#browser_ai_chat_agent.py
# browser_ai_chat_agent.py
"""AIチャットエージェントクラス（Gemini/DeepSeek対応）"""
import asyncio
import time
import json
import re
from datetime import datetime
from typing import Optional, Dict
from playwright.async_api import Page
import logging

from config_utils import ErrorHandler, FileNameGenerator

logger = logging.getLogger(__name__)

class AIChatAgent:
    """AIサービス（Gemini/DeepSeek）との対話を担当"""
    
    def __init__(self, page: Page, service: str = "google", credentials: Dict = None):
        self.page = page
        self.service = service.lower()
        self.credentials = credentials or {}
    
    async def navigate_to_gemini(self) -> None:
        """Geminiサイトにアクセス（クラッシュ検知強化版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            
            logger.info("Geminiサイトにアクセス中...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiサイトへのアクセス試行 {attempt}/{max_attempts}")
                    
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)
                    
                    logger.info("✅ Geminiサイトへのアクセスが成功しました")
                    break
                    
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました")
                        logger.error("手動でページをリロードしてください")
                        input("Geminiページが読み込まれたら、Enterキーを押してください: ")
                    else:
                        logger.info("5秒後に再試行します...")
                        await asyncio.sleep(5)
            
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            
            await self.handle_welcome_screens()
            logger.info("✅ Geminiサイトの準備が完了しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiアクセス")
            logger.info("手動でGeminiページを開いてください")
            input("準備完了後、Enterキーを押してください: ")
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekサイトにアクセス（Cloudflareボット検証対応版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            logger.info("DeepSeekサイトにアクセス中...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"DeepSeekサイトへのアクセス試行 {attempt}/{max_attempts}")
                    await self.page.goto("https://chat.deepseek.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(5000)
                    logger.info("DeepSeekサイトへのアクセスが成功しました")
                    break
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました。手動でページをリロードしてください")
                        input("DeepSeekページが読み込まれたら、Enterキーを押してください: ")
                    else:
                        logger.info("5秒後に再試行します...")
                        await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            
            # Cloudflareボット検証チェック
            logger.info("Cloudflareボット検証をチェック中...")
            cloudflare_check = await self.page.evaluate('''
                () => {
                    const body = document.body.innerText || '';
                    if (body.includes('Verifying you are human') || 
                        body.includes('あなたがボットではないことを確認') ||
                        body.includes('Just a moment') ||
                        body.includes('Checking your browser')) {
                        return true;
                    }
                    return false;
                }
            ''')
            
            if cloudflare_check:
                logger.warning("⚠️ Cloudflareボット検証が検出されました")
                logger.info("ブラウザで自動的にチェックが完了するまで待機します...")
                
                start_time = time.time()
                while time.time() - start_time < 60:
                    await self.page.wait_for_timeout(3000)
                    
                    still_checking = await self.page.evaluate('''
                        () => {
                            const body = document.body.innerText || '';
                            if (body.includes('Verifying you are human') || 
                                body.includes('あなたがボットではないことを確認') ||
                                body.includes('Just a moment') ||
                                body.includes('Checking your browser')) {
                                return true;
                            }
                            return false;
                        }
                    ''')
                    
                    if not still_checking:
                        logger.info("✅ Cloudflare検証が完了しました")
                        break
                    
                    elapsed = int(time.time() - start_time)
                    if elapsed % 10 == 0:
                        logger.info(f"待機中... {elapsed}秒経過")
                
                await self.page.wait_for_timeout(3000)
                current_url = self.page.url
                logger.info(f"検証後のURL: {current_url}")
            
            # ログインページにいるかチェック
            if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                logger.info("\n" + "="*60)
                logger.info("⚠️ DeepSeekへのログインが必要です")
                logger.info("="*60)
                logger.info("")
                logger.info("📌 ログイン手順：")
                logger.info("1. ブラウザで「Log in with Google」ボタンをクリック")
                logger.info("2. Googleアカウントを選択（または入力）")
                logger.info(f"   使用するアカウント: {self.credentials.get('email', 'B2セルのGoogle ID')}")
                logger.info("3. ログイン完了を待つ")
                logger.info("4. チャット画面が表示されたら、このコンソールに戻ってEnterキーを押す")
                logger.info("")
                logger.info("💡 ヒント：")
                logger.info("  - 「Chrome は自動テスト...」メッセージは無視してください")
                logger.info("  - Googleログインは通常通り動作します")
                logger.info("  - 2回目以降はCookieで自動ログインされます")
                logger.info("="*60)
                
                input("\n✅ ログイン完了後、Enterキーを押してください: ")
                
                await self.page.wait_for_timeout(2000)
                current_url = self.page.url
                logger.info(f"ログイン後のURL: {current_url}")
                
                if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                    logger.warning("⚠️ まだログインページにいます")
                    logger.info("もう一度「Log in with Google」をクリックしてください")
                    input("完了後、Enterキーを押してください: ")
                    await self.page.wait_for_timeout(2000)
            
            # チャット画面に到達できているか確認
            await self.page.wait_for_timeout(3000)
            chat_ready = await self.page.evaluate('''
                () => {
                    const inputs = document.querySelectorAll('textarea, input[type="text"]');
                    return inputs.length > 0;
                }
            ''')
            
            if not chat_ready:
                logger.warning("⚠️ チャット画面が見つかりません")
                logger.info("ブラウザでチャット画面が表示されるまで待機してください")
                input("\n✅ チャット画面が表示されたら、Enterキーを押してください: ")
            else:
                logger.info("✅ チャット画面を確認しました")
            
            logger.info("✅ DeepSeekサイトの準備が完了しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "DeepSeekアクセス")
            logger.info("手動でDeepSeekページを開いてください")
            input("準備完了後、Enterキーを押してください: ")
    
    async def handle_welcome_screens(self) -> None:
        """利用規約やウェルカム画面を処理"""
        try:
            if not self.page:
                return
            logger.info("ウェルカム画面やポップアップを確認中...")
            continue_buttons = [
                'text=続行', 'text=開始', 'text=同意', 'text=Continue',
                'text=Get started', 'text=Agree', 'text=Got it', 'text=OK',
                '[data-testid="continue-button"]'
            ]
            start_time = time.time()
            found_buttons = 0
            while time.time() - start_time < 10 and found_buttons < 3:
                for button_selector in continue_buttons:
                    try:
                        button = await self.page.query_selector(button_selector)
                        if button and await button.is_visible():
                            await button.click()
                            await self.page.wait_for_timeout(2000)
                            logger.info(f"ボタンをクリックしました: {button_selector}")
                            found_buttons += 1
                            break
                    except Exception:
                        continue
                await self.page.wait_for_timeout(1000)
            if found_buttons > 0:
                logger.info(f"{found_buttons}個のウェルカム画面を処理しました")
            else:
                logger.info("ウェルカム画面は見つかりませんでした（正常）")
        except Exception as e:
            ErrorHandler.log_error(e, "ウェルカム画面処理")
    
    async def ensure_normal_chat_mode(self) -> None:
        """通常のチャットモードであることを確認（Storybookを回避）- 強化版"""
        try:
            if not self.page:
                return
            logger.info("チャットモードを確認中...")
            current_url = self.page.url
            if 'storybook' in current_url.lower():
                logger.warning("StorybookのURLが検出されました。通常モードに戻します...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("通常のチャットモードに戻しました")
                return
            storybook_active = await self.page.evaluate('''
                () => {
                    const buttons = document.querySelectorAll('button');
                    for (const btn of buttons) {
                        const text = btn.textContent || '';
                        const ariaLabel = btn.getAttribute('aria-label') || '';
                        if ((text.includes('Storybook') || ariaLabel.includes('Storybook')) &&
                            (btn.getAttribute('aria-pressed') === 'true' || 
                             btn.classList.contains('active') ||
                             btn.classList.contains('selected'))) {
                            return true;
                        }
                    }
                    return false;
                }
            ''')
            if storybook_active:
                logger.warning("Storybookモードが検出されました。通常モードに戻します...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("通常のチャットモードに戻しました")
            else:
                logger.info("通常のチャットモードです")
        except Exception as e:
            ErrorHandler.log_error(e, "チャットモード確認")
    
    async def send_prompt(self, prompt: str) -> None:
        """プロンプトを入力して送信（サービス自動判別版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            await self.ensure_normal_chat_mode()
            logger.info(f"プロンプトを送信中: {prompt[:50]}...")
            
            if self.service == "deepseek":
                await self.send_prompt_deepseek(prompt)
            else:
                await self.send_prompt_gemini(prompt)
                
        except Exception as e:
            ErrorHandler.log_error(e, "プロンプト送信")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_gemini(self, prompt: str) -> None:
        """Geminiでプロンプトを送信(ポップアップ対応版)"""
        try:
            # 入力欄を探す
            input_selectors = [
                'textarea[placeholder*="メッセージを Gemini に送信"]',
                'textarea[placeholder*="Send a message to Gemini"]',
                'div[contenteditable="true"][role="textbox"]',
                'textarea[data-testid="message-input"]',
                'div.ql-editor[contenteditable="true"]',
                'textarea.ql-editor',
                '[data-message-input]',
                'div[contenteditable="true"][aria-label*="メッセージ"]',
                'div[contenteditable="true"][aria-label*="message"]',
                'div[contenteditable="true"][tabindex="0"]',
                'textarea[aria-label*="Gemini"]',
                '[data-testid="input-area"] textarea',
                '[data-testid="input-area"] div[contenteditable="true"]',
            ]
            
            input_element = None
            for selector in input_selectors:
                try:
                    await self.page.wait_for_selector(selector, timeout=5000)
                    input_element = await self.page.query_selector(selector)
                    if input_element:
                        logger.info(f"入力欄を発見: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                await self.page.screenshot(path="debug_input_not_found.png")
                raise Exception("入力欄が見つかりません")
            
            # ポップアップ・オーバーレイを閉じる処理
            try:
                # 1. メール配信登録ポップアップの「後で」ボタンをクリック
                later_button_selectors = [
                    'button:has-text("後で")',
                    'button:has-text("Later")',
                    '[aria-label*="後で"]',
                    '[aria-label*="Later"]'
                ]
                
                for selector in later_button_selectors:
                    try:
                        later_button = await self.page.query_selector(selector)
                        if later_button and await later_button.is_visible():
                            await later_button.click()
                            await self.page.wait_for_timeout(1000)
                            logger.info("✅ メール配信ポップアップを閉じました")
                            break
                    except:
                        continue
                
                # 2. オーバーレイ全体を閉じる（バックドロップクリック）
                overlay_backdrop = await self.page.query_selector('.cdk-overlay-backdrop')
                if overlay_backdrop:
                    try:
                        await overlay_backdrop.click()
                        await self.page.wait_for_timeout(500)
                        logger.info("✅ オーバーレイを閉じました")
                    except:
                        pass
                
                # 3. Escキーでポップアップを閉じる（最終手段）
                await self.page.keyboard.press('Escape')
                await self.page.wait_for_timeout(500)
                
            except Exception as e:
                logger.debug(f"ポップアップ処理: {e}")
            
            # 入力欄をクリック
            await input_element.click()
            await self.page.wait_for_timeout(500)
            
            # 既存のテキストをクリア
            await self.page.keyboard.press("Control+a")
            await self.page.wait_for_timeout(500)
            
            # プロンプトを入力
            await input_element.fill(prompt)
            await self.page.wait_for_timeout(1500)
            
            # 送信ボタンをクリック
            send_selectors = [
                'button[data-testid="send-button"]',
                '[data-testid="send-button"]'
            ]
            
            sent = False
            for selector in send_selectors:
                try:
                    send_button = await self.page.query_selector(selector)
                    if send_button and await send_button.is_enabled():
                        await send_button.click()
                        logger.info("送信ボタンをクリックしました")
                        sent = True
                        break
                except:
                    continue
            
            if not sent:
                await input_element.press('Enter')
                logger.info("Enterキーで送信しました")
            
            await self.page.wait_for_timeout(3000)
            
        except Exception as e:
            ErrorHandler.log_error(e, "プロンプト送信")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_deepseek(self, prompt: str) -> None:
        """DeepSeekでプロンプトを送信（改善版）"""
        # まずスクリーンショットを撮って状態を確認
        debug_screenshot = f"debug_deepseek_before_input_{datetime.now().strftime('%H%M%S')}.png"
        try:
            await self.page.screenshot(path=debug_screenshot)
            logger.info(f"📸 入力前のスクリーンショット: {debug_screenshot}")
        except:
            pass
        
        # 複数の可能性のあるセレクタを試す
        input_selectors = [
            'textarea[placeholder*="Ask"]',
            'textarea[placeholder*="Type"]',
            'textarea[placeholder*="message"]',
            'textarea[placeholder*="メッセージ"]',
            'textarea[placeholder*="入力"]',
            'div[contenteditable="true"][role="textbox"]',
            'div[contenteditable="true"]',
            'textarea',
            'input[type="text"]',
        ]
        
        input_element = None
        used_selector = None
        
        # 各セレクタを順番に試す
        for selector in input_selectors:
            try:
                logger.info(f"入力欄を探索中: {selector}")
                element = await self.page.query_selector(selector)
                if element:
                    # 要素が見えているか確認
                    is_visible = await element.is_visible()
                    if is_visible:
                        input_element = element
                        used_selector = selector
                        logger.info(f"✅ 入力欄を発見: {selector}")
                        break
                    else:
                        logger.info(f"要素は存在するが非表示: {selector}")
            except Exception as e:
                logger.debug(f"セレクタ {selector} でエラー: {e}")
                continue
        
        if not input_element:
            # 全セレクタで失敗した場合
            await self.page.screenshot(path="debug_deepseek_input_not_found.png")
            logger.error("❌ DeepSeek入力欄が見つかりません")
            logger.error("以下を確認してください：")
            logger.error("1. ログインが完了していますか？")
            logger.error("2. チャット画面が表示されていますか？")
            logger.error("3. Cloudflareの検証は完了しましたか？")
            
            # ページのHTMLをデバッグ出力
            page_content = await self.page.evaluate('document.body.innerText')
            logger.info(f"ページ内容（先頭500文字）:\n{page_content[:500]}")
            
            # 手動介入を促す
            logger.info("\n手動で入力欄が見えるまで操作してください")
            input("入力欄が表示されたら、Enterキーを押してください: ")
            
            # 再度探す
            for selector in input_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element and await element.is_visible():
                        input_element = element
                        used_selector = selector
                        logger.info(f"✅ 入力欄を発見（2回目）: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                raise Exception("入力欄が見つかりません（2回目の試行後）")
        
        # 入力欄にフォーカス
        await input_element.click()
        await self.page.wait_for_timeout(500)
        
        # プロンプトを入力
        await input_element.fill(prompt)
        await self.page.wait_for_timeout(1500)
        
        # 送信ボタンを探す
        send_button = None
        send_selectors = [
            'button[type="submit"]',
            'button[aria-label*="Send"]',
            'button[aria-label*="送信"]',
            'button:has-text("送信")',
            'button:has-text("Send")',
            'button svg',  # アイコンボタン
        ]
        
        for selector in send_selectors:
            try:
                btn = await self.page.query_selector(selector)
                if btn and await btn.is_visible() and await btn.is_enabled():
                    send_button = btn
                    logger.info(f"送信ボタンを発見: {selector}")
                    break
            except:
                continue
        
        if send_button:
            await send_button.click()
            logger.info("✅ DeepSeek送信ボタンをクリックしました")
        else:
            # ボタンが見つからない場合はEnterキーで送信
            logger.info("送信ボタンが見つからないため、Enterキーで送信します")
            await input_element.press("Enter")
            logger.info("✅ Enterキーで送信しました")
        
        await self.page.wait_for_timeout(3000)
    
    async def wait_for_text_generation(self, max_wait: int = 120) -> bool:
        """テキスト生成完了まで待機"""
        try:
            if not self.page:
                return False
            logger.info("テキスト生成を待機中...")
            start_time = time.time()
            check_interval = 2
            await self.page.wait_for_timeout(5000)
            while time.time() - start_time < max_wait:
                await self.page.wait_for_timeout(check_interval * 1000)
                elapsed = int(time.time() - start_time)
                is_complete = await self.page.evaluate('''
                    () => {
                        const allButtons = document.querySelectorAll('button');
                        for (const btn of allButtons) {
                            const text = btn.textContent || '';
                            const ariaLabel = btn.getAttribute('aria-label') || '';
                            if (text.includes('再生成') || text.includes('Regenerate') ||
                                ariaLabel.includes('再生成') || ariaLabel.includes('Regenerate')) {
                                return true;
                            }
                        }
                        const sendButtons = document.querySelectorAll('[data-testid="send-button"], button[type="submit"]');
                        for (const btn of sendButtons) {
                            if (!btn.disabled && !btn.hasAttribute('disabled')) {
                                return true;
                            }
                        }
                        const loadingElements = document.querySelectorAll('[data-testid="loading"], .loading, .spinner');
                        if (loadingElements.length === 0) {
                            return true;
                        }
                        return false;
                    }
                ''')
                if is_complete:
                    logger.info(f"✅ テキスト生成完了を検出")
                    await self.page.wait_for_timeout(2000)
                    return True
                if elapsed % 10 == 0 and elapsed > 0:
                    logger.info(f"⏳ 待機中... {elapsed}秒経過")
            logger.warning(f"⏰ タイムアウト（{max_wait}秒）")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, "テキスト生成待機")
            return False
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """
        プロンプト送信と応答待機を一括処理（推奨インターフェース）
        
        Args:
            prompt: 送信するプロンプト
            max_wait: 最大待機時間（秒）
            
        Returns:
            bool: 成功時 True
        """
        try:
            # プロンプト送信
            await self.send_prompt(prompt)
            
            # 応答待機
            success = await self.wait_for_text_generation(max_wait)
            
            if success:
                logger.info("✅ プロンプト送信と応答待機が完了しました")
            else:
                logger.warning("⚠️ プロンプト送信は成功しましたが、応答待機がタイムアウトしました")
            
            return success
            
        except Exception as e:
            logger.error(f"❌ プロンプト送信と待機中にエラー: {e}")
            return False

    
    async def extract_latest_text_response(self) -> str:
        """最新のテキスト応答を抽出（サービス自動判別版）"""
        try:
            if self.service == "deepseek":
                return await self.extract_latest_text_response_deepseek()
            else:
                return await self.extract_latest_text_response_gemini()
        except Exception as e:
            ErrorHandler.log_error(e, "テキスト抽出")
            return None
    
    async def extract_latest_text_response_gemini(self) -> str:
        """Geminiの最新のテキスト応答を抽出（コード完全性検証ロジック修正版）"""
        try:
            logger.info("=" * 60)
            logger.info("★★★ Geminiテキスト抽出開始 ★★★")
            logger.info("=" * 60)
            
            all_results = {}
            
            # 方法1: モデルメッセージのデータ属性から取得
            try:
                method1_text = await self.page.evaluate('''() => {
                    const modelMessages = document.querySelectorAll('[data-message-author="model"]');
                    if (modelMessages.length === 0) return null;
                    
                    const latestMessage = modelMessages[modelMessages.length - 1];
                    return latestMessage.innerText || latestMessage.textContent || '';
                }''')
                all_results['方法1'] = method1_text
                logger.info(f"方法1結果: {len(method1_text) if method1_text else 0}文字")
            except Exception as e:
                logger.debug(f"方法1失敗: {e}")
                all_results['方法1'] = None

            # 方法2: マークダウンコンテンツから取得
            try:
                method2_text = await self.page.evaluate('''() => {
                    const markdownContainers = document.querySelectorAll('[class*="markdown"]');
                    if (markdownContainers.length === 0) return null;
                    
                    let longest = '';
                    for (const container of markdownContainers) {
                        const text = container.innerText || container.textContent || '';
                        if (text.length > longest.length) {
                            longest = text;
                        }
                    }
                    return longest;
                }''')
                all_results['方法2'] = method2_text
                logger.info(f"方法2結果: {len(method2_text) if method2_text else 0}文字")
            except Exception as e:
                logger.debug(f"方法2失敗: {e}")
                all_results['方法2'] = None

            # 方法3: メッセージクラスから取得
            try:
                method3_text = await self.page.evaluate('''() => {
                    const messages = document.querySelectorAll('[class*="message"]');
                    if (messages.length === 0) return null;
                    
                    let modelTexts = [];
                    for (const msg of messages) {
                        const text = msg.innerText || msg.textContent || '';
                        // ユーザーメッセージを除外（短いまたは特定のパターン）
                        if (text.length > 100 && 
                            !text.includes('あなたは経験豊富な') &&
                            !text.includes('【あなたの役割】') &&
                            !text.includes('【執筆依頼】')) {
                            modelTexts.push(text);
                        }
                    }
                    return modelTexts.length > 0 ? modelTexts[modelTexts.length - 1] : null;
                }''')
                all_results['方法3'] = method3_text
                logger.info(f"方法3結果: {len(method3_text) if method3_text else 0}文字")
            except Exception as e:
                logger.debug(f"方法3失敗: {e}")
                all_results['方法3'] = None
            
            # 優先順位で選択（コード完全性検証を緩和）
            priority_order = ['方法1', '方法2', '方法3']
            best_result = None
            best_method = None
            
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 100:
                    text = all_results[method]
                    
                    # プロンプトが混入していないか最終チェック
                    if ('あなたは経験豊富な' in text or 
                        '【あなたの役割】' in text or
                        '【執筆依頼】' in text):
                        logger.warning(f"{method}にプロンプトが混入 - スキップ")
                        continue
                    
                    # コードブロック検証（緩和版）
                    validation_result = self._validate_code_block_completeness_enhanced(text)
                    
                    if validation_result['is_complete']:
                        logger.info(f"✅ {method}: 完全な応答を検出")
                        best_result = text.strip()
                        best_method = method
                        break
                    else:
                        # 不完全でも長文の場合は警告を出して採用する
                        if len(text) > 1500:  # 長文の場合は許容
                            logger.warning(f"⚠️ {method}: 不完全だが長文のため採用 - {validation_result['reason']}")
                            best_result = text.strip()
                            best_method = method
                            break
                        else:
                            logger.warning(f"⚠️ {method}: 不完全な応答 - {validation_result['reason']}")
            
            if best_result:
                logger.info(f"\n🎯 採用: {best_method} ({len(best_result)}文字)")
                logger.info(f"先頭200文字:\n{best_result[:200]}")
                return best_result
            
            # すべて失敗した場合でも、最長のテキストを返す（最終手段）
            fallback_text = None
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 500:
                    fallback_text = all_results[method]
                    logger.warning(f"⚠️ フォールバック採用: {method} ({len(fallback_text)}文字)")
                    break
            
            if fallback_text:
                return fallback_text.strip()
            
            # 本当に何も取得できない場合
            logger.error("\n❌ 全方法失敗 - Geminiの応答が取得できませんでした")
            
            # デバッグ用: ページの構造を確認
            page_structure = await self.page.evaluate('''() => {
                return {
                    messageCount: document.querySelectorAll('[class*="message"]').length,
                    modelMessages: document.querySelectorAll('[data-message-author="model"]').length,
                    markdownContainers: document.querySelectorAll('[class*="markdown"]').length
                };
            }''')
            logger.info(f"ページ構造: {page_structure}")
            
            return None
                    
        except Exception as e:
            logger.error(f"❌ 抽出全体エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
        
    def _validate_code_block_completeness_enhanced(self, text: str) -> Dict:
        """
        コードブロックの完全性を検証(緩和版 - 専門文書・長文対応強化)
            
        Returns:
            Dict: {
                'is_complete': bool,
                'reason': str,
                'details': str,
                'incomplete_blocks': List[Dict]
            }
        """
        try:
            # コードブロック(```)のペアチェック(主要チェック)
            code_fence_pattern = r'```(\w+)?\n(.*?)```'
            code_blocks = re.findall(code_fence_pattern, text, re.DOTALL)
                
            # 開始タグのみで終了タグがないパターンを検出
            open_fences = re.findall(r'```(\w+)?(?![\s\S]*?```)', text, re.DOTALL)
                
            if open_fences:
                # 閉じられていないコードブロックを検出
                incomplete_blocks = []
                for lang in open_fences:
                    # 該当箇所のスニペットを取得
                    pattern = f'```{lang}' if lang else '```'
                    idx = text.find(pattern)
                    snippet = text[idx:idx+100] + '...' if idx != -1 else 'N/A'
                        
                    incomplete_blocks.append({
                        'type': f'code({lang})' if lang else 'code(unknown)',
                        'snippet': snippet
                    })
                    
                return {
                    'is_complete': False,
                    'reason': 'コードブロックが閉じられていません',
                    'details': f'{len(open_fences)}個の未閉じブロックを検出',
                    'incomplete_blocks': incomplete_blocks
                }
                
            # PHPコードの完全性チェック
            if '<?php' in text:
                php_blocks = re.findall(r'```php\n(.*?)```', text, re.DOTALL)
                for php_code in php_blocks:
                    # 関数定義の開始と終了の波括弧の数をチェック
                    open_braces = php_code.count('{')
                    close_braces = php_code.count('}')
                        
                    if open_braces > close_braces:
                        # 最後の10行を取得
                        last_lines = '\n'.join(php_code.split('\n')[-10:])
                            
                        return {
                            'is_complete': False,
                            'reason': 'PHPコードの波括弧が閉じられていません',
                            'details': f'開始: {open_braces}, 終了: {close_braces}',
                            'incomplete_blocks': [{
                                'type': 'php',
                                'snippet': f'...最後の10行:\n{last_lines}'
                            }]
                        }
                
            # JSONコードの完全性チェック
            json_blocks = re.findall(r'```json\n(.*?)```', text, re.DOTALL)
            for json_code in json_blocks:
                try:
                    json.loads(json_code)
                except json.JSONDecodeError as e:
                    return {
                        'is_complete': False,
                        'reason': 'JSONコードが不正です',
                        'details': f'JSONエラー: {str(e)}',
                        'incomplete_blocks': [{
                            'type': 'json',
                            'snippet': json_code[-200:] if len(json_code) > 200 else json_code
                        }]
                    }
                
            # ========================================
            # 🔧 Pydanticモデル定義の検証（新規追加）
            # ========================================
            if 'from pydantic import' in text or 'class ' in text and 'BaseModel' in text:
                # Pydanticモデル定義のクラス構造チェック
                pydantic_class_pattern = r'class\s+(\w+)\(BaseModel\):(.*?)(?=\nclass\s|\Z)'
                pydantic_classes = re.findall(pydantic_class_pattern, text, re.DOTALL)
                    
                for class_name, class_body in pydantic_classes:
                    # クラス本体が空でないか確認
                    if not class_body.strip():
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticモデル {class_name} の定義が空です',
                            'details': 'クラス本体にフィールド定義が必要',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': f'class {class_name}(BaseModel): ...'
                            }]
                        }
                        
                    # フィールド定義が少なくとも1つあるか確認
                    field_pattern = r'^\s+\w+:\s*\w+'
                    if not re.search(field_pattern, class_body, re.MULTILINE):
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticモデル {class_name} にフィールド定義がありません',
                            'details': 'モデルには少なくとも1つのフィールドが必要',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': class_body[:200]
                            }]
                        }
                
            # ========================================
            # 🔧 OpenAPIスキーマの検証（新規追加）
            # ========================================
            if 'openapi:' in text.lower() or '"openapi"' in text.lower():
                # OpenAPI/Swaggerスキーマの基本構造をチェック
                required_openapi_keys = ['openapi', 'info', 'paths']
                    
                # YAMLまたはJSON形式の検出
                if 'openapi:' in text:
                    # YAML形式の検証
                    for key in required_openapi_keys:
                        if f'{key}:' not in text:
                            return {
                                'is_complete': False,
                                'reason': f'OpenAPIスキーマに必須キー "{key}" がありません',
                                'details': 'OpenAPIスキーマには openapi, info, paths が必要',
                                'incomplete_blocks': [{
                                    'type': 'openapi_yaml',
                                    'snippet': text[:300]
                                }]
                            }
                else:
                    # JSON形式の検証
                    try:
                        # JSON抽出試行
                        json_match = re.search(r'\{.*\}', text, re.DOTALL)
                        if json_match:
                            openapi_json = json.loads(json_match.group(0))
                            for key in required_openapi_keys:
                                if key not in openapi_json:
                                    return {
                                        'is_complete': False,
                                        'reason': f'OpenAPIスキーマに必須キー "{key}" がありません',
                                        'details': 'OpenAPIスキーマには openapi, info, paths が必要',
                                        'incomplete_blocks': [{
                                            'type': 'openapi_json',
                                            'snippet': json_match.group(0)[:300]
                                        }]
                                    }
                    except (json.JSONDecodeError, AttributeError):
                        pass  # JSON形式でない場合はスキップ
                
            # ========================================
            # 🔧 文章の突然の終了チェックを大幅緩和（専門文書対応）
            # ========================================
            text_stripped = text.strip()
            if text_stripped:
                last_char = text_stripped[-1]
                    
                # 専門文書や技術文書の終了パターンを拡張
                japanese_section_endings = [
                    '項', '章', '目', '節', '条', '款', '点',  # 既存
                    '。', '）', ')', '}', ']', '`', '>', '"',  # 新規追加
                    '了', '成', '定', '明', '示', '用', '理'   # 専門用語末尾
                ]
                    
                # 厳格な終了文字リスト（これらで終わればOK）
                strict_end_chars = ['.', '。', '!', '!', '?', '?', '`', '}', ']', ')']
                    
                if (last_char not in strict_end_chars and 
                    last_char not in japanese_section_endings and
                    not text_stripped.endswith('```')):
                        
                    # ========================================
                    # 🔧 長文・専門文書の場合は大幅に緩和（新ロジック）
                    # ========================================
                        
                    # 条件1: 3000文字以上の超長文は終了文字をチェックしない
                    if len(text_stripped) > 3000:
                        logger.info(f"✅ 超長文({len(text_stripped)}文字)のため終了文字チェックをスキップ")
                        return {
                            'is_complete': True,
                            'reason': '超長文のため終了文字チェックを免除',
                            'details': f'文字数: {len(text_stripped)}, 最後の文字: {last_char}'
                        }
                        
                    # 条件2: 2000文字以上でコードブロックが3個以上ある場合は許容
                    if len(text_stripped) > 2000 and len(code_blocks) >= 3:
                        logger.info(f"✅ 長文({len(text_stripped)}文字)かつコードブロック{len(code_blocks)}個のため許容")
                        return {
                            'is_complete': True,
                            'reason': '長文かつ多数のコードブロックを含むため許容',
                            'details': f'文字数: {len(text_stripped)}, コードブロック数: {len(code_blocks)}'
                        }
                        
                    # 条件3: Pydanticモデルやスキーマ定義を含む場合は許容
                    if ('from pydantic import' in text or 
                        'class ' in text and 'BaseModel' in text or
                        'openapi:' in text.lower()):
                        logger.info("✅ 専門的な技術文書(Pydantic/OpenAPI)のため許容")
                        return {
                            'is_complete': True,
                            'reason': '専門的な技術文書として許容',
                            'details': 'Pydanticモデルまたはスキーマ定義を含む'
                        }
                        
                    # 条件4: 1500文字以上で「まとめ」「結論」「以上」などの締めくくり表現がある場合
                    conclusion_patterns = [
                        'まとめ', '結論', '以上', '完了', '終わり',
                        'summary', 'conclusion', 'end', 'complete'
                    ]
                    if len(text_stripped) > 1500 and any(pattern in text_stripped[-500:].lower() for pattern in conclusion_patterns):
                        logger.info("✅ 長文で締めくくり表現を含むため許容")
                        return {
                            'is_complete': True,
                            'reason': '長文で締めくくり表現を含む',
                            'details': f'文字数: {len(text_stripped)}'
                        }
                        
                    # 上記条件に該当しない短文は不完全と判定
                    if len(text_stripped) < 1500:
                        last_50_chars = text_stripped[-50:]
                            
                        return {
                            'is_complete': False,
                            'reason': '文章が途中で切れている可能性があります',
                            'details': f'最後の文字: "{last_char}"',
                            'incomplete_blocks': [{
                                'type': 'text',
                                'snippet': f'...最後の50文字: {last_50_chars}'
                            }]
                        }
                    else:
                        # 1500文字以上だが条件に該当しない場合は警告のみで許容
                        logger.warning(f"⚠️ 長文({len(text_stripped)}文字)だが終了文字が不明瞭: '{last_char}'")
                        return {
                            'is_complete': True,
                            'reason': '長文のため警告付きで許容',
                            'details': f'文字数: {len(text_stripped)}, 最後の文字: {last_char}'
                        }
                
            # すべてのチェックをパス
            return {
                'is_complete': True,
                'reason': 'すべての検証に合格',
                'details': f'コードブロック数: {len(code_blocks)}'
            }
                
        except Exception as e:
            logger.error(f"コード完全性検証エラー: {e}")
            # エラー時は安全側に倒して不完全とみなす
            return {
                'is_complete': False,
                'reason': '検証処理でエラー発生',
                'details': str(e),
                'incomplete_blocks': []
            }
    
    async def extract_latest_text_response_deepseek(self) -> str:
        """DeepSeekの最新のテキスト応答を抽出（改良版）"""
        try:
            logger.info("=" * 60)
            logger.info("★★★ DeepSeekテキスト抽出開始 ★★★")
            logger.info("=" * 60)
            
            # DeepSeek特有のセレクタで応答を取得
            response_text = await self.page.evaluate('''() => {
                // メッセージコンテナを探す
                const messages = document.querySelectorAll('[class*="message"], [class*="chat"], div[role="article"]');
                let longest = '';
                
                for (const msg of messages) {
                    const text = msg.innerText || '';
                    // ユーザーのメッセージは除外
                    if (text.length > 100 && text.length > longest.length) {
                        // システムやアシスタントのメッセージのみ
                        const isUserMessage = msg.querySelector('[class*="user"]') || 
                                            msg.classList.toString().includes('user');
                        if (!isUserMessage) {
                            longest = text;
                        }
                    }
                }
                
                if (!longest) {
                    // フォールバック: 最後の長いdivを取得
                    const divs = document.querySelectorAll('div');
                    for (const d of divs) {
                        const t = d.innerText || '';
                        if (t.length > longest.length && t.length > 200) {
                            longest = t;
                        }
                    }
                }
                
                return longest;
            }''')
            
            if response_text and len(response_text) > 50:
                logger.info(f"✅ DeepSeek応答抽出成功: {len(response_text)}文字")
                logger.info(f"先頭500文字:\n{response_text[:500]}")
                
                # 検証を実行（緩和版）
                validation_result = self._validate_code_block_completeness_enhanced(response_text)
                
                if not validation_result['is_complete'] and len(response_text) > 1500:
                    logger.warning(f"⚠️ DeepSeek応答不完全だが長文のため採用: {validation_result['reason']}")
                    # 長文の場合は不完全でも採用
                    return response_text.strip()
                elif validation_result['is_complete']:
                    logger.info("✅ DeepSeek応答検証合格")
                    return response_text.strip()
                else:
                    logger.warning(f"⚠️ DeepSeek応答不完全: {validation_result['reason']}")
                    return response_text.strip()  # 不完全でも返す（以前はNoneを返していた）
            else:
                logger.error("❌ DeepSeek応答が見つかりません")
                return None
                
        except Exception as e:
            logger.error(f"❌ DeepSeek抽出エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    # === 既存のメソッドは変更なし（extract_json_from_text など） ===

    # 旧バージョンのメソッドを新しいメソッドで置き換えるための互換性レイヤー
    def _validate_code_block_completeness(self, text: str) -> Dict:
        """
        旧バージョンのメソッド - 新しいメソッドを呼び出す
        （既存コードとの互換性維持のため）
        """
        return self._validate_code_block_completeness_enhanced(text)

    def extract_json_from_text(self, text: str) -> str:
        """テキストからJSON部分を抽出"""
        try:
            if not text:
                return None
                
            # パターン1: ```json ... ``` に囲まれたJSON
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # パターン2: 単純なJSONオブジェクトの抽出
            json_match = re.search(r'^\s*(\{.*\})\s*$', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # パターン3: 先頭からJSONを探す
            start_idx = text.find('{')
            if start_idx != -1:
                # { から始めて、対応する } までを探す
                brace_count = 0
                for i, char in enumerate(text[start_idx:]):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            potential_json = text[start_idx:start_idx+i+1]
                            try:
                                json.loads(potential_json)
                                return potential_json.strip()
                            except:
                                continue
            return None
        except Exception as e:
            logger.error(f"JSON抽出エラー: {e}")
            return None
        
    

#browser_controller.py
# browser_controller.py
"""ブラウザ制御クラス（分割リファクタリング版）"""
import asyncio
from pathlib import Path
from typing import Optional, Dict
import logging

from browser_lifecycle import BrowserLifecycleManager
from brower_cookie_and_session import CookieSessionManager  # ファイル名修正
from browser_ai_chat_agent import AIChatAgent
from browser_wp_session_manager import WPSessionManager
from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserController:
    """ブラウザ制御ファサードクラス"""
    
    def __init__(self, download_folder: Path, mode: str = "image", service: str = "google", credentials: Dict = None):
        self.download_folder = download_folder
        self.mode = mode
        self.service = service.lower()
        self.credentials = credentials or {}
        
        # 設定ファイルのパス
        self.cookies_file = Path(config.COOKIES_FILE) if config.COOKIES_FILE else None
        self.browser_data_dir = Path(config.BROWSER_DATA_DIR) if config.BROWSER_DATA_DIR else None
        self.wp_cookies_file = Path(config.BROWSER_DATA_DIR) / "wp_cookies.json" if config.BROWSER_DATA_DIR else None
        
        # マネージャーの初期化（setup_browserで完全初期化）
        self.lifecycle_manager: Optional[BrowserLifecycleManager] = None
        self.session_manager: Optional[CookieSessionManager] = None
        self.ai_agent: Optional[AIChatAgent] = None
        self.wp_manager: Optional[WPSessionManager] = None
    
    async def setup_browser(self) -> None:
        """ブラウザのセットアップ - すべてのマネージャーを初期化"""
        try:
            # ライフサイクルマネージャーの初期化とセットアップ
            self.lifecycle_manager = BrowserLifecycleManager(
                browser_data_dir=self.browser_data_dir,
                download_folder=self.download_folder
            )
            await self.lifecycle_manager.setup_browser()
            
            # セッションマネージャーの初期化
            self.session_manager = CookieSessionManager(
                context=self.lifecycle_manager.context,
                cookies_file=self.cookies_file
            )
            
            # AIチャットエージェントの初期化
            self.ai_agent = AIChatAgent(
                page=self.lifecycle_manager.page,
                service=self.service,
                credentials=self.credentials
            )
            
            # WordPressセッションマネージャーの初期化
            self.wp_manager = WPSessionManager(
                context=self.lifecycle_manager.context,
                wp_cookies_file=self.wp_cookies_file
            )
            
            logger.info(f"✅ ブラウザ制御ファサード初期化完了（サービス: {self.service}）")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ブラウザファサードセットアップ")
            raise
    
    # プロパティの委譲
    @property
    def context(self):
        return self.lifecycle_manager.context if self.lifecycle_manager else None
    
    @property
    def page(self):
        return self.lifecycle_manager.page if self.lifecycle_manager else None
    
    @property
    def wp_page(self):
        return self.wp_manager.wp_page if self.wp_manager else None
    
    @property
    def is_logged_in(self):
        return self.wp_manager.is_logged_in if self.wp_manager else False
    
    # AIチャット関連メソッドの委譲
    async def navigate_to_gemini(self) -> None:
        """Geminiにナビゲート - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.navigate_to_gemini()
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekにナビゲート - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.navigate_to_deepseek()
    
    async def send_prompt(self, prompt: str) -> None:
        """プロンプト送信 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.send_prompt(prompt)
    
    async def wait_for_text_generation(self, max_wait: int = 180) -> bool:
        """
        テキスト生成完了を待機（強化版）
            
        Args:
            max_wait: 最大待機時間（秒）
                
        Returns:
            bool: 生成完了フラグ
        """
        try:
            logger.info(f"⏱️ テキスト生成待機開始（最大{max_wait}秒）")
                
            start_time = asyncio.get_event_loop().time()
            check_interval = 2.0  # 2秒ごとにチェック
            last_length = 0
            stable_count = 0
            required_stable = 3  # 3回連続で変化なしで完了と判定
                
            while True:
                elapsed = asyncio.get_event_loop().time() - start_time
                    
                if elapsed > max_wait:
                    logger.warning(f"⏱️ タイムアウト（{max_wait}秒）")
                    return False
                    
                # 現在のテキスト長を取得
                try:
                    current_text = await self._get_current_text_quick()
                    current_length = len(current_text)
                        
                    # テキストが増えているか確認
                    if current_length > last_length:
                        logger.info(f"📝 生成中: {current_length}文字（経過: {int(elapsed)}秒）")
                        last_length = current_length
                        stable_count = 0
                    else:
                        # 長さが変わらない
                        stable_count += 1
                        logger.info(f"⏸️ 安定: {stable_count}/{required_stable}（{current_length}文字）")
                            
                        if stable_count >= required_stable:
                            logger.info(f"✅ 生成完了（{current_length}文字、{int(elapsed)}秒）")
                            return True
                    
                except Exception as e:
                    logger.warning(f"⚠️ チェックエラー: {e}")
                    
                # 待機
                await asyncio.sleep(check_interval)
            
        except Exception as e:
            logger.error(f"❌ 待機エラー: {e}")
            return False
    
    async def extract_latest_text_response(self, allow_partial: bool = True) -> Optional[str]:
        """
        最新のテキスト応答を抽出（強化版）
        
        Args:
            allow_partial: 部分的な応答も許可するか
            
        Returns:
            Optional[str]: 抽出されたテキスト
        """
        try:
            logger.info("="*60)
            logger.info("★★★ Gemini応答抽出開始（強化版） ★★★")
            logger.info("="*60)
            
            results = {}
            
            # ============================================================
            # === 方法1: model-response-text クラス ===
            # ============================================================
            try:
                message_divs = await self.page.query_selector_all('div.model-response-text')
                if message_divs:
                    last_message = message_divs[-1]
                    text1 = await last_message.inner_text()
                    if text1 and len(text1) > 100:
                        results['method1'] = text1
                        logger.info(f"✅ 方法1成功: {len(text1)}文字")
            except Exception as e:
                logger.warning(f"⚠️ 方法1失敗: {e}")
            
            # ============================================================
            # === 方法2: markdown-container クラス ===
            # ============================================================
            try:
                markdown_divs = await self.page.query_selector_all('div.markdown-container')
                if markdown_divs:
                    last_markdown = markdown_divs[-1]
                    text2 = await last_markdown.inner_text()
                    if text2 and len(text2) > 100:
                        results['method2'] = text2
                        logger.info(f"✅ 方法2成功: {len(text2)}文字")
            except Exception as e:
                logger.warning(f"⚠️ 方法2失敗: {e}")
            
            # ============================================================
            # === 方法3: message-content クラス ===
            # ============================================================
            try:
                content_divs = await self.page.query_selector_all('div.message-content')
                if content_divs:
                    # 最後のメッセージコンテンツ
                    for div in reversed(content_divs):
                        text3 = await div.inner_text()
                        if text3 and len(text3) > 100 and 'model-response' not in text3.lower():
                            results['method3'] = text3
                            logger.info(f"✅ 方法3成功: {len(text3)}文字")
                            break
            except Exception as e:
                logger.warning(f"⚠️ 方法3失敗: {e}")
            
            # ============================================================
            # === 方法4: data-test-id 属性 ===
            # ============================================================
            try:
                test_divs = await self.page.query_selector_all('[data-test-id*="conversation-turn"]')
                if test_divs:
                    last_turn = test_divs[-1]
                    text4 = await last_turn.inner_text()
                    if text4 and len(text4) > 100:
                        results['method4'] = text4
                        logger.info(f"✅ 方法4成功: {len(text4)}文字")
            except Exception as e:
                logger.warning(f"⚠️ 方法4失敗: {e}")
            
            # ============================================================
            # === 結果選択（最長のものを選択） ===
            # ============================================================
            if not results:
                logger.error("❌ 全方法失敗 - 応答が取得できませんでした")
                
                # デバッグ情報
                try:
                    page_content = await self.page.content()
                    logger.info(f"📄 ページ長: {len(page_content)}文字")
                except:
                    pass
                
                return None
            
            # 最も長いテキストを選択
            best_method = max(results.items(), key=lambda x: len(x[1]))
            selected_text = best_method[1]
            
            logger.info(f"✅ 最適結果選択: {best_method[0]} ({len(selected_text)}文字)")
            
            # ============================================================
            # === 品質チェック（緩和版） ===
            # ============================================================
            warnings = []
            
            # 長さチェック
            if len(selected_text) < 500:
                warnings.append(f'短い応答（{len(selected_text)}文字）')
            
            # コードブロックチェック（緩和）
            if allow_partial:
                # 部分的なコードブロックも許可
                if '```' in selected_text:
                    open_count = selected_text.count('```')
                    if open_count % 2 != 0:
                        warnings.append('コードブロック未完結（許可）')
            else:
                # 厳密なチェック
                open_blocks = selected_text.count('```')
                if open_blocks % 2 != 0:
                    warnings.append('コードブロック未完結')
            
            # 警告表示
            if warnings:
                logger.warning("⚠️ 品質警告:")
                for w in warnings:
                    logger.warning(f"  - {w}")
            
            # 部分応答も許可する場合は、警告があっても返す
            if allow_partial:
                logger.info("✅ 部分応答を許可 - そのまま返却")
                return selected_text
            
            # 厳密モードの場合、重大な問題があればNone
            if len(selected_text) < 100:
                logger.error("❌ 応答が短すぎる（100文字未満）")
                return None
            
            logger.info("="*60)
            logger.info(f"✅ 応答抽出完了: {len(selected_text)}文字")
            logger.info("="*60)
            
            return selected_text
        
        except Exception as e:
            logger.error(f"❌ 応答抽出エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """プロンプト送信と待機 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        return await self.ai_agent.send_prompt_and_wait(prompt, max_wait)
    
    # クッキー管理の委譲
    async def save_cookies(self) -> None:
        """クッキー保存 - セッションマネージャーに委譲"""
        if not self.session_manager:
            raise Exception("セッションマネージャーが初期化されていません")
        await self.session_manager.save_cookies()
    
    async def load_cookies(self) -> bool:
        """クッキー読み込み - セッションマネージャーに委譲"""
        if not self.session_manager:
            logger.warning("セッションマネージャーが初期化されていません")
            return False
        return await self.session_manager.load_cookies()
    
    # WordPress関連メソッドの委譲
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """WordPressセッション初期化 - WPマネージャーに委譲"""
        if not self.wp_manager:
            raise Exception("WordPressマネージャーが初期化されていません")
        return await self.wp_manager.initialize_wp_session(auth_module)
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressクッキー保存 - WPマネージャーに委譲"""
        if not self.wp_manager:
            raise Exception("WordPressマネージャーが初期化されていません")
        return await self.wp_manager.save_wordpress_cookies(wp_url)
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressクッキー読み込み - WPマネージャーに委譲"""
        if not self.wp_manager:
            raise Exception("WordPressマネージャーが初期化されていません")
        return await self.wp_manager.load_wordpress_cookies(wp_url)
    
    # クリーンアップの委譲
    async def cleanup(self) -> None:
        """リソースクリーンアップ - ライフサイクルマネージャーに委譲"""
        # WordPressセッションを閉じる
        if self.wp_manager:
            await self.wp_manager.close_wp_session()
        
        # メインのブラウザリソースをクリーンアップ
        if self.lifecycle_manager:
            await self.lifecycle_manager.cleanup()
    
    # ユーティリティメソッド
    async def save_text_to_file(self, text: str, filename: str) -> bool:
        """テキストファイル保存 - ユーティリティとして維持"""
        try:
            save_path = self.download_folder / filename
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(text)
            if save_path.exists():
                file_size = save_path.stat().st_size
                logger.info(f"✅ テキスト保存成功: {filename} ({file_size:,} bytes)")
                return True
            else:
                logger.error(f"❌ テキスト保存失敗: {filename}")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "テキストファイル保存")
            return False
    
    # 後方互換性のためのメソッド
    async def _is_browser_alive(self) -> bool:
        """ブラウザ生存確認 - ライフサイクルマネージャーに委譲"""
        if not self.lifecycle_manager:
            return False
        return await self.lifecycle_manager._is_browser_alive()
    
    async def handle_welcome_screens(self) -> None:
        """ウェルカム画面処理 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.handle_welcome_screens()
    
    async def ensure_normal_chat_mode(self) -> None:
        """通常チャットモード確認 - AIエージェントに委譲"""
        if not self.ai_agent:
            raise Exception("AIエージェントが初期化されていません")
        await self.ai_agent.ensure_normal_chat_mode()
    
    # 非推奨メソッド（後方互換性のため）
    async def _wait_for_generation_complete(self, max_wait: int = 120) -> bool:
        """非推奨メソッド - 後方互換性のため維持"""
        logger.warning("⚠️ 非推奨メソッド _wait_for_generation_complete が呼び出されました")
        return await self.wait_for_text_generation(max_wait)
    
async def ensure_browser_ready(self) -> bool:
    """
    ブラウザの準備完了を確認（セッション管理強化版）
        
    Returns:
        bool: 準備完了フラグ
    """
    try:
        # ブラウザが起動しているか確認
        if not self.browser:
            logger.error("❌ ブラウザが起動していません")
            return False
            
        # コンテキストが有効か確認
        if not self.context:
            logger.error("❌ ブラウザコンテキストがありません")
            return False
            
        # ページが有効か確認
        if not self.page:
            logger.error("❌ ページがありません")
            return False
            
        # ページが閉じられていないか確認
        try:
            is_closed = self.page.is_closed()
            if is_closed:
                logger.error("❌ ページが閉じられています - 再作成")
                self.page = await self.context.new_page()
                await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
                await asyncio.sleep(3)
                logger.info("✅ ページを再作成しました")
        except Exception as e:
            logger.warning(f"⚠️ ページ状態確認エラー: {e}")
            
        # Geminiページにいるか確認
        current_url = self.page.url
        if 'gemini.google.com' not in current_url:
            logger.warning(f"⚠️ Geminiページではありません: {current_url}")
            logger.info("🔄 Geminiページに移動中...")
            await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
            await asyncio.sleep(3)
            
        logger.info("✅ ブラウザ準備完了")
        return True
        
    except Exception as e:
        logger.error(f"❌ ブラウザ準備確認エラー: {e}")
        return False
    
async def send_prompt(self, prompt: str) -> bool:
    """
    プロンプト送信（セッション管理付き）
        
    Args:
        prompt: 送信するプロンプト
            
    Returns:
        bool: 送信成功フラグ
    """
    try:
        # ブラウザ準備確認
        if not await self.ensure_browser_ready():
            logger.error("❌ ブラウザが準備できていません")
            return False
            
        logger.info("📤 プロンプト送信中...")
            
        # プロンプト入力欄を探す
        input_selectors = [
            'textarea[placeholder*="メッセージ"]',
            'textarea[aria-label*="メッセージ"]',
            'div[contenteditable="true"]',
            'textarea.ql-editor',
            'div.ql-editor'
        ]
            
        input_box = None
        for selector in input_selectors:
            try:
                input_box = await self.page.wait_for_selector(selector, timeout=5000)
                if input_box:
                    break
            except:
                continue
            
        if not input_box:
            logger.error("❌ 入力欄が見つかりません")
            return False
            
        # プロンプト入力
        await input_box.click()
        await asyncio.sleep(0.5)
        await input_box.fill(prompt)
        await asyncio.sleep(1)
            
        # 送信ボタンクリック
        send_button = await self.page.query_selector('button[aria-label*="送信"]')
        if send_button:
            await send_button.click()
            logger.info("✅ プロンプト送信完了")
            return True
        else:
            # Enterキーで送信
            await self.page.keyboard.press('Enter')
            logger.info("✅ プロンプト送信完了（Enter）")
            return True
        
    except Exception as e:
        logger.error(f"❌ プロンプト送信エラー: {e}")
        return False
    

#browser_lifecycle.py
# browser_lifecycle.py
"""ブラウザライフサイクル管理クラス"""
import asyncio
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import async_playwright, Page, BrowserContext
import logging
import psutil

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserLifecycleManager:
    """ブラウザの起動・終了・生存管理を担当"""
    
    def __init__(self, browser_data_dir: Path, download_folder: Path):
        self.browser_data_dir = browser_data_dir
        self.download_folder = download_folder
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.playwright = None
        
        self.download_folder.mkdir(exist_ok=True, parents=True)
        if self.browser_data_dir:
            self.browser_data_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup_browser(self) -> None:
        """ブラウザの初期化（マルチモニター対応版）"""
        try:
            logger.info("="*60)
            logger.info("ブラウザ起動開始...")
            logger.info("="*60)
            
            # 既存のプロセスクリーンアップ
            await self._cleanup_existing_browser_processes()
            
            self.playwright = await async_playwright().start()
            logger.info(f"ユーザーデータディレクトリ: {self.browser_data_dir}")
            
            # マルチモニター対応: ウィンドウ位置とサイズを指定
            window_width = 1280
            window_height = 700
            x_position = 0
            y_position = 0
            
            # ブラウザ起動（位置とサイズ指定）
            self.context = await self.playwright.chromium.launch_persistent_context(
                user_data_dir=str(self.browser_data_dir),
                viewport={'width': window_width, 'height': window_height},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                accept_downloads=True,
                ignore_https_errors=True,
                no_viewport=False,
                **config.BROWSER_CONFIG
            )
            
            logger.info("✅ ブラウザコンテキスト作成成功")
            
            # ページ作成
            self.page = await self.context.new_page()
            
            # ウィンドウを指定位置に移動
            await self.page.evaluate(f"""
                window.moveTo({x_position}, {y_position});
                window.resizeTo({window_width}, {window_height});
            """)
            
            logger.info(f"✅ ウィンドウを位置 ({x_position}, {y_position}) に配置")
            
            # ブラウザが正常に起動したか確認
            await asyncio.sleep(2)
            if not await self._is_browser_alive():
                raise Exception("ブラウザが起動直後にクラッシュしました")
            
            logger.info("✅ ブラウザ生存確認完了")
            
            # 自動化検出を回避
            await self.page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false,
                });
                window.navigator.chrome = {
                    runtime: {},
                };
                const originalQuery = window.navigator.permissions.query;
                window.navigator.permissions.query = (parameters) => (
                    parameters.name === 'notifications' ?
                        Promise.resolve({ state: Notification.permission }) :
                        originalQuery(parameters)
                );
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['ja-JP', 'ja', 'en-US', 'en'],
                });
            """)
            
            self.page.set_default_timeout(config.PAGE_TIMEOUT)
            self.page.set_default_navigation_timeout(config.PAGE_TIMEOUT)
            
            logger.info("="*60)
            logger.info("✅ ブラウザ起動完了")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ブラウザ起動")
            logger.error("="*60)
            logger.error("❌ ブラウザ起動失敗")
            logger.error("="*60)
            
            logger.error(f"エラー詳細: {str(e)}")
            logger.error(f"ブラウザデータディレクトリ: {self.browser_data_dir}")
            
            await self._cleanup_existing_browser_processes()
            raise Exception(f"ブラウザ起動に失敗しました: {str(e)}")
    
    async def _is_browser_alive(self) -> bool:
        """ブラウザが生きているか確認"""
        try:
            if not self.page:
                return False
            result = await self.page.evaluate("1 + 1")
            return result == 2
        except Exception as e:
            logger.warning(f"ブラウザ生存確認失敗: {e}")
            return False
    
    async def _cleanup_existing_browser_processes(self):
        """既存のChromiumプロセスをクリーンアップ"""
        try:
            logger.info("既存のChromiumプロセスを確認中...")
            
            killed_count = 0
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if 'chrome' in proc.info['name'].lower() or 'chromium' in proc.info['name'].lower():
                        cmdline = proc.cmdline()
                        if str(self.browser_data_dir) in ' '.join(cmdline):
                            logger.warning(f"既存のChromiumプロセスを終了: PID={proc.info['pid']}")
                            proc.kill()
                            killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if killed_count > 0:
                logger.info(f"✅ {killed_count}個のプロセスを終了しました")
                await asyncio.sleep(2)
            else:
                logger.info("既存プロセスなし")
                
        except ImportError:
            logger.warning("psutilがインストールされていません。プロセスクリーンアップをスキップ")
        except Exception as e:
            logger.warning(f"プロセスクリーンアップエラー: {e}")
    
    async def cleanup(self) -> None:
        """リソースのクリーンアップ"""
        try:
            logger.info("🔄 リソースクリーンアップを開始します...")

            # 非同期タスクのキャンセル
            try:
                tasks = [t for t in asyncio.all_tasks() 
                        if t is not asyncio.current_task()]
                        
                if tasks:
                    logger.info(f"🔄 {len(tasks)}個の非同期タスクをキャンセル中...")
                    for task in tasks:
                        task.cancel()
                            
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=5.0
                    )
                    logger.info("✅ 非同期タスククリーンアップ完了")
            except asyncio.TimeoutError:
                logger.warning("⚠️ タスクキャンセルのタイムアウト")
            except Exception as e:
                logger.warning(f"⚠️ タスクキャンセル中のエラー: {e}")

            # ページのクローズ
            if self.page:
                try:
                    await self.page.close()
                    logger.info("✅ ページをクローズしました")
                except Exception as e:
                    logger.warning(f"⚠️ ページクローズ中の警告: {e}")

            # コンテキストのクローズ
            if self.context:
                try:
                    await self.context.close()
                    logger.info("✅ ブラウザコンテキストをクローズしました")
                except Exception as e:
                    logger.warning(f"⚠️ コンテキストクローズ中の警告: {e}")

            # Playwrightの停止
            if self.playwright:
                try:
                    await self.playwright.stop()
                    logger.info("✅ Playwrightを停止しました")
                except Exception as e:
                    logger.warning(f"⚠️ Playwright停止中の警告: {e}")

            logger.info("✅ リソースクリーンアップ完了")

        except Exception as e:
            logger.error(f"❌ クリーンアップ中のエラー: {e}")

#browser_wp_session_manager.py
# browser_wp_session_manager.py
"""WordPressセッション管理クラス"""
import json
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import Page, BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class WPSessionManager:
    """WordPressセッションの管理を担当"""
    
    def __init__(self, context: BrowserContext, wp_cookies_file: Path):
        self.context = context
        self.wp_cookies_file = wp_cookies_file
        self.wp_page: Optional[Page] = None
        self.is_logged_in = False
    
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """
        WordPress セッション初期化（完全修正版 - クッキー強制ナビゲーション対応）
            
        Args:
            auth_module: WordPress認証モジュール（任意）
            
        Returns:
            bool: 初期化成功時 True
        """
        try:
            logger.info("="*60)
            logger.info("🔐 WordPress セッション初期化中...")
            logger.info("="*60)
                
            # Phase 1: 新しいタブを作成
            if not self.context:
                logger.error("❌ ブラウザコンテキストが初期化されていません")
                return False
                
            self.wp_page = await self.context.new_page()
            logger.info("✅ WordPress 専用タブを作成しました")
                
            # Phase 2: 認証情報の検証
            if not auth_module:
                logger.warning("⚠️ WordPress 認証モジュールが提供されていません")
                logger.info("手動ログインが必要になる可能性があります")
                
            # Phase 3: ログイン実行（クッキー優先 + 強制ナビゲーション）
            logger.info("🔄 WordPress認証を実行中...")
            
            if auth_module:
                login_success = await auth_module.login(self.wp_page)
            else:
                # 認証モジュールがない場合は手動ログインを促す
                login_success = await self._manual_wp_login()
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("✅ WordPress セッション初期化完了")
                logger.info("  認証方法: クッキー or 手動ログイン")
                logger.info("  ページURL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("❌ WordPress ログイン失敗")
                logger.error("  原因: 認証情報またはネットワークの問題")
                logger.error("  対策: 認証情報を確認してください")
                logger.error("="*60)
                    
                # デバッグ用: 失敗時のスクリーンショット
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("📸 デバッグ用スクリーンショット: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"❌ WordPress セッション初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _manual_wp_login(self) -> bool:
        """手動WordPressログイン処理"""
        try:
            logger.info("="*60)
            logger.info("🔐 手動WordPressログインが必要です")
            logger.info("="*60)
            logger.info("")
            logger.info("📌 ログイン手順：")
            logger.info("1. ブラウザでWordPress管理画面を開く")
            logger.info("2. ユーザー名/パスワードでログイン")
            logger.info("3. ダッシュボードが表示されたらこのコンソールに戻る")
            logger.info("4. Enterキーを押して続行")
            logger.info("")
            logger.info("💡 ヒント：")
            logger.info("  - ログイン後はこのタブを閉じないでください")
            logger.info("  - セッションはCookieで維持されます")
            logger.info("="*60)
            
            # 一般的なWordPressログインURLに移動
            await self.wp_page.goto("/wp-admin", wait_until="domcontentloaded")
            
            input("\n✅ ログイン完了後、Enterキーを押してください: ")
            
            # ログイン成功を確認
            current_url = self.wp_page.url
            if 'wp-admin' in current_url or 'dashboard' in current_url.lower():
                logger.info("✅ WordPressログイン成功を確認")
                return True
            else:
                logger.warning("⚠️ WordPress管理画面に到達していない可能性があります")
                return False
                
        except Exception as e:
            logger.error(f"手動ログイン処理エラー: {e}")
            return False
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPress専用のクッキーを保存"""
        try:
            if not self.context or not self.wp_cookies_file:
                logger.warning("⚠️ クッキー保存: コンテキストまたはファイルパスがありません")
                return False
            
            # 現在のクッキーを取得
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("保存するクッキーがありません")
                return False
            
            # WordPress関連のクッキーをフィルタリング
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_cookies = [c for c in cookies if wp_domain in c.get('domain', '')]
            
            if not wp_cookies:
                logger.warning("WordPress関連のクッキーが見つかりません")
                return False
            
            # 既存のクッキーファイルを読み込み
            all_cookies = {}
            if self.wp_cookies_file.exists():
                try:
                    with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                        all_cookies = json.load(f)
                except Exception as e:
                    logger.warning(f"既存クッキー読み込みエラー: {e}")
                    all_cookies = {}
            
            # WordPress クッキーを更新
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            all_cookies[wp_key] = {
                'cookies': wp_cookies,
                'timestamp': time.time(),
                'domain': wp_url
            }
            
            # ファイルに保存
            self.wp_cookies_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.wp_cookies_file, 'w', encoding='utf-8') as f:
                json.dump(all_cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"✅ WordPress クッキー保存完了: {len(wp_cookies)}個")
            return True
            
        except Exception as e:
            logger.error(f"❌ WordPress クッキー保存エラー: {e}")
            return False
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPress専用のクッキーを読み込み"""
        try:
            if not self.wp_cookies_file or not self.wp_cookies_file.exists():
                logger.warning("WordPress クッキーファイルが存在しません")
                return False
            
            if not self.context:
                logger.warning("コンテキストが初期化されていません")
                return False
            
            # クッキーファイルを読み込み
            with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                all_cookies = json.load(f)
            
            # WordPress クッキーを取得
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            
            if wp_key not in all_cookies:
                logger.warning(f"WordPress クッキーが見つかりません: {wp_key}")
                return False
            
            wp_cookie_data = all_cookies[wp_key]
            cookies = wp_cookie_data.get('cookies', [])
            
            if not cookies:
                logger.warning("有効な WordPress クッキーがありません")
                return False
            
            # 有効期限をチェック
            valid_cookies = []
            for cookie in cookies:
                if 'expires' in cookie:
                    if cookie['expires'] > time.time():
                        valid_cookies.append(cookie)
                else:
                    # expires がないクッキーはセッションクッキー
                    valid_cookies.append(cookie)
            
            if not valid_cookies:
                logger.warning("有効期限切れのクッキーのみ存在します")
                return False
            
            # クッキーをコンテキストに追加
            await self.context.add_cookies(valid_cookies)
            logger.info(f"✅ WordPress クッキー読み込み完了: {len(valid_cookies)}個")
            
            return True
            
        except Exception as e:
            logger.error(f"❌ WordPress クッキー読み込みエラー: {e}")
            return False
    
    async def close_wp_session(self) -> None:
        """WordPressセッションを閉じる"""
        try:
            if self.wp_page:
                await self.wp_page.close()
                self.wp_page = None
                self.is_logged_in = False
                logger.info("✅ WordPressセッションを閉じました")
        except Exception as e:
            logger.warning(f"WordPressセッションクローズ中の警告: {e}")

#cache_manager.py
"""
CacheManager - インテリジェントキャッシュ管理エージェント

頻繁なエラーパターンのキャッシュ、修正済みエラーの記録、
類似エラーの検出と高速修正、キャッシュ有効期限管理を提供する。
"""

import json
import hashlib
import pickle
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import Counter
import logging

logger = logging.getLogger(__name__)


@dataclass
class ErrorPattern:
    """エラーパターン"""
    error_type: str
    error_message_pattern: str
    stack_trace_pattern: str
    file_pattern: str
    frequency: int = 0
    last_seen: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "error_type": self.error_type,
            "error_message_pattern": self.error_message_pattern,
            "stack_trace_pattern": self.stack_trace_pattern,
            "file_pattern": self.file_pattern,
            "frequency": self.frequency,
            "last_seen": self.last_seen.isoformat()
        }


@dataclass
class CachedFix:
    """キャッシュされた修正"""
    error_hash: str
    fix_code: str
    fix_description: str
    success_rate: float
    application_count: int
    created_at: datetime
    last_used: datetime
    ttl_hours: int = 168  # 1週間
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_expired(self) -> bool:
        """有効期限切れかチェック"""
        expiry = self.created_at + timedelta(hours=self.ttl_hours)
        return datetime.now() > expiry
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "error_hash": self.error_hash,
            "fix_code": self.fix_code,
            "fix_description": self.fix_description,
            "success_rate": self.success_rate,
            "application_count": self.application_count,
            "created_at": self.created_at.isoformat(),
            "last_used": self.last_used.isoformat(),
            "ttl_hours": self.ttl_hours,
            "metadata": self.metadata
        }


class CacheManagerAgent:
    """
    インテリジェントキャッシュ管理エージェント
    
    主な機能:
    1. エラーパターンの学習とキャッシュ
    2. 修正済みエラーの記録
    3. 類似エラーの高速検出
    4. キャッシュ有効期限管理
    5. キャッシュヒット率の最適化
    """
    
    def __init__(self, 
                 cache_dir: str = ".cache",
                 similarity_threshold: float = 0.85,
                 max_cache_size: int = 1000):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self.similarity_threshold = similarity_threshold
        self.max_cache_size = max_cache_size
        
        # キャッシュストレージ
        self.fix_cache: Dict[str, CachedFix] = {}
        self.error_patterns: Dict[str, ErrorPattern] = {}
        
        # 統計情報
        self.stats = {
            "cache_hits": 0,
            "cache_misses": 0,
            "patterns_learned": 0,
            "fixes_cached": 0,
            "successful_applications": 0,
            "failed_applications": 0
        }
        
        # キャッシュファイル
        self.cache_file = self.cache_dir / "fix_cache.pkl"
        self.patterns_file = self.cache_dir / "error_patterns.json"
        
        # 起動時にキャッシュを読み込む
        self._load_cache()
        
        logger.info(f"CacheManagerAgent initialized (cache_dir={cache_dir})")
    
    def compute_error_hash(self, error_context: Dict[str, Any]) -> str:
        """
        エラーコンテキストからハッシュを計算
        
        類似したエラーは同じハッシュを持つように正規化する
        """
        # エラーメッセージから変数名や値を除去して正規化
        error_type = error_context.get("error_type", "")
        error_message = error_context.get("error_message", "")
        source_file = error_context.get("source_file", "")
        
        # 正規化: 数字、ファイルパスの具体的な部分を除去
        normalized_message = self._normalize_error_message(error_message)
        normalized_file = Path(source_file).name if source_file else ""
        
        # ハッシュ用の文字列を作成
        hash_string = f"{error_type}|{normalized_message}|{normalized_file}"
        
        return hashlib.sha256(hash_string.encode()).hexdigest()[:16]
    
    def _normalize_error_message(self, message: str) -> str:
        """エラーメッセージを正規化"""
        import re
        
        # 数字を除去
        message = re.sub(r'\d+', 'N', message)
        
        # ファイルパスを除去
        message = re.sub(r'[/\\][^\s]+', '<PATH>', message)
        
        # 変数名を一般化（簡易版）
        message = re.sub(r"'[^']+'" , '<VAR>', message)
        message = re.sub(r'"[^"]+"', '<VAR>', message)
        
        return message.lower().strip()
    
    def cache_fix(self,
                 error_context: Dict[str, Any],
                 fix_code: str,
                 fix_description: str,
                 ttl_hours: int = 168) -> str:
        """
        修正をキャッシュに保存
        
        Args:
            error_context: エラーコンテキスト
            fix_code: 修正コード
            fix_description: 修正の説明
            ttl_hours: 有効期限（時間）
        
        Returns:
            エラーハッシュ
        """
        error_hash = self.compute_error_hash(error_context)
        
        if error_hash in self.fix_cache:
            # 既存のキャッシュを更新
            cached_fix = self.fix_cache[error_hash]
            cached_fix.last_used = datetime.now()
            logger.debug(f"Updated existing cache entry: {error_hash}")
        else:
            # 新しいキャッシュエントリを作成
            cached_fix = CachedFix(
                error_hash=error_hash,
                fix_code=fix_code,
                fix_description=fix_description,
                success_rate=0.0,
                application_count=0,
                created_at=datetime.now(),
                last_used=datetime.now(),
                ttl_hours=ttl_hours,
                metadata={
                    "error_type": error_context.get("error_type"),
                    "original_message": error_context.get("error_message", "")[:200]
                }
            )
            self.fix_cache[error_hash] = cached_fix
            self.stats["fixes_cached"] += 1
            logger.info(f"Cached new fix: {error_hash}")
        
        # エラーパターンを学習
        self._learn_error_pattern(error_context)
        
        # キャッシュを保存
        self._save_cache()
        
        # サイズ制限をチェック
        self._enforce_cache_size_limit()
        
        return error_hash
    
    def get_cached_fix(self, error_context: Dict[str, Any]) -> Optional[CachedFix]:
        """
        キャッシュから修正を取得
        
        Args:
            error_context: エラーコンテキスト
        
        Returns:
            キャッシュされた修正（見つからない場合はNone）
        """
        error_hash = self.compute_error_hash(error_context)
        
        # 完全一致を探す
        if error_hash in self.fix_cache:
            cached_fix = self.fix_cache[error_hash]
            
            # 有効期限をチェック
            if cached_fix.is_expired():
                logger.info(f"Cache entry expired: {error_hash}")
                del self.fix_cache[error_hash]
                self._save_cache()
                self.stats["cache_misses"] += 1
                return None
            
            # 使用情報を更新
            cached_fix.last_used = datetime.now()
            self.stats["cache_hits"] += 1
            logger.info(f"Cache hit: {error_hash}")
            
            return cached_fix
        
        # 類似したエラーを探す
        similar_fix = self._find_similar_fix(error_context)
        
        if similar_fix:
            self.stats["cache_hits"] += 1
            logger.info(f"Similar cache hit: {similar_fix.error_hash}")
            return similar_fix
        
        self.stats["cache_misses"] += 1
        logger.debug(f"Cache miss: {error_hash}")
        
        return None
    
    def _find_similar_fix(self, error_context: Dict[str, Any]) -> Optional[CachedFix]:
        """類似したエラーの修正を検索"""
        error_type = error_context.get("error_type", "")
        error_message = error_context.get("error_message", "")
        
        # 同じエラータイプのキャッシュエントリを検索
        candidates = []
        
        for cached_fix in self.fix_cache.values():
            if cached_fix.metadata.get("error_type") == error_type:
                # 類似度を計算
                similarity = self._calculate_similarity(
                    error_message,
                    cached_fix.metadata.get("original_message", "")
                )
                
                if similarity >= self.similarity_threshold:
                    candidates.append((similarity, cached_fix))
        
        if not candidates:
            return None
        
        # 最も類似度の高いものを返す
        best_similarity, best_fix = max(candidates, key=lambda x: x[0])
        logger.debug(f"Found similar fix with similarity: {best_similarity:.2f}")
        
        return best_fix
    
    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """2つのテキストの類似度を計算（簡易版）"""
        if not text1 or not text2:
            return 0.0
        
        # 正規化
        text1 = self._normalize_error_message(text1)
        text2 = self._normalize_error_message(text2)
        
        # 単語レベルのJaccard類似度
        words1 = set(text1.split())
        words2 = set(text2.split())
        
        if not words1 or not words2:
            return 0.0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)
    
    def record_fix_result(self, error_hash: str, success: bool):
        """
        修正結果を記録してキャッシュの信頼性を更新
        
        Args:
            error_hash: エラーハッシュ
            success: 修正が成功したか
        """
        if error_hash not in self.fix_cache:
            logger.warning(f"Error hash not found in cache: {error_hash}")
            return
        
        cached_fix = self.fix_cache[error_hash]
        cached_fix.application_count += 1
        
        if success:
            self.stats["successful_applications"] += 1
        else:
            self.stats["failed_applications"] += 1
        
        # 成功率を更新（移動平均）
        old_rate = cached_fix.success_rate
        new_rate = 1.0 if success else 0.0
        
        # 指数移動平均（より最近の結果を重視）
        alpha = 0.3
        cached_fix.success_rate = alpha * new_rate + (1 - alpha) * old_rate
        
        logger.debug(f"Updated fix success rate: {error_hash} -> {cached_fix.success_rate:.2f}")
        
        self._save_cache()
    
    def _learn_error_pattern(self, error_context: Dict[str, Any]):
        """エラーパターンを学習"""
        error_type = error_context.get("error_type", "")
        error_message = error_context.get("error_message", "")
        stack_trace = error_context.get("stack_trace", "")
        source_file = error_context.get("source_file", "")
        
        # パターンキーを作成
        pattern_key = f"{error_type}_{self._normalize_error_message(error_message)[:50]}"
        
        if pattern_key in self.error_patterns:
            # 既存パターンの頻度を増やす
            pattern = self.error_patterns[pattern_key]
            pattern.frequency += 1
            pattern.last_seen = datetime.now()
        else:
            # 新しいパターンを記録
            pattern = ErrorPattern(
                error_type=error_type,
                error_message_pattern=self._normalize_error_message(error_message),
                stack_trace_pattern=self._extract_stack_pattern(stack_trace),
                file_pattern=Path(source_file).name if source_file else "",
                frequency=1,
                last_seen=datetime.now()
            )
            self.error_patterns[pattern_key] = pattern
            self.stats["patterns_learned"] += 1
        
        self._save_patterns()
    
    def _extract_stack_pattern(self, stack_trace: str) -> str:
        """スタックトレースからパターンを抽出"""
        import re
        
        # ファイル名と行番号を除いて、関数名のみを抽出
        lines = stack_trace.split('\n')
        functions = []
        
        for line in lines:
            # "in <function_name>" のパターンを探す
            match = re.search(r'in (\w+)', line)
            if match:
                functions.append(match.group(1))
        
        return ' -> '.join(functions[:5])  # 最初の5つの関数のみ
    
    def get_frequent_errors(self, limit: int = 10) -> List[Tuple[str, ErrorPattern]]:
        """頻繁に発生するエラーパターンを取得"""
        sorted_patterns = sorted(
            self.error_patterns.items(),
            key=lambda x: x[1].frequency,
            reverse=True
        )
        
        return sorted_patterns[:limit]
    
    def get_best_fixes(self, limit: int = 10) -> List[CachedFix]:
        """成功率の高い修正を取得"""
        valid_fixes = [
            fix for fix in self.fix_cache.values()
            if not fix.is_expired() and fix.application_count >= 3
        ]
        
        sorted_fixes = sorted(
            valid_fixes,
            key=lambda f: f.success_rate,
            reverse=True
        )
        
        return sorted_fixes[:limit]
    
    def get_cache_hit_rate(self) -> float:
        """キャッシュヒット率を取得"""
        total = self.stats["cache_hits"] + self.stats["cache_misses"]
        if total == 0:
            return 0.0
        
        return self.stats["cache_hits"] / total
    
    def cleanup_expired(self) -> int:
        """有効期限切れのキャッシュを削除"""
        expired_keys = [
            key for key, fix in self.fix_cache.items()
            if fix.is_expired()
        ]
        
        for key in expired_keys:
            del self.fix_cache[key]
        
        if expired_keys:
            self._save_cache()
            logger.info(f"Cleaned up {len(expired_keys)} expired cache entries")
        
        return len(expired_keys)
    
    def cleanup_low_success_rate(self, threshold: float = 0.3) -> int:
        """成功率の低いキャッシュを削除"""
        low_success_keys = [
            key for key, fix in self.fix_cache.items()
            if fix.application_count >= 5 and fix.success_rate < threshold
        ]
        
        for key in low_success_keys:
            logger.info(f"Removing low success rate fix: {key} "
                       f"(rate={self.fix_cache[key].success_rate:.2f})")
            del self.fix_cache[key]
        
        if low_success_keys:
            self._save_cache()
            logger.info(f"Cleaned up {len(low_success_keys)} low success rate entries")
        
        return len(low_success_keys)
    
    def _enforce_cache_size_limit(self):
        """キャッシュサイズ制限を適用"""
        if len(self.fix_cache) <= self.max_cache_size:
            return
        
        # 最も使われていないエントリを削除（LRU）
        sorted_fixes = sorted(
            self.fix_cache.items(),
            key=lambda x: x[1].last_used
        )
        
        to_remove = len(self.fix_cache) - self.max_cache_size
        
        for key, _ in sorted_fixes[:to_remove]:
            del self.fix_cache[key]
        
        logger.info(f"Removed {to_remove} least recently used cache entries")
        self._save_cache()
    
    def get_statistics(self) -> Dict[str, Any]:
        """統計情報を取得"""
        valid_fixes = sum(1 for fix in self.fix_cache.values() if not fix.is_expired())
        expired_fixes = len(self.fix_cache) - valid_fixes
        
        avg_success_rate = 0.0
        if valid_fixes > 0:
            rates = [
                fix.success_rate for fix in self.fix_cache.values()
                if not fix.is_expired() and fix.application_count >= 3
            ]
            if rates:
                avg_success_rate = sum(rates) / len(rates)
        
        return {
            **self.stats,
            "cache_hit_rate": round(self.get_cache_hit_rate() * 100, 2),
            "total_cached_fixes": len(self.fix_cache),
            "valid_fixes": valid_fixes,
            "expired_fixes": expired_fixes,
            "error_patterns": len(self.error_patterns),
            "avg_fix_success_rate": round(avg_success_rate * 100, 2)
        }
    
    def export_report(self) -> Dict[str, Any]:
        """詳細レポートをエクスポート"""
        return {
            "statistics": self.get_statistics(),
            "frequent_errors": [
                {
                    "pattern_key": key,
                    "error_type": pattern.error_type,
                    "frequency": pattern.frequency,
                    "last_seen": pattern.last_seen.isoformat()
                }
                for key, pattern in self.get_frequent_errors()
            ],
            "best_fixes": [
                {
                    "error_hash": fix.error_hash,
                    "success_rate": round(fix.success_rate * 100, 2),
                    "application_count": fix.application_count,
                    "description": fix.fix_description[:100]
                }
                for fix in self.get_best_fixes()
            ],
            "generated_at": datetime.now().isoformat()
        }
    
    def _save_cache(self):
        """キャッシュをファイルに保存"""
        try:
            with open(self.cache_file, 'wb') as f:
                pickle.dump(self.fix_cache, f)
            logger.debug(f"Cache saved: {len(self.fix_cache)} entries")
        except Exception as e:
            logger.error(f"Failed to save cache: {e}")
    
    def _load_cache(self):
        """キャッシュをファイルから読み込む"""
        if not self.cache_file.exists():
            return
        
        try:
            with open(self.cache_file, 'rb') as f:
                self.fix_cache = pickle.load(f)
            logger.info(f"Cache loaded: {len(self.fix_cache)} entries")
        except Exception as e:
            logger.error(f"Failed to load cache: {e}")
            self.fix_cache = {}
    
    def _save_patterns(self):
        """エラーパターンをファイルに保存"""
        try:
            patterns_data = {
                key: pattern.to_dict()
                for key, pattern in self.error_patterns.items()
            }
            
            with open(self.patterns_file, 'w', encoding='utf-8') as f:
                json.dump(patterns_data, f, indent=2, ensure_ascii=False)
            
            logger.debug(f"Patterns saved: {len(self.error_patterns)} patterns")
        except Exception as e:
            logger.error(f"Failed to save patterns: {e}")
    
    def _load_patterns(self):
        """エラーパターンをファイルから読み込む"""
        if not self.patterns_file.exists():
            return
        
        try:
            with open(self.patterns_file, 'r', encoding='utf-8') as f:
                patterns_data = json.load(f)
            
            for key, pattern_dict in patterns_data.items():
                pattern = ErrorPattern(
                    error_type=pattern_dict["error_type"],
                    error_message_pattern=pattern_dict["error_message_pattern"],
                    stack_trace_pattern=pattern_dict["stack_trace_pattern"],
                    file_pattern=pattern_dict["file_pattern"],
                    frequency=pattern_dict["frequency"],
                    last_seen=datetime.fromisoformat(pattern_dict["last_seen"])
                )
                self.error_patterns[key] = pattern
            
            logger.info(f"Patterns loaded: {len(self.error_patterns)} patterns")
        except Exception as e:
            logger.error(f"Failed to load patterns: {e}")
            self.error_patterns = {}


# 使用例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    cache_manager = CacheManagerAgent()
    
    # エラーコンテキストの例
    error_context1 = {
        "error_type": "ImportError",
        "error_message": "cannot import name 'foo' from 'bar'",
        "stack_trace": "Traceback...\n  in main\n  in process",
        "source_file": "/path/to/file.py"
    }
    
    # 修正をキャッシュ
    error_hash = cache_manager.cache_fix(
        error_context1,
        fix_code="from bar import foo_new as foo",
        fix_description="Updated import statement",
        ttl_hours=168
    )
    
    print(f"\nCached fix with hash: {error_hash}")
    
    # キャッシュから取得
    cached_fix = cache_manager.get_cached_fix(error_context1)
    if cached_fix:
        print(f"\nCache hit! Fix: {cached_fix.fix_description}")
    
    # 修正結果を記録
    cache_manager.record_fix_result(error_hash, success=True)
    cache_manager.record_fix_result(error_hash, success=True)
    cache_manager.record_fix_result(error_hash, success=False)
    
    # 類似エラーをテスト
    error_context2 = {
        "error_type": "ImportError",
        "error_message": "cannot import name 'baz' from 'qux'",
        "stack_trace": "Traceback...\n  in main\n  in process",
        "source_file": "/path/to/other.py"
    }
    
    similar_fix = cache_manager.get_cached_fix(error_context2)
    if similar_fix:
        print(f"\nSimilar fix found! Description: {similar_fix.fix_description}")
    
    # 統計情報
    stats = cache_manager.get_statistics()
    print(f"\nStatistics:")
    print(json.dumps(stats, indent=2))
    
    # レポート
    report = cache_manager.export_report()
    print(f"\nReport:")
    print(json.dumps(report, indent=2))


#cloud_fix_agent.py
# cloud_fix_agent.py
"""
クラウド修正エージェント
複雑なエラーをクラウドAIで修正
"""

import asyncio
import logging
import os
import json
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path

from data_models import BugFixTask, FixResult, ErrorContextModel

logger = logging.getLogger(__name__)


class CloudFixAgent:
    """
    クラウド修正エージェント
    
    特徴:
    - 高性能AI（GPT-4o, Claude Opus, Gemini等）
    - 複雑なエラー対応
    - コンテキスト理解が深い
    - 大規模リファクタリング対応
    """
    
    def __init__(
        self,
        command_monitor,
        wp_tester=None,
        api_provider: str = "openai",  # openai, anthropic, google
        api_key: Optional[str] = None,
        model_name: Optional[str] = None
    ):
        """
        初期化
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_tester: WordPressTester
            api_provider: APIプロバイダー
            api_key: APIキー
            model_name: モデル名（省略時はデフォルト）
        """
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        self.api_provider = api_provider
        self.api_key = api_key or os.getenv(f"{api_provider.upper()}_API_KEY")
        
        # モデル名の設定
        self.model_name = model_name or self._get_default_model()
        
        # バックアップディレクトリ
        self.backup_dir = Path("./backups/cloud_fix")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # 修正履歴
        self.fix_history = []
        
        # 統計情報
        self.stats = {
            "total_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0,
            "total_api_calls": 0,
            "total_tokens_used": 0
        }
        
        # クライアント初期化
        self._init_api_client()
        
        logger.info(f"✅ CloudFixAgent 初期化完了 (provider={api_provider}, model={self.model_name})")
    
    def _get_default_model(self) -> str:
        """デフォルトモデル名を取得"""
        defaults = {
            "openai": "gpt-4o",
            "anthropic": "claude-opus-4",
            "google": "gemini-2.0-flash-exp"
        }
        return defaults.get(self.api_provider, "gpt-4o")
    
    def _init_api_client(self):
        """APIクライアントを初期化"""
        if self.api_provider == "openai":
            try:
                import openai
                self.client = openai.OpenAI(api_key=self.api_key)
                logger.info(f"✅ OpenAI API クライアント初期化完了 (model={self.model_name})")
            except ImportError:
                logger.error("❌ openai パッケージがインストールされていません")
                self.client = None
        
        elif self.api_provider == "anthropic":
            try:
                import anthropic
                self.client = anthropic.Anthropic(api_key=self.api_key)
                logger.info(f"✅ Anthropic API クライアント初期化完了 (model={self.model_name})")
            except ImportError:
                logger.error("❌ anthropic パッケージがインストールされていません")
                self.client = None
        
        elif self.api_provider == "google":
            try:
                import google.generativeai as genai
                genai.configure(api_key=self.api_key)
                self.client = genai.GenerativeModel(self.model_name)
                logger.info(f"✅ Google Gemini API クライアント初期化完了 (model={self.model_name})")
            except ImportError:
                logger.error("❌ google-generativeai パッケージがインストールされていません")
                self.client = None
    
    async def execute_bug_fix_task(self, bug_fix_task: BugFixTask) -> FixResult:
        """
        バグ修正タスクを実行（クラウドAI使用）
        
        Args:
            bug_fix_task: バグ修正タスク
            
        Returns:
            FixResult: 修正結果
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        try:
            logger.info("=" * 60)
            logger.info(f"☁️ クラウドバグ修正タスク実行: {task_id}")
            logger.info("=" * 60)
            
            self.stats["total_fixes"] += 1
            
            # 1. 詳細な修正プロンプトを構築
            fix_prompt = self._build_detailed_fix_prompt(bug_fix_task.error_context)
            logger.info(f"📝 詳細プロンプト構築完了 ({len(fix_prompt)}文字)")
            
            # 2. クラウドAIに修正を依頼
            ai_result = await self._request_cloud_ai_fix(fix_prompt)
            
            if not ai_result['success']:
                self.stats["failed_fixes"] += 1
                return self._create_failed_result(
                    task_id,
                    f"クラウドAI修正依頼失敗: {ai_result.get('error')}",
                    start_time
                )
            
            generated_code = ai_result['generated_code']
            modified_files = ai_result.get('modified_files', bug_fix_task.target_files)
            confidence = ai_result.get('confidence', 0.0)
            reasoning = ai_result.get('reasoning', '')
            
            logger.info(f"🤖 クラウドAI修正コード取得 ({len(generated_code)}文字, 信頼度={confidence})")
            
            # 3. バックアップ作成
            backup_path = await self._create_backup(bug_fix_task.target_files)
            logger.info(f"💾 バックアップ作成: {backup_path}")
            
            # 4. 修正コードを適用
            apply_result = await self._apply_fix_code(modified_files, generated_code)
            
            if not apply_result['success']:
                self.stats["failed_fixes"] += 1
                return self._create_failed_result(
                    task_id,
                    f"修正コード適用失敗: {apply_result.get('error')}",
                    start_time
                )
            
            # 5. テスト実行（オプション）
            test_passed = True
            if self.wp_tester and bug_fix_task.run_tests:
                test_result = await self._run_tests(bug_fix_task)
                test_passed = test_result['success']
                
                if not test_passed:
                    logger.warning(f"⚠️ テスト失敗: {test_result.get('error')}")
                    # バックアップから復元
                    await self._restore_from_backup(backup_path)
                    self.stats["failed_fixes"] += 1
                    return self._create_failed_result(
                        task_id,
                        f"テスト失敗: {test_result.get('error')}",
                        start_time
                    )
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            # 修正履歴に追加
            self.fix_history.append({
                "task_id": task_id,
                "timestamp": datetime.now().isoformat(),
                "provider": self.api_provider,
                "model": self.model_name,
                "confidence": confidence,
                "success": True,
                "execution_time": execution_time
            })
            
            self.stats["successful_fixes"] += 1
            
            logger.info(f"✅ クラウド修正完了: {task_id} ({execution_time:.2f}秒)")
            
            return FixResult(
                task_id=task_id,
                success=True,
                modified_files=modified_files,
                generated_code=generated_code,
                test_passed=test_passed,
                execution_time=execution_time,
                confidence_score=confidence,
                reasoning=reasoning,
                backup_path=str(backup_path)
            )
            
        except Exception as e:
            logger.error(f"💥 クラウド修正エラー: {e}", exc_info=True)
            self.stats["failed_fixes"] += 1
            return self._create_failed_result(task_id, str(e), start_time)
    
    def _build_detailed_fix_prompt(self, error_context: ErrorContextModel) -> str:
        """
        クラウドAI用の詳細なプロンプトを構築
        
        Args:
            error_context: エラーコンテキスト
            
        Returns:
            str: 詳細な修正プロンプト
        """
        prompt_parts = []
        
        # システムプロンプト
        prompt_parts.append("""あなたは熟練したPython開発者であり、エラー修正のエキスパートです。
以下のエラーを分析し、最適な修正コードを生成してください。

## 出力形式
以下のJSON形式で出力してください：

```json
{
    "analysis": "エラーの詳細な分析",
    "root_cause": "根本原因",
    "fix_strategy": "修正戦略",
    "modified_files": {
        "ファイルパス1": "完全な修正後のコード",
        "ファイルパス2": "完全な修正後のコード"
    },
    "confidence": 0.95,
    "reasoning": "この修正を選んだ理由",
    "test_suggestions": ["テストケース1", "テストケース2"],
    "potential_side_effects": ["副作用1", "副作用2"]
}
```
""")
        prompt_parts.append("")
        
        # エラー情報（詳細）
        prompt_parts.append("=" * 60)
        prompt_parts.append("【エラー情報】")
        prompt_parts.append("=" * 60)
        prompt_parts.append(f"エラータイプ: {error_context.error_type}")
        prompt_parts.append(f"エラーメッセージ: {error_context.error_message}")
        prompt_parts.append(f"深刻度: {error_context.severity.value}")
        prompt_parts.append(f"カテゴリ: {error_context.error_category.value}")
        prompt_parts.append(f"発生ファイル: {error_context.file_path}:{error_context.line_number}")
        prompt_parts.append("")
        
        # スタックトレース（全体）
        if error_context.full_traceback:
            prompt_parts.append("【完全なスタックトレース】")
            prompt_parts.append("```python")
            prompt_parts.append(error_context.full_traceback)
            prompt_parts.append("```")
            prompt_parts.append("")
        
        # 周辺コード（詳細）
        if error_context.surrounding_code:
            prompt_parts.append("【周辺コード（前後10行）】")
            prompt_parts.append("```python")
            prompt_parts.append(error_context.surrounding_code)
            prompt_parts.append("```")
            prompt_parts.append("")
        
        # ローカル変数（全体）
        if error_context.local_variables:
            prompt_parts.append("【ローカル変数の状態】")
            prompt_parts.append("```python")
            for var_name, var_value in error_context.local_variables.items():
                prompt_parts.append(f"{var_name} = {var_value}")
            prompt_parts.append("```")
            prompt_parts.append("")
        
        # コンテキスト情報
        if error_context.context_info:
            prompt_parts.append("【追加コンテキスト】")
            for key, value in error_context.context_info.items():
                prompt_parts.append(f"- {key}: {value}")
            prompt_parts.append("")
        
        # 過去の修正履歴（参考）
        if self.fix_history:
            prompt_parts.append("【過去の修正履歴（参考）】")
            recent_fixes = self.fix_history[-3:]  # 直近3件
            for fix in recent_fixes:
                if fix.get('success'):
                    prompt_parts.append(f"- {fix['task_id']}: 成功 (信頼度={fix.get('confidence', 'N/A')})")
            prompt_parts.append("")
        
        prompt_parts.append("=" * 60)
        prompt_parts.append("上記の情報を基に、最適な修正コードをJSON形式で提供してください。")
        prompt_parts.append("=" * 60)
        
        return "\n".join(prompt_parts)
    
    async def _request_cloud_ai_fix(self, prompt: str) -> Dict[str, Any]:
        """
        クラウドAIに修正を依頼
        
        Args:
            prompt: 修正プロンプト
            
        Returns:
            Dict: AI応答結果
        """
        try:
            self.stats["total_api_calls"] += 1
            
            if self.api_provider == "openai":
                return await self._request_openai(prompt)
            elif self.api_provider == "anthropic":
                return await self._request_anthropic(prompt)
            elif self.api_provider == "google":
                return await self._request_google(prompt)
            else:
                return {
                    "success": False,
                    "error": f"未サポートのプロバイダー: {self.api_provider}"
                }
                
        except Exception as e:
            logger.error(f"❌ AI API呼び出しエラー: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _request_openai(self, prompt: str) -> Dict[str, Any]:
        """OpenAI APIにリクエスト"""
        try:
            response = await asyncio.to_thread(
                self.client.chat.completions.create,
                model=self.model_name,
                messages=[
                    {"role": "system", "content": "あなたは熟練したPython開発者です。"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}
            )
            
            content = response.choices[0].message.content
            self.stats["total_tokens_used"] += response.usage.total_tokens
            
            result = json.loads(content)
            
            return {
                "success": True,
                "generated_code": result.get("modified_files", {}),
                "modified_files": list(result.get("modified_files", {}).keys()),
                "confidence": result.get("confidence", 0.8),
                "reasoning": result.get("reasoning", ""),
                "analysis": result.get("analysis", ""),
                "test_suggestions": result.get("test_suggestions", [])
            }
            
        except Exception as e:
            logger.error(f"❌ OpenAI API エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _request_anthropic(self, prompt: str) -> Dict[str, Any]:
        """Anthropic APIにリクエスト"""
        try:
            response = await asyncio.to_thread(
                self.client.messages.create,
                model=self.model_name,
                max_tokens=4096,
                temperature=0.3,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            self.stats["total_tokens_used"] += response.usage.input_tokens + response.usage.output_tokens
            
            result = json.loads(content)
            
            return {
                "success": True,
                "generated_code": result.get("modified_files", {}),
                "modified_files": list(result.get("modified_files", {}).keys()),
                "confidence": result.get("confidence", 0.8),
                "reasoning": result.get("reasoning", ""),
                "analysis": result.get("analysis", "")
            }
            
        except Exception as e:
            logger.error(f"❌ Anthropic API エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _request_google(self, prompt: str) -> Dict[str, Any]:
        """Google Gemini APIにリクエスト"""
        try:
            response = await asyncio.to_thread(
                self.client.generate_content,
                prompt,
                generation_config={
                    "temperature": 0.3,
                    "response_mime_type": "application/json"
                }
            )
            
            content = response.text
            result = json.loads(content)
            
            return {
                "success": True,
                "generated_code": result.get("modified_files", {}),
                "modified_files": list(result.get("modified_files", {}).keys()),
                "confidence": result.get("confidence", 0.8),
                "reasoning": result.get("reasoning", "")
            }
            
        except Exception as e:
            logger.error(f"❌ Google Gemini API エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _create_backup(self, target_files: List[str]) -> Path:
        """バックアップを作成"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_subdir = self.backup_dir / timestamp
        backup_subdir.mkdir(parents=True, exist_ok=True)
        
        for file_path in target_files:
            src = Path(file_path)
            if src.exists():
                dst = backup_subdir / src.name
                await asyncio.to_thread(dst.write_text, src.read_text(encoding='utf-8'))
        
        return backup_subdir
    
    async def _apply_fix_code(self, modified_files: Dict[str, str], code: str) -> Dict[str, Any]:
        """修正コードを適用"""
        try:
            if isinstance(code, dict):
                # 辞書形式（ファイルパス: コード）
                for file_path, file_code in code.items():
                    target = Path(file_path)
                    await asyncio.to_thread(target.write_text, file_code, encoding='utf-8')
                    logger.info(f"✅ 修正適用: {file_path}")
            else:
                # 単一コード
                if modified_files:
                    target = Path(modified_files[0])
                    await asyncio.to_thread(target.write_text, code, encoding='utf-8')
                    logger.info(f"✅ 修正適用: {modified_files[0]}")
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"❌ 修正コード適用エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _restore_from_backup(self, backup_path: Path):
        """バックアップから復元"""
        try:
            for backup_file in backup_path.glob("*"):
                # 元のファイルパスを推定（簡易版）
                original_path = Path(backup_file.name)
                if original_path.exists():
                    content = await asyncio.to_thread(backup_file.read_text, encoding='utf-8')
                    await asyncio.to_thread(original_path.write_text, content, encoding='utf-8')
                    logger.info(f"♻️ バックアップから復元: {original_path}")
        except Exception as e:
            logger.error(f"❌ バックアップ復元エラー: {e}")
    
    async def _run_tests(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """テストを実行"""
        if not self.wp_tester:
            return {"success": True, "message": "テスター未設定"}
        
        try:
            test_result = await self.wp_tester.run_tests(bug_fix_task.task_id)
            return {
                "success": test_result.get("passed", False),
                "error": test_result.get("error") if not test_result.get("passed") else None
            }
        except Exception as e:
            logger.error(f"❌ テスト実行エラー: {e}")
            return {"success": False, "error": str(e)}
    
    def _create_failed_result(
        self, 
        task_id: str, 
        error_message: str, 
        start_time: datetime
    ) -> FixResult:
        """失敗結果を作成"""
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return FixResult(
            task_id=task_id,
            success=False,
            modified_files=[],
            generated_code="",
            test_passed=False,
            execution_time=execution_time,
            error_message=error_message,
            confidence_score=0.0
        )
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_fixes"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_fixes"]
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "provider": self.api_provider,
            "model": self.model_name
        }

#cloud_storage_manager.py
# cloud_storage_manager.py
"""
クラウドストレージマネージャー
ローカルとクラウドストレージの透過的な連携
"""

import asyncio
import logging
import os
import json
from typing import Dict, Any, Optional, Union
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class CloudStorageManager:
    """
    クラウドストレージマネージャー
    
    機能:
    - ローカルとクラウドストレージの透過的なアクセス
    - 自動同期
    - キャッシュ管理
    - 複数のクラウドプロバイダー対応
    """
    
    def __init__(
        self,
        provider: str = "local",  # local, gcs, s3, azure
        bucket_name: Optional[str] = None,
        local_cache_dir: str = "./storage_cache",
        auto_sync: bool = True
    ):
        """
        初期化
        
        Args:
            provider: ストレージプロバイダー
            bucket_name: バケット/コンテナ名
            local_cache_dir: ローカルキャッシュディレクトリ
            auto_sync: 自動同期フラグ
        """
        self.provider = provider
        self.bucket_name = bucket_name
        self.local_cache_dir = Path(local_cache_dir)
        self.auto_sync = auto_sync
        
        # キャッシュディレクトリ作成
        self.local_cache_dir.mkdir(parents=True, exist_ok=True)
        
        # クラウドクライアント
        self.client = None
        self.bucket = None
        
        # 統計情報
        self.stats = {
            "uploads": 0,
            "downloads": 0,
            "cache_hits": 0,
            "cache_misses": 0
        }
        
        # プロバイダー初期化
        if provider != "local":
            self._init_cloud_provider()
        
        logger.info(f"✅ CloudStorageManager 初期化完了 (provider={provider})")
    
    def _init_cloud_provider(self):
        """クラウドプロバイダーを初期化"""
        try:
            if self.provider == "gcs":
                self._init_gcs()
            elif self.provider == "s3":
                self._init_s3()
            elif self.provider == "azure":
                self._init_azure()
            else:
                logger.warning(f"⚠️ 未サポートのプロバイダー: {self.provider}")
        
        except Exception as e:
            logger.error(f"❌ クラウドプロバイダー初期化エラー: {e}")
            logger.warning("⚠️ ローカルモードにフォールバック")
            self.provider = "local"
    
    def _init_gcs(self):
        """Google Cloud Storage初期化"""
        try:
            from google.cloud import storage
            self.client = storage.Client()
            self.bucket = self.client.bucket(self.bucket_name)
            logger.info(f"✅ GCS バケット接続: {self.bucket_name}")
        except ImportError:
            logger.error("❌ google-cloud-storage パッケージがインストールされていません")
            raise
    
    def _init_s3(self):
        """AWS S3初期化"""
        try:
            import boto3
            self.client = boto3.client('s3')
            self.bucket_name = self.bucket_name
            logger.info(f"✅ S3 バケット接続: {self.bucket_name}")
        except ImportError:
            logger.error("❌ boto3 パッケージがインストールされていません")
            raise
    
    def _init_azure(self):
        """Azure Blob Storage初期化"""
        try:
            from azure.storage.blob import BlobServiceClient
            connection_string = os.getenv("AZURE_STORAGE_CONNECTION_STRING")
            self.client = BlobServiceClient.from_connection_string(connection_string)
            self.bucket = self.client.get_container_client(self.bucket_name)
            logger.info(f"✅ Azure コンテナ接続: {self.bucket_name}")
        except ImportError:
            logger.error("❌ azure-storage-blob パッケージがインストールされていません")
            raise
    
    # ========================================
    # 基本操作（透過的API）
    # ========================================
    
    async def read_file(
        self, 
        file_path: str,
        encoding: Optional[str] = 'utf-8'
    ) -> Union[str, bytes]:
        """
        ファイルを読み込み（ローカル/クラウド透過的）
        
        Args:
            file_path: ファイルパス
            encoding: エンコーディング（Noneの場合はバイナリ）
            
        Returns:
            Union[str, bytes]: ファイル内容
        """
        try:
            # キャッシュチェック
            cached_path = self._get_cache_path(file_path)
            
            if cached_path.exists():
                self.stats["cache_hits"] += 1
                logger.debug(f"📦 キャッシュヒット: {file_path}")
                
                if encoding:
                    return await asyncio.to_thread(
                        cached_path.read_text,
                        encoding=encoding
                    )
                else:
                    return await asyncio.to_thread(cached_path.read_bytes)
            
            self.stats["cache_misses"] += 1
            
            # クラウドから読み込み
            if self.provider != "local":
                content = await self._download_from_cloud(file_path)
                
                # キャッシュに保存
                if self.auto_sync:
                    await self._save_to_cache(file_path, content)
                
                if encoding and isinstance(content, bytes):
                    return content.decode(encoding)
                return content
            
            # ローカルから読み込み
            local_path = Path(file_path)
            if encoding:
                return await asyncio.to_thread(
                    local_path.read_text,
                    encoding=encoding
                )
            else:
                return await asyncio.to_thread(local_path.read_bytes)
            
        except Exception as e:
            logger.error(f"❌ ファイル読み込みエラー: {file_path} - {e}")
            raise
    
    async def write_file(
        self,
        file_path: str,
        content: Union[str, bytes],
        encoding: Optional[str] = 'utf-8'
    ):
        """
        ファイルを書き込み（ローカル/クラウド透過的）
        
        Args:
            file_path: ファイルパス
            content: 書き込む内容
            encoding: エンコーディング
        """
        try:
            # ローカルに書き込み
            local_path = Path(file_path)
            local_path.parent.mkdir(parents=True, exist_ok=True)
            
            if isinstance(content, str):
                await asyncio.to_thread(
                    local_path.write_text,
                    content,
                    encoding=encoding
                )
            else:
                await asyncio.to_thread(local_path.write_bytes, content)
            
            # クラウドに同期
            if self.provider != "local" and self.auto_sync:
                await self._upload_to_cloud(file_path, content)
            
            # キャッシュを更新
            await self._save_to_cache(file_path, content)
            
            logger.debug(f"✅ ファイル書き込み成功: {file_path}")
            
        except Exception as e:
            logger.error(f"❌ ファイル書き込みエラー: {file_path} - {e}")
            raise
    
    async def file_exists(self, file_path: str) -> bool:
        """ファイルの存在確認"""
        try:
            # ローカルチェック
            if Path(file_path).exists():
                return True
            
            # クラウドチェック
            if self.provider != "local":
                return await self._exists_in_cloud(file_path)
            
            return False
            
        except Exception as e:
            logger.error(f"❌ 存在確認エラー: {file_path} - {e}")
            return False
    
    async def delete_file(self, file_path: str):
        """ファイル削除"""
        try:
            # ローカル削除
            local_path = Path(file_path)
            if local_path.exists():
                await asyncio.to_thread(local_path.unlink)
            
            # クラウド削除
            if self.provider != "local":
                await self._delete_from_cloud(file_path)
            
            # キャッシュ削除
            cached_path = self._get_cache_path(file_path)
            if cached_path.exists():
                await asyncio.to_thread(cached_path.unlink)
            
            logger.debug(f"✅ ファイル削除成功: {file_path}")
            
        except Exception as e:
            logger.error(f"❌ ファイル削除エラー: {file_path} - {e}")
            raise
    
    # ========================================
    # クラウド操作（プロバイダー別）
    # ========================================
    
    async def _download_from_cloud(self, file_path: str) -> bytes:
        """クラウドからダウンロード"""
        self.stats["downloads"] += 1
        
        if self.provider == "gcs":
            return await self._download_from_gcs(file_path)
        elif self.provider == "s3":
            return await self._download_from_s3(file_path)
        elif self.provider == "azure":
            return await self._download_from_azure(file_path)
        else:
            raise ValueError(f"Unsupported provider: {self.provider}")
    
    async def _upload_to_cloud(self, file_path: str, content: Union[str, bytes]):
        """クラウドにアップロード"""
        self.stats["uploads"] += 1
        
        if isinstance(content, str):
            content = content.encode('utf-8')
        
        if self.provider == "gcs":
            await self._upload_to_gcs(file_path, content)
        elif self.provider == "s3":
            await self._upload_to_s3(file_path, content)
        elif self.provider == "azure":
            await self._upload_to_azure(file_path, content)
    
    async def _exists_in_cloud(self, file_path: str) -> bool:
        """クラウドでの存在確認"""
        if self.provider == "gcs":
            return await self._exists_in_gcs(file_path)
        elif self.provider == "s3":
            return await self._exists_in_s3(file_path)
        elif self.provider == "azure":
            return await self._exists_in_azure(file_path)
        return False
    
    async def _delete_from_cloud(self, file_path: str):
        """クラウドから削除"""
        if self.provider == "gcs":
            await self._delete_from_gcs(file_path)
        elif self.provider == "s3":
            await self._delete_from_s3(file_path)
        elif self.provider == "azure":
            await self._delete_from_azure(file_path)
    
    # ========================================
    # GCS操作
    # ========================================
    
    async def _download_from_gcs(self, file_path: str) -> bytes:
        """GCSからダウンロード"""
        blob = self.bucket.blob(file_path)
        return await asyncio.to_thread(blob.download_as_bytes)
    
    async def _upload_to_gcs(self, file_path: str, content: bytes):
        """GCSにアップロード"""
        blob = self.bucket.blob(file_path)
        await asyncio.to_thread(blob.upload_from_string, content)
    
    async def _exists_in_gcs(self, file_path: str) -> bool:
        """GCSでの存在確認"""
        blob = self.bucket.blob(file_path)
        return await asyncio.to_thread(blob.exists)
    
    async def _delete_from_gcs(self, file_path: str):
        """GCSから削除"""
        blob = self.bucket.blob(file_path)
        await asyncio.to_thread(blob.delete)
    
    # ========================================
    # S3操作
    # ========================================
    
    async def _download_from_s3(self, file_path: str) -> bytes:
        """S3からダウンロード"""
        response = await asyncio.to_thread(
            self.client.get_object,
            Bucket=self.bucket_name,
            Key=file_path
        )
        return response['Body'].read()
    
    async def _upload_to_s3(self, file_path: str, content: bytes):
        """S3にアップロード"""
        await asyncio.to_thread(
            self.client.put_object,
            Bucket=self.bucket_name,
            Key=file_path,
            Body=content
        )
    
    async def _exists_in_s3(self, file_path: str) -> bool:
        """S3での存在確認"""
        try:
            await asyncio.to_thread(
                self.client.head_object,
                Bucket=self.bucket_name,
                Key=file_path
            )
            return True
        except:
            return False
    
    async def _delete_from_s3(self, file_path: str):
        """S3から削除"""
        await asyncio.to_thread(
            self.client.delete_object,
            Bucket=self.bucket_name,
            Key=file_path
        )
    
    # ========================================
    # Azure操作
    # ========================================
    
    async def _download_from_azure(self, file_path: str) -> bytes:
        """Azureからダウンロード"""
        blob_client = self.bucket.get_blob_client(file_path)
        return await asyncio.to_thread(blob_client.download_blob().readall)
    
    async def _upload_to_azure(self, file_path: str, content: bytes):
        """Azureにアップロード"""
        blob_client = self.bucket.get_blob_client(file_path)
        await asyncio.to_thread(blob_client.upload_blob, content, overwrite=True)
    
    async def _exists_in_azure(self, file_path: str) -> bool:
        """Azureでの存在確認"""
        blob_client = self.bucket.get_blob_client(file_path)
        return await asyncio.to_thread(blob_client.exists)
    
    async def _delete_from_azure(self, file_path: str):
        """Azureから削除"""
        blob_client = self.bucket.get_blob_client(file_path)
        await asyncio.to_thread(blob_client.delete_blob)
    
    # ========================================
    # キャッシュ管理
    # ========================================
    
    def _get_cache_path(self, file_path: str) -> Path:
        """キャッシュパスを取得"""
        # ファイルパスをキャッシュディレクトリ内のパスに変換
        safe_path = file_path.replace("/", "_").replace("\\", "_")
        return self.local_cache_dir / safe_path
    
    async def _save_to_cache(self, file_path: str, content: Union[str, bytes]):
        """キャッシュに保存"""
        try:
            cached_path = self._get_cache_path(file_path)
            
            if isinstance(content, str):
                await asyncio.to_thread(
                    cached_path.write_text,
                    content,
                    encoding='utf-8'
                )
            else:
                await asyncio.to_thread(cached_path.write_bytes, content)
            
        except Exception as e:
            logger.warning(f"⚠️ キャッシュ保存失敗: {file_path} - {e}")
    
    async def clear_cache(self):
        """キャッシュをクリア"""
        try:
            for cache_file in self.local_cache_dir.glob("*"):
                await asyncio.to_thread(cache_file.unlink)
            
            logger.info("✅ キャッシュクリア完了")
            
        except Exception as e:
            logger.error(f"❌ キャッシュクリアエラー: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        cache_hit_rate = 0.0
        total_cache_ops = self.stats["cache_hits"] + self.stats["cache_misses"]
        
        if total_cache_ops > 0:
            cache_hit_rate = self.stats["cache_hits"] / total_cache_ops
        
        return {
            **self.stats,
            "cache_hit_rate": cache_hit_rate,
            "provider": self.provider
        }

#code_review_agent.py
# code_review_agent.py
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class CodeReviewAgent:
    """コードレビューAI - プログラムコードの改善を提案"""
    
    CODE_REVIEW_PROMPT = """あなたは優秀なソフトウェアエンジニアです。以下のプログラムコードをレビューし、改善点を提案してください。

【コード情報】
- ファイル名: {filename}
- エージェント名: {agent_name}
- コード行数: {line_count}
- ファイルサイズ: {file_size}文字

【レビュー観点】
1. バグやエラーの可能性がある部分
2. パフォーマンス改善できる部分  
3. 可読性・保守性向上の提案
4. セキュリティ上の問題
5. Pythonのベストプラクティス違反

【コード内容】
```python
{code_content}
【出力形式】

コードレビュー結果: {agent_name}
🔍 発見した問題点
問題1: [具体的な問題と場所]

問題2: [具体的な問題と場所]

💡 改善提案
提案1: [具体的な改善方法]

提案2: [具体的な改善方法]

🚀 推奨修正例

# 修正前
[問題のあるコード]

# 修正後  
[改善したコード]


📊 総合評価
[コードの品質を簡単に評価]"""

def __init__(self, browser_controller):
    self.browser = browser_controller

async def review_code(self, agent_name, code_data):
    """コードをレビューして改善提案"""
    try:
        logger.info(f"🔍 {agent_name} のコードレビュー開始")
        
        # プロンプト作成
        prompt = self.CODE_REVIEW_PROMPT.format(
            filename=code_data['filename'],
            agent_name=agent_name,
            line_count=code_data['content'].count('\n') + 1,
            file_size=len(code_data['content']),
            code_content=code_data['content'][:3000]  # 最初の3000文字のみ
        )
        
        # AIにレビュー依頼
        await self.browser.send_prompt(prompt)
        success = await self.browser.wait_for_text_generation(max_wait=120)
        
        if not success:
            return None
        
        # 結果取得
        review_result = await self.browser.extract_latest_text_response()
        return review_result
        
    except Exception as e:
        logger.error(f"❌ コードレビューエラー: {e}")
        return None
    




#command_monitor_agent.py
# command_monitor_agent.py - ACF監視強化版
import asyncio
import re
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Optional, Callable
from datetime import datetime

logger = logging.getLogger(__name__)

class CommandMonitorAgent:
    """コマンド実行と出力監視 - ACF/WP-CLI特化版"""
    

    def __init__(self, browser_controller, sheets_manager):
        self.browser_controller = browser_controller
        self.sheets_manager = sheets_manager
    
        # 既存のエラーパターン
        self.error_patterns = [
            r'Error:', r'Exception:', r'Traceback'
        ]
    
        # === 新規追加: PHP固有のエラーパターン ===
        self.php_error_patterns = [
            r'Parse error:',
            r'Syntax error',
            r'Fatal error:',
            r'Warning:',
            r'Notice:',
            r'Undefined function',
            r'Undefined variable',
            r'Class.*not found',
            r'Call to undefined function',
            r'Cannot modify header information',
        ]
    
        # WP-CLI専用エラーパターン（強化版）
        self.wp_cli_error_patterns = [
            r'Error:\s+',
            r'Fatal error:',
            r'Plugin not found',
            r'Could not create',
            r'Database connection error',
            r'Warning:\s+[A-Z]',
            # === 新規追加: CPT登録関連エラー ===
            r'Invalid post type',
            r'Post type.*already exists',
            r'register_post_type.*failed',
            r'Permission denied',
            r'Failed to create',
        ]
    
        # === 新規追加: ACF専用エラーパターン ===
        self.acf_error_patterns = [
            r'ACF:\s+Error',
            r'Field group not found',
            r'Invalid field group',
            r'JSON decode error',
            r'acf_add_local_field_group.*failed',
            r'ACF.*not activated',
        ]
    
        self.wp_cli_success_patterns = [
            r'Success:',
            r'Plugin .* activated',
            r'Updated \d+ post',
            r'Created \d+ post',
            # === 新規追加: CPT登録成功パターン ===
            r'Post type.*registered',
            r'Custom post type.*created',
            r'Registration of.*successful',
        ]
    
        # === 新規追加: CPT警告パターン ===
        self.cpt_warning_patterns = [
            r'Post type.*already registered',
            r'Duplicate post type',
            r'Menu position conflict',
            r'Rewrite rules may need to be flushed',
        ]
    
    def _detect_errors(self, output: str) -> bool:
        """エラー検出 - ACF対応強化"""
        # 汎用エラーチェック
        for pattern in self.error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                return True
        
        # WP-CLI専用エラーチェック
        for pattern in self.wp_cli_error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.warning(f"⚠️ WP-CLI/ACFエラー検出: {pattern}")
                return True
        
        return False
    
    def _validate_wp_cli_success(self, output: str, expected_action: str) -> bool:
        """WP-CLI実行の成功検証 - ACF対応"""
        # 成功パターンのマッチング
        for pattern in self.wp_cli_success_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.info(f"✅ WP-CLI成功: {expected_action}")
                return True
        
        logger.error(f"❌ WP-CLI成功メッセージ未検出: {expected_action}")
        return False
    
    def _extract_acf_field_group_info(self, output: str) -> Optional[Dict]:
        """ACFフィールドグループ情報の抽出（新規追加）"""
        try:
            info = {}
            
            # フィールドグループキーの抽出
            key_match = re.search(r'group_([a-z0-9_]+)', output)
            if key_match:
                info['key'] = key_match.group(0)
            
            # フィールド数の抽出
            fields_match = re.search(r'(\d+)\s+field', output, re.IGNORECASE)
            if fields_match:
                info['field_count'] = int(fields_match.group(1))
            
            # エラーの抽出
            errors = self._extract_errors(output)
            if errors:
                info['errors'] = errors
            
            # 警告の抽出
            warnings = self._extract_acf_warnings(output)
            if warnings:
                info['warnings'] = warnings
            
            return info if info else None
            
        except Exception as e:
            logger.error(f"ACF情報抽出エラー: {e}")
            return None
    
    def _extract_acf_warnings(self, output: str) -> List[str]:
        """ACF警告メッセージを抽出（新規追加）"""
        warnings = []
        lines = output.split('\n')
        
        for i, line in enumerate(lines):
            for pattern in self.acf_warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        return warnings
    
    async def execute_command(self, command: str, timeout: int = 300) -> Dict:
        """コマンドを実行して出力を監視 - ACF情報抽出追加"""
        try:
            logger.info(f"🔧 コマンド実行: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            
            output = stdout.decode('utf-8', errors='ignore')
            error_output = stderr.decode('utf-8', errors='ignore')
            return_code = process.returncode
            
            # === 新規追加: ACFコマンドの特別処理 ===
            acf_info = None
            if 'wp acf' in command:
                acf_info = self._extract_acf_field_group_info(output + error_output)
                if acf_info:
                    logger.info(f"📋 ACF情報: {acf_info}")
            
            result = {
                'command': command,
                'return_code': return_code,
                'stdout': output,
                'stderr': error_output,
                'timestamp': datetime.now().isoformat(),
                'has_errors': self._detect_errors(output + error_output),
                'errors': self._extract_errors(output + error_output),
                'warnings': self._extract_warnings(output + error_output),
                'acf_info': acf_info  # ACF固有情報
            }
            
            # 結果のサマリーログ
            if result['has_errors']:
                logger.error(f"❌ コマンド実行エラー: {command}")
                for error in result['errors']:
                    logger.error(f"   {error}")
            elif result['warnings']:
                logger.warning(f"⚠️ コマンド実行警告: {command}")
                for warning in result['warnings']:
                    logger.warning(f"   {warning}")
            else:
                logger.info(f"✅ コマンド実行成功: {command}")
            
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"⏱️ コマンドタイムアウト ({timeout}秒): {command}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': f'コマンド実行タイムアウト ({timeout}秒)',
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [f'実行タイムアウト ({timeout}秒)'],
                'warnings': [],
                'acf_info': None
            }
        except Exception as e:
            logger.error(f"💥 コマンド実行エラー: {e}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': str(e),
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [str(e)],
                'warnings': [],
                'acf_info': None
            }
    
    def _extract_errors(self, output: str) -> List[str]:
        """エラーメッセージを抽出"""
        errors = []
        lines = output.split('\n')
        
        # 汎用エラー + WP-CLI/ACFエラー
        all_error_patterns = self.error_patterns + self.wp_cli_error_patterns
        
        for i, line in enumerate(lines):
            for pattern in all_error_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    # エラー行とその前後2行を取得
                    start = max(0, i - 2)
                    end = min(len(lines), i + 3)
                    context = '\n'.join(lines[start:end])
                    errors.append(context)
                    break
        
        return errors
    
    def _extract_warnings(self, output: str) -> List[str]:
        """警告メッセージを抽出"""
        warnings = []
        lines = output.split('\n')
        
        warning_patterns = [r'Warning:', r'Notice:']
        
        for i, line in enumerate(lines):
            for pattern in warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        # ACF警告も追加
        acf_warnings = self._extract_acf_warnings(output)
        warnings.extend(acf_warnings)
        
        return warnings
    
    async def monitor_acf_import_process(self, json_path: Path, timeout: int = 180) -> Dict:
        """ACFインポートプロセスの専用監視（新規追加）"""
        try:
            logger.info(f"📥 ACFインポート監視開始: {json_path}")
            
            # WP-CLIコマンド実行
            command = f"wp acf import {json_path}"
            result = await self.execute_command(command, timeout=timeout)
            
            # 成功検証
            is_success = (
                result['return_code'] == 0 and
                not result['has_errors'] and
                self._validate_wp_cli_success(result['stdout'], 'ACF import')
            )
            
            if is_success:
                logger.info("✅ ACFインポート成功")
            else:
                logger.error("❌ ACFインポート失敗")
            
            return {
                'success': is_success,
                'command_result': result,
                'acf_info': result.get('acf_info'),
                'errors': result.get('errors', []),
                'warnings': result.get('warnings', [])
            }
            
        except Exception as e:
            logger.error(f"ACFインポート監視エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#compatibility_fix.py
"""
Python 3.13 非同期互換性修正
Windows環境でのasyncioプロアクターイベントの問題を解決
"""

import asyncio
import sys
import warnings

def apply_windows_async_fix():
    """Windows環境での非同期問題を修正"""
    if sys.platform == "win32":
        # ResourceWarningを無視（一時的対応）
        warnings.filterwarnings("ignore", category=ResourceWarning)
        
        # イベントループポリシーを設定
        if sys.version_info >= (3, 13):
            try:
                asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
            except Exception:
                # 既に設定されている場合は無視
                pass

def safe_async_shutdown():
    """安全な非同期シャットダウン"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            loop.stop()
        if not loop.is_closed():
            loop.close()
    except Exception:
        pass

#config_hybrid.py
# config_hybrid.py
"""
ハイブリッド型自律コード修正システム - 設定ファイル
"""

import os
from pathlib import Path
from typing import Optional
from dataclasses import dataclass, field


@dataclass
class HybridFixConfig:
    """ハイブリッド修正システムの設定"""
    
    # ========================================
    # 基本設定
    # ========================================
    
    # 実行モード
    run_mode: str = field(
        default_factory=lambda: os.getenv("RUN_MODE", "local")
    )  # local, cloud, hybrid
    
    # デフォルト修正戦略
    default_strategy: str = field(
        default_factory=lambda: os.getenv("DEFAULT_STRATEGY", "ADAPTIVE")
    )  # LOCAL_ONLY, CLOUD_ONLY, LOCAL_FIRST, CLOUD_FIRST, PARALLEL, ADAPTIVE
    
    # ========================================
    # ローカルエージェント設定
    # ========================================
    
    # ローカルAI使用フラグ
    use_local_ai: bool = field(
        default_factory=lambda: os.getenv("USE_LOCAL_AI", "true").lower() == "true"
    )
    
    # ローカル修正タイムアウト（秒）
    local_timeout: int = field(
        default_factory=lambda: int(os.getenv("LOCAL_TIMEOUT", "30"))
    )
    
    # ========================================
    # クラウドエージェント設定
    # ========================================
    
    # クラウドプロバイダー
    cloud_provider: str = field(
        default_factory=lambda: os.getenv("CLOUD_PROVIDER", "openai")
    )  # openai, anthropic, google
    
    # クラウドモデル名
    cloud_model: str = field(
        default_factory=lambda: os.getenv("CLOUD_MODEL", "gpt-4o")
    )
    
    # クラウド修正タイムアウト（秒）
    cloud_timeout: int = field(
        default_factory=lambda: int(os.getenv("CLOUD_TIMEOUT", "120"))
    )
    
    # APIキー
    openai_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("OPENAI_API_KEY")
    )
    
    anthropic_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("ANTHROPIC_API_KEY")
    )
    
    google_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("GOOGLE_API_KEY")
    )
    
    # ========================================
    # テスト設定
    # ========================================
    
    # 自動テスト有効化
    enable_auto_tests: bool = field(
        default_factory=lambda: os.getenv("ENABLE_AUTO_TESTS", "true").lower() == "true"
    )
    
    # WordPressパス
    wp_path: str = field(
        default_factory=lambda: os.getenv("WP_PATH", "/var/www/html")
    )
    
    # テストタイムアウト（秒）
    test_timeout: int = field(
        default_factory=lambda: int(os.getenv("TEST_TIMEOUT", "60"))
    )
    
    # ========================================
    # GitHub設定
    # ========================================
    
    # 自動PR作成有効化
    enable_auto_pr: bool = field(
        default_factory=lambda: os.getenv("ENABLE_AUTO_PR", "false").lower() == "true"
    )
    
    # GitHubトークン
    github_token: Optional[str] = field(
        default_factory=lambda: os.getenv("GITHUB_TOKEN")
    )
    
    # リポジトリパス
    repo_path: str = field(
        default_factory=lambda: os.getenv("REPO_PATH", ".")
    )
    
    # リポジトリオーナー
    repo_owner: Optional[str] = field(
        default_factory=lambda: os.getenv("REPO_OWNER")
    )
    
    # リポジトリ名
    repo_name: Optional[str] = field(
        default_factory=lambda: os.getenv("REPO_NAME")
    )
    
    # PRの自動マージ
    github_auto_merge: bool = field(
        default_factory=lambda: os.getenv("GITHUB_AUTO_MERGE", "false").lower() == "true"
    )
    
    # ========================================
    # ストレージ設定
    # ========================================
    
    # ストレージプロバイダー
    storage_provider: str = field(
        default_factory=lambda: os.getenv("STORAGE_PROVIDER", "local")
    )  # local, gcs, s3, azure
    
    # ストレージバケット名
    storage_bucket: Optional[str] = field(
        default_factory=lambda: os.getenv("STORAGE_BUCKET")
    )
    
    # 自動同期
    auto_sync_storage: bool = field(
        default_factory=lambda: os.getenv("AUTO_SYNC_STORAGE", "true").lower() == "true"
    )
    
    # ========================================
    # バックアップ設定
    # ========================================
    
    # バックアップディレクトリ
    backup_dir: str = field(
        default_factory=lambda: os.getenv("BACKUP_DIR", "./backups")
    )
    
    # 最大バックアップ数
    max_backups: int = field(
        default_factory=lambda: int(os.getenv("MAX_BACKUPS", "10"))
    )
    
    # バックアップ保持日数
    backup_retention_days: int = field(
        default_factory=lambda: int(os.getenv("BACKUP_RETENTION_DAYS", "30"))
    )
    
    # ========================================
    # リトライ設定
    # ========================================
    
    # 最大リトライ回数
    max_retry_count: int = field(
        default_factory=lambda: int(os.getenv("MAX_RETRY_COUNT", "3"))
    )
    
    # リトライ間隔（秒）
    retry_delay: int = field(
        default_factory=lambda: int(os.getenv("RETRY_DELAY", "5"))
    )
    
    # ========================================
    # ログ設定
    # ========================================
    
    # ログレベル
    log_level: str = field(
        default_factory=lambda: os.getenv("LOG_LEVEL", "INFO")
    )
    
    # ログファイル
    log_file: Optional[str] = field(
        default_factory=lambda: os.getenv("LOG_FILE", "./logs/hybrid_fix.log")
    )
    
    # ログローテーション
    log_rotation: str = field(
        default_factory=lambda: os.getenv("LOG_ROTATION", "10 MB")
    )
    
    # ========================================
    # パフォーマンス設定
    # ========================================
    
    # 並列実行の最大数
    max_parallel_fixes: int = field(
        default_factory=lambda: int(os.getenv("MAX_PARALLEL_FIXES", "3"))
    )
    
    # キャッシュ有効化
    enable_cache: bool = field(
        default_factory=lambda: os.getenv("ENABLE_CACHE", "true").lower() == "true"
    )
    
    # キャッシュTTL（秒）
    cache_ttl: int = field(
        default_factory=lambda: int(os.getenv("CACHE_TTL", "3600"))
    )
    
    # ========================================
    # 通知設定
    # ========================================
    
    # Slack通知
    enable_slack_notifications: bool = field(
        default_factory=lambda: os.getenv("ENABLE_SLACK_NOTIFICATIONS", "false").lower() == "true"
    )
    
    slack_webhook_url: Optional[str] = field(
        default_factory=lambda: os.getenv("SLACK_WEBHOOK_URL")
    )
    
    # メール通知
    enable_email_notifications: bool = field(
        default_factory=lambda: os.getenv("ENABLE_EMAIL_NOTIFICATIONS", "false").lower() == "true"
    )
    
    email_recipients: str = field(
        default_factory=lambda: os.getenv("EMAIL_RECIPIENTS", "")
    )
    
    # ========================================
    # ヘルスチェック設定
    # ========================================
    
    # ヘルスチェック間隔（秒）
    health_check_interval: int = field(
        default_factory=lambda: int(os.getenv("HEALTH_CHECK_INTERVAL", "60"))
    )
    
    # メトリクス収集
    enable_metrics: bool = field(
        default_factory=lambda: os.getenv("ENABLE_METRICS", "true").lower() == "true"
    )
    
    # ========================================
    # デバッグ設定
    # ========================================
    
    # デバッグモード
    debug_mode: bool = field(
        default_factory=lambda: os.getenv("DEBUG_MODE", "false").lower() == "true"
    )
    
    # 詳細ログ
    verbose_logging: bool = field(
        default_factory=lambda: os.getenv("VERBOSE_LOGGING", "false").lower() == "true"
    )
    
    # ドライラン（実際の修正を適用しない）
    dry_run: bool = field(
        default_factory=lambda: os.getenv("DRY_RUN", "false").lower() == "true"
    )
    
    def __post_init__(self):
        """初期化後の処理"""
        # ディレクトリを作成
        Path(self.backup_dir).mkdir(parents=True, exist_ok=True)
        
        if self.log_file:
            Path(self.log_file).parent.mkdir(parents=True, exist_ok=True)
    
    def validate(self) -> bool:
        """設定を検証"""
        errors = []
        
        # 戦略の検証
        valid_strategies = [
            "LOCAL_ONLY", "CLOUD_ONLY", "LOCAL_FIRST", 
            "CLOUD_FIRST", "PARALLEL", "ADAPTIVE"
        ]
        if self.default_strategy not in valid_strategies:
            errors.append(f"Invalid strategy: {self.default_strategy}")
        
        # クラウドプロバイダーの検証
        valid_providers = ["openai", "anthropic", "google"]
        if self.cloud_provider not in valid_providers:
            errors.append(f"Invalid cloud provider: {self.cloud_provider}")
        
        # APIキーの検証
        if self.cloud_provider == "openai" and not self.openai_api_key:
            errors.append("OpenAI API key is required")
        
        if self.cloud_provider == "anthropic" and not self.anthropic_api_key:
            errors.append("Anthropic API key is required")
        
        if self.cloud_provider == "google" and not self.google_api_key:
            errors.append("Google API key is required")
        
        # GitHub設定の検証
        if self.enable_auto_pr:
            if not self.github_token:
                errors.append("GitHub token is required for auto PR")
            if not self.repo_owner or not self.repo_name:
                errors.append("GitHub repo owner and name are required for auto PR")
        
        # ストレージ設定の検証
        valid_storage_providers = ["local", "gcs", "s3", "azure"]
        if self.storage_provider not in valid_storage_providers:
            errors.append(f"Invalid storage provider: {self.storage_provider}")
        
        if self.storage_provider != "local" and not self.storage_bucket:
            errors.append(f"Storage bucket is required for {self.storage_provider}")
        
        if errors:
            for error in errors:
                print(f"❌ 設定エラー: {error}")
            return False
        
        return True
    
    def print_config(self):
        """設定を表示"""
        print("\n" + "=" * 80)
        print("⚙️  ハイブリッド修正システム 設定")
        print("=" * 80)
        print(f"実行モード: {self.run_mode}")
        print(f"デフォルト戦略: {self.default_strategy}")
        print(f"\n【ローカルエージェント】")
        print(f"  ローカルAI: {'有効' if self.use_local_ai else '無効'}")
        print(f"  タイムアウト: {self.local_timeout}秒")
        print(f"\n【クラウドエージェント】")
        print(f"  プロバイダー: {self.cloud_provider}")
        print(f"  モデル: {self.cloud_model}")
        print(f"  タイムアウト: {self.cloud_timeout}秒")
        print(f"\n【テスト】")
        print(f"  自動テスト: {'有効' if self.enable_auto_tests else '無効'}")
        print(f"  WPパス: {self.wp_path}")
        print(f"\n【GitHub】")
        print(f"  自動PR: {'有効' if self.enable_auto_pr else '無効'}")
        if self.enable_auto_pr:
            print(f"  リポジトリ: {self.repo_owner}/{self.repo_name}")
        print(f"\n【ストレージ】")
        print(f"  プロバイダー: {self.storage_provider}")
        if self.storage_provider != "local":
            print(f"  バケット: {self.storage_bucket}")
        print(f"\n【バックアップ】")
        print(f"  ディレクトリ: {self.backup_dir}")
        print(f"  最大保持数: {self.max_backups}")
        print(f"\n【その他】")
        print(f"  デバッグモード: {'有効' if self.debug_mode else '無効'}")
        print(f"  ドライラン: {'有効' if self.dry_run else '無効'}")
        print("=" * 80 + "\n")
    
    @classmethod
    def from_env_file(cls, env_file: str = ".env"):
        """環境変数ファイルから設定を読み込み"""
        if Path(env_file).exists():
            from dotenv import load_dotenv
            load_dotenv(env_file)
        
        return cls()
    
    def to_dict(self) -> dict:
        """辞書形式に変換"""
        return {
            key: getattr(self, key)
            for key in self.__dataclass_fields__.keys()
        }


# ========================================
# プリセット設定
# ========================================

class DevelopmentConfig(HybridFixConfig):
    """開発環境用設定"""
    
    def __init__(self):
        super().__init__()
        self.run_mode = "local"
        self.default_strategy = "LOCAL_FIRST"
        self.use_local_ai = True
        self.enable_auto_pr = False
        self.debug_mode = True
        self.verbose_logging = True
        self.dry_run = True


class ProductionConfig(HybridFixConfig):
    """本番環境用設定"""
    
    def __init__(self):
        super().__init__()
        self.run_mode = "hybrid"
        self.default_strategy = "ADAPTIVE"
        self.use_local_ai = True
        self.enable_auto_tests = True
        self.enable_auto_pr = True
        self.storage_provider = "gcs"
        self.debug_mode = False
        self.dry_run = False


class CloudOnlyConfig(HybridFixConfig):
    """クラウドのみの設定"""
    
    def __init__(self):
        super().__init__()
        self.run_mode = "cloud"
        self.default_strategy = "CLOUD_ONLY"
        self.use_local_ai = False
        self.enable_auto_tests = True
        self.enable_auto_pr = True


# ========================================
# 設定ファクトリー
# ========================================

def get_config(env: str = "development") -> HybridFixConfig:
    """
    環境に応じた設定を取得
    
    Args:
        env: 環境名 (development, production, cloud_only)
        
    Returns:
        HybridFixConfig: 設定オブジェクト
    """
    configs = {
        "development": DevelopmentConfig,
        "production": ProductionConfig,
        "cloud_only": CloudOnlyConfig
    }
    
    config_class = configs.get(env, HybridFixConfig)
    config = config_class()
    
    # 環境変数から追加で読み込み
    if os.getenv("CONFIG_FROM_ENV", "false").lower() == "true":
        config = HybridFixConfig.from_env_file()
    
    return config


if __name__ == "__main__":
    # テスト実行
    config = get_config("development")
    
    print("設定の検証中...")
    if config.validate():
        print("✅ 設定は有効です")
        config.print_config()
    else:
        print("❌ 設定に問題があります")

#config_utils.py
import logging
import uuid
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import time

# config_utils.py の SmartLogFormatter クラスを修正

class SmartLogFormatter(logging.Formatter):
    """スマートなログフォーマッタ - 短縮識別版"""
    
    # クラス変数として状態を保持
    _message_count = 0
    _last_timestamp_display = 0
    _last_date_display = ""
    _lock = False
    
    # エージェント別の絵文字マッピング（短縮版）
    AGENT_EMOJIS = {
        # 🏃‍♂️ 実行系
        'run_multi_agent': '🚀 multi-agent',
        '__main__': '🏁 main',
    
        # 👑 PM系
        'pm_agent': '👑 pm-agent',
        'pm_system_prompts': '📋 pm-prompts',
    
        # ⚙️ タスク実行系
        'task_executor': '⚙️ task-exec',
        'task_executor_content': '📝 task-content',
        'task_executor_ma': '🔍 task-ma',
        'task_coordinator': '🎯 task-coord',
        'content_task_executor': '📄 content-exec',
        'system_cli_executor': '💻 cli-exec',
        'workflow_executor': '🔄 workflow',
        'test_tasks': '🧪 test-tasks',
    
        # 🎨 デザイン系
        'design_agent': '🎨 design',
        'ui_agent': '📱 ui',
    
        # 💻 開発系
        'dev_agent': '💻 dev',
        'dev_agent_acf': '🔌 dev-acf',
    
        # ✅ レビュー系
        'review_agent': '✅ review',
        'review_agent_prompts': '📋 review-prompts',
        'review_agent_prompts_ACF': '🔧 review-acf',
    
        # 🕷️ ブラウザ制御系
        'browser_controller': '🕷️ browser',
        'browser_cookie_and_session': '🍪 cookie-session',
        'browser_lifecycle': '🔁 browser-life',
        'browser_ai_chat_agent': '🤖 browser-ai',
        'browser_wp_session_manager': '🌐 wp-session',
    
        # 📊 データ連携系
        'sheets_manager': '📊 sheets-mgr',
    
        # 🔧 ユーティリティ系
        'config_utils': '⚙️ config',
        'command_monitor_agent': '👁️ monitor',
        'compatibility_fix': '🔧 compat-fix',
        'quick_fix': '⚡ quick-fix',
        'error_handler_enhanced': '🚨 error-handler',
    
        # ✍️ コンテンツライター系
        'base_writer': '✍️ writer-base',
        'ja_writer_agent': '🗾 ja-writer',
        'en_writer_agent': '🔠 en-writer',
        'ru_writer_agent': '🇷🇺 ru-writer',
        'uz_writer_agent': '🇺🇿 uz-writer',
        'zh_writer_agent': '🇨🇳 zh-writer',
        'ko_writer_agent': '🇰🇷 ko-writer',
        'tr_writer_agent': '🇹🇷 tr-writer',
        
        # 🆕 M&A専門エージェント
        'ma_executor': '💼 ma-exec',
        'ma_requirements': '📋 ma-req',
        'ma_data_migration': '🔄 ma-migrate',
        'ma_api_integration': '🔗 ma-api',
    
        # 🌐 WordPress系
        'wp_agent': '🌐 wp-agent',
        'wp_auth': '🔐 wp-auth',
        'wp_post_editor': '📝 wp-editor',
        'wp_post_creator': '🆕 wp-creator',
        'wp_plugin_manager': '🔌 wp-plugin',
        'wp_settings_manager': '⚙️ wp-config',
        'wp_design': '🎨 wp-design',
        'wp_dev': '🔧 wp-dev',
        'wp_tester': '🧪 wp-test',
        'wp_utils': '🛠️ wp-utils',
    
    }
    
    def format(self, record):
        # 再帰呼び出し防止
        if SmartLogFormatter._lock:
            return super().format(record)
        
        SmartLogFormatter._lock = True
        try:
            # メッセージカウント
            SmartLogFormatter._message_count += 1
            current_time = time.time()
            
            # エージェント識別
            agent_name = record.name
            # モジュール名から短縮名を取得
            if '.' in agent_name:
                agent_short = agent_name.split('.')[-1]  # 最後の部分
            else:
                agent_short = agent_name
            
            # エージェント絵文字を取得
            agent_display = self.AGENT_EMOJIS.get(agent_short, f'📋 {agent_short[:6]}')
            
            # レベル別の絵文字と色（エラーを強調）
            level_info = {
                'INFO': ('💬', ''),
                'WARNING': ('⚠️', 'WARN'),
                'ERROR': ('❌', 'ERROR'),
                'DEBUG': ('🐛', 'DEBUG'),
                'CRITICAL': ('💥', 'CRITICAL')
            }
            
            level_emoji, level_prefix = level_info.get(record.levelname, ('📝', ''))
            
            # メッセージ
            message = record.getMessage()
            
            # タイムスタンプ判定
            current_date = time.strftime('%Y-%m-%d')
            show_date = (SmartLogFormatter._last_date_display != current_date)
            show_timestamp = (
                SmartLogFormatter._message_count % 30 == 1 or 
                current_time - SmartLogFormatter._last_timestamp_display > 300 or
                show_date
            )
            
            # フォーマット構築
            parts = []
            
            # タイムスタンプ
            if show_date:
                SmartLogFormatter._last_date_display = current_date
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%Y-%m-%d %H:%M')
                parts.append(f"🕒 {timestamp}")
            elif show_timestamp:
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%H:%M')
                parts.append(f"🕒 {timestamp}")
            
            # エージェント名（常に表示）
            parts.append(agent_display)
            
            # レベル（エラー/警告時は強調）
            if level_prefix:
                # エラーレベルの場合は赤色で表示（ターミナルで色付け）
                if record.levelname in ['ERROR', 'CRITICAL']:
                    parts.append(f"{level_emoji} \033[91m{level_prefix}\033[0m")  # 赤色
                elif record.levelname == 'WARNING':
                    parts.append(f"{level_emoji} \033[93m{level_prefix}\033[0m")  # 黄色
                else:
                    parts.append(f"{level_emoji} {level_prefix}")
            else:
                parts.append(level_emoji)
            
            # メッセージ
            parts.append(message)
            
            # 結合
            result = ' '.join(parts)
            
            return result
            
        finally:
            SmartLogFormatter._lock = False


def setup_optimized_logging():
    """最適化されたログ設定（エージェント識別強化版）"""
    
    # ルートロガー
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # ← INFO を DEBUG に変更
    
    # 既存のハンドラをクリア
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # コンソールハンドラ（エージェント識別強化）
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SmartLogFormatter())
    
    # ファイルハンドラ（詳細ログ）
    file_handler = logging.FileHandler('gemini_automation.log', encoding='utf-8')
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(file_formatter)
    
    # ハンドラ追加
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)


# グローバルで実行
setup_optimized_logging()


class Config:
    """設定クラス"""
    SPREADSHEET_ID = "1qpMLT9HKlPT9qY17fpqOkSIbehKH77wZ8bA1yfPSO_s"
    DOWNLOAD_IMAGE_FOLDER: Optional[str] = None
    DOWNLOAD_TEXT_FOLDER: Optional[str] = None
    SERVICE_ACCOUNT_FILE: Optional[str] = None
    COOKIES_FILE: Optional[str] = None
    BROWSER_DATA_DIR: Optional[str] = None
    GENERATION_MODE: Optional[str] = None
    TEXT_FORMAT: Optional[str] = None
    SERVICE_TYPE: Optional[str] = None
    AGENT_OUTPUT_FOLDER = None
    MAX_ITERATIONS = 3
    DRIVE_TEXT_FOLDER_ID = "16QVK_-z8JVmhLQuLVprOx9_DnoNc4eUc"
    DRIVE_IMAGE_FOLDER_ID = "1jkuMH1UNeBvNNvrz8iVidyVMmtmYrHiS"
    
    BROWSER_CONFIG = {
        "headless": False,
        "slow_mo": 800,
        "args": [
            "--disable-blink-features=AutomationControlled",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "--no-sandbox",
            "--disable-dev-shm-usage"
            # ⚠️ --single-process を削除（Windowsで不安定なため）
        ],
        "timeout": 60000
    }
    
    def __init__(self):
        self.WP_COOKIES_FILE = os.environ.get('WP_COOKIES_FILE', 
                                            os.path.join(Path.home(), 'Documents', 'gemini_auto_generate', 'wordpress_cookies.json'))
            
        # クッキー有効期限（デフォルト30日）
        self.WP_COOKIE_EXPIRY_DAYS = int(os.environ.get('WP_COOKIE_EXPIRY_DAYS', '30'))
        
    VIEWPORT_SIZE = {'width': 1024, 'height': 768}
    PAGE_TIMEOUT = 60000
    IMAGE_GENERATION_TIMEOUT = 180
    TEXT_GENERATION_TIMEOUT = 120
    
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]


class FileNameGenerator:
    """ファイル名生成"""
    
    @staticmethod
    def generate_unique_filename(index: int, extension: str = ".png", mode: str = "image") -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        unique_id = str(uuid.uuid4())[:8]
        
        if mode == "text":
            prefix = "gemini_text"
            ext = ".txt"
        else:
            prefix = "gemini_image"
            ext = extension
        
        return f"{prefix}_{index:03d}_{timestamp}_{unique_id}{ext}"
    
    @staticmethod
    def validate_filename(filename: str) -> bool:
        try:
            invalid_chars = '<>:"/\\|?*'
            return not any(char in filename for char in invalid_chars)
        except:
            return False


class ErrorHandler:
    """エラーハンドリング"""
    
    @staticmethod
    def log_error(error: Exception, context: str = "") -> None:
        logger = logging.getLogger(__name__)
        logger.error(f"{context}: {str(error)}")
    
    @staticmethod
    def handle_missing_attribute_error(obj, attr_name: str, default_value=None):
        logger = logging.getLogger(__name__)
        if not hasattr(obj, attr_name):
            logger.warning(f"属性 '{attr_name}' が見つかりません。デフォルト値を使用")
            setattr(obj, attr_name, default_value)
        return getattr(obj, attr_name)


class PathManager:
    """パス管理"""
    
    @staticmethod
    def ensure_directory_exists(path: Path) -> None:
        path.mkdir(parents=True, exist_ok=True)
    
    @staticmethod
    def get_safe_path(base_path: str) -> Path:
        path = Path(base_path)
        PathManager.ensure_directory_exists(path)
        return path


config = Config()

#config_validator.py
"""
ConfigValidator - 設定検証とバリデーションエージェント

設定ファイルの構文チェック、APIキーの有効性確認、環境変数の検証、
依存関係の確認、設定の推奨値提案を提供する。
"""

import os
import json
import yaml
import re
import requests
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class ValidationLevel(Enum):
    """検証レベル"""
    ERROR = "error"  # 致命的なエラー
    WARNING = "warning"  # 警告
    INFO = "info"  # 情報
    SUCCESS = "success"  # 成功


@dataclass
class ValidationResult:
    """検証結果"""
    level: ValidationLevel
    category: str
    message: str
    field: Optional[str] = None
    expected: Optional[Any] = None
    actual: Optional[Any] = None
    suggestion: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "level": self.level.value,
            "category": self.category,
            "message": self.message,
            "field": self.field,
            "expected": self.expected,
            "actual": self.actual,
            "suggestion": self.suggestion
        }


@dataclass
class ConfigSchema:
    """設定スキーマ定義"""
    required_fields: Set[str]
    optional_fields: Set[str]
    field_types: Dict[str, type]
    field_validators: Dict[str, Any]  # カスタムバリデータ
    recommended_values: Dict[str, Any]
    
    def get_all_fields(self) -> Set[str]:
        return self.required_fields | self.optional_fields


class ConfigValidatorAgent:
    """
    設定検証とバリデーションエージェント
    
    主な機能:
    1. 設定ファイルの構文チェック
    2. APIキーの有効性確認
    3. 環境変数の検証
    4. 依存関係の確認
    5. 設定の推奨値提案
    """
    
    def __init__(self):
        self.validation_results: List[ValidationResult] = []
        
        # 設定スキーマの定義
        self.schemas = {
            "browser": self._define_browser_schema(),
            "ai": self._define_ai_schema(),
            "wordpress": self._define_wordpress_schema(),
            "system": self._define_system_schema()
        }
        
        logger.info("ConfigValidatorAgent initialized")
    
    def _define_browser_schema(self) -> ConfigSchema:
        """ブラウザ設定スキーマ"""
        return ConfigSchema(
            required_fields={"headless", "user_data_dir"},
            optional_fields={"window_size", "disable_gpu", "no_sandbox"},
            field_types={
                "headless": bool,
                "user_data_dir": str,
                "window_size": tuple,
                "disable_gpu": bool,
                "no_sandbox": bool
            },
            field_validators={
                "window_size": lambda v: len(v) == 2 and all(isinstance(x, int) for x in v)
            },
            recommended_values={
                "headless": True,  # クラウド環境では推奨
                "window_size": (1920, 1080)
            }
        )
    
    def _define_ai_schema(self) -> ConfigSchema:
        """AI設定スキーマ"""
        return ConfigSchema(
            required_fields={"provider", "model", "api_key"},
            optional_fields={"temperature", "max_tokens", "timeout"},
            field_types={
                "provider": str,
                "model": str,
                "api_key": str,
                "temperature": float,
                "max_tokens": int,
                "timeout": int
            },
            field_validators={
                "provider": lambda v: v in ["openai", "anthropic", "google", "deepseek"],
                "temperature": lambda v: 0.0 <= v <= 2.0,
                "max_tokens": lambda v: v > 0
            },
            recommended_values={
                "temperature": 0.7,
                "max_tokens": 4000,
                "timeout": 60
            }
        )
    
    def _define_wordpress_schema(self) -> ConfigSchema:
        """WordPress設定スキーマ"""
        return ConfigSchema(
            required_fields={"url", "username", "password"},
            optional_fields={"wp_cli_path", "ssh_host", "ssh_user"},
            field_types={
                "url": str,
                "username": str,
                "password": str,
                "wp_cli_path": str,
                "ssh_host": str,
                "ssh_user": str
            },
            field_validators={
                "url": lambda v: v.startswith("http://") or v.startswith("https://")
            },
            recommended_values={}
        )
    
    def _define_system_schema(self) -> ConfigSchema:
        """システム設定スキーマ"""
        return ConfigSchema(
            required_fields={"run_mode"},
            optional_fields={"log_level", "max_retries", "timeout"},
            field_types={
                "run_mode": str,
                "log_level": str,
                "max_retries": int,
                "timeout": int
            },
            field_validators={
                "run_mode": lambda v: v in ["local", "cloud"],
                "log_level": lambda v: v in ["DEBUG", "INFO", "WARNING", "ERROR"]
            },
            recommended_values={
                "log_level": "INFO",
                "max_retries": 3,
                "timeout": 300
            }
        )
    
    def validate_config_file(self, filepath: str) -> List[ValidationResult]:
        """
        設定ファイルを検証
        
        Args:
            filepath: 設定ファイルパス
        
        Returns:
            検証結果のリスト
        """
        self.validation_results = []
        
        # ファイルの存在確認
        if not os.path.exists(filepath):
            self.validation_results.append(ValidationResult(
                level=ValidationLevel.ERROR,
                category="file",
                message=f"Configuration file not found: {filepath}",
                suggestion="Create the configuration file or check the path"
            ))
            return self.validation_results
        
        # ファイル形式の判定と読み込み
        try:
            config_data = self._load_config_file(filepath)
        except Exception as e:
            self.validation_results.append(ValidationResult(
                level=ValidationLevel.ERROR,
                category="syntax",
                message=f"Failed to parse configuration file: {str(e)}",
                suggestion="Check file syntax (JSON/YAML format)"
            ))
            return self.validation_results
        
        # 各カテゴリの設定を検証
        for category, schema in self.schemas.items():
            if category in config_data:
                self._validate_category(category, config_data[category], schema)
            else:
                self.validation_results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category=category,
                    message=f"Category '{category}' not found in configuration",
                    suggestion=f"Consider adding '{category}' configuration"
                ))
        
        return self.validation_results
    
    def _load_config_file(self, filepath: str) -> Dict[str, Any]:
        """設定ファイルを読み込む"""
        suffix = Path(filepath).suffix.lower()
        
        with open(filepath, 'r', encoding='utf-8') as f:
            if suffix == '.json':
                return json.load(f)
            elif suffix in ['.yaml', '.yml']:
                return yaml.safe_load(f)
            elif suffix == '.py':
                # Python設定ファイルの簡易読み込み
                # 注意: 実行は危険なので、変数定義のみをパース
                content = f.read()
                config = {}
                # 簡易パーサー（実際にはastモジュールを使うべき）
                for line in content.split('\n'):
                    if '=' in line and not line.strip().startswith('#'):
                        try:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = eval(value.strip())
                            config[key] = value
                        except:
                            pass
                return config
            else:
                raise ValueError(f"Unsupported file format: {suffix}")
    
    def _validate_category(self, 
                          category: str,
                          config: Dict[str, Any],
                          schema: ConfigSchema):
        """カテゴリ設定を検証"""
        # 必須フィールドのチェック
        for field in schema.required_fields:
            if field not in config:
                self.validation_results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category=category,
                    field=field,
                    message=f"Required field '{field}' is missing",
                    suggestion=f"Add '{field}' to the configuration"
                ))
        
        # フィールドの型チェック
        for field, value in config.items():
            if field in schema.field_types:
                expected_type = schema.field_types[field]
                if not isinstance(value, expected_type):
                    self.validation_results.append(ValidationResult(
                        level=ValidationLevel.ERROR,
                        category=category,
                        field=field,
                        message=f"Field '{field}' has wrong type",
                        expected=expected_type.__name__,
                        actual=type(value).__name__,
                        suggestion=f"Change type to {expected_type.__name__}"
                    ))
            
            # カスタムバリデータのチェック
            if field in schema.field_validators:
                validator = schema.field_validators[field]
                try:
                    if not validator(value):
                        self.validation_results.append(ValidationResult(
                            level=ValidationLevel.ERROR,
                            category=category,
                            field=field,
                            message=f"Field '{field}' failed validation",
                            actual=value,
                            suggestion="Check the value against requirements"
                        ))
                except Exception as e:
                    self.validation_results.append(ValidationResult(
                        level=ValidationLevel.ERROR,
                        category=category,
                        field=field,
                        message=f"Validation error for '{field}': {str(e)}",
                        actual=value
                    ))
        
        # 推奨値のチェック
        for field, recommended in schema.recommended_values.items():
            if field in config and config[field] != recommended:
                self.validation_results.append(ValidationResult(
                    level=ValidationLevel.INFO,
                    category=category,
                    field=field,
                    message=f"Field '{field}' differs from recommended value",
                    expected=recommended,
                    actual=config[field],
                    suggestion=f"Consider using recommended value: {recommended}"
                ))
    
    def validate_api_keys(self, config: Dict[str, Any]) -> List[ValidationResult]:
        """
        APIキーの有効性を確認
        
        Args:
            config: 設定データ
        
        Returns:
            検証結果のリスト
        """
        results = []
        
        # OpenAI APIキー
        if "ai" in config and "api_key" in config["ai"]:
            api_key = config["ai"]["api_key"]
            provider = config["ai"].get("provider", "")
            
            if provider == "openai":
                is_valid, message = self._test_openai_key(api_key)
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS if is_valid else ValidationLevel.ERROR,
                    category="api_key",
                    field="openai_api_key",
                    message=message,
                    suggestion="Check your API key in the OpenAI dashboard" if not is_valid else None
                ))
            elif provider == "anthropic":
                is_valid, message = self._test_anthropic_key(api_key)
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS if is_valid else ValidationLevel.ERROR,
                    category="api_key",
                    field="anthropic_api_key",
                    message=message,
                    suggestion="Check your API key in the Anthropic console" if not is_valid else None
                ))
        
        return results
    
    def _test_openai_key(self, api_key: str) -> Tuple[bool, str]:
        """OpenAI APIキーをテスト"""
        try:
            headers = {"Authorization": f"Bearer {api_key}"}
            response = requests.get(
                "https://api.openai.com/v1/models",
                headers=headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return True, "OpenAI API key is valid"
            elif response.status_code == 401:
                return False, "OpenAI API key is invalid"
            else:
                return False, f"OpenAI API returned status {response.status_code}"
        except Exception as e:
            return False, f"Failed to test OpenAI API key: {str(e)}"
    
    def _test_anthropic_key(self, api_key: str) -> Tuple[bool, str]:
        """Anthropic APIキーをテスト"""
        try:
            headers = {
                "x-api-key": api_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            }
            # 簡易的なテストリクエスト
            payload = {
                "model": "claude-3-haiku-20240307",
                "max_tokens": 10,
                "messages": [{"role": "user", "content": "Hi"}]
            }
            response = requests.post(
                "https://api.anthropic.com/v1/messages",
                headers=headers,
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                return True, "Anthropic API key is valid"
            elif response.status_code == 401:
                return False, "Anthropic API key is invalid"
            else:
                return False, f"Anthropic API returned status {response.status_code}"
        except Exception as e:
            return False, f"Failed to test Anthropic API key: {str(e)}"
    
    def validate_environment_variables(self, 
                                      required_vars: List[str]) -> List[ValidationResult]:
        """
        環境変数を検証
        
        Args:
            required_vars: 必須環境変数のリスト
        
        Returns:
            検証結果のリスト
        """
        results = []
        
        for var_name in required_vars:
            value = os.getenv(var_name)
            
            if value is None:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="environment",
                    field=var_name,
                    message=f"Required environment variable '{var_name}' is not set",
                    suggestion=f"Set {var_name} in your environment"
                ))
            elif not value.strip():
                results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category="environment",
                    field=var_name,
                    message=f"Environment variable '{var_name}' is empty",
                    suggestion=f"Provide a value for {var_name}"
                ))
            else:
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="environment",
                    field=var_name,
                    message=f"Environment variable '{var_name}' is set"
                ))
        
        return results
    
    def validate_dependencies(self, 
                            requirements_file: str = "requirements.txt") -> List[ValidationResult]:
        """
        依存関係を検証
        
        Args:
            requirements_file: requirements.txtのパス
        
        Returns:
            検証結果のリスト
        """
        results = []
        
        if not os.path.exists(requirements_file):
            results.append(ValidationResult(
                level=ValidationLevel.WARNING,
                category="dependencies",
                message=f"Requirements file not found: {requirements_file}",
                suggestion="Create a requirements.txt file"
            ))
            return results
        
        # requirements.txtを読み込む
        with open(requirements_file, 'r', encoding='utf-8') as f:
            requirements = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        # 各パッケージの存在を確認
        for req in requirements:
            # バージョン指定を分離
            package_name = re.split(r'[<>=!]', req)[0].strip()
            
            try:
                __import__(package_name.replace('-', '_'))
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="dependencies",
                    field=package_name,
                    message=f"Package '{package_name}' is installed"
                ))
            except ImportError:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="dependencies",
                    field=package_name,
                    message=f"Package '{package_name}' is not installed",
                    suggestion=f"Run: pip install {req}"
                ))
        
        return results
    
    def check_directory_structure(self, 
                                 base_dir: str,
                                 required_dirs: List[str]) -> List[ValidationResult]:
        """
        必要なディレクトリ構造を検証
        
        Args:
            base_dir: ベースディレクトリ
            required_dirs: 必須ディレクトリのリスト
        
        Returns:
            検証結果のリスト
        """
        results = []
        base_path = Path(base_dir)
        
        for dir_name in required_dirs:
            dir_path = base_path / dir_name
            
            if not dir_path.exists():
                results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category="directory_structure",
                    field=dir_name,
                    message=f"Required directory not found: {dir_name}",
                    suggestion=f"Create directory: mkdir {dir_path}"
                ))
            elif not dir_path.is_dir():
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="directory_structure",
                    field=dir_name,
                    message=f"Path exists but is not a directory: {dir_name}",
                    suggestion=f"Remove file and create directory: {dir_path}"
                ))
            else:
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="directory_structure",
                    field=dir_name,
                    message=f"Directory exists: {dir_name}"
                ))
        
        return results
    
    def validate_network_connectivity(self, 
                                    urls: List[str]) -> List[ValidationResult]:
        """
        ネットワーク接続性を検証
        
        Args:
            urls: テストするURLのリスト
        
        Returns:
            検証結果のリスト
        """
        results = []
        
        for url in urls:
            try:
                response = requests.head(url, timeout=5, allow_redirects=True)
                
                if response.status_code < 400:
                    results.append(ValidationResult(
                        level=ValidationLevel.SUCCESS,
                        category="network",
                        field=url,
                        message=f"URL is accessible: {url}"
                    ))
                else:
                    results.append(ValidationResult(
                        level=ValidationLevel.WARNING,
                        category="network",
                        field=url,
                        message=f"URL returned status {response.status_code}: {url}",
                        suggestion="Check if the service is running"
                    ))
            except requests.exceptions.Timeout:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="network",
                    field=url,
                    message=f"Connection timeout: {url}",
                    suggestion="Check network connectivity or firewall settings"
                ))
            except requests.exceptions.ConnectionError:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="network",
                    field=url,
                    message=f"Connection failed: {url}",
                    suggestion="Check if the service is running and accessible"
                ))
            except Exception as e:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="network",
                    field=url,
                    message=f"Network error for {url}: {str(e)}"
                ))
        
        return results
    
    def validate_file_permissions(self, 
                                 files: List[str],
                                 required_permissions: str = "rw") -> List[ValidationResult]:
        """
        ファイルパーミッションを検証
        
        Args:
            files: チェックするファイルのリスト
            required_permissions: 必要なパーミッション ('r', 'w', 'x' の組み合わせ)
        
        Returns:
            検証結果のリスト
        """
        results = []
        
        for filepath in files:
            if not os.path.exists(filepath):
                results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category="permissions",
                    field=filepath,
                    message=f"File not found: {filepath}",
                    suggestion=f"Create the file: {filepath}"
                ))
                continue
            
            has_read = os.access(filepath, os.R_OK)
            has_write = os.access(filepath, os.W_OK)
            has_execute = os.access(filepath, os.X_OK)
            
            missing = []
            if 'r' in required_permissions and not has_read:
                missing.append('read')
            if 'w' in required_permissions and not has_write:
                missing.append('write')
            if 'x' in required_permissions and not has_execute:
                missing.append('execute')
            
            if missing:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="permissions",
                    field=filepath,
                    message=f"Insufficient permissions for {filepath}: missing {', '.join(missing)}",
                    suggestion=f"Grant {', '.join(missing)} permission to the file"
                ))
            else:
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="permissions",
                    field=filepath,
                    message=f"File has correct permissions: {filepath}"
                ))
        
        return results
    
    def generate_validation_report(self, 
                                  results: List[ValidationResult]) -> Dict[str, Any]:
        """
        検証レポートを生成
        
        Args:
            results: 検証結果のリスト
        
        Returns:
            レポートデータ
        """
        errors = [r for r in results if r.level == ValidationLevel.ERROR]
        warnings = [r for r in results if r.level == ValidationLevel.WARNING]
        info = [r for r in results if r.level == ValidationLevel.INFO]
        success = [r for r in results if r.level == ValidationLevel.SUCCESS]
        
        # カテゴリ別集計
        by_category = {}
        for result in results:
            if result.category not in by_category:
                by_category[result.category] = {
                    "errors": 0,
                    "warnings": 0,
                    "info": 0,
                    "success": 0
                }
            by_category[result.category][result.level.value + "s"] += 1
        
        return {
            "summary": {
                "total": len(results),
                "errors": len(errors),
                "warnings": len(warnings),
                "info": len(info),
                "success": len(success),
                "is_valid": len(errors) == 0
            },
            "by_category": by_category,
            "details": {
                "errors": [r.to_dict() for r in errors],
                "warnings": [r.to_dict() for r in warnings],
                "info": [r.to_dict() for r in info]
            },
            "generated_at": datetime.now().isoformat()
        }
    
    def auto_fix_config(self, 
                       config: Dict[str, Any],
                       validation_results: List[ValidationResult]) -> Tuple[Dict[str, Any], List[str]]:
        """
        設定を自動修正（可能な範囲で）
        
        Args:
            config: 設定データ
            validation_results: 検証結果
        
        Returns:
            (修正された設定, 適用された修正のリスト)
        """
        fixed_config = config.copy()
        applied_fixes = []
        
        for result in validation_results:
            # 推奨値の適用
            if result.level == ValidationLevel.INFO and result.expected is not None:
                category = result.category
                field = result.field
                
                if category in fixed_config and field:
                    fixed_config[category][field] = result.expected
                    applied_fixes.append(
                        f"Applied recommended value for {category}.{field}: {result.expected}"
                    )
            
            # 不足フィールドの追加（推奨値がある場合）
            if result.level == ValidationLevel.ERROR and "missing" in result.message.lower():
                category = result.category
                field = result.field
                
                if category in self.schemas:
                    schema = self.schemas[category]
                    if field in schema.recommended_values:
                        if category not in fixed_config:
                            fixed_config[category] = {}
                        
                        fixed_config[category][field] = schema.recommended_values[field]
                        applied_fixes.append(
                            f"Added missing field {category}.{field} with recommended value"
                        )
        
        return fixed_config, applied_fixes
    
    def export_validation_report(self, 
                               results: List[ValidationResult],
                               filepath: str):
        """
        検証レポートをファイルにエクスポート
        
        Args:
            results: 検証結果
            filepath: 出力ファイルパス
        """
        report = self.generate_validation_report(results)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Validation report exported to {filepath}")
    
    def get_summary(self, results: List[ValidationResult]) -> str:
        """
        検証結果のサマリーテキストを生成
        
        Args:
            results: 検証結果
        
        Returns:
            サマリーテキスト
        """
        errors = sum(1 for r in results if r.level == ValidationLevel.ERROR)
        warnings = sum(1 for r in results if r.level == ValidationLevel.WARNING)
        success = sum(1 for r in results if r.level == ValidationLevel.SUCCESS)
        
        if errors == 0 and warnings == 0:
            return f"✅ All validations passed ({success} checks)"
        elif errors == 0:
            return f"⚠️  Validation passed with {warnings} warnings"
        else:
            return f"❌ Validation failed with {errors} errors and {warnings} warnings"


# 使用例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    validator = ConfigValidatorAgent()
    
    # テスト用の設定
    test_config = {
        "browser": {
            "headless": False,
            "user_data_dir": "./user_data",
            "window_size": (1920, 1080)
        },
        "ai": {
            "provider": "openai",
            "model": "gpt-4",
            "api_key": "sk-test-key",
            "temperature": 0.7
        },
        "wordpress": {
            "url": "https://example.com",
            "username": "admin"
            # password が不足（エラー）
        },
        "system": {
            "run_mode": "local",
            "log_level": "INFO"
        }
    }
    
    # 設定をファイルに保存
    config_file = "test_config.json"
    with open(config_file, 'w') as f:
        json.dump(test_config, f, indent=2)
    
    # 設定ファイルを検証
    print("\n=== Validating Configuration File ===")
    results = validator.validate_config_file(config_file)
    
    for result in results:
        print(f"[{result.level.value.upper()}] {result.category}: {result.message}")
        if result.suggestion:
            print(f"  💡 {result.suggestion}")
    
    # 環境変数を検証
    print("\n=== Validating Environment Variables ===")
    env_results = validator.validate_environment_variables([
        "OPENAI_API_KEY",
        "WP_USERNAME",
        "WP_PASSWORD"
    ])
    
    for result in env_results:
        print(f"[{result.level.value.upper()}] {result.field}: {result.message}")
    
    # 依存関係を検証（実際のrequirements.txtがある場合）
    # dep_results = validator.validate_dependencies()
    
    # レポートを生成
    print("\n=== Validation Report ===")
    all_results = results + env_results
    report = validator.generate_validation_report(all_results)
    print(json.dumps(report["summary"], indent=2))
    
    # サマリー
    print("\n" + validator.get_summary(all_results))
    
    # 自動修正
    print("\n=== Auto-fixing Configuration ===")
    fixed_config, applied_fixes = validator.auto_fix_config(test_config, results)
    
    for fix in applied_fixes:
        print(f"✓ {fix}")
    
    # クリーンアップ
    os.remove(config_file)


#content_task_executor.py
"""
content_task_executor.py - コンテンツ生成タスク専門実行モジュール
AIサイトとの対話、プロンプト送信、応答抽出、検証を担当
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

# 設定
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """
    コンテンツ生成タスクの専門実行モジュール
    
    ブラウザ制御を通じたAI対話、コンテンツ生成、
    抽出、検証ロジックを統合
    """
    
    def __init__(
        self,
        browser_controller,
        sheets_manager: GoogleSheetsManager
    ):
        """
        初期化
        
        Args:
            browser_controller: BrowserControllerインスタンス
            sheets_manager: GoogleSheetsManagerインスタンス
        """
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        
        # AI設定
        self.ai_sites = {
            'gemini': 'https://gemini.google.com',
            'deepseek': 'https://chat.deepseek.com',
            'claude': 'https://claude.ai'
        }
        
        # デフォルトAI
        self.default_ai = 'gemini'
        
        # タイムアウト設定
        self.default_timeout = 180.0
        self.generation_timeout = 240.0
        
        logger.info("✅ ContentTaskExecutor 初期化完了")
    
    async def execute_content_task(self, task: Dict) -> Dict:
        """
        コンテンツ生成タスクを実行
            
        Args:
            task: タスク情報辞書
                
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("=" * 60)
            logger.info(f"✍️ コンテンツタスク実行開始: {task_id}")
            logger.info("=" * 60)
                
            # ========================================
            # 🆕 コンテンツタイプ判定と専門プロンプト適用（強化版）
            # ========================================
            content_type = self._determine_content_type(task)
            logger.info(f"📋 コンテンツタイプ: {content_type}")
                
            # 専門文書タイプの場合、プロンプトを差し替え
            if content_type == 'pydantic_migration':
                task['prompt'] = self._build_pydantic_migration_prompt(task)
                logger.info("🔧 Pydantic移行プロンプトを適用")
            elif content_type == 'openapi_schema':
                task['prompt'] = self._build_openapi_schema_prompt(task)
                logger.info("📐 OpenAPIスキーマプロンプトを適用")
            elif content_type == 'requirements_document':
                task['prompt'] = self._build_requirements_document_prompt(task)
                logger.info("📄 要件定義書プロンプトを適用")
                
            # ========================================
            # 既存の実行ロジック
            # ========================================
                
            # タスクパラメータ抽出
            prompt = task.get('prompt', task.get('description', ''))
            ai_site = task.get('ai_site', self.default_ai).lower()
            output_format = task.get('output_format', 'markdown')
                
            # ブラウザチェック
            if not self.browser:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラが初期化されていません'
                }
                
            # AIサイトナビゲーション
            nav_result = await self._navigate_to_ai_site(ai_site)
            if not nav_result['success']:
                return nav_result
                
            # プロンプト送信と応答待機
            response_result = await self._send_prompt_and_wait(
                prompt, 
                timeout=self.generation_timeout
            )
            if not response_result['success']:
                return response_result
                
            # 応答テキスト抽出
            extract_result = await self._extract_response_text()
            if not extract_result['success']:
                return extract_result
                
            content = extract_result['content']
                
            # コンテンツ検証
            validation_result = self._validate_content(content, task)
            if not validation_result['valid']:
                logger.warning(f"⚠️ コンテンツ検証警告: {validation_result['message']}")
                
            # 出力ファイル保存
            output_file = await self._save_content_output(
                task_id, 
                content, 
                output_format
            )
                
            logger.info(f"✅ コンテンツタスク {task_id} 完了")
                
            return {
                'success': True,
                'content': content,
                'output_file': output_file,
                'ai_site': ai_site,
                'content_type': content_type,  # タイプ情報を追加
                'validation': validation_result,
                'full_text': content,
                'summary': content[:500] if len(content) > 500 else content
            }
                
        except asyncio.TimeoutError:
            logger.error(f"⏱️ コンテンツタスク {task_id} タイムアウト")
            return {
                'success': False,
                'error': f'タイムアウト ({self.generation_timeout}秒)'
            }
            
        except Exception as e:
            logger.error(f"❌ コンテンツタスク {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_content_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _navigate_to_ai_site(self, ai_site: str) -> Dict:
        """
        AIサイトにナビゲーション
        
        Args:
            ai_site: AIサイト識別子 ('gemini', 'deepseek', 'claude')
            
        Returns:
            Dict: ナビゲーション結果
        """
        try:
            logger.info(f"🌐 {ai_site.upper()} にナビゲーション中...")
            
            # サイトURL取得
            if ai_site not in self.ai_sites:
                logger.warning(f"⚠️ 未知のAIサイト: {ai_site}, デフォルト {self.default_ai} を使用")
                ai_site = self.default_ai
            
            url = self.ai_sites[ai_site]
            
            # ブラウザメソッド呼び出し
            if ai_site == 'gemini':
                if hasattr(self.browser, 'navigate_to_gemini'):
                    result = await self.browser.navigate_to_gemini()
                else:
                    result = await self.browser.navigate_to_url(url)
            elif ai_site == 'deepseek':
                if hasattr(self.browser, 'navigate_to_deepseek'):
                    result = await self.browser.navigate_to_deepseek()
                else:
                    result = await self.browser.navigate_to_url(url)
            else:
                result = await self.browser.navigate_to_url(url)
            
            if result:
                logger.info(f"✅ {ai_site.upper()} へのナビゲーション成功")
                return {'success': True}
            else:
                logger.error(f"❌ {ai_site.upper()} へのナビゲーション失敗")
                return {'success': False, 'error': f'{ai_site} へのナビゲーション失敗'}
        
        except Exception as e:
            logger.error(f"❌ AIサイトナビゲーションエラー: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _send_prompt_and_wait(
        self, 
        prompt: str, 
        timeout: float = None
    ) -> Dict:
        """
        プロンプトを送信して応答を待機
        
        Args:
            prompt: 送信するプロンプト
            timeout: タイムアウト時間（秒）
            
        Returns:
            Dict: 実行結果
        """
        try:
            if timeout is None:
                timeout = self.generation_timeout
            
            logger.info(f"📤 プロンプト送信中... (タイムアウト: {timeout}秒)")
            
            # 統合メソッド使用（存在する場合）
            if hasattr(self.browser, 'send_prompt_and_wait'):
                result = await self.browser.send_prompt_and_wait(
                    prompt, 
                    timeout=timeout
                )
                if result:
                    logger.info("✅ プロンプト送信と応答待機完了")
                    return {'success': True}
                else:
                    logger.error("❌ プロンプト送信または応答待機失敗")
                    return {'success': False, 'error': 'プロンプト送信失敗'}
            else:
                # 個別メソッド使用（後方互換性）
                if hasattr(self.browser, 'send_prompt'):
                    await self.browser.send_prompt(prompt)
                else:
                    logger.error("❌ send_prompt メソッドが見つかりません")
                    return {'success': False, 'error': 'send_prompt メソッド未実装'}
                
                # 応答待機
                if hasattr(self.browser, 'wait_for_text_generation'):
                    await self.browser.wait_for_text_generation(timeout)
                    logger.info("✅ プロンプト送信と応答待機完了")
                    return {'success': True}
                else:
                    logger.warning("⚠️ wait_for_text_generation メソッドなし - 固定待機")
                    await asyncio.sleep(30)  # フォールバック待機
                    return {'success': True}
        
        except asyncio.TimeoutError:
            logger.error(f"⏱️ プロンプト応答タイムアウト ({timeout}秒)")
            return {'success': False, 'error': 'タイムアウト'}
        
        except Exception as e:
            logger.error(f"❌ プロンプト送信エラー: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _extract_response_text(self) -> Dict:
        """
        AIからの応答テキストを抽出
        
        Returns:
            Dict: 抽出結果 {'success': bool, 'content': str}
        """
        try:
            logger.info("📥 応答テキスト抽出中...")
            
            if not hasattr(self.browser, 'extract_latest_text_response'):
                logger.error("❌ extract_latest_text_response メソッドが見つかりません")
                return {'success': False, 'error': '応答抽出メソッド未実装'}
            
            content = await self.browser.extract_latest_text_response()
            
            if not content:
                logger.warning("⚠️ 抽出されたコンテンツが空です")
                return {'success': False, 'error': '抽出コンテンツなし'}
            
            logger.info(f"✅ 応答テキスト抽出完了 ({len(content)}文字)")
            return {'success': True, 'content': content}
        
        except Exception as e:
            logger.error(f"❌ 応答テキスト抽出エラー: {e}")
            return {'success': False, 'error': str(e)}
    
    def _validate_content(self, content: str, task: Dict) -> Dict:
        """
        生成コンテンツを検証
        
        Args:
            content: 検証対象コンテンツ
            task: タスク情報
            
        Returns:
            Dict: 検証結果 {'valid': bool, 'message': str, 'warnings': list}
        """
        warnings = []
        
        # 最小文字数チェック
        min_length = task.get('min_length', 100)
        if len(content.strip()) < min_length:
            warnings.append(f'コンテンツが短すぎます（{len(content)}文字 < {min_length}文字）')
        
        # コードブロック完全性チェック
        if '```' in content:
            code_block_count = content.count('```')
            if code_block_count % 2 != 0:
                warnings.append('コードブロックが不完全です（閉じられていないブロックがあります）')
        
        # PHPコード完全性チェック
        if '<?php' in content:
            if '?>' not in content and not content.rstrip().endswith('}'):
                warnings.append('PHPコードが不完全な可能性があります')
        
        # 必須キーワードチェック
        required_keywords = task.get('required_keywords', [])
        missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]
        if missing_keywords:
            warnings.append(f'必須キーワード不足: {", ".join(missing_keywords)}')
        
        valid = len(warnings) == 0
        message = '検証合格' if valid else f'{len(warnings)}件の警告'
        
        return {
            'valid': valid,
            'message': message,
            'warnings': warnings
        }
    
    async def _save_content_output(
        self, 
        task_id: str, 
        content: str, 
        output_format: str = 'markdown'
    ) -> str:
        """
        コンテンツを出力ファイルに保存
        
        Args:
            task_id: タスクID
            content: 保存するコンテンツ
            output_format: 出力形式 ('markdown', 'text', 'html')
            
        Returns:
            str: 保存されたファイルパス
        """
        try:
            # ファイル拡張子マッピング
            ext_map = {
                'markdown': '.md',
                'text': '.txt',
                'html': '.html',
                'php': '.php'
            }
            ext = ext_map.get(output_format, '.txt')
            
            # ファイル名生成
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"content_{task_id}_{timestamp}{ext}"
            
            # 出力ディレクトリ確保
            output_dir = Path(config.OUTPUT_DIR) if hasattr(config, 'OUTPUT_DIR') else Path('./outputs')
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # ファイル保存
            output_path = output_dir / filename
            
            if hasattr(self.browser, 'save_text_to_file'):
                # BrowserControllerの保存メソッド使用
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
                logger.info(f"✅ コンテンツ保存完了: {saved_path}")
                return str(saved_path)
            else:
                # 直接ファイル保存
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                logger.info(f"✅ コンテンツ保存完了: {output_path}")
                return str(output_path)
        
        except Exception as e:
            logger.error(f"❌ コンテンツ保存エラー: {e}")
            ErrorHandler.log_error(e, "ContentTaskExecutor._save_content_output")
            return ""
    
    async def execute_multi_step_content_task(self, task: Dict) -> Dict:
        """
        複数ステップのコンテンツ生成タスクを実行
        
        例: プロンプト1 → 応答抽出 → プロンプト2 → 最終出力
        
        Args:
            task: タスク情報辞書（'steps'キーに複数ステップ定義）
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("⚠️ ステップ定義なし - 単一タスクとして実行")
            return await self.execute_content_task(task)
        
        try:
            logger.info("=" * 60)
            logger.info(f"🔄 マルチステップタスク実行: {task_id}")
            logger.info(f"ステップ数: {len(steps)}")
            logger.info("=" * 60)
            
            results = []
            accumulated_content = ""
            
            for i, step in enumerate(steps, 1):
                logger.info(f"\n--- ステップ {i}/{len(steps)} ---")
                
                # ステップタスク構築
                step_task = {
                    **task,  # 親タスクの属性を継承
                    'task_id': f"{task_id}_step{i}",
                    'prompt': step.get('prompt', ''),
                    'description': step.get('description', f'ステップ{i}'),
                }
                
                # 前ステップの結果を参照する場合
                if step.get('use_previous_output') and accumulated_content:
                    step_task['prompt'] = step_task['prompt'].replace(
                        '{previous_output}', 
                        accumulated_content
                    )
                
                # ステップ実行
                step_result = await self.execute_content_task(step_task)
                
                if not step_result.get('success'):
                    logger.error(f"❌ ステップ {i} 失敗")
                    return {
                        'success': False,
                        'error': f"ステップ {i} 失敗: {step_result.get('error')}",
                        'completed_steps': i - 1,
                        'step_results': results
                    }
                
                results.append(step_result)
                accumulated_content = step_result.get('content', '')
                
                logger.info(f"✅ ステップ {i} 完了")
                
                # ステップ間待機
                if i < len(steps):
                    await asyncio.sleep(2)
            
            logger.info(f"✅ 全 {len(steps)} ステップ完了")
            
            return {
                'success': True,
                'content': accumulated_content,
                'steps_completed': len(steps),
                'step_results': results,
                'full_text': accumulated_content,
                'summary': accumulated_content[:500] if len(accumulated_content) > 500 else accumulated_content
            }
        
        except Exception as e:
            logger.error(f"❌ マルチステップタスク {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_multi_step_content_task({task_id})")
            return {
                'success': False,
                'error': str(e),
                'step_results': results
            }
    
    def display_suggested_tasks(self, tasks: List[Dict]):
        """
        提案されたタスクを表示
        
        Args:
            tasks: 提案タスクのリスト
        """
        print("\n" + "="*60)
        print("📋 提案されたコンテンツタスク:")
        print("="*60)
        for i, task in enumerate(tasks, 1):
            print(f"\n{i}. {task.get('description', 'N/A')}")
            print(f"   AI: {task.get('ai_site', 'gemini')}")
            print(f"   形式: {task.get('output_format', 'markdown')}")
            print(f"   優先度: {task.get('priority', 'medium')}")
        print("="*60)
    
    async def edit_suggested_tasks(self, tasks: List[Dict]) -> List[Dict]:
        """
        提案タスクを編集
        
        Args:
            tasks: 編集対象のタスクリスト
            
        Returns:
            List[Dict]: 編集後のタスクリスト
        """
        edited_tasks = []
        
        for i, task in enumerate(tasks, 1):
            print(f"\n--- タスク {i}/{len(tasks)} の編集 ---")
            print(f"現在の説明: {task.get('description', 'N/A')}")
            
            edit = input("このタスクを編集しますか? (y/n/s=スキップ): ").lower()
            
            if edit == 's':
                print("このタスクをスキップします")
                continue
            elif edit == 'y':
                new_desc = input("新しい説明 (Enter=変更なし): ")
                if new_desc:
                    task['description'] = new_desc
                
                new_ai = input(f"AI (現在: {task.get('ai_site', 'gemini')}, Enter=変更なし): ")
                if new_ai:
                    task['ai_site'] = new_ai
                
                new_format = input(f"出力形式 (現在: {task.get('output_format', 'markdown')}, Enter=変更なし): ")
                if new_format:
                    task['output_format'] = new_format
            
            edited_tasks.append(task)
        
        return edited_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """
        手動でコンテンツタスクを作成
        
        Returns:
            List[Dict]: 作成されたタスクリスト
        """
        manual_tasks = []
        
        print("\n" + "="*60)
        print("✍️ 手動コンテンツタスク作成")
        print("="*60)
        
        while True:
            print(f"\n--- タスク {len(manual_tasks) + 1} ---")
            
            description = input("タスク説明 (Enter=完了): ")
            if not description:
                break
            
            prompt = input("プロンプト (Enter=説明と同じ): ")
            if not prompt:
                prompt = description
            
            ai_site = input("AI (gemini/deepseek/claude, Enter=gemini): ") or 'gemini'
            output_format = input("出力形式 (markdown/text/html, Enter=markdown): ") or 'markdown'
            priority = input("優先度 (high/medium/low, Enter=medium): ") or 'medium'
            
            task = {
                'description': description,
                'prompt': prompt,
                'ai_site': ai_site,
                'output_format': output_format,
                'priority': priority,
                'required_role': 'content'
            }
            
            manual_tasks.append(task)
            print(f"✅ タスク {len(manual_tasks)} 追加完了")
            
            continue_add = input("\n別のタスクを追加しますか? (y/n): ").lower()
            if continue_add != 'y':
                break
        
        print(f"\n✅ {len(manual_tasks)}件のタスクを作成しました")
        return manual_tasks
    
    def _determine_content_type(self, task: Dict) -> str:
        """
        コンテンツタイプを判定
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: コンテンツタイプ
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
        
        # 記事生成
        if any(kw in description or kw in prompt for kw in ['記事', 'article', 'ブログ', 'blog']):
            return 'article'
        
        # 翻訳
        if any(kw in description or kw in prompt for kw in ['翻訳', 'translate', 'translation']):
            return 'translation'
        
        # 技術文書
        if any(kw in description or kw in prompt for kw in ['要件定義', '設計書', '仕様書', 'technical', 'spec']):
            return 'technical_document'
        
        return 'generic'
    
    async def _execute_article_generation(self, task: Dict) -> Dict:
        """
        記事生成タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📰 記事生成タスク実行")
            
            # プロンプト構築
            prompt = self._build_article_prompt(task)
            
            # AIチャットエージェントを使用して生成
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=180)
                
                if success:
                    # 応答取得
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 100:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'article',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': '記事生成失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': '記事生成失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 記事生成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_translation_task(self, task: Dict) -> Dict:
        """
        翻訳タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🌐 翻訳タスク実行")
            
            # 翻訳プロンプト構築
            prompt = self._build_translation_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'translation',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': '翻訳失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': '翻訳失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 翻訳エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_technical_document_task(self, task: Dict) -> Dict:
        """
        技術文書生成タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📋 技術文書生成タスク実行")
            
            # 技術文書プロンプト構築
            prompt = self._build_technical_document_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=300)  # 長めのタイムアウト
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    # 技術文書は部分的な成功も許容
                    if response_text and len(response_text) > 500:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': len(response_text) > 2000  # 完全性フラグ
                        }
                    elif response_text and len(response_text) > 200:
                        # 部分的な成功
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': False,
                            'partial_success': True,
                            'warning': '文書が完全ではない可能性があります'
                        }
                    else:
                        return {
                            'success': False,
                            'error': '技術文書生成失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': '技術文書生成失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 技術文書生成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_generic_content_task(self, task: Dict) -> Dict:
        """
        汎用コンテンツ生成タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📄 汎用コンテンツ生成タスク実行")
            
            prompt = task.get('prompt', '')
            if not prompt:
                return {
                    'success': False,
                    'error': 'プロンプトが指定されていません'
                }
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'generic',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'コンテンツ生成失敗: 応答が短すぎます'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'コンテンツ生成失敗: AI応答待機タイムアウト'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ブラウザコントローラーが利用できません'
                }
                
        except Exception as e:
            logger.error(f"❌ 汎用コンテンツ生成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }    
    
    def _build_article_prompt(self, task: Dict) -> str:
            """記事生成用プロンプトを構築"""
            base_prompt = task.get('prompt', '')
            language = task.get('language', 'ja')
            
            if language == 'ja':
                return f"""以下のテーマで質の高い記事を生成してください：

    {base_prompt}

    【記事の要件】
    - 専門的かつ分かりやすい内容
    - 具体的な事例やデータを含める
    - 読者の関心を引く導入部
    - 明確な結論で締めくくる
    - 1500文字以上で詳細に記述

    【出力形式】
    - 見出しを適切に使用
    - 段落分けを明確に
    - 読みやすい文体で"""
            
            else:
                return f"""Generate a high-quality article on the following topic:

    {base_prompt}

    【Article Requirements】
    - Professional yet accessible content
    - Include specific examples and data
    - Engaging introduction
    - Clear conclusion
    - Detailed description over 1500 words

    【Output Format】
    - Use appropriate headings
    - Clear paragraph breaks
    - Readable writing style"""
        
    def _build_translation_prompt(self, task: Dict) -> str:
        """翻訳用プロンプトを構築"""
        source_text = task.get('source_text', '')
        target_language = task.get('target_language', 'ja')
        source_language = task.get('source_language', 'en')
        
        return f"""以下のテキストを{source_language}から{target_language}に翻訳してください：

    {source_text}

    【翻訳要件】
    - 自然で流暢な表現
    - 専門用語は適切に訳す
    - 文化的な違いを考慮
    - 原文の意味を正確に伝える"""
        
    def _build_technical_document_prompt(self, task: Dict) -> str:
        """技術文書用プロンプトを構築"""
        base_prompt = task.get('prompt', '')
        
        return f"""以下の要件に基づいて詳細な技術文書を作成してください：

    {base_prompt}

    【文書要件】
    - 技術的に正確な内容
    - 体系的な構成
    - 具体的な実装例やコードサンプル
    - わかりやすい説明
    - 2000文字以上で詳細に記述

    【出力形式】
    - 章立てを明確に
    - コードブロックは適切にフォーマット
    - 表やリストを必要に応じて使用
    - 専門用語は初出時に簡潔に説明"""
    
    
    def _build_pydantic_migration_prompt(self, task: Dict) -> str:
        """
        Pydanticモデル移行専用プロンプトを構築
    
        Args:
            task: タスク情報辞書
        
        Returns:
            str: Pydanticモデル移行プロンプト
        """
        base_prompt = task.get('prompt', '')
        current_implementation = task.get('current_implementation', '')
    
        return f"""以下の要件に基づいて、既存のデータ構造をPydanticモデルに移行してください:

    {base_prompt}

    【現在の実装】
    {current_implementation if current_implementation else '※データ構造の詳細は要件定義書を参照'}

    【Pydantic移行要件】
    1. **Pydanticモデル定義**
        - すべてのデータ構造をPydantic BaseModelクラスとして定義
        - 型ヒント(Type Hints)を明確に指定
        - Field()を使用したバリデーション設定
        - Optional型の適切な使用

    2. **バリデーション実装**
        - 必須フィールドの定義
        - データ型の厳格なチェック
        - カスタムバリデータの実装
        - エラーメッセージの日本語化

    3. **JSONスキーマ生成**
        - model.schema_json()によるスキーマ出力
        - OpenAPI互換性の確保
        - ドキュメント文字列の記述

    4. **自動テストコード**
        - pytest対応のテストケース
        - 正常系・異常系のテストデータ
        - バリデーションエラーの確認

    【出力形式】
    ```python
    from pydantic import BaseModel, Field, validator
    from typing import Optional, List
    from datetime import datetime
    # (完全なPydanticモデル定義コード)
    【必須要素】

    すべてのフィールドに型ヒントとField()による説明
    @validatorデコレータによるカスタム検証ロジック
    repr()メソッドのオーバーライド
    model_config設定(alias, extra='forbid'など)

    2000文字以上で詳細に記述してください。"""
    
    def _build_openapi_schema_prompt(self, task: Dict) -> str:
        """
        OpenAPIスキーマ生成専用プロンプトを構築
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: OpenAPIスキーマ生成プロンプト
        """
        base_prompt = task.get('prompt', '')
        api_endpoints = task.get('api_endpoints', [])
        
        endpoints_list = '\n'.join([f"  - {ep}" for ep in api_endpoints]) if api_endpoints else '※要件定義書参照'
        
        return f"""以下のAPI仕様に基づいて、完全なOpenAPI 3.0スキーマを生成してください:
    {base_prompt}
    【対象APIエンドポイント】
    {endpoints_list}
    【OpenAPIスキーマ要件】

    1.基本構造
    OpenAPI 3.0.0準拠
    info(タイトル、バージョン、説明)
    servers(開発・本番環境)
    paths(全エンドポイント)
    components/schemas(データモデル)


    2.エンドポイント定義
    HTTPメソッド(GET, POST, PUT, DELETE)
    パスパラメータとクエリパラメータ
    リクエストボディ(application/json)
    レスポンススキーマ(200, 400, 500)
    認証要件(bearerAuth)


    3.データモデル定義
    すべてのリクエスト/レスポンス型
    プロパティの型と説明
    required配列の定義
    example値の提供

    4.セキュリティ定義
    securitySchemes定義
    JWT認証の設定
    OAuth2フロー(該当する場合)

    【出力形式】
    openapi: 3.0.0
    info:
      title: (APIタイトル)
      version: 1.0.0
      description: (API説明)
    servers:
      - url: https://api.example.com/v1
    paths:
      # (完全なエンドポイント定義)
    components:
      schemas:
        # (完全なデータモデル定義)
      securitySchemes:
        bearerAuth:
          type: http
          scheme: bearer
          bearerFormat: JWT
    2500文字以上で詳細に記述してください。"""
    def _build_requirements_document_prompt(self, task: Dict) -> str:
        """
        要件定義書作成専用プロンプトを構築
    
        Args:
            task: タスク情報辞書
        
        Returns:
            str: 要件定義書プロンプト
        """
        base_prompt = task.get('prompt', '')
        project_name = task.get('project_name', 'プロジェクト')
    
        return f"""以下のプロジェクトについて、包括的な要件定義書を作成してください:
    プロジェクト名: {project_name}
    {base_prompt}
    【要件定義書の構成】
    1. プロジェクト概要

    プロジェクトの背景と目的
    対象ユーザー・ステークホルダー
    プロジェクトのスコープ
    成功指標(KPI)

    2. 機能要件
    2.1 ユーザー機能

    会員登録・ログイン
    プロフィール管理
    (その他機能を列挙)

    2.2 管理機能

    コンテンツ管理
    ユーザー管理
    レポート・分析

    2.3 API仕様

    エンドポイント一覧
    認証方式
    データフォーマット

    3. 非機能要件
    3.1 パフォーマンス要件

    レスポンスタイム目標
    同時接続数
    データ量の想定

    3.2 セキュリティ要件

    認証・認可方式
    データ暗号化
    脆弱性対策

    3.3 可用性・拡張性

    SLA目標
    バックアップ・リカバリ
    スケーラビリティ

    4. 技術スタック
    4.1 フロントエンド

    フレームワーク/ライブラリ
    状態管理
    UI/UXライブラリ

    4.2 バックエンド

    言語・フレームワーク
    データベース
    APIアーキテクチャ

    4.3 インフラ

    ホスティング環境
    CI/CD
    監視・ログ

    5. データ設計
    5.1 データモデル

    エンティティ一覧
    リレーションシップ
    主要な制約

    5.2 データフロー

    データの流れ
    外部連携
    バッチ処理

    6. 画面設計
    6.1 画面一覧

    画面名と役割
    画面遷移図
    ワイヤーフレーム概要

    7. 外部連携

    決済API
    メール送信
    ソーシャルログイン

    8. 運用・保守

    リリース計画
    運用体制
    サポート体制

    9. リスク管理

    想定リスク
    対策
    緊急時対応

    10. スケジュール

    マイルストーン
    各フェーズの期間
    リリース日

    【記述要件】

    各セクションを具体的かつ詳細に記述
    技術的な実装案も含める
    数値目標を明確に設定
    図表の説明も含める(実際の図は別途)

    3000文字以上で詳細に記述してください。"""
   
    def _determine_content_type(self, task: Dict) -> str:
        """
        コンテンツタイプを判定
    
        Args:
            task: タスク情報辞書
        
        Returns:
            str: コンテンツタイプ
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
    
        # ========================================
        # 🆕 専門文書タイプの判定（新規追加）
        # ========================================
    
        # Pydantic移行タスク
        if any(kw in description or kw in prompt for kw in ['pydantic', 'モデル移行', 'model migration', 'バリデーション']):
            return 'pydantic_migration'
    
        # OpenAPIスキーマ生成
        if any(kw in description or kw in prompt for kw in ['openapi', 'swagger', 'api仕様', 'api schema']):
            return 'openapi_schema'
    
        # 要件定義書作成
        if any(kw in description or kw in prompt for kw in ['要件定義書', '要件定義', 'requirements document', 'システム要件']):
            return 'requirements_document'
    
        # ========================================
        # 既存の判定ロジック
        # ========================================
    
        # 記事生成
        if any(kw in description or kw in prompt for kw in ['記事', 'article', 'ブログ', 'blog']):
            return 'article'
    
        # 翻訳
        if any(kw in description or kw in prompt for kw in ['翻訳', 'translate', 'translation']):
            return 'translation'
    
        # 技術文書
        if any(kw in description or kw in prompt for kw in ['要件定義', '設計書', '仕様書', 'technical', 'spec']):
            return 'technical_document'
    
        return 'generic'
    
    def _is_partial_success(self, result: Dict) -> bool:
        """
        部分的な成功か判定
        
        Args:
            result: 実行結果
            
        Returns:
            bool: 部分成功ならTrue
        """
        if not result:
            return False
        
        # コンテンツがある程度あれば部分成功とみなす
        content = result.get('content') or result.get('full_text')
        if content and len(str(content)) > 500:
            return True
        
        # 技術文書で不完全フラグがある場合
        if result.get('content_type') == 'technical_document' and content and len(str(content)) > 200:
            return True
        
        return False
    
    
    

#content_writer_agent.py
# content_writer_agent.py
import asyncio
import logging
import json
from pathlib import Path
from typing import Dict
from datetime import datetime

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class ContentWriterAgent:
    """強化版コンテンツライターAI - コンパクトな構造化HTML記事を生成"""
    
    CONTENT_WRITER_PROMPT = """あなたは経験豊富なコンテンツライターです。ウズベキスタンのM&A市場に関する専門知識を持っています。

【あなたの役割】
- 指定されたURLの記事を読み、ウズベキスタンのM&Aに興味があるビジネスオーナー向けに有益な記事を作成
- ブログにそのまま掲載できる高品質の構造化HTML記事を執筆
- SEOを意識した構成とキーワード配置
- 多言語対応（日本語/英語/ロシア語など）

【執筆の原則】
1. 「了解しました！」などの挨拶は一切不要
2. 最初から完全なHTML形式で出力
3. 数字や重要な部分は<strong>タグで強調
4. 適切な見出し構造（h2, h3）と段落で読みやすく
5. リストを活用した構造化
6. ターゲット読者（ビジネスオーナー、投資家）の関心に合わせた内容

【記事の長さ】
- 目標文字数: 1800〜3500文字、2000~3000文字程度が最もベスト
- コンパクトで価値の高い内容に集中
- 冗長な説明を避け、重要なポイントのみを記載

【出力形式 - シンプルなHTML構造】
以下のHTML構造で出力してください：

<article class="mna-article">
  <h1>記事タイトル - 魅力的でSEOを意識</h1>
  
  <div class="article-meta">
    <span class="publish-date">公開日: YYYY年MM月DD日</span>
    <span class="target-region">対象地域: ウズベキスタン</span>
  </div>
  
  <section class="intro">
    <h2>はじめに</h2>
    <p>この記事のテーマと価値を簡潔に説明（2-3文）</p>
  </section>
  
  <section class="main-content">
    <h2>主要ポイント</h2>
    <p>重要な情報を簡潔に説明（3-4段落）</p>
    
    <div class="key-points">
      <h3>注目すべき点</h3>
      <ul>
        <li><strong>ポイント1</strong>: 簡潔な説明</li>
        <li><strong>ポイント2</strong>: 簡潔な説明</li>
        <li><strong>ポイント3</strong>: 簡潔な説明</li>
      </ul>
    </div>
  </section>
  
  <section class="business-value">
    <h2>ビジネス機会</h2>
    <p>ウズベキスタンのM&A市場における具体的な機会（2-3段落）</p>
  </section>
  
  <section class="conclusion">
    <h2>まとめ</h2>
    <p>要点を2-3文でまとめる</p>
  </section>
  
  <div class="article-footer">
    <p><strong>参照元</strong>: <a href="元記事URL" target="_blank">元記事タイトル</a></p>
  </div>
</article>

【重要な制約】
- 各セクションは簡潔に（1セクションあたり200-300文字）
- 冗長な表現を避ける
- 必ず最後（</article>タグ）まで完結させる
"""

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
            else:
                self.output_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
                self.output_folder.mkdir(exist_ok=True, parents=True)
        else:
            self.output_folder = output_folder
    
    async def process_task(self, task: Dict) -> Dict:
        """コンテンツ作成タスクを処理 - コンパクトな構造化HTML出力"""
        try:
            logger.info(f"🔧 強化版コンテンツライターAI: タスク処理開始")
            logger.info(f"タスク: {task['description'][:100]}...")
            
            # タスクから要件を抽出
            task_info = self._parse_task_requirements(task['description'])
            
            # タスクに明示的な言語フィールドがある場合は優先
            if 'language' in task and task['language']:
                task_info['language'] = task['language']
                logger.info(f"📌 タスクフィールドから言語を取得: {task_info['language']}")
            
            logger.info(f"  URL: {task_info['url'][:60] if task_info['url'] else '(URLなし)'}...")
            logger.info(f"  言語: {task_info['language']}")
            logger.info(f"  ターゲット: {task_info['target_audience']}")
            
            # 言語別のプロンプト調整
            language_specific_prompt = self._get_language_specific_prompt(task_info['language'])
            
            # プロンプトを構築（コンパクト版）
            full_prompt = f"""{self.CONTENT_WRITER_PROMPT}

{language_specific_prompt}

【具体的な執筆依頼】
参照URL: {task_info['url']}
ターゲット読者: {task_info['target_audience']}
言語: {task_info['language']}

【厳守事項】
1. 上記URLの記事を読み、{task_info['target_audience']}向けに有益な記事を作成
2. 目標文字数: 1500〜1800文字（これを絶対に超えない）
3. 完全なHTML形式で出力（マークダウン不可）
4. 見出し構造（h1, h2, h3）を適切に使用
5. 重要な数字は<strong>タグで強調
6. 記事全体を{task_info['language']}で執筆
7. 各セクションは簡潔に（1セクション200-300文字）

【最重要】
- 記事は必ず完結させる（途中で終わらない）
- </article>タグで必ず閉じる
- conclusionセクションとarticle-footerを必ず含める
- 長すぎる記事は途中で切れる可能性があるため、コンパクトに書く

**1800文字以内で、HTMLタグを使用した完全な記事を最後まで書き切ってください。**"""
            
            # Geminiに送信
            logger.info("Geminiにコンパクトな構造化HTML記事作成を依頼中...")
            logger.info(f"  目標文字数: 1500〜1800文字")
            logger.info(f"  プロンプト長: {len(full_prompt)}文字")
            await self.browser.send_prompt(full_prompt)
            
            # 応答待機（コンパクトなので短めでOK）
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                return {
                    'success': False,
                    'error': 'コンテンツライターAI: タイムアウト'
                }
            
            # 応答を取得
            article_html = await self.browser.extract_latest_text_response()
            
            if not article_html:
                return {
                    'success': False,
                    'error': 'コンテンツライターAI: 記事取得失敗'
                }
            
            logger.info(f"✅ 構造化HTML記事生成完了: {len(article_html)}文字")
            
            # HTMLの完全性をチェック
            if not self._validate_html_completeness(article_html):
                logger.warning("⚠️ 記事が途中で途切れている可能性があります")
            
            # タイトルを抽出（最初の<h1>タグ）
            import re
            title_match = re.search(r'<h1[^>]*>(.+?)</h1>', article_html, re.IGNORECASE | re.DOTALL)
            article_title = title_match.group(1).strip() if title_match else "（タイトル不明）"
            
            logger.info(f"  記事タイトル: {article_title}")
            
            # JSON形式でメタデータとともに保存
            article_data = {
                'task_id': task['task_id'],
                'title': article_title,
                'html_content': article_html,
                'language': task_info['language'],
                'target_audience': task_info['target_audience'],
                'source_url': task_info['url'],
                'created_at': datetime.now().isoformat(),
                'word_count': len(article_html),
                'content_type': 'structured_html_compact',
                'is_complete': self._validate_html_completeness(article_html)
            }
            
            # JSONファイルとして保存
            json_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            json_output_path = self.output_folder / json_filename
            
            with open(json_output_path, 'w', encoding='utf-8') as f:
                json.dump(article_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"構造化記事をJSON保存: {json_filename}")
            
            # HTMLファイルも別途保存（確認用）
            html_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            html_output_path = self.output_folder / html_filename
            
            with open(html_output_path, 'w', encoding='utf-8') as f:
                f.write("<!DOCTYPE html>\n")
                f.write("<html lang='ja'>\n")
                f.write("<head>\n")
                f.write("<meta charset='UTF-8'>\n")
                f.write("<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n")
                f.write(f"<title>{article_title}</title>\n")
                f.write("<style>\n")
                f.write("body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.8; margin: 40px; max-width: 800px; margin: 0 auto; padding: 40px; }\n")
                f.write("h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 15px; font-size: 28px; }\n")
                f.write("h2 { color: #34495e; margin-top: 35px; font-size: 22px; border-left: 4px solid #3498db; padding-left: 10px; }\n")
                f.write("h3 { color: #16a085; font-size: 18px; margin-top: 20px; }\n")
                f.write(".article-meta { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 25px 0; font-size: 14px; }\n")
                f.write(".key-points { background: #e8f4fd; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3498db; }\n")
                f.write(".article-footer { margin-top: 50px; padding-top: 25px; border-top: 2px solid #ddd; color: #666; }\n")
                f.write("ul { line-height: 1.8; }\n")
                f.write("li { margin-bottom: 10px; }\n")
                f.write("strong { color: #e74c3c; }\n")
                f.write("p { margin-bottom: 15px; }\n")
                f.write("</style>\n")
                f.write("</head>\n")
                f.write("<body>\n")
                f.write(article_html)
                f.write("</body>\n")
                f.write("</html>\n")
            
            logger.info(f"HTMLプレビューも保存: {html_filename}")
            
            # サマリーを作成
            article_preview = self._extract_text_preview(article_html)
            
            summary = f"記事タイトル: {article_title}\n言語: {task_info['language']}\n文字数: {len(article_html)}\n完全性: {'✅ 完全' if article_data['is_complete'] else '⚠️ 不完全'}\nプレビュー: {article_preview}"
            
            return {
                'success': True,
                'output_file': str(json_output_path),
                'html_file': str(html_output_path),
                'summary': summary,
                'full_text': article_html,
                'article_title': article_title,
                'content_type': 'structured_html_compact',
                'language': task_info['language'],
                'is_complete': article_data['is_complete']
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "強化版コンテンツライターAI処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _validate_html_completeness(self, html_content: str) -> bool:
        """HTMLが完全かどうかをチェック"""
        import re
        
        # 必須要素がすべて含まれているかチェック
        required_elements = [
            r'<article[^>]*>',           # 開始タグ
            r'</article>',                # 終了タグ
            r'<section[^>]*class="conclusion"',  # まとめセクション
            r'<div[^>]*class="article-footer"'   # フッター
        ]
        
        for pattern in required_elements:
            if not re.search(pattern, html_content, re.IGNORECASE):
                logger.warning(f"⚠️ 必須要素が見つかりません: {pattern}")
                return False
        
        return True
    
    def _get_language_specific_prompt(self, language: str) -> str:
        """言語別の追加プロンプトを返す"""
        prompts = {
            "日本語": """
【日本語記事の特徴】
- 必ず日本語（ひらがな、カタカナ、漢字を含む自然な日本語）で執筆
- 敬語を使用し、ビジネスフォーマルな文体を維持
- 具体的なデータとともに説明を展開
- ウズベキスタンのM&A市場における日本企業の視点を重視
- 読者（日本のビジネスオーナー）が理解しやすい表現を使用
- 1500〜1800文字以内にまとめる

【執筆時の注意点】
- 英語や他言語は固有名詞・専門用語以外では使用しない
- 数字は半角、単位は全角（例: 6%、100億円）
- 各セクションは簡潔に200-300文字程度
- 記事は必ず最後（</article>タグ）まで完結させる
""",
            "English": """
【English Article Features】
- Write entirely in English (no Japanese characters except proper nouns)
- Use business formal English throughout
- Include specific data and examples
- Focus on investment opportunities in Uzbekistan's M&A market
- Target international business owners and investors
- Keep article between 1500-1800 characters
- Complete the article with proper conclusion and footer sections
""",
            "Русский (ロシア語)": """
【Русскоязычная статья особенности】
- Пишите полностью на русском языке
- Используйте деловой русский язык
- Включите конкретные данные и примеры
- Акцент на возможностях слияний и поглощений в Узбекистане
- Целевая аудитория - русскоязычные инвесторы
- Объём статьи: 1500-1800 символов
- Завершите статью полноценным заключением
"""
        }
        return prompts.get(language, prompts["日本語"])
    
    def _extract_text_preview(self, html_content: str) -> str:
        """HTMLからテキストプレビューを抽出"""
        import re
        # HTMLタグを除去
        text = re.sub(r'<[^>]+>', ' ', html_content)
        # 連続する空白を単一スペースに
        text = re.sub(r'\s+', ' ', text)
        # 先頭200文字を返す
        return text.strip()[:200] + "..." if len(text) > 200 else text
    
    def _parse_task_requirements(self, description: str) -> Dict[str, str]:
        """タスク説明から要件を抽出（日本語デフォルト版）"""
        import re
        
        # URLを抽出
        url_match = re.search(r'https?://[^\s]+', description)
        url = url_match.group(0) if url_match else ""
        
        # === 言語検出ロジック（日本語デフォルト戦略） ===
        # 基本方針: 明示的な指定がない限り、常に日本語で生成
        language = "日本語"  # 絶対的なデフォルト
        
        # 明示的な言語指定パターン（非常に厳格に）
        explicit_lang_patterns = {
            "English": [
                r'英語で(?:作成|記事|執筆|書)',
                r'write in english',
                r'in english(?:\s+language)?',
                r'create.*in english',
                r'言語[：:]\s*(?:英語|English)'
            ],
            "Русский (ロシア語)": [
                r'ロシア語で(?:作成|記事|執筆|書)',
                r'на русском(?:\s+языке)?',
                r'in russian',
                r'言語[：:]\s*(?:ロシア語|русский)'
            ],
            "中文": [
                r'中国語で(?:作成|記事|執筆|書)',
                r'中文で(?:作成|記事|執筆|書)',
                r'in chinese',
                r'用中文',
                r'言語[：:]\s*(?:中国語|中文|Chinese)'
            ],
            "한국어": [
                r'韓国語で(?:作成|記事|執筆|書)',
                r'한국어로',
                r'in korean',
                r'言語[：:]\s*(?:韓国語|한국어)'
            ],
            "Türkçe": [
                r'トルコ語で(?:作成|記事|執筆|書)',
                r'türkçe(?:\'de)?',
                r'in turkish',
                r'言語[：:]\s*(?:トルコ語|Türkçe)'
            ],
            "O'zbek": [
                r'ウズベク語で(?:作成|記事|執筆|書)',
                r'o\'zbek tilida',
                r'in uzbek',
                r'言語[：:]\s*(?:ウズベク語|O\'zbek)'
            ]
        }
        
        # 明示的な言語指定をチェック
        explicit_lang_found = False
        for lang, patterns in explicit_lang_patterns.items():
            for pattern in patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    language = lang
                    explicit_lang_found = True
                    logger.info(f"✅ 明示的な言語指定を検出: {language}")
                    logger.info(f"   マッチしたパターン: {pattern}")
                    break
            if explicit_lang_found:
                break
        
        # 明示的な指定がなかった場合
        if not explicit_lang_found:
            logger.info("📌 明示的な言語指定なし → デフォルトの日本語を使用")
            
            # 補助的な判定（極端なケースのみ）
            # キリル文字が大半を占める場合のみロシア語と判定
            cyrillic_count = len(re.findall(r'[А-Яа-яЁё]', description))
            total_chars = len(re.sub(r'\s', '', description))
            
            # ハングルが大半を占める場合のみ韓国語と判定
            hangul_count = len(re.findall(r'[가-힣]', description))
            
            if total_chars > 0:
                if cyrillic_count > total_chars * 0.3:  # 30%以上がキリル文字
                    language = "Русский (ロシア語)"
                    logger.info(f"🔍 キリル文字が多数（{cyrillic_count}/{total_chars}）: ロシア語")
                elif hangul_count > total_chars * 0.3:  # 30%以上がハングル
                    language = "한국어"
                    logger.info(f"🔍 ハングルが多数（{hangul_count}/{total_chars}）: 韓国語")
                else:
                    # それ以外は全て日本語（ひらがな・カタカナ・漢字・英数字混在含む）
                    logger.info("📝 デフォルト言語確定: 日本語")
        
        # ターゲット読者を抽出
        target_patterns = [
            r'(.+?)向けに',
            r'(.+?)向けの',
            r'ターゲット[：:]\s*(.+)',
            r'for (.+?) considering',
            r'для (.+?),',
            r'対象読者[：:]\s*(.+)'
        ]
        target_audience = ""
        for pattern in target_patterns:
            match = re.search(pattern, description)
            if match:
                target_audience = match.group(1).strip()
                break
        
        if not target_audience:
            target_audience = "ウズベキスタンのM&Aに興味があるビジネスオーナー"
        
        # 特別な要件を抽出
        requirements = []
        if '構造化' in description or 'HTML' in description.upper():
            requirements.append("構造化HTML形式で出力")
        if 'データ' in description or '数字' in description:
            requirements.append("具体的なデータと数字を含める")
        if '事例' in description or 'ケーススタディ' in description:
            requirements.append("実際の事例やケーススタディを含める")
        
        logger.info(f"📝 最終決定言語: {language}")
        logger.info(f"🎯 ターゲット読者: {target_audience}")
        
        def _get_translation_prompt(self, source_language: str, target_language: str) -> str:
            """翻訳タスク用の追加プロンプト"""
            return f"""
        【翻訳タスクの指示】
        これは翻訳タスクです。以下の指示に厳密に従ってください：

        1. 元の記事の内容を{target_language}に正確に翻訳
        2. HTML構造とフォーマットを維持
        3. 文化的な違いを考慮した自然な表現を使用
        4. 専門用語は正確に翻訳
        5. 数字やデータはそのまま保持

        翻訳元言語: {source_language}
        翻訳先言語: {target_language}

        **重要: 翻訳後の記事は完全なHTML形式で、必ず</article>タグで終了すること**
        """
        
        return {
            'url': url,
            'language': language,
            'target_audience': target_audience,
            'requirements': '、'.join(requirements) if requirements else "標準的な構造化記事"
        }

#data_models.py
"""
data_models.py - 自律型修正システムのデータモデル定義
ErrorContextModelとバグ修正タスクの構造化データモデル
"""

from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum


class ErrorSeverity(str, Enum):
    """エラー深刻度"""
    CRITICAL = "critical"  # システム停止レベル
    HIGH = "high"         # 機能不全
    MEDIUM = "medium"     # 部分的な問題
    LOW = "low"          # 軽微な問題


class ErrorCategory(str, Enum):
    """エラーカテゴリ"""
    IMPORT_ERROR = "import_error"
    ATTRIBUTE_ERROR = "attribute_error"
    TYPE_ERROR = "type_error"
    SYNTAX_ERROR = "syntax_error"
    WP_CLI_ERROR = "wp_cli_error"
    ACF_ERROR = "acf_error"
    RUNTIME_ERROR = "runtime_error"
    UNKNOWN = "unknown"


class CodeLocation(BaseModel):
    """コードの位置情報"""
    file_path: str = Field(..., description="ファイルパス")
    line_number: int = Field(..., description="エラー発生行番号")
    function_name: Optional[str] = Field(None, description="関数名")
    class_name: Optional[str] = Field(None, description="クラス名")
    
    @validator('line_number')
    def validate_line_number(cls, v):
        if v < 1:
            raise ValueError("行番号は1以上である必要があります")
        return v


class StackTraceFrame(BaseModel):
    """スタックトレースのフレーム情報"""
    file_path: str = Field(..., description="ファイルパス")
    line_number: int = Field(..., description="行番号")
    function_name: str = Field(..., description="関数名")
    code_context: Optional[str] = Field(None, description="コード文脈(前後3行)")


class ErrorContextModel(BaseModel):
    """
    エラーコンテキスト - AI修正に必要な全情報を構造化
    
    このモデルは、発生したエラーの詳細情報を保持し、
    AIが適切な修正コードを生成するための入力として使用される
    """
    
    # 基本情報
    error_id: str = Field(..., description="エラーID (task_id + timestamp)")
    timestamp: datetime = Field(default_factory=datetime.now, description="エラー発生時刻")
    task_id: str = Field(..., description="失敗したタスクID")
    agent_name: Optional[str] = Field(None, description="実行中のエージェント名")
    
    # エラー分類
    error_type: str = Field(..., description="Pythonエラー型名 (AttributeError等)")
    error_category: ErrorCategory = Field(ErrorCategory.UNKNOWN, description="エラーカテゴリ")
    severity: ErrorSeverity = Field(ErrorSeverity.MEDIUM, description="深刻度")
    
    # エラー詳細
    error_message: str = Field(..., description="エラーメッセージ")
    full_traceback: str = Field(..., description="完全なスタックトレース")
    stack_frames: List[StackTraceFrame] = Field(default_factory=list, description="構造化スタックトレース")
    
    # コード情報
    error_location: Optional[CodeLocation] = Field(None, description="エラー発生位置")
    problematic_code: Optional[str] = Field(None, description="問題のあるコードスニペット")
    surrounding_code: Optional[str] = Field(None, description="周辺コード(前後10行)")
    
    # 実行コンテキスト
    local_variables: Dict[str, Any] = Field(default_factory=dict, description="ローカル変数の状態")
    global_variables: Dict[str, Any] = Field(default_factory=dict, description="グローバル変数の状態")
    function_arguments: Optional[Dict[str, Any]] = Field(None, description="関数の引数")
    
    # タスク情報
    task_description: Optional[str] = Field(None, description="タスク説明")
    task_parameters: Optional[Dict[str, Any]] = Field(None, description="タスクパラメータ")
    
    # WordPress/ACF固有情報
    wp_context: Optional[Dict[str, Any]] = Field(None, description="WordPressコンテキスト")
    acf_info: Optional[Dict[str, Any]] = Field(None, description="ACF情報")
    
    # 修正試行履歴
    previous_fix_attempts: List[Dict[str, Any]] = Field(default_factory=list, description="過去の修正試行")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
    
    @validator('error_category', pre=True, always=True)
    def categorize_error(cls, v, values):
        """エラータイプから自動的にカテゴリを判定"""
        if v != ErrorCategory.UNKNOWN:
            return v
        
        error_type = values.get('error_type', '').lower()
        error_message = values.get('error_message', '').lower()
        
        if 'import' in error_type or 'modulenotfound' in error_type:
            return ErrorCategory.IMPORT_ERROR
        elif 'attributeerror' in error_type:
            return ErrorCategory.ATTRIBUTE_ERROR
        elif 'typeerror' in error_type:
            return ErrorCategory.TYPE_ERROR
        elif 'syntaxerror' in error_type:
            return ErrorCategory.SYNTAX_ERROR
        elif 'wp-cli' in error_message or 'wordpress' in error_message:
            return ErrorCategory.WP_CLI_ERROR
        elif 'acf' in error_message:
            return ErrorCategory.ACF_ERROR
        else:
            return ErrorCategory.RUNTIME_ERROR


class BugFixTask(BaseModel):
    """
    バグ修正タスク - 自律修正ワークフローのタスク定義
    """
    
    task_id: str = Field(..., description="バグ修正タスクID (FIX_BUG_xxx)")
    original_task_id: str = Field(..., description="元のタスクID")
    error_context: ErrorContextModel = Field(..., description="エラーコンテキスト")
    
    # タスク設定
    priority: str = Field("critical", description="優先度 (critical/high/medium/low)")
    required_role: str = Field("quick_fix", description="必要な役割")
    
    # 修正戦略
    fix_strategy: Optional[str] = Field(None, description="修正戦略 (patch/rewrite/refactor)")
    target_files: List[str] = Field(default_factory=list, description="修正対象ファイル")
    
    # AI生成用プロンプト
    fix_prompt: Optional[str] = Field(None, description="AI修正プロンプト")
    
    # 検証要件
    test_command: Optional[str] = Field(None, description="テストコマンド")
    expected_outcome: Optional[str] = Field(None, description="期待される結果")
    
    # ステータス管理
    status: str = Field("pending", description="ステータス (pending/in_progress/testing/success/failed)")
    created_at: datetime = Field(default_factory=datetime.now, description="作成日時")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class FixResult(BaseModel):
    """修正結果モデル"""
    
    task_id: str = Field(..., description="バグ修正タスクID")
    success: bool = Field(..., description="修正成功フラグ")
    
    # 修正内容
    modified_files: List[str] = Field(default_factory=list, description="修正されたファイル")
    generated_code: Optional[str] = Field(None, description="AI生成コード")
    patch_content: Optional[str] = Field(None, description="パッチ内容(Diff形式)")
    
    # テスト結果
    test_passed: bool = Field(False, description="テスト成功")
    test_output: Optional[str] = Field(None, description="テスト出力")
    test_errors: List[str] = Field(default_factory=list, description="テストエラー")
    
    # GitHub連携情報
    branch_name: Optional[str] = Field(None, description="作成されたブランチ名")
    commit_hash: Optional[str] = Field(None, description="コミットハッシュ")
    pr_number: Optional[int] = Field(None, description="プルリクエスト番号")
    pr_url: Optional[str] = Field(None, description="プルリクエストURL")
    
    # メタ情報
    execution_time: float = Field(..., description="実行時間(秒)")
    completed_at: datetime = Field(default_factory=datetime.now, description="完了日時")
    error_message: Optional[str] = Field(None, description="エラーメッセージ(失敗時)")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class TestCaseModel(BaseModel):
    """自動テストケースモデル"""
    
    test_id: str = Field(..., description="テストID")
    test_name: str = Field(..., description="テスト名")
    test_type: str = Field(..., description="テストタイプ (unit/integration/e2e)")
    
    # テスト定義
    test_command: str = Field(..., description="テストコマンド")
    test_file: Optional[str] = Field(None, description="テストファイルパス")
    test_function: Optional[str] = Field(None, description="テスト関数名")
    
    # 期待値
    expected_return_code: int = Field(0, description="期待されるリターンコード")
    expected_output_pattern: Optional[str] = Field(None, description="期待される出力パターン(正規表現)")
    forbidden_patterns: List[str] = Field(default_factory=list, description="禁止パターン(エラー文字列)")
    
    # 実行結果
    last_run: Optional[datetime] = Field(None, description="最終実行日時")
    last_result: Optional[bool] = Field(None, description="最終結果")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

#data_models_extended.py
# data_models.py
"""
データモデル定義（拡張版）
ハイブリッド自律修正システム用
"""

from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field


# ========================================
# Enum定義
# ========================================

class ErrorSeverity(str, Enum):
    """エラー深刻度"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ErrorCategory(str, Enum):
    """エラーカテゴリ"""
    SYNTAX = "syntax"
    IMPORT = "import"
    RUNTIME = "runtime"
    LOGIC = "logic"
    DESIGN = "design"
    PERFORMANCE = "performance"
    SECURITY = "security"
    UNKNOWN = "unknown"


class TaskStatus(str, Enum):
    """タスクステータス"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class FixStrategy(str, Enum):
    """修正戦略"""
    LOCAL_ONLY = "local_only"
    CLOUD_ONLY = "cloud_only"
    LOCAL_FIRST = "local_first"
    CLOUD_FIRST = "cloud_first"
    PARALLEL = "parallel"
    ADAPTIVE = "adaptive"


# ========================================
# エラー関連モデル
# ========================================

class ErrorContextModel(BaseModel):
    """エラーコンテキスト"""
    error_type: str = Field(..., description="エラータイプ")
    error_message: str = Field(..., description="エラーメッセージ")
    severity: ErrorSeverity = Field(ErrorSeverity.MEDIUM, description="深刻度")
    error_category: ErrorCategory = Field(ErrorCategory.UNKNOWN, description="カテゴリ")
    
    file_path: Optional[str] = Field(None, description="エラー発生ファイル")
    line_number: Optional[int] = Field(None, description="行番号")
    
    full_traceback: Optional[str] = Field(None, description="完全なトレースバック")
    surrounding_code: Optional[str] = Field(None, description="周辺コード")
    local_variables: Optional[Dict[str, Any]] = Field(None, description="ローカル変数")
    
    context_info: Optional[Dict[str, Any]] = Field(None, description="追加コンテキスト")
    timestamp: datetime = Field(default_factory=datetime.now, description="発生時刻")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error_type": "AttributeError",
                "error_message": "'NoneType' object has no attribute 'get'",
                "severity": "high",
                "error_category": "runtime",
                "file_path": "wp_agent.py",
                "line_number": 42
            }
        }


class ErrorClassification(BaseModel):
    """エラー分類結果"""
    error_type: str
    category: str
    complexity: str
    complexity_score: float
    confidence: float
    recommended_strategy: str
    factors: List[str] = Field(default_factory=list)


# ========================================
# タスク関連モデル
# ========================================

class BugFixTask(BaseModel):
    """バグ修正タスク"""
    task_id: str = Field(..., description="タスクID")
    error_context: ErrorContextModel = Field(..., description="エラーコンテキスト")
    target_files: List[str] = Field(default_factory=list, description="対象ファイル")
    
    priority: int = Field(5, description="優先度（1-10）")
    run_tests: bool = Field(True, description="テスト実行フラグ")
    create_pr: bool = Field(False, description="PR作成フラグ")
    
    fix_strategy: Optional[FixStrategy] = Field(None, description="修正戦略")
    timeout: int = Field(300, description="タイムアウト（秒）")
    
    metadata: Dict[str, Any] = Field(default_factory=dict, description="メタデータ")
    created_at: datetime = Field(default_factory=datetime.now)
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "Task-54-Fix",
                "target_files": ["wp_agent.py"],
                "priority": 8,
                "run_tests": True
            }
        }


class Task(BaseModel):
    """汎用タスク"""
    task_id: str
    task_type: str
    description: str
    status: TaskStatus = TaskStatus.PENDING
    
    priority: int = 5
    assigned_agent: Optional[str] = None
    
    dependencies: List[str] = Field(default_factory=list)
    parameters: Dict[str, Any] = Field(default_factory=dict)
    
    created_at: datetime = Field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


# ========================================
# 修正結果関連モデル
# ========================================

class FixResult(BaseModel):
    """修正結果"""
    task_id: str = Field(..., description="タスクID")
    success: bool = Field(..., description="成功フラグ")
    
    modified_files: List[str] = Field(default_factory=list, description="修正されたファイル")
    generated_code: str = Field("", description="生成されたコード")
    
    test_passed: bool = Field(False, description="テスト合格フラグ")
    execution_time: float = Field(0.0, description="実行時間（秒）")
    
    confidence_score: float = Field(0.0, description="信頼度スコア（0-1）")
    reasoning: str = Field("", description="修正理由")
    
    backup_path: Optional[str] = Field(None, description="バックアップパス")
    pr_url: Optional[str] = Field(None, description="プルリクエストURL")
    
    error_message: Optional[str] = Field(None, description="エラーメッセージ")
    warnings: List[str] = Field(default_factory=list, description="警告リスト")
    
    metadata: Dict[str, Any] = Field(default_factory=dict, description="メタデータ")
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # エージェント情報
    agent_used: Optional[str] = Field(None, description="使用されたエージェント")
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "Task-54-Fix",
                "success": True,
                "modified_files": ["wp_agent.py"],
                "test_passed": True,
                "execution_time": 12.5,
                "confidence_score": 0.92
            }
        }


class TestResult(BaseModel):
    """テスト結果"""
    task_id: str
    passed: bool
    
    total_tests: int = 0
    passed_tests: int = 0
    failed_tests: int = 0
    skipped_tests: int = 0
    
    execution_time: float = 0.0
    
    test_details: List[Dict[str, Any]] = Field(default_factory=list)
    error: Optional[str] = None
    
    timestamp: datetime = Field(default_factory=datetime.now)


# ========================================
# Git/GitHub関連モデル
# ========================================

class CommitInfo(BaseModel):
    """コミット情報"""
    commit_hash: str
    branch_name: str
    commit_message: str
    author: str = "AutoFixAgent"
    timestamp: datetime = Field(default_factory=datetime.now)
    
    modified_files: List[str] = Field(default_factory=list)


class PullRequestInfo(BaseModel):
    """プルリクエスト情報"""
    pr_number: Optional[int] = None
    pr_url: str
    title: str
    body: str
    
    base_branch: str = "main"
    head_branch: str
    
    status: str = "open"
    created_at: datetime = Field(default_factory=datetime.now)


# ========================================
# 統計情報モデル
# ========================================

class AgentStats(BaseModel):
    """エージェント統計情報"""
    agent_name: str
    
    total_tasks: int = 0
    successful_tasks: int = 0
    failed_tasks: int = 0
    
    total_execution_time: float = 0.0
    average_execution_time: float = 0.0
    
    success_rate: float = 0.0
    
    additional_metrics: Dict[str, Any] = Field(default_factory=dict)
    last_updated: datetime = Field(default_factory=datetime.now)


class SystemStats(BaseModel):
    """システム全体の統計"""
    total_fixes: int = 0
    successful_fixes: int = 0
    failed_fixes: int = 0
    
    local_fixes: int = 0
    cloud_fixes: int = 0
    hybrid_fixes: int = 0
    
    total_tests: int = 0
    passed_tests: int = 0
    
    total_prs: int = 0
    merged_prs: int = 0
    
    uptime_seconds: float = 0.0
    
    agent_stats: Dict[str, AgentStats] = Field(default_factory=dict)
    
    last_updated: datetime = Field(default_factory=datetime.now)


# ========================================
# AI応答モデル
# ========================================

class AIFixResponse(BaseModel):
    """AI修正応答"""
    analysis: str = Field(..., description="エラー分析")
    root_cause: str = Field(..., description="根本原因")
    fix_strategy: str = Field(..., description="修正戦略")
    
    modified_files: Dict[str, str] = Field(..., description="ファイルパス: コード")
    
    confidence: float = Field(..., ge=0.0, le=1.0, description="信頼度")
    reasoning: str = Field(..., description="修正理由")
    
    test_suggestions: List[str] = Field(default_factory=list)
    potential_side_effects: List[str] = Field(default_factory=list)
    
    class Config:
        json_schema_extra = {
            "example": {
                "analysis": "AttributeError due to None value",
                "root_cause": "Missing null check",
                "fix_strategy": "Add defensive programming",
                "modified_files": {
                    "wp_agent.py": "def method():\n    if obj is not None:\n        ..."
                },
                "confidence": 0.95,
                "reasoning": "Added null check to prevent AttributeError"
            }
        }


# ========================================
# 設定モデル
# ========================================

class HybridFixConfig(BaseModel):
    """ハイブリッド修正設定"""
    default_strategy: FixStrategy = FixStrategy.ADAPTIVE
    
    local_timeout: int = 30
    cloud_timeout: int = 120
    
    enable_auto_tests: bool = True
    enable_auto_pr: bool = False
    
    max_retry_count: int = 3
    
    cloud_provider: str = "openai"
    cloud_model: str = "gpt-4o"
    
    github_auto_merge: bool = False
    
    backup_retention_days: int = 30


# ========================================
# ユーティリティ関数
# ========================================

def create_bug_fix_task_from_exception(
    task_id: str,
    exception: Exception,
    file_path: str,
    line_number: int,
    **kwargs
) -> BugFixTask:
    """例外からバグ修正タスクを作成"""
    import traceback
    
    error_context = ErrorContextModel(
        error_type=type(exception).__name__,
        error_message=str(exception),
        file_path=file_path,
        line_number=line_number,
        full_traceback=traceback.format_exc(),
        **kwargs
    )
    
    return BugFixTask(
        task_id=task_id,
        error_context=error_context,
        target_files=[file_path]
    )


def create_fix_result_success(
    task_id: str,
    modified_files: List[str],
    generated_code: str,
    **kwargs
) -> FixResult:
    """成功結果を作成"""
    return FixResult(
        task_id=task_id,
        success=True,
        modified_files=modified_files,
        generated_code=generated_code,
        test_passed=True,
        **kwargs
    )


def create_fix_result_failure(
    task_id: str,
    error_message: str,
    **kwargs
) -> FixResult:
    """失敗結果を作成"""
    return FixResult(
        task_id=task_id,
        success=False,
        error_message=error_message,
        **kwargs
    )

#dependency_resolver.py
"""
DependencyResolver - 依存関係解決と管理エージェント

パッケージ依存関係の分析、競合の検出と解決、バージョン互換性チェック、
自動アップデート提案、依存関係グラフの生成を提供する。
"""

import subprocess
import json
import re
from pathlib import Path
from typing import Dict, Any, List, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class DependencyStatus(Enum):
    """依存関係ステータス"""
    SATISFIED = "satisfied"
    MISSING = "missing"
    OUTDATED = "outdated"
    CONFLICT = "conflict"
    INCOMPATIBLE = "incompatible"


@dataclass
class Package:
    """パッケージ情報"""
    name: str
    installed_version: Optional[str] = None
    required_version: Optional[str] = None
    latest_version: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "installed_version": self.installed_version,
            "required_version": self.required_version,
            "latest_version": self.latest_version,
            "dependencies": self.dependencies
        }


@dataclass
class DependencyIssue:
    """依存関係の問題"""
    status: DependencyStatus
    package: Package
    description: str
    resolution: Optional[str] = None
    severity: str = "medium"  # low, medium, high, critical
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "status": self.status.value,
            "package": self.package.to_dict(),
            "description": self.description,
            "resolution": self.resolution,
            "severity": self.severity
        }


@dataclass
class DependencyGraph:
    """依存関係グラフ"""
    nodes: Dict[str, Package]
    edges: List[Tuple[str, str]]  # (from_package, to_package)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "nodes": {name: pkg.to_dict() for name, pkg in self.nodes.items()},
            "edges": [{"from": f, "to": t} for f, t in self.edges]
        }


class DependencyResolverAgent:
    """
    依存関係解決と管理エージェント
    
    主な機能:
    1. パッケージ依存関係の分析
    2. バージョン競合の検出と解決
    3. バージョン互換性チェック
    4. 自動アップデート提案
    5. 依存関係グラフの生成
    """
    
    def __init__(self, requirements_file: str = "requirements.txt"):
        self.requirements_file = requirements_file
        
        # パッケージ情報
        self.packages: Dict[str, Package] = {}
        self.issues: List[DependencyIssue] = []
        
        # 統計情報
        self.stats = {
            "total_packages": 0,
            "satisfied": 0,
            "missing": 0,
            "outdated": 0,
            "conflicts": 0
        }
        
        logger.info("DependencyResolverAgent initialized")
    
    def analyze_dependencies(self) -> List[DependencyIssue]:
        """
        依存関係を分析
        
        Returns:
            検出された問題のリスト
        """
        self.issues = []
        self.packages = {}
        
        # requirements.txtを読み込む
        required_packages = self._parse_requirements()
        
        # インストール済みパッケージを取得
        installed_packages = self._get_installed_packages()
        
        # 各パッケージを分析
        for pkg_spec in required_packages:
            pkg_name, version_spec = self._parse_package_spec(pkg_spec)
            
            package = Package(
                name=pkg_name,
                required_version=version_spec
            )
            
            # インストール状況をチェック
            if pkg_name in installed_packages:
                package.installed_version = installed_packages[pkg_name]
                
                # バージョン互換性をチェック
                if not self._is_version_compatible(
                    package.installed_version,
                    version_spec
                ):
                    issue = DependencyIssue(
                        status=DependencyStatus.INCOMPATIBLE,
                        package=package,
                        description=f"Installed version {package.installed_version} "
                                  f"does not satisfy requirement {version_spec}",
                        resolution=f"pip install {pkg_name}{version_spec}",
                        severity="high"
                    )
                    self.issues.append(issue)
                    self.stats["conflicts"] += 1
                else:
                    self.stats["satisfied"] += 1
            else:
                # パッケージが未インストール
                issue = DependencyIssue(
                    status=DependencyStatus.MISSING,
                    package=package,
                    description=f"Package {pkg_name} is not installed",
                    resolution=f"pip install {pkg_spec}",
                    severity="critical"
                )
                self.issues.append(issue)
                self.stats["missing"] += 1
            
            self.packages[pkg_name] = package
            self.stats["total_packages"] += 1
        
        # 最新バージョンをチェック
        self._check_latest_versions()
        
        # 依存関係の依存をチェック
        self._check_transitive_dependencies()
        
        return self.issues
    
    def _parse_requirements(self) -> List[str]:
        """requirements.txtをパース"""
        if not Path(self.requirements_file).exists():
            logger.warning(f"Requirements file not found: {self.requirements_file}")
            return []
        
        requirements = []
        with open(self.requirements_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # コメントと空行をスキップ
                if line and not line.startswith('#'):
                    requirements.append(line)
        
        return requirements
    
    def _get_installed_packages(self) -> Dict[str, str]:
        """インストール済みパッケージの一覧を取得"""
        try:
            result = subprocess.run(
                ['pip', 'list', '--format=json'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                packages_data = json.loads(result.stdout)
                return {
                    pkg['name'].lower(): pkg['version']
                    for pkg in packages_data
                }
        except Exception as e:
            logger.error(f"Failed to get installed packages: {e}")
        
        return {}
    
    def _parse_package_spec(self, spec: str) -> Tuple[str, Optional[str]]:
        """
        パッケージ指定をパース
        
        例: "package==1.0.0" -> ("package", "==1.0.0")
        """
        # バージョン指定子を抽出
        match = re.match(r'^([a-zA-Z0-9_-]+)(.*)$', spec)
        if match:
            name = match.group(1).lower()
            version_spec = match.group(2).strip() if match.group(2) else None
            return name, version_spec
        
        return spec.lower(), None
    
    def _is_version_compatible(self, 
                              installed: str,
                              required: Optional[str]) -> bool:
        """
        バージョン互換性をチェック
        
        簡易版の実装（より正確にはpackaging.specifiersを使用すべき）
        """
        if not required:
            return True
        
        # ==, >=, <=, >, <, != などの演算子をパース
        operators = ['==', '>=', '<=', '>', '<', '!=', '~=']
        
        for op in operators:
            if op in required:
                version = required.replace(op, '').strip()
                return self._compare_versions(installed, version, op)
        
        return True
    
    def _compare_versions(self, v1: str, v2: str, op: str) -> bool:
        """バージョンを比較"""
        try:
            # バージョンを数値のタプルに変換
            v1_parts = tuple(int(x) for x in v1.split('.'))
            v2_parts = tuple(int(x) for x in v2.split('.'))
            
            if op == '==':
                return v1_parts == v2_parts
            elif op == '>=':
                return v1_parts >= v2_parts
            elif op == '<=':
                return v1_parts <= v2_parts
            elif op == '>':
                return v1_parts > v2_parts
            elif op == '<':
                return v1_parts < v2_parts
            elif op == '!=':
                return v1_parts != v2_parts
            elif op == '~=':
                # Compatible release (PEP 440)
                # ~=1.4.5 は >=1.4.5, <1.5.0 と同等
                return v1_parts >= v2_parts and v1_parts[0] == v2_parts[0]
        except:
            # バージョン比較に失敗した場合はTrueを返す
            return True
        
        return True
    
    def _check_latest_versions(self):
        """最新バージョンをチェック"""
        for pkg_name, package in self.packages.items():
            if not package.installed_version:
                continue
            
            try:
                # PyPIから最新バージョンを取得
                result = subprocess.run(
                    ['pip', 'index', 'versions', pkg_name],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if result.returncode == 0:
                    # 出力から最新バージョンを抽出
                    match = re.search(r'Available versions: ([\d.]+)', result.stdout)
                    if match:
                        latest = match.group(1)
                        package.latest_version = latest
                        
                        # アップデート可能かチェック
                        if self._compare_versions(package.installed_version, latest, '<'):
                            issue = DependencyIssue(
                                status=DependencyStatus.OUTDATED,
                                package=package,
                                description=f"Package {pkg_name} can be updated from "
                                          f"{package.installed_version} to {latest}",
                                resolution=f"pip install --upgrade {pkg_name}",
                                severity="low"
                            )
                            self.issues.append(issue)
                            self.stats["outdated"] += 1
            except Exception as e:
                logger.debug(f"Failed to check latest version for {pkg_name}: {e}")
    
    def _check_transitive_dependencies(self):
        """推移的依存関係をチェック"""
        for pkg_name, package in self.packages.items():
            if not package.installed_version:
                continue
            
            try:
                # パッケージの依存関係を取得
                result = subprocess.run(
                    ['pip', 'show', pkg_name],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if result.returncode == 0:
                    # Requires行から依存関係を抽出
                    for line in result.stdout.split('\n'):
                        if line.startswith('Requires:'):
                            deps = line.replace('Requires:', '').strip()
                            if deps:
                                package.dependencies = [
                                    d.strip() for d in deps.split(',')
                                ]
            except Exception as e:
                logger.debug(f"Failed to check dependencies for {pkg_name}: {e}")
    
    def detect_conflicts(self) -> List[DependencyIssue]:
        """バージョン競合を検出"""
        conflicts = []
        
        # すべてのパッケージの依存関係をチェック
        dependency_requirements = {}
        
        for pkg_name, package in self.packages.items():
            for dep in package.dependencies:
                dep_name, dep_version = self._parse_package_spec(dep)
                
                if dep_name not in dependency_requirements:
                    dependency_requirements[dep_name] = []
                
                dependency_requirements[dep_name].append({
                    'required_by': pkg_name,
                    'version_spec': dep_version
                })
        
        # 競合をチェック
        for dep_name, requirements in dependency_requirements.items():
            if len(requirements) > 1:
                # 複数のバージョン要求がある場合、競合の可能性
                version_specs = [req['version_spec'] for req in requirements]
                if len(set(version_specs)) > 1:
                    package = self.packages.get(dep_name, Package(name=dep_name))
                    
                    issue = DependencyIssue(
                        status=DependencyStatus.CONFLICT,
                        package=package,
                        description=f"Version conflict for {dep_name}: "
                                  f"required by {', '.join(req['required_by'] for req in requirements)} "
                                  f"with different version specs",
                        resolution="Manually resolve version requirements",
                        severity="high"
                    )
                    conflicts.append(issue)
        
        return conflicts
    
    def generate_dependency_graph(self) -> DependencyGraph:
        """依存関係グラフを生成"""
        nodes = {}
        edges = []
        
        for pkg_name, package in self.packages.items():
            nodes[pkg_name] = package
            
            for dep in package.dependencies:
                dep_name, _ = self._parse_package_spec(dep)
                edges.append((pkg_name, dep_name))
        
        return DependencyGraph(nodes=nodes, edges=edges)
    
    def suggest_updates(self) -> List[Dict[str, Any]]:
        """
        アップデート推奨を生成
        
        Returns:
            アップデート推奨のリスト
        """
        suggestions = []
        
        for issue in self.issues:
            if issue.status == DependencyStatus.OUTDATED:
                pkg = issue.package
                suggestions.append({
                    "package": pkg.name,
                    "current_version": pkg.installed_version,
                    "latest_version": pkg.latest_version,
                    "command": issue.resolution,
                    "priority": self._calculate_update_priority(pkg)
                })
        
        # 優先度でソート
        suggestions.sort(key=lambda x: x["priority"], reverse=True)
        
        return suggestions
    
    def _calculate_update_priority(self, package: Package) -> int:
        """アップデート優先度を計算（0-100）"""
        if not package.installed_version or not package.latest_version:
            return 0
        
        try:
            current_parts = tuple(int(x) for x in package.installed_version.split('.'))
            latest_parts = tuple(int(x) for x in package.latest_version.split('.'))
            
            # メジャーバージョンが異なる: 高優先度
            if current_parts[0] < latest_parts[0]:
                return 90
            
            # マイナーバージョンが異なる: 中優先度
            if len(current_parts) > 1 and len(latest_parts) > 1:
                if current_parts[1] < latest_parts[1]:
                    return 60
            
            # パッチバージョンのみ: 低優先度
            return 30
        except:
            return 50  # デフォルト
    
    def generate_report(self) -> Dict[str, Any]:
        """分析レポートを生成"""
        # 重大度別の問題
        by_severity = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        }
        
        for issue in self.issues:
            by_severity[issue.severity].append(issue.to_dict())
        
        # 依存関係グラフ
        graph = self.generate_dependency_graph()
        
        return {
            "summary": {
                **self.stats,
                "total_issues": len(self.issues)
            },
            "issues_by_severity": {
                severity: len(issues)
                for severity, issues in by_severity.items()
            },
            "issues": [issue.to_dict() for issue in self.issues],
            "update_suggestions": self.suggest_updates(),
            "dependency_graph": graph.to_dict()
        }
    
    def export_report(self, filepath: str):
        """レポートをファイルにエクスポート"""
        report = self.generate_report()
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Dependency report exported to {filepath}")
    
    def auto_fix_issues(self, 
                       fix_missing: bool = True,
                       fix_outdated: bool = False) -> List[str]:
        """
        問題を自動修正
        
        Args:
            fix_missing: 欠落パッケージをインストール
            fix_outdated: 古いパッケージをアップデート
        
        Returns:
            実行されたコマンドのリスト
        """
        executed_commands = []
        
        for issue in self.issues:
            if not issue.resolution:
                continue
            
            should_fix = False
            
            if fix_missing and issue.status == DependencyStatus.MISSING:
                should_fix = True
            elif fix_outdated and issue.status == DependencyStatus.OUTDATED:
                should_fix = True
            
            if should_fix:
                try:
                    logger.info(f"Executing: {issue.resolution}")
                    result = subprocess.run(
                        issue.resolution.split(),
                        capture_output=True,
                        text=True,
                        timeout=300
                    )
                    
                    if result.returncode == 0:
                        executed_commands.append(issue.resolution)
                        logger.info(f"Successfully fixed: {issue.package.name}")
                    else:
                        logger.error(f"Failed to fix {issue.package.name}: {result.stderr}")
                except Exception as e:
                    logger.error(f"Error fixing {issue.package.name}: {e}")
        
        return executed_commands


# 使用例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    resolver = DependencyResolverAgent("requirements.txt")
    
    # 依存関係を分析
    print("\n=== Analyzing Dependencies ===")
    issues = resolver.analyze_dependencies()
    
    print(f"\nFound {len(issues)} issues:")
    for issue in issues[:5]:  # 最初の5件を表示
        print(f"[{issue.status.value}] {issue.package.name}: {issue.description}")
        if issue.resolution:
            print(f"  → {issue.resolution}")
    
    # レポート生成
    print("\n=== Dependency Report ===")
    report = resolver.generate_report()
    print(json.dumps(report["summary"], indent=2))
    
    # アップデート推奨
    print("\n=== Update Suggestions ===")
    suggestions = resolver.suggest_updates()
    for sugg in suggestions[:3]:
        print(f"{sugg['package']}: {sugg['current_version']} → {sugg['latest_version']}")
        print(f"  Priority: {sugg['priority']}/100")
        print(f"  Command: {sugg['command']}")


#design_agent.py
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime

# 最初にロガーを設定
logger = logging.getLogger(__name__)

# 原因切り分けのためのインポートチェック
try:
    from config_utils import ErrorHandler, PathManager
    CONFIG_UTILS_AVAILABLE = True
    logger.debug("✅ config_utils インポート成功")
except ImportError as e:
    logger.error(f"❌ config_utils インポートエラー: {e}")
    CONFIG_UTILS_AVAILABLE = False
    # フォールバッククラス
    class ErrorHandler:
        @staticmethod
        def log_error(e, context):
            print(f"ERROR [{context}]: {e}")
    
    class PathManager:
        @staticmethod
        def get_safe_path(path):
            return Path(path)

try:
    from browser_controller import BrowserController
    BROWSER_CONTROLLER_AVAILABLE = True
    logger.debug("✅ browser_controller インポート成功")
except ImportError as e:
    logger.error(f"❌ browser_controller インポートエラー: {e}")
    BROWSER_CONTROLLER_AVAILABLE = False

class DesignAgent:
    """設計AI - 要件定義、設計書、アーキテクチャを作成"""
    
    DESIGN_SYSTEM_PROMPT = """あなたは経験豊富なシステム設計者です。

【あなたの役割】
- 要件定義書の作成
- システムアーキテクチャの設計
- データベーススキーマの設計
- API仕様の定義
- 技術選定と理由の説明

【設計の原則】
1. 実装可能性を最優先する
2. セキュリティを考慮する
3. スケーラビリティを意識する
4. 開発者が理解しやすい文書を作成

【出力形式】
タスクの内容に応じて、以下の形式で出力してください：

## タスク概要
（タスクの理解と目的）

## 設計内容
（具体的な設計内容）

## 技術選定
（使用する技術とその理由）

## 実装における注意点
（開発時の注意事項）

## 次のステップ
（このタスク後に行うべきこと）"""

    def __init__(self, browser_controller=None, browser=None, output_folder: Path = None):
        """
        初期化 - 引数名の互換性を確保
        
        原因切り分けのための詳細ログ:
        """
        logger.info("🔍 DesignAgent.__init__() 開始")
        logger.info(f"   browser_controller: {type(browser_controller)}")
        logger.info(f"   browser: {type(browser)}")
        logger.info(f"   output_folder: {output_folder}")
        
        # 原因1: 引数名の不一致を解決
        if browser_controller is not None:
            self.browser = browser_controller
            logger.info("✅ browser_controller を使用")
        elif browser is not None:
            self.browser = browser
            logger.info("✅ browser を使用")
        else:
            self.browser = None
            logger.warning("⚠️ ブラウザインスタンスが提供されていません")
        
        # 原因2: 出力フォルダの設定ロジック
        self.output_folder = self._setup_output_folder(output_folder)
        
        # 初期化状態の確認
        self._validate_initialization()
        
        logger.info("✅ DesignAgent.__init__() 完了")

    def _setup_output_folder(self, output_folder: Optional[Path]) -> Path:
        """出力フォルダを設定（原因切り分け付き）"""
        logger.info("🔍 出力フォルダ設定開始")
        
        # 原因3: 出力フォルダが直接指定されている場合
        if output_folder is not None:
            safe_path = PathManager.get_safe_path(output_folder) if CONFIG_UTILS_AVAILABLE else Path(output_folder)
            logger.info(f"✅ 直接指定の出力フォルダ: {safe_path}")
            return safe_path
        
        # 原因4: configから取得を試みる
        try:
            from config_utils import config
            if hasattr(config, 'AGENT_OUTPUT_FOLDER') and config.AGENT_OUTPUT_FOLDER:
                safe_path = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"✅ configから取得した出力フォルダ: {safe_path}")
                return safe_path
        except Exception as e:
            logger.error(f"❌ configからの取得失敗: {e}")
        
        # 原因5: フォールバックパス
        fallback_path = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
        fallback_path.mkdir(exist_ok=True, parents=True)
        logger.warning(f"⚠️ フォールバックフォルダを使用: {fallback_path}")
        
        return fallback_path

    def _validate_initialization(self):
        """初期化状態を検証（原因切り分け）"""
        logger.info("🔍 初期化状態検証開始")
        
        # 原因6: ブラウザコントローラーの状態確認
        if self.browser is None:
            logger.error("❌ ブラウザコントローラーが設定されていません")
        else:
            logger.info(f"✅ ブラウザコントローラー: {type(self.browser)}")
            # メソッドの存在確認
            required_methods = ['send_prompt', 'wait_for_text_generation', 'extract_latest_text_response']
            for method in required_methods:
                if hasattr(self.browser, method):
                    logger.info(f"✅ メソッド存在: {method}")
                else:
                    logger.error(f"❌ メソッド不足: {method}")
        
        # 原因7: 出力フォルダの権限確認
        try:
            test_file = self.output_folder / "test_write_permission.txt"
            test_file.write_text("test")
            test_file.unlink()
            logger.info("✅ 出力フォルダ書き込み権限: OK")
        except Exception as e:
            logger.error(f"❌ 出力フォルダ書き込み権限エラー: {e}")
        
        # 原因8: 必要なモジュールの可用性確認
        logger.info(f"✅ config_utils 可用性: {CONFIG_UTILS_AVAILABLE}")
        logger.info(f"✅ browser_controller 可用性: {BROWSER_CONTROLLER_AVAILABLE}")
        
        logger.info("🔍 初期化状態検証完了")

    async def process_task(self, task: Dict) -> Dict:
        """設計タスクを処理（詳細な原因切り分け付き）"""
        task_id = task.get('task_id', 'UNKNOWN')
        logger.info(f"\n🎯 DesignAgent.process_task() 開始: {task_id}")
        
        try:
            # 原因9: タスクデータの検証
            self._validate_task_data(task)
            
            logger.info(f"設計AI: タスク処理開始 - {task['description']}")
            
            # プロンプトを構築
            full_prompt = self._build_prompt(task)
            logger.info(f"📝 プロンプト長: {len(full_prompt)}文字")
            
            # 原因10: ブラウザ操作前の状態確認
            if not await self._pre_browser_validation():
                return {
                    'success': False,
                    'error': 'ブラウザ検証失敗'
                }
            
            # Geminiに送信
            logger.info("Geminiに設計タスクを送信中...")
            logger.info("🔄 ブラウザ操作開始...")
            
            send_success = await self.browser.send_prompt(full_prompt)
            if not send_success:
                logger.error("❌ プロンプト送信失敗")
                return {
                    'success': False,
                    'error': '設計AI: プロンプト送信失敗'
                }
            
            logger.info("✅ プロンプト送信成功")
            
            # 応答待機
            logger.info("⏳ 応答待機中...")
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                logger.error("❌ テキスト生成タイムアウト")
                return {
                    'success': False,
                    'error': '設計AI: タイムアウト'
                }
            
            logger.info("✅ テキスト生成完了")
            
            # 応答を取得
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.error("❌ 応答テキスト取得失敗")
                return {
                    'success': False,
                    'error': '設計AI: 応答取得失敗'
                }
            
            logger.info(f"✅ 応答取得完了: {len(response_text)}文字")
            logger.info(f"設計AI: 応答取得完了（{len(response_text)}文字）")
            
            # 結果をファイルに保存
            result = await self._save_results(task, response_text)
            
            logger.info(f"✅ タスク完了: {task_id}")
            return result
            
        except Exception as e:
            # 原因11: 詳細な例外情報
            error_msg = self._analyze_exception(e, task)
            ErrorHandler.log_error(e, "設計AI処理")
            
            logger.error(f"❌ タスク失敗: {task_id} - {error_msg}")
            return {
                'success': False,
                'error': error_msg
            }

    def _validate_task_data(self, task: Dict):
        """タスクデータを検証"""
        logger.info("🔍 タスクデータ検証")
        
        required_fields = ['task_id', 'description']
        for field in required_fields:
            if field not in task:
                raise ValueError(f"必須フィールド '{field}' がありません")
            logger.info(f"✅ 必須フィールド: {field}")
        
        logger.info(f"📋 タスクID: {task.get('task_id')}")
        logger.info(f"📋 説明: {task.get('description')[:50]}...")
        logger.info(f"📋 ロール: {task.get('required_role', 'N/A')}")

    def _build_prompt(self, task: Dict) -> str:
        """プロンプトを構築"""
        return f"""{self.DESIGN_SYSTEM_PROMPT}

【タスク】
{task['description']}

上記のタスクについて、詳細な設計を行ってください。
実装可能で具体的な設計書を作成してください。"""

    async def _pre_browser_validation(self) -> bool:
        """ブラウザ操作前の検証"""
        logger.info("🔍 ブラウザ操作前検証")
        
        if self.browser is None:
            logger.error("❌ ブラウザインスタンスがありません")
            return False
        
        # ブラウザの状態確認
        if hasattr(self.browser, 'is_ready'):
            is_ready = await self.browser.is_ready()
            if not is_ready:
                logger.error("❌ ブラウザが準備できていません")
                return False
        
        logger.info("✅ ブラウザ検証: OK")
        return True

    async def _save_results(self, task: Dict, response_text: str) -> Dict:
        """結果を保存"""
        logger.info("🔍 結果保存処理")
        
        filename = f"design_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        output_path = self.output_folder / filename
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# 設計書: {task['description']}\n\n")
                f.write(f"タスクID: {task['task_id']}\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
            
            logger.info(f"✅ 設計書保存: {output_path}")
            logger.info(f"設計書を保存: {output_path}")
            
            # サマリーを作成（最初の500文字）
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
            
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
            
        except Exception as e:
            logger.error(f"❌ ファイル保存エラー: {e}")
            raise

    def _analyze_exception(self, e: Exception, task: Dict) -> str:
        """例外を詳細に分析"""
        error_type = type(e).__name__
        task_id = task.get('task_id', 'UNKNOWN')
        
        logger.info(f"🔍 例外分析: {error_type}")
        logger.info(f"🔍 例外メッセージ: {str(e)}")
        
        # 原因タイプに基づいたメッセージ
        if "browser" in str(e).lower() or "send_prompt" in str(e):
            return f"ブラウザ操作エラー: {str(e)}"
        elif "timeout" in str(e).lower():
            return f"タイムアウトエラー: {str(e)}"
        elif "file" in str(e).lower() or "write" in str(e):
            return f"ファイル操作エラー: {str(e)}"
        elif "import" in str(e).lower():
            return f"インポートエラー: {str(e)}"
        else:
            return f"設計タスク実行エラー ({error_type}): {str(e)}"

    # デバッグ用メソッド
    def get_status(self) -> Dict:
        """エージェントの状態を取得"""
        return {
            'browser_available': self.browser is not None,
            'output_folder': str(self.output_folder),
            'config_utils_available': CONFIG_UTILS_AVAILABLE,
            'browser_controller_available': BROWSER_CONTROLLER_AVAILABLE,
            'output_folder_writable': self._check_folder_writable()
        }

    def _check_folder_writable(self) -> bool:
        """フォルダ書き込み可能かチェック"""
        try:
            test_file = self.output_folder / "test_write.tmp"
            test_file.write_text("test")
            test_file.unlink()
            return True
        except:
            return False


# テスト用コード
async def test_design_agent():
    """DesignAgentのテスト"""
    print("🧪 DesignAgent テスト開始")
    
    # モックブラウザ（実際の環境に合わせて調整）
    class MockBrowser:
        async def send_prompt(self, prompt):
            print(f"📤 モック送信: {len(prompt)}文字")
            return True
        
        async def wait_for_text_generation(self, max_wait=180):
            await asyncio.sleep(1)
            return True
        
        async def extract_latest_text_response(self):
            return "これはモック応答です。設計内容: ..."
    
    # テスト実行
    try:
        browser = MockBrowser()
        agent = DesignAgent(browser_controller=browser)
        
        test_task = {
            'task_id': 'TEST_001',
            'description': 'テスト設計タスク',
            'required_role': 'design'
        }
        
        result = await agent.process_task(test_task)
        print(f"🧪 テスト結果: {result}")
        
    except Exception as e:
        print(f"❌ テスト失敗: {e}")


if __name__ == "__main__":
    # 単体テスト
    asyncio.run(test_design_agent())

#dev_agent.py
# dev_agent.py
"""開発AI - コード生成とテストコード、WordPress専用機能の作成（引数診断強化版）"""
import asyncio
import logging
import inspect
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)


class DevAgent:
    """開発AI - コード生成とテストコード、WordPress専用機能の作成"""

    def __init__(self, browser: BrowserController = None, browser_controller: BrowserController = None, output_folder: Path = None):
        """
        初期化メソッド（複数引数名対応版）
    
        Args:
            browser: BrowserController インスタンス
            browser_controller: BrowserController インスタンス（互換性用）
            output_folder: 出力フォルダパス
        """
        # 引数診断ログ
        logger.info("🔍 DevAgent 初期化診断:")
        logger.info(f"   - browser: {browser is not None}")
        logger.info(f"   - browser_controller: {browser_controller is not None}")
        logger.info(f"   - output_folder: {output_folder}")
    
        # browser_controller を優先し、次に browser を使用
        if browser_controller is not None:
            self.browser = browser_controller
            logger.info("✅ browser_controller を使用")
        elif browser is not None:
            self.browser = browser
            logger.info("✅ browser を使用")
        else:
            logger.error("❌ browser_controller も browser も提供されていません")
            self.browser = None
    
        # 出力フォルダの設定
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"Agent出力先（B14から取得）: {self.output_folder}")
            else:
                # フォールバック: デフォルトパス
                self.output_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.warning(f"B14が空のため、デフォルトフォルダを使用: {self.output_folder}")
        else:
            self.output_folder = output_folder
    
        self.design_docs = {}  # 設計書を参照できるようにする
    
        # 初期化完了ログ
        logger.info(f"✅ DevAgent 初期化完了:")
        logger.info(f"   - browser: {self.browser is not None}")
        logger.info(f"   - output_folder: {self.output_folder}")

    # 既存のプロンプト定義は変更なし...
    DEV_SYSTEM_PROMPT = """あなたは経験豊富なソフトウェアエンジニアです。..."""

    WORDPRESS_CPT_PROMPT = """あなたはWordPress開発の専門家です。..."""

    async def process_task(self, task: Dict) -> Dict:
        """開発タスクを処理（引数診断強化版）"""
        try:
            # 引数状態の診断
            self._diagnose_agent_state(task)
        
            logger.info(f"開発AI: タスク処理開始 - {task['description']}")
        
            # WordPress カスタム投稿タイプ作成タスクか判定
            if self._is_wordpress_cpt_task(task):
                return await self._process_wordpress_cpt_task(task)
        
            # WordPress タクソノミー作成タスクか判定
            if self._is_wordpress_taxonomy_task(task):
                return await self._process_wordpress_taxonomy_task(task)
        
            # 通常の開発タスク
            return await self._process_general_task(task)
        
        except Exception as e:
            ErrorHandler.log_error(e, "開発AI処理")
            return {
                'success': False,
                'error': str(e)
            }

    def _diagnose_agent_state(self, task: Dict):
        """エージェント状態の診断"""
        logger.info("🔍 DevAgent 状態診断:")
        logger.info(f"   - タスクID: {task.get('task_id', 'N/A')}")
        logger.info(f"   - タスク説明: {task.get('description', 'N/A')[:100]}...")
        logger.info(f"   - browser インスタンス: {self.browser is not None}")
        logger.info(f"   - output_folder 存在: {self.output_folder.exists() if self.output_folder else False}")
    
        # 重要なメソッドの存在確認
        required_methods = ['send_prompt', 'wait_for_text_generation', 'extract_latest_text_response']
        if self.browser:
            for method in required_methods:
                has_method = hasattr(self.browser, method) and callable(getattr(self.browser, method))
                logger.info(f"   - browser.{method}: {'✅' if has_method else '❌'}")
    
        # 引数シグネチャの診断
        try:
            init_signature = inspect.signature(self.__init__)
            params = list(init_signature.parameters.keys())
            logger.info(f"   - __init__ パラメータ: {params}")
        except Exception as e:
            logger.warning(f"   - シグネチャ診断エラー: {e}")

    def _is_wordpress_cpt_task(self, task: Dict) -> bool:
        """WordPressカスタム投稿タイプ作成タスクか判定"""
        description = task.get('description', '').lower()
        keywords = [
            'custom post type',
            'カスタム投稿タイプ',
            'cpt',
            'register_post_type',
            '投稿タイプ'
        ]
        return any(kw in description for kw in keywords)

    def _is_wordpress_taxonomy_task(self, task: Dict) -> bool:
        """WordPressタクソノミー作成タスクか判定"""
        description = task.get('description', '').lower()
        keywords = [
            'taxonomy',
            'タクソノミー',
            'カスタム分類',
            'register_taxonomy'
        ]
        return any(kw in description for kw in keywords)

    async def _process_wordpress_cpt_task(self, task: Dict) -> Dict:
        """WordPressカスタム投稿タイプ作成タスクを処理"""
        try:
            # ブラウザ状態の確認
            if not self.browser:
                return {
                    'success': False,
                    'error': 'DevAgent: browser_controller が初期化されていません'
                }
        
            logger.info("="*60)
            logger.info("WordPress カスタム投稿タイプ作成タスク")
            logger.info("="*60)
        
            # タスクから情報を抽出
            cpt_info = self._extract_cpt_info(task)
        
            logger.info(f"投稿タイプスラッグ: {cpt_info['slug']}")
            logger.info(f"表示名（単数）: {cpt_info['singular_name']}")
            logger.info(f"表示名（複数）: {cpt_info['plural_name']}")
        
            # プロンプトを構築
            full_prompt = self._build_wordpress_cpt_prompt(task, cpt_info)
        
            # Geminiに送信
            logger.info("Geminiに要件定義書作成タスクを送信中...")
            await self.browser.send_prompt(full_prompt)

            # 応答待機（要件定義書は長いので300秒）
            logger.info("⏱️ 待機時間: 300秒（要件定義書作成）")
        
            # ブラウザメソッドの互換性対応
            if hasattr(self.browser, 'wait_for_text_generation'):
                success = await self.browser.wait_for_text_generation(max_wait=300)
            elif hasattr(self.browser, '_wait_for_generation_complete'):
                success = await self.browser._wait_for_generation_complete()
            else:
                logger.error("❌ 利用可能な待機メソッドが見つかりません")
                return {
                    'success': False,
                    'error': '利用可能な待機メソッドが見つかりません'
                }

            if not success:
                return {
                    'success': False,
                    'error': '開発AI: タイムアウト（要件定義書作成: 300秒）'
                }
        
            # 応答を取得
            response_text = await self.browser.extract_latest_text_response()
        
            if not response_text:
                return {
                    'success': False,
                    'error': '開発AI: 応答取得失敗'
                }
        
            logger.info(f"開発AI: 応答取得完了（{len(response_text)}文字）")
        
            # 結果を保存
            output_files = self._save_wordpress_cpt_code(response_text, task, cpt_info)
        
            # サマリーを作成
            summary = f"""✅ WordPressカスタム投稿タイプ作成完了

【投稿タイプ情報】
- スラッグ: {cpt_info['slug']}
- 表示名: {cpt_info['singular_name']} / {cpt_info['plural_name']}
- サポート機能: {', '.join(cpt_info['supports'])}

【生成ファイル】
"""
            for file_info in output_files:
                summary += f"- {file_info['type']}: {file_info['path'].name}\n"
        
            summary += f"\n【次のステップ】\n"
            summary += f"1. functions.php または専用プラグインに追加\n"
            summary += f"2. パーマリンク設定を保存（設定 > パーマリンク設定）\n"
            summary += f"3. 管理画面で「{cpt_info['menu_name']}」メニューを確認\n"
        
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'cpt_slug': cpt_info['slug']
            }
        
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressカスタム投稿タイプ作成")
            return {
                'success': False,
                'error': str(e)
            }

    # 既存のメソッドは変更なし...
    def _extract_cpt_info(self, task: Dict) -> Dict:
        """タスクからカスタム投稿タイプの情報を抽出"""
        # 実装は変更なし...
        pass

    def _build_wordpress_cpt_prompt(self, task: Dict, cpt_info: Dict) -> str:
        """WordPressカスタム投稿タイプ用のプロンプトを構築"""
        # 実装は変更なし...
        pass

    def _save_wordpress_cpt_code(self, text: str, task: Dict, cpt_info: Dict) -> list:
        """WordPressカスタム投稿タイプのコードを保存"""
        # 実装は変更なし...
        pass

    def _extract_php_code(self, text: str) -> Optional[str]:
        """テキストからPHPコードを抽出"""
        # 実装は変更なし...
        pass

    async def _process_wordpress_taxonomy_task(self, task: Dict) -> Dict:
        """WordPressタクソノミー作成タスクを処理"""
        # 実装は変更なし...
        pass

    async def _process_general_task(self, task: Dict) -> Dict:
        """通常の開発タスクを処理"""
        try:
            # ブラウザ状態の確認
            if not self.browser:
                return {
                    'success': False,
                    'error': 'DevAgent: browser_controller が初期化されていません'
                }
        
            logger.info("通常の開発タスクとして処理")
        
            # 対応する設計書があれば読み込む
            design_context = self._load_design_context(task)
        
            # プロンプトを構築
            full_prompt = f"""{self.DEV_SYSTEM_PROMPT}

【タスク】
{task['description']}"""

            if design_context:
                full_prompt += f"""

【設計書（参考）】
{design_context}"""
        
            full_prompt += """

上記のタスクについて、完全に動作するコードを実装してください。
エラーハンドリングとコメントを含めてください。"""
        
            # Geminiに送信
            logger.info("Geminiに開発タスクを送信中...")
            await self.browser.send_prompt(full_prompt)
        
            # タスクの種類によって待機時間を調整
            description = task.get('description', '').lower()
    
            if any(word in description for word in ['要件定義', '設計書', 'アーキテクチャ', '仕様書']):
                max_wait = 300  # 要件定義書などは5分
                logger.info("📋 要件定義・設計書タスク - 待機時間を300秒に延長")
            else:
                max_wait = 180  # 通常は3分
        
            # ブラウザメソッドの互換性対応
            if hasattr(self.browser, 'wait_for_text_generation'):
                success = await self.browser.wait_for_text_generation(max_wait=max_wait)
            elif hasattr(self.browser, '_wait_for_generation_complete'):
                success = await self.browser._wait_for_generation_complete()
            else:
                logger.error("❌ 利用可能な待機メソッドが見つかりません")
                return {
                    'success': False,
                    'error': '利用可能な待機メソッドが見つかりません'
                }
        
            if not success:
                return {
                    'success': False,
                    'error': '開発AI: タイムアウト'
                }
        
            # 応答を取得
            response_text = await self.browser.extract_latest_text_response()
        
            if not response_text:
                return {
                    'success': False,
                    'error': '開発AI: 応答取得失敗'
                }
        
            logger.info(f"開発AI: 応答取得完了（{len(response_text)}文字）")
        
            # コードをファイルに保存
            filename = f"code_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            output_path = self.output_folder / filename
        
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# コード: {task['description']}\n\n")
                f.write(f"タスクID: {task['task_id']}\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
        
            logger.info(f"コードを保存: {output_path}")
        
            # コード部分を抽出して個別ファイルに保存
            self._extract_and_save_code(response_text, task)
        
            # サマリーを作成
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
        
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
        
        except Exception as e:
            ErrorHandler.log_error(e, "開発AI処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _load_design_context(self, task: Dict) -> str:
        """対応する設計書があれば読み込む"""
        try:
            # design_*.md ファイルを探す
            design_files = list(self.output_folder.glob(f"design_{task['task_id']}_*.md"))
            
            if design_files:
                # 最新のファイルを読み込む
                latest_design = sorted(design_files)[-1]
                with open(latest_design, 'r', encoding='utf-8') as f:
                    content = f.read()
                logger.info(f"設計書を読み込みました: {latest_design.name}")
                return content[:2000]  # 最初の2000文字のみ
            
            return ""
        except Exception as e:
            logger.warning(f"設計書読み込みエラー: {e}")
            return ""
    
    def _extract_and_save_code(self, text: str, task: Dict):
        """コードブロックを抽出して個別ファイルに保存"""
        try:
            # ```言語 ... ``` パターンを抽出
            code_blocks = re.findall(r'```(\w+)\n(.*?)```', text, re.DOTALL)
            
            for i, (lang, code) in enumerate(code_blocks):
                # ファイル拡張子を決定
                ext_map = {
                    'python': '.py',
                    'javascript': '.js',
                    'typescript': '.ts',
                    'html': '.html',
                    'css': '.css',
                    'java': '.java',
                    'cpp': '.cpp',
                    'c': '.c',
                    'php': '.php',
                    'ruby': '.rb',
                    'go': '.go',
                    'rust': '.rs',
                }
                ext = ext_map.get(lang.lower(), '.txt')
                
                # ファイルに保存
                code_filename = f"code_{task['task_id']}_{i+1}{ext}"
                code_path = self.output_folder / code_filename
                
                with open(code_path, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                logger.info(f"コードファイルを保存: {code_filename}")
                
        except Exception as e:
            logger.warning(f"コード抽出エラー: {e}")

#dev_agent_acf.py
# dev_agent_acf.py
"""ACF（Advanced Custom Fields）専用開発モジュール"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager, config

logger = logging.getLogger(__name__)


# =============================================================================
# ACFフィールドグループ専用プロンプト
# =============================================================================

ACF_FIELD_GROUP_PROMPT = """あなたはACF ProとWordPress開発の専門家です。

【ACFカスタムフィールドグループの作成】

以下の要件に基づいて、完全に動作するACFフィールドグループの定義を生成してください。

【必須要素】
1. フィールドグループの基本設定
   - タイトル、キー、配置場所（投稿タイプ）
2. 各フィールドの詳細定義
   - フィールドタイプ（text, number, select, relationship など）
   - ラベル、名前、キー
   - 検証ルール、デフォルト値
3. 条件付きロジック（必要に応じて）
4. PHP登録コード（`acf_add_local_field_group`）
5. JSON形式のエクスポート（WP-CLIインポート用）

【出力形式】

## ACFフィールドグループ: {group_title}

### 概要
（このフィールドグループの目的と用途）

### PHP登録コード（functions.phpに追加）

```php
<?php
/**
 * ACF Field Group: {group_title}
 * 投稿タイプ: {post_type}
 */

if (function_exists('acf_add_local_field_group')) {{
    acf_add_local_field_group(array(
        'key' => 'group_{unique_key}',
        'title' => '{group_title}',
        'fields' => array(
            // フィールド定義
            array(
                'key' => 'field_{field_key}',
                'label' => '{field_label}',
                'name' => '{field_name}',
                'type' => '{field_type}',
                'required' => {{true|false}},
                'default_value' => '',
            ),
        ),
        'location' => array(
            array(
                array(
                    'param' => 'post_type',
                    'operator' => '==',
                    'value' => '{post_type}',
                ),
            ),
        ),
        'menu_order' => 0,
        'position' => 'normal',
        'style' => 'default',
        'label_placement' => 'top',
        'instruction_placement' => 'label',
        'active' => true,
        'show_in_rest' => 1,
    ));
}}
?>
```

### JSON定義（WP-CLIインポート用）

```json
{{
  "key": "group_{unique_key}",
  "title": "{group_title}",
  "fields": [
    {{
      "key": "field_{field_key}",
      "label": "{field_label}",
      "name": "{field_name}",
      "type": "{field_type}",
      "required": {{true|false}}
    }}
  ],
  "location": [
    [
      {{
        "param": "post_type",
        "operator": "==",
        "value": "{post_type}"
      }}
    ]
  ]
}}
```

### 使用方法

#### テンプレートでの取得
```php
<?php
// 単一値の取得
$value = get_field('field_name', $post_id);

// 条件付き表示
if (get_field('field_name')) :
    echo esc_html(get_field('field_name'));
endif;
?>
```

### 注意事項
- ACF Pro 6.0以上が必要です
- フィールドキーは一意である必要があります
"""


# =============================================================================
# ACFDevAgentクラス（ACF専用機能）
# =============================================================================

class ACFDevAgent:
    """ACF（Advanced Custom Fields）専用開発エージェント"""
    
    def __init__(self, browser, output_folder: Path):
        """
        初期化
        
        Args:
            browser: BrowserControllerインスタンス
            output_folder: 出力先フォルダ
        """
        self.browser = browser
        self.output_folder = output_folder
        self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # =========================================================================
    # パート1: タスク判定メソッド
    # =========================================================================
    
    def is_acf_task(self, task: Dict) -> bool:
        """
        ACFフィールドグループ作成タスクか判定
        
        Args:
            task: タスク辞書
            
        Returns:
            bool: ACFタスクの場合True
        """
        description = task.get('description', '').lower()
        keywords = [
            'acf',
            'advanced custom fields',
            'カスタムフィールド',
            'フィールドグループ',
            'field group'
        ]
        return any(kw in description for kw in keywords)
    
    # =========================================================================
    # パート2: ACFタスク処理メイン
    # =========================================================================
    
    async def process_acf_task(self, task: Dict) -> Dict:
        """
        ACFフィールドグループ作成タスクを処理
        
        Args:
            task: タスク辞書
            
        Returns:
            Dict: 処理結果
        """
        try:
            logger.info("="*60)
            logger.info("ACFフィールドグループ作成タスク")
            logger.info("="*60)
            
            # === パート2-1: タスクから情報を抽出 ===
            acf_info = self._extract_acf_info(task)
            
            # === パート2-2: プロンプトを構築 ===
            full_prompt = self._build_acf_prompt(task, acf_info)
            
            # === パート2-3: Geminiに送信 ===
            logger.info("Geminiにタスクを送信中...")
            await self.browser.send_prompt(full_prompt)
            
            # === パート2-4: 応答待機 ===
            success = await self.browser.wait_for_text_generation(
                max_wait=config.WP_DEV_TIMEOUT if hasattr(config, 'WP_DEV_TIMEOUT') else 300
            )
            
            if not success:
                return {
                    'success': False,
                    'error': '開発AI: タイムアウト（ACFフィールドグループ作成）'
                }
            
            # === パート2-5: 応答を取得 ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': '開発AI: 応答取得失敗'
                }
            
            logger.info(f"開発AI: 応答取得完了（{len(response_text)}文字）")
            
            # === パート2-6: コード検証 ===
            validation_result = self._validate_acf_code(response_text)
            if not validation_result['is_valid']:
                logger.warning(f"⚠️ ACFコード検証で問題検出: {validation_result['issues']}")
            
            # === パート2-7: 結果を保存 ===
            output_files = self._save_acf_code(response_text, task, acf_info)
            
            # === パート2-8: サマリー作成 ===
            summary = self._create_acf_summary(acf_info, output_files, validation_result)
            
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'validation': validation_result
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "ACFフィールドグループ作成")
            return {
                'success': False,
                'error': str(e)
            }
    
    # =========================================================================
    # パート3: ACF情報抽出
    # =========================================================================
    
    def _extract_acf_info(self, task: Dict) -> Dict:
        """
        タスクからACF情報を抽出
        
        Args:
            task: タスク辞書
            
        Returns:
            Dict: ACF情報
        """
        description = task.get('description', '')
        parameters = task.get('parameters', {})
        
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        return {
            'group_title': parameters.get('group_title', 'M&A案件フィールド'),
            'post_type': parameters.get('post_type', 'ma_case'),
            'field_count': parameters.get('field_count', 10),
            'unique_key': parameters.get('unique_key', 'ma_case_fields')
        }
    
    # =========================================================================
    # パート4: プロンプト構築
    # =========================================================================
    
    def _build_acf_prompt(self, task: Dict, acf_info: Dict) -> str:
        """
        ACFフィールドグループ用のプロンプトを構築
        
        Args:
            task: タスク辞書
            acf_info: ACF情報
            
        Returns:
            str: 完全なプロンプト
        """
        prompt = ACF_FIELD_GROUP_PROMPT.format(
            group_title=acf_info['group_title'],
            post_type=acf_info['post_type'],
            unique_key=acf_info['unique_key'],
            field_label='例: 企業名',
            field_name='company_name',
            field_key='company_name',
            field_type='text'
        )
        
        prompt += f"""

【このタスクの具体的な要件】
{task.get('description', '')}

【重要な指示】
1. PHPコードは完全に動作する状態で生成してください
2. JSON形式の定義も必ず含めてください
3. すべてのフィールドにキー（key）を設定してください
4. セキュリティ（エスケープ処理）を考慮してください
5. 多言語対応（Polylang）を考慮してください

上記の要件に基づいて、完全なACFフィールドグループの定義を生成してください。
"""
        
        return prompt
    
    # =========================================================================
    # パート5: ACFコード検証
    # =========================================================================
    
    def _validate_acf_code(self, text: str) -> Dict:
        """
        ACFコードの検証
        
        Args:
            text: 検証対象のテキスト
            
        Returns:
            Dict: 検証結果
        """
        issues = []
        
        # === パート5-1: 必須関数のチェック ===
        if 'acf_add_local_field_group' not in text:
            issues.append('acf_add_local_field_group() 関数が見つかりません')
        
        # === パート5-2: フィールドキーの一意性チェック ===
        field_keys = re.findall(r"'key'\s*=>\s*'(field_[^']+)'", text)
        if len(field_keys) != len(set(field_keys)):
            issues.append('フィールドキーが重複しています')
        
        # === パート5-3: JSONの妥当性チェック ===
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        for json_str in json_blocks:
            try:
                json.loads(json_str)
            except json.JSONDecodeError:
                issues.append('JSON形式が不正です')
        
        # === パート5-4: セキュリティ関数のチェック ===
        if 'get_field(' in text and 'esc_html' not in text and 'esc_attr' not in text:
            issues.append('出力エスケープ関数が不足しています（esc_html, esc_attr）')
        
        return {
            'is_valid': len(issues) == 0,
            'issues': issues
        }
    
    # =========================================================================
    # パート6: ファイル保存
    # =========================================================================
    
    def _save_acf_code(self, text: str, task: Dict, acf_info: Dict) -> list:
        """
        ACFフィールドグループのコードを保存
        
        Args:
            text: 保存対象のテキスト
            task: タスク辞書
            acf_info: ACF情報
            
        Returns:
            list: 保存されたファイル情報のリスト
        """
        output_files = []
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # === パート6-1: 完全なドキュメントを保存 ===
            doc_filename = f"acf_{acf_info['unique_key']}_{timestamp}.md"
            doc_path = self.output_folder / doc_filename
            
            with open(doc_path, 'w', encoding='utf-8') as f:
                f.write(f"# ACFフィールドグループ: {acf_info['group_title']}\n\n")
                f.write(f"作成日時: {datetime.now().isoformat()}\n\n")
                f.write(text)
            
            output_files.append({
                'type': 'ドキュメント',
                'path': doc_path
            })
            logger.info(f"ドキュメント保存: {doc_filename}")
            
            # === パート6-2: PHPコードを抽出して保存 ===
            php_code = self._extract_php_code(text)
            if php_code:
                php_filename = f"acf_{acf_info['unique_key']}_{timestamp}.php"
                php_path = self.output_folder / php_filename
                
                with open(php_path, 'w', encoding='utf-8') as f:
                    f.write("<?php\n")
                    f.write(f"/**\n * ACF Field Group: {acf_info['group_title']}\n */\n\n")
                    f.write(php_code)
                
                output_files.append({
                    'type': 'PHPコード',
                    'path': php_path
                })
                logger.info(f"PHPコード保存: {php_filename}")
            
            # === パート6-3: JSON定義を抽出して保存 ===
            json_data = self._extract_json_from_text(text)
            if json_data:
                json_filename = f"acf_{acf_info['unique_key']}_{timestamp}.json"
                json_path = self.output_folder / json_filename
                
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(json_data, f, ensure_ascii=False, indent=2)
                
                output_files.append({
                    'type': 'JSON定義',
                    'path': json_path
                })
                logger.info(f"JSON定義保存: {json_filename}")
            
            # === パート6-4: READMEを生成 ===
            readme_filename = f"README_acf_{acf_info['unique_key']}_{timestamp}.md"
            readme_path = self.output_folder / readme_filename
            
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write(f"# {acf_info['group_title']} - インストールガイド\n\n")
                f.write(f"## 概要\n\n")
                f.write(f"投稿タイプ: {acf_info['post_type']}\n\n")
                f.write(f"## インストール方法\n\n")
                f.write(f"### 方法1: PHPコードで登録\n\n")
                f.write(f"1. `{php_filename}` の内容を `functions.php` に追加\n\n")
                f.write(f"### 方法2: WP-CLI経由\n\n")
                f.write(f"```bash\nwp acf import {json_filename}\n```\n\n")
            
            output_files.append({
                'type': 'README',
                'path': readme_path
            })
            logger.info(f"README保存: {readme_filename}")
            
            return output_files
            
        except Exception as e:
            logger.error(f"ファイル保存エラー: {e}")
            return output_files
    
    # =========================================================================
    # パート7: コード抽出ヘルパー
    # =========================================================================
    
    def _extract_php_code(self, text: str) -> Optional[str]:
        """PHPコードを抽出"""
        php_pattern = r'```php\s*(.*?)```'
        matches = re.findall(php_pattern, text, re.DOTALL)
        
        if matches:
            longest_code = max(matches, key=len)
            longest_code = re.sub(r'^\s*<\?php\s*', '', longest_code)
            return longest_code.strip()
        
        return None
    
    def _extract_json_from_text(self, text: str) -> Optional[Dict]:
        """JSON定義を抽出"""
        json_pattern = r'```json\s*(.*?)```'
        matches = re.findall(json_pattern, text, re.DOTALL)
        
        if matches:
            try:
                return json.loads(matches[0])
            except json.JSONDecodeError:
                return None
        
        return None
    
    # =========================================================================
    # パート8: サマリー作成
    # =========================================================================
    
    def _create_acf_summary(self, acf_info: Dict, output_files: list, 
                           validation_result: Dict) -> str:
        """ACFタスクのサマリーを作成"""
        summary = f"""✅ ACFフィールドグループ作成完了

【フィールドグループ情報】
- タイトル: {acf_info['group_title']}
- 投稿タイプ: {acf_info['post_type']}
- フィールド数: {acf_info['field_count']}

【生成ファイル】
"""
        for file_info in output_files:
            summary += f"- {file_info['type']}: {file_info['path'].name}\n"
        
        if not validation_result['is_valid']:
            summary += f"\n【検証結果】\n"
            for issue in validation_result['issues']:
                summary += f"⚠️ {issue}\n"
        
        return summary

#error_classifier.py
# error_classifier.py
"""
エラー分類器
エラーの複雑度と種類を判定
"""

import logging
import re
from typing import Dict, Any, Optional
from enum import Enum
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class ErrorContextModel:
    """エラーコンテキストのデータモデル"""
    error_type: str
    error_message: Optional[str] = None
    surrounding_code: Optional[str] = None
    full_traceback: Optional[str] = None


class ErrorComplexity(Enum):
    """エラー複雑度"""
    SIMPLE = "simple"      # 単純（ルールベースで対応可能）
    MEDIUM = "medium"      # 中程度（ローカルAIで対応可能）
    COMPLEX = "complex"    # 複雑（クラウドAI推奨）


class ErrorCategory(Enum):
    """エラーカテゴリ"""
    SYNTAX = "syntax"                    # 構文エラー
    IMPORT = "import"                    # インポートエラー
    RUNTIME = "runtime"                  # 実行時エラー
    LOGIC = "logic"                      # ロジックエラー
    DESIGN = "design"                    # 設計レベルの問題
    PERFORMANCE = "performance"          # パフォーマンス問題
    SECURITY = "security"                # セキュリティ問題
    UNKNOWN = "unknown"                  # 不明


class ErrorClassifier:
    """
    エラー分類器
    
    機能:
    - エラーの複雑度判定
    - エラーカテゴリの分類
    - 修正戦略の推奨
    - 信頼度スコアの算出
    """
    
    def __init__(self):
        """初期化"""
        self._init_classification_rules()
        logger.info("✅ ErrorClassifier 初期化完了")
    
    def _init_classification_rules(self):
        """分類ルールを初期化"""
        
        # 単純なエラーパターン（ルールベースで対応可能）
        self.simple_patterns = {
            "SyntaxError": ErrorCategory.SYNTAX,
            "IndentationError": ErrorCategory.SYNTAX,
            "ImportError": ErrorCategory.IMPORT,
            "ModuleNotFoundError": ErrorCategory.IMPORT,
        }
        
        # 中程度のエラーパターン
        self.medium_patterns = {
            "AttributeError": ErrorCategory.RUNTIME,
            "NameError": ErrorCategory.RUNTIME,
            "TypeError": ErrorCategory.RUNTIME,
            "ValueError": ErrorCategory.RUNTIME,
            "KeyError": ErrorCategory.RUNTIME,
            "IndexError": ErrorCategory.RUNTIME,
        }
        
        # 複雑なエラーパターン
        self.complex_patterns = {
            "RecursionError": ErrorCategory.LOGIC,
            "MemoryError": ErrorCategory.PERFORMANCE,
            "RuntimeError": ErrorCategory.LOGIC,
            "AssertionError": ErrorCategory.LOGIC,
        }
        
        # 複雑度判定の重み付け要因
        self.complexity_factors = {
            "multi_file": 2.0,           # 複数ファイルにまたがる
            "async_code": 1.5,           # 非同期コード
            "class_hierarchy": 1.8,      # クラス階層が複雑
            "external_dependency": 1.3,  # 外部依存関係
            "database_operation": 1.6,   # データベース操作
            "network_operation": 1.5,    # ネットワーク操作
            "file_operation": 1.2,       # ファイル操作
            "concurrency": 2.0,          # 並行処理
        }
    
    def classify(self, error_context: ErrorContextModel) -> Dict[str, Any]:
        """
        エラーを分類
        
        Args:
            error_context: エラーコンテキスト
            
        Returns:
            Dict: 分類結果
        """
        try:
            # 基本分類
            error_type = error_context.error_type
            category = self._classify_category(error_type)
            
            # 複雑度判定
            complexity_score = self._calculate_complexity_score(error_context)
            complexity = self._determine_complexity(complexity_score)
            
            # 信頼度計算
            confidence = self._calculate_confidence(error_context, category, complexity)
            
            # 推奨戦略
            recommended_strategy = self._recommend_strategy(complexity, confidence)
            
            result = {
                "error_type": error_type,
                "category": category.value,
                "complexity": complexity.value,
                "complexity_score": complexity_score,
                "confidence": confidence,
                "recommended_strategy": recommended_strategy,
                "factors": self._identify_complexity_factors(error_context)
            }
            
            logger.info(
                f"📊 エラー分類: {error_type} → "
                f"{category.value}/{complexity.value} "
                f"(スコア={complexity_score:.2f}, 信頼度={confidence:.2f})"
            )
            
            return result
            
        except Exception as e:
            logger.error(f"❌ エラー分類失敗: {e}", exc_info=True)
            
            # デフォルト値を返す
            return {
                "error_type": error_context.error_type,
                "category": ErrorCategory.UNKNOWN.value,
                "complexity": ErrorComplexity.MEDIUM.value,
                "complexity_score": 1.0,
                "confidence": 0.5,
                "recommended_strategy": "cloud_first",
                "factors": []
            }
    
    def _classify_category(self, error_type: str) -> ErrorCategory:
        """エラーカテゴリを分類"""
        
        # 単純パターンチェック
        if error_type in self.simple_patterns:
            return self.simple_patterns[error_type]
        
        # 中程度パターンチェック
        if error_type in self.medium_patterns:
            return self.medium_patterns[error_type]
        
        # 複雑パターンチェック
        if error_type in self.complex_patterns:
            return self.complex_patterns[error_type]
        
        # その他のパターンマッチング
        if "Import" in error_type or "Module" in error_type:
            return ErrorCategory.IMPORT
        
        if "Syntax" in error_type or "Indent" in error_type:
            return ErrorCategory.SYNTAX
        
        if "Runtime" in error_type:
            return ErrorCategory.RUNTIME
        
        # デフォルト
        return ErrorCategory.UNKNOWN
    
    def _calculate_complexity_score(self, error_context: ErrorContextModel) -> float:
        """複雑度スコアを計算"""
        
        base_score = 1.0
        
        # エラータイプによる基本スコア
        if error_context.error_type in self.simple_patterns:
            base_score = 0.3
        elif error_context.error_type in self.medium_patterns:
            base_score = 1.0
        elif error_context.error_type in self.complex_patterns:
            base_score = 2.0
        
        # 複雑度要因を適用
        factors = self._identify_complexity_factors(error_context)
        
        for factor in factors:
            weight = self.complexity_factors.get(factor, 1.0)
            base_score *= weight
        
        return base_score
    
    def _identify_complexity_factors(self, error_context: ErrorContextModel) -> list:
        """複雑度要因を特定"""
        factors = []
        
        # コンテキスト情報から判定
        code = error_context.surrounding_code or ""
        traceback = error_context.full_traceback or ""
        
        # 非同期コード
        if "async " in code or "await " in code:
            factors.append("async_code")
        
        # クラス階層
        if "class " in code and "super()" in code:
            factors.append("class_hierarchy")
        
        # 外部依存関係
        if "import " in code or "from " in code:
            factors.append("external_dependency")
        
        # データベース操作
        if any(db in code.lower() for db in ["sql", "database", "db.", "cursor", "query"]):
            factors.append("database_operation")
        
        # ネットワーク操作
        if any(net in code.lower() for net in ["http", "request", "socket", "api"]):
            factors.append("network_operation")
        
        # ファイル操作
        if any(file_op in code.lower() for file_op in ["open(", "file", "read(", "write("]):
            factors.append("file_operation")
        
        # 並行処理
        if any(conc in code.lower() for conc in ["thread", "process", "lock", "queue"]):
            factors.append("concurrency")
        
        # 複数ファイル（スタックトレースから判定）
        if traceback:
            file_count = len(set(re.findall(r'File "(.*?)"', traceback)))
            if file_count > 1:
                factors.append("multi_file")
        
        return factors
    
    def _determine_complexity(self, complexity_score: float) -> ErrorComplexity:
        """スコアから複雑度を決定"""
        
        if complexity_score < 0.5:
            return ErrorComplexity.SIMPLE
        elif complexity_score < 1.5:
            return ErrorComplexity.MEDIUM
        else:
            return ErrorComplexity.COMPLEX
    
    def _calculate_confidence(
        self, 
        error_context: ErrorContextModel,
        category: ErrorCategory,
        complexity: ErrorComplexity
    ) -> float:
        """分類の信頼度を計算"""
        
        confidence = 0.5  # 基本値
        
        # エラータイプが既知パターンに一致する場合は高信頼度
        if error_context.error_type in self.simple_patterns or \
           error_context.error_type in self.medium_patterns or \
           error_context.error_type in self.complex_patterns:
            confidence += 0.3
        
        # エラーメッセージが明確な場合
        if error_context.error_message and len(error_context.error_message) > 10:
            confidence += 0.1
        
        # 周辺コードが利用可能な場合
        if error_context.surrounding_code:
            confidence += 0.1
        
        # スタックトレースが利用可能な場合
        if error_context.full_traceback:
            confidence += 0.05
        
        # 信頼度を0-1に正規化
        return min(confidence, 1.0)
    
    def _recommend_strategy(self, complexity: ErrorComplexity, confidence: float) -> str:
        """推奨戦略を決定"""
        
        if complexity == ErrorComplexity.SIMPLE:
            if confidence > 0.8:
                return "local_only"
            else:
                return "local_first"
        
        elif complexity == ErrorComplexity.MEDIUM:
            if confidence > 0.7:
                return "local_first"
            else:
                return "cloud_first"
        
        else:  # COMPLEX
            if confidence > 0.6:
                return "cloud_first"
            else:
                return "cloud_only"
    
    def print_classification(self, classification: Dict[str, Any]):
        """分類結果を表示"""
        print("\n" + "=" * 60)
        print("📊 エラー分類結果")
        print("=" * 60)
        print(f"エラータイプ: {classification['error_type']}")
        print(f"カテゴリ: {classification['category']}")
        print(f"複雑度: {classification['complexity']} (スコア={classification['complexity_score']:.2f})")
        print(f"信頼度: {classification['confidence']:.1%}")
        print(f"推奨戦略: {classification['recommended_strategy']}")
        
        if classification['factors']:
            print("\n複雑度要因:")
            for factor in classification['factors']:
                print(f"  - {factor}")
        
        print("=" * 60 + "\n")


# 使用例
if __name__ == "__main__":
    # テスト用のエラーコンテキスト
    test_context = ErrorContextModel(
        error_type="ImportError",
        error_message="No module named 'nonexistent_module'",
        surrounding_code="import nonexistent_module",
        full_traceback="Traceback (most recent call last):\n  File \"test.py\", line 1, in <module>\n    import nonexistent_module\nImportError: No module named 'nonexistent_module'"
    )
    
    classifier = ErrorClassifier()
    result = classifier.classify(test_context)
    classifier.print_classification(result)

#error_handler_enhanced.py
"""
error_handler_enhanced.py - 自律修正システム用エラーハンドラ
スタックトレース捕捉、構造化、バグ修正タスク生成機能を提供
"""

import logging
import traceback
import sys
import inspect
from typing import Optional, Dict, Any, List, Tuple
from datetime import datetime
from pathlib import Path
from enum import Enum
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


# データモデル定義
class ErrorSeverity(Enum):
    """エラーの深刻度"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ErrorCategory(Enum):
    """エラーカテゴリ"""
    SYNTAX = "syntax"
    IMPORT = "import"
    RUNTIME = "runtime"
    LOGIC = "logic"
    DESIGN = "design"
    PERFORMANCE = "performance"
    SECURITY = "security"
    UNKNOWN = "unknown"


@dataclass
class CodeLocation:
    """コード位置情報"""
    file_path: str
    line_number: int
    function_name: Optional[str] = None
    class_name: Optional[str] = None


@dataclass
class StackTraceFrame:
    """スタックトレースフレーム"""
    file_path: str
    line_number: int
    function_name: str
    code_context: Optional[str] = None
    local_variables: Optional[Dict[str, Any]] = None


@dataclass
class ErrorContextModel:
    """エラーコンテキストモデル"""
    error_id: str
    timestamp: datetime
    task_id: str
    agent_name: Optional[str] = None
    error_type: str = "UnknownError"
    error_message: Optional[str] = None
    full_traceback: Optional[str] = None
    stack_frames: List[StackTraceFrame] = field(default_factory=list)
    error_location: Optional[CodeLocation] = None
    problematic_code: Optional[str] = None
    surrounding_code: Optional[str] = None
    local_variables: Dict[str, Any] = field(default_factory=dict)
    severity: ErrorSeverity = ErrorSeverity.MEDIUM
    task_description: Optional[str] = None
    task_parameters: Optional[Dict[str, Any]] = None


@dataclass
class BugFixTask:
    """バグ修正タスク"""
    task_id: str
    original_task_id: str
    error_context: ErrorContextModel
    priority: str = "medium"
    required_role: str = "quick_fix"
    target_files: List[str] = field(default_factory=list)
    status: str = "pending"
    created_at: datetime = field(default_factory=datetime.now)
    assigned_agent: Optional[str] = None


class EnhancedErrorHandler:
    """
    強化版エラーハンドラ - 自律修正システム用
    
    機能:
    1. エラー情報の詳細な捕捉
    2. スタックトレースの構造化
    3. エラーコンテキストの構築
    4. バグ修正タスクの自動生成
    """
    
    def __init__(self):
        """初期化"""
        # メモリバッファ(最新100件のエラーを保持)
        self.error_buffer: List[ErrorContextModel] = []
        self.max_buffer_size = 100
        
        # エラーカウンタ
        self.error_counter = 0
        
        logger.info("✅ EnhancedErrorHandler 初期化完了")
    
    def capture_error(
        self,
        exception: Exception,
        task_id: Optional[str] = None,
        agent_name: Optional[str] = None,
        task_context: Optional[Dict[str, Any]] = None
    ) -> ErrorContextModel:
        """
        エラーを捕捉して構造化されたコンテキストを生成
        
        Args:
            exception: 捕捉された例外
            task_id: 実行中のタスクID
            agent_name: 実行中のエージェント名
            task_context: タスクコンテキスト情報
            
        Returns:
            ErrorContextModel: 構造化されたエラーコンテキスト
        """
        try:
            # エラーIDを生成
            self.error_counter += 1
            error_id = f"ERROR_{task_id or 'UNKNOWN'}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{self.error_counter}"
            
            # エラー型とメッセージ
            error_type = type(exception).__name__
            error_message = str(exception)
            
            # スタックトレースの取得
            exc_type, exc_value, exc_tb = sys.exc_info()
            full_traceback = ''.join(traceback.format_exception(exc_type, exc_value, exc_tb))
            
            # スタックフレームの構造化
            stack_frames = self._extract_stack_frames(exc_tb) if exc_tb else []
            
            # エラー発生位置の特定
            error_location = self._extract_error_location(exc_tb) if exc_tb else None
            
            # 問題のあるコードスニペットを取得
            problematic_code, surrounding_code = self._extract_code_snippets(
                error_location.file_path if error_location else None,
                error_location.line_number if error_location else None
            )
            
            # ローカル変数の取得
            local_vars = self._extract_local_variables(exc_tb) if exc_tb else {}
            
            # 深刻度を判定
            severity = self._determine_severity(error_type, error_message)
            
            # ErrorContextModelを構築
            error_context = ErrorContextModel(
                error_id=error_id,
                timestamp=datetime.now(),
                task_id=task_id or "UNKNOWN",
                agent_name=agent_name,
                error_type=error_type,
                error_message=error_message,
                full_traceback=full_traceback,
                stack_frames=stack_frames,
                error_location=error_location,
                problematic_code=problematic_code,
                surrounding_code=surrounding_code,
                local_variables=local_vars,
                severity=severity,
                task_description=task_context.get('description') if task_context else None,
                task_parameters=task_context.get('parameters') if task_context else None
            )
            
            # バッファに追加
            self._add_to_buffer(error_context)
            
            # ログ出力
            logger.error(f"❌ エラー捕捉: {error_id}")
            logger.error(f"   タイプ: {error_type}")
            logger.error(f"   メッセージ: {error_message}")
            logger.error(f"   深刻度: {severity.value}")
            
            if error_location:
                logger.error(f"   場所: {error_location.file_path}:{error_location.line_number}")
            
            return error_context
            
        except Exception as e:
            logger.error(f"💥 エラー捕捉中にエラー: {e}")
            # フォールバック: 最小限のエラーコンテキスト
            return self._create_minimal_error_context(exception, task_id, agent_name)
    
    def _extract_stack_frames(self, traceback_obj) -> List[StackTraceFrame]:
        """スタックトレースからフレーム情報を抽出"""
        frames = []
        
        try:
            tb_list = traceback.extract_tb(traceback_obj)
            
            for frame_summary in tb_list:
                # コード文脈を取得(前後1行)
                code_context = self._get_code_context(
                    frame_summary.filename,
                    frame_summary.lineno,
                    context_lines=1
                )
                
                frame = StackTraceFrame(
                    file_path=frame_summary.filename,
                    line_number=frame_summary.lineno,
                    function_name=frame_summary.name,
                    code_context=code_context
                )
                frames.append(frame)
        
        except Exception as e:
            logger.warning(f"⚠️ スタックフレーム抽出エラー: {e}")
        
        return frames
    
    def _extract_error_location(self, traceback_obj) -> Optional[CodeLocation]:
        """エラー発生位置を抽出"""
        try:
            tb_list = traceback.extract_tb(traceback_obj)
            
            if not tb_list:
                return None
            
            # 最後のフレーム(エラー発生箇所)を取得
            last_frame = tb_list[-1]
            
            return CodeLocation(
                file_path=last_frame.filename,
                line_number=last_frame.lineno,
                function_name=last_frame.name
            )
        
        except Exception as e:
            logger.warning(f"⚠️ エラー位置抽出エラー: {e}")
            return None
    
    def _extract_code_snippets(
        self, 
        file_path: Optional[str], 
        line_number: Optional[int]
    ) -> Tuple[Optional[str], Optional[str]]:
        """問題のあるコードと周辺コードを抽出"""
        if not file_path or not line_number:
            return None, None
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            # 問題のある行(1行)
            if 1 <= line_number <= len(lines):
                problematic_code = lines[line_number - 1].rstrip()
            else:
                problematic_code = None
            
            # 周辺コード(前後10行)
            start_line = max(0, line_number - 11)
            end_line = min(len(lines), line_number + 10)
            surrounding_lines = lines[start_line:end_line]
            
            # 行番号付きで整形
            surrounding_code = '\n'.join([
                f"{start_line + i + 1:4d} | {line.rstrip()}"
                for i, line in enumerate(surrounding_lines)
            ])
            
            return problematic_code, surrounding_code
        
        except Exception as e:
            logger.warning(f"⚠️ コードスニペット抽出エラー: {e}")
            return None, None
    
    def _get_code_context(
        self, 
        file_path: str, 
        line_number: int, 
        context_lines: int = 1
    ) -> Optional[str]:
        """指定行の前後のコードコンテキストを取得"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            start = max(0, line_number - context_lines - 1)
            end = min(len(lines), line_number + context_lines)
            
            context = ''.join(lines[start:end])
            return context.strip()
        
        except:
            return None
    
    def _extract_local_variables(self, traceback_obj) -> Dict[str, Any]:
        """ローカル変数の状態を抽出(安全に)"""
        local_vars = {}
        
        try:
            frame = traceback_obj.tb_frame
            
            for var_name, var_value in frame.f_locals.items():
                try:
                    # シリアライズ可能な値のみ保存
                    if isinstance(var_value, (str, int, float, bool, type(None))):
                        local_vars[var_name] = var_value
                    elif isinstance(var_value, (list, tuple, dict)):
                        # 複雑な構造は文字列表現に変換
                        local_vars[var_name] = str(var_value)[:200]  # 最大200文字
                    else:
                        local_vars[var_name] = f"<{type(var_value).__name__} object>"
                except:
                    local_vars[var_name] = "<unprintable>"
        
        except Exception as e:
            logger.warning(f"⚠️ ローカル変数抽出エラー: {e}")
        
        return local_vars
    
    def _determine_severity(self, error_type: str, error_message: str) -> ErrorSeverity:
        """エラーの深刻度を判定"""
        error_lower = (error_type + error_message).lower()
        
        # CRITICAL: システム停止レベル
        if any(kw in error_lower for kw in [
            'systemerror', 'memoryerror', 'recursionerror',
            'keyboardinterrupt', 'syntaxerror'
        ]):
            return ErrorSeverity.CRITICAL
        
        # HIGH: 機能不全
        if any(kw in error_lower for kw in [
            'attributeerror', 'importerror', 'modulenotfound',
            'typeerror', 'valueerror'
        ]):
            return ErrorSeverity.HIGH
        
        # MEDIUM: 部分的な問題
        if any(kw in error_lower for kw in [
            'keyerror', 'indexerror', 'filenotfounderror'
        ]):
            return ErrorSeverity.MEDIUM
        
        # LOW: 軽微な問題
        return ErrorSeverity.LOW
    
    def _add_to_buffer(self, error_context: ErrorContextModel):
        """エラーコンテキストをバッファに追加"""
        self.error_buffer.append(error_context)
        
        # バッファサイズ制限
        if len(self.error_buffer) > self.max_buffer_size:
            self.error_buffer.pop(0)  # 最古のエラーを削除
    
    def _create_minimal_error_context(
        self,
        exception: Exception,
        task_id: Optional[str],
        agent_name: Optional[str]
    ) -> ErrorContextModel:
        """最小限のエラーコンテキストを作成(フォールバック)"""
        return ErrorContextModel(
            error_id=f"ERROR_MINIMAL_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            timestamp=datetime.now(),
            task_id=task_id or "UNKNOWN",
            agent_name=agent_name,
            error_type=type(exception).__name__,
            error_message=str(exception),
            full_traceback=traceback.format_exc(),
            severity=ErrorSeverity.MEDIUM
        )
    
    def get_recent_errors(self, count: int = 10) -> List[ErrorContextModel]:
        """最近のエラーを取得"""
        return self.error_buffer[-count:]
    
    def get_error_by_id(self, error_id: str) -> Optional[ErrorContextModel]:
        """IDでエラーを検索"""
        for error in reversed(self.error_buffer):
            if error.error_id == error_id:
                return error
        return None
    
    def clear_buffer(self):
        """バッファをクリア"""
        self.error_buffer.clear()
        logger.info("🧹 エラーバッファをクリアしました")


class TaskErrorHandler:
    """
    タスク実行用エラーハンドラ - バグ修正タスク生成機能付き
    """
    
    def __init__(self, error_handler: EnhancedErrorHandler):
        """
        初期化
        
        Args:
            error_handler: EnhancedErrorHandlerインスタンス
        """
        self.error_handler = error_handler
        self.bug_fix_tasks: List[BugFixTask] = []
        
        logger.info("✅ TaskErrorHandler 初期化完了")
    
    def handle_task_error(
        self,
        exception: Exception,
        task: Dict[str, Any],
        agent_name: Optional[str] = None,
        auto_generate_fix_task: bool = True
    ) -> Optional[BugFixTask]:
        """
        タスク実行エラーを処理し、必要に応じてバグ修正タスクを生成
        
        Args:
            exception: 捕捉された例外
            task: 失敗したタスク情報
            agent_name: エージェント名
            auto_generate_fix_task: バグ修正タスク自動生成フラグ
            
        Returns:
            BugFixTask: 生成されたバグ修正タスク(生成しない場合はNone)
        """
        try:
            task_id = task.get('task_id', 'UNKNOWN')
            
            # エラーコンテキストを捕捉
            error_context = self.error_handler.capture_error(
                exception=exception,
                task_id=task_id,
                agent_name=agent_name,
                task_context=task
            )
            
            # 自動修正が不要な場合は終了
            if not auto_generate_fix_task:
                return None
            
            # 致命的なエラーのみバグ修正タスクを生成
            if error_context.severity in [ErrorSeverity.CRITICAL, ErrorSeverity.HIGH]:
                bug_fix_task = self._generate_bug_fix_task(error_context, task)
                self.bug_fix_tasks.append(bug_fix_task)
                
                logger.info(f"🔧 バグ修正タスク生成: {bug_fix_task.task_id}")
                return bug_fix_task
            
            return None
            
        except Exception as e:
            logger.error(f"💥 タスクエラーハンドリング中にエラー: {e}")
            return None
    
    def _generate_bug_fix_task(
        self,
        error_context: ErrorContextModel,
        original_task: Dict[str, Any]
    ) -> BugFixTask:
        """バグ修正タスクを生成"""
        
        # バグ修正タスクIDを生成
        fix_task_id = f"FIX_BUG_{error_context.task_id}_{datetime.now().strftime('%H%M%S')}"
        
        # 修正対象ファイルを特定
        target_files = []
        if error_context.error_location:
            target_files.append(error_context.error_location.file_path)
        
        bug_fix_task = BugFixTask(
            task_id=fix_task_id,
            original_task_id=error_context.task_id,
            error_context=error_context,
            priority="critical" if error_context.severity == ErrorSeverity.CRITICAL else "high",
            required_role="quick_fix",
            target_files=target_files,
            status="pending"
        )
        
        return bug_fix_task
    
    def get_pending_fix_tasks(self) -> List[BugFixTask]:
        """未処理のバグ修正タスクを取得"""
        return [task for task in self.bug_fix_tasks if task.status == "pending"]
    
    def get_all_fix_tasks(self) -> List[BugFixTask]:
        """全バグ修正タスクを取得"""
        return self.bug_fix_tasks.copy()


# 使用例
if __name__ == "__main__":
    # テスト用のエラーハンドラ
    error_handler = EnhancedErrorHandler()
    task_handler = TaskErrorHandler(error_handler)
    
    # テスト用の例外
    try:
        # 意図的にエラーを発生
        result = 1 / 0
    except Exception as e:
        # エラーを捕捉
        error_context = error_handler.capture_error(
            exception=e,
            task_id="TEST_TASK_001",
            agent_name="TestAgent",
            task_context={
                "description": "テストタスク",
                "parameters": {"param1": "value1"}
            }
        )
        
        print(f"捕捉されたエラー: {error_context.error_type}")
        print(f"エラーメッセージ: {error_context.error_message}")
        print(f"深刻度: {error_context.severity.value}")
        
        # バグ修正タスク生成
        bug_task = task_handler.handle_task_error(
            exception=e,
            task={"task_id": "TEST_TASK_001", "description": "テストタスク"},
            agent_name="TestAgent"
        )
        
        if bug_task:
            print(f"生成された修正タスク: {bug_task.task_id}")

#example_usage.py
# example_usage.py
"""
ハイブリッド型自律コード修正システムの使用例
"""

import asyncio
import logging
from pathlib import Path

# エージェントのインポート
from hybrid_fix_orchestrator import HybridFixOrchestrator, FixStrategy
from local_fix_agent import LocalFixAgent
from cloud_fix_agent import CloudFixAgent
from error_classifier import ErrorClassifier
from wp_tester_agent import WPTesterAgent
from github_agent import GitHubAgent
from patch_manager import PatchManager
from cloud_storage_manager import CloudStorageManager

# データモデル
from data_models import (
    BugFixTask,
    ErrorContextModel,
    ErrorSeverity,
    ErrorCategory,
    create_bug_fix_task_from_exception
)

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)


# ========================================
# 例1: 基本的な使用方法
# ========================================

async def example_1_basic_usage():
    """基本的な自動修正の例"""
    
    logger.info("=" * 80)
    logger.info("例1: 基本的な自動修正")
    logger.info("=" * 80)
    
    # コマンドモニター（仮）
    class DummyCommandMonitor:
        async def execute_command(self, cmd):
            return {"success": True, "stdout": ""}
    
    cmd_monitor = DummyCommandMonitor()
    
    # エージェント初期化
    local_agent = LocalFixAgent(
        command_monitor=cmd_monitor,
        use_local_ai=False  # まずはルールベースのみ
    )
    
    cloud_agent = CloudFixAgent(
        command_monitor=cmd_monitor,
        api_provider="openai",
        model_name="gpt-4o"
    )
    
    classifier = ErrorClassifier()
    
    # オーケストレーター初期化
    orchestrator = HybridFixOrchestrator(
        local_agent=local_agent,
        cloud_agent=cloud_agent,
        error_classifier=classifier,
        default_strategy=FixStrategy.ADAPTIVE
    )
    
    # エラーコンテキスト作成
    error_context = ErrorContextModel(
        error_type="AttributeError",
        error_message="'NoneType' object has no attribute 'get'",
        severity=ErrorSeverity.HIGH,
        error_category=ErrorCategory.RUNTIME,
        file_path="wp_agent.py",
        line_number=42,
        surrounding_code="""
def process_data(self, data):
    result = self.fetch_config()
    value = result.get('key')  # ← エラー発生箇所
    return value
""",
        full_traceback="""
Traceback (most recent call last):
  File "wp_agent.py", line 42, in process_data
    value = result.get('key')
AttributeError: 'NoneType' object has no attribute 'get'
"""
    )
    
    # バグ修正タスク作成
    task = BugFixTask(
        task_id="Example-1-AttributeError-Fix",
        error_context=error_context,
        target_files=["wp_agent.py"],
        priority=8,
        run_tests=False,  # この例ではテストをスキップ
        create_pr=False
    )
    
    # 修正実行
    result = await orchestrator.execute_fix_task(task)
    
    # 結果表示
    print("\n" + "=" * 80)
    print("🔧 修正結果")
    print("=" * 80)
    print(f"成功: {result.success}")
    print(f"修正ファイル: {result.modified_files}")
    print(f"信頼度: {result.confidence_score:.1%}")
    print(f"実行時間: {result.execution_time:.2f}秒")
    print(f"使用エージェント: {result.agent_used}")
    
    if result.success:
        print(f"\n📝 修正理由:\n{result.reasoning}")
    else:
        print(f"\n❌ エラー: {result.error_message}")
    
    # 統計表示
    orchestrator.print_stats()


# ========================================
# 例2: 例外からの自動修正
# ========================================

async def example_2_exception_handling():
    """実行時例外からの自動修正"""
    
    logger.info("=" * 80)
    logger.info("例2: 例外からの自動修正")
    logger.info("=" * 80)
    
    # 擬似的なコード実行
    try:
        # エラーが発生するコード
        data = None
        result = data.get('key')  # AttributeError発生
    
    except Exception as e:
        logger.info(f"例外を捕捉: {type(e).__name__}: {e}")
        
        # 例外からタスクを自動生成
        task = create_bug_fix_task_from_exception(
            task_id="Example-2-Auto-Generated",
            exception=e,
            file_path="example_code.py",
            line_number=10
        )
        
        # オーケストレーター初期化（簡易版）
        # ... (エージェント初期化は省略)
        
        logger.info(f"✅ バグ修正タスク自動生成: {task.task_id}")
        logger.info(f"   エラータイプ: {task.error_context.error_type}")
        logger.info(f"   重要度: {task.error_context.severity.value}")


# ========================================
# 例3: 複数戦略の比較
# ========================================

async def example_3_strategy_comparison():
    """異なる戦略の比較"""
    
    logger.info("=" * 80)
    logger.info("例3: 複数戦略の比較")
    logger.info("=" * 80)
    
    # ... (初期化は省略)
    
    strategies = [
        FixStrategy.LOCAL_ONLY,
        FixStrategy.CLOUD_ONLY,
        FixStrategy.LOCAL_FIRST,
        FixStrategy.PARALLEL
    ]
    
    results = {}
    
    for strategy in strategies:
        logger.info(f"\n📊 戦略テスト: {strategy.value}")
        
        # タスク作成（同じエラーコンテキスト）
        # task = ... (省略)
        
        # 戦略を指定して実行
        # result = await orchestrator.execute_fix_task(task, strategy=strategy)
        
        # results[strategy.value] = result
    
    # 結果比較
    print("\n" + "=" * 80)
    print("📊 戦略別比較")
    print("=" * 80)
    print(f"{'戦略':<20} {'成功':<10} {'実行時間':<15} {'信頼度':<10}")
    print("-" * 80)
    
    for strategy_name, result in results.items():
        print(
            f"{strategy_name:<20} "
            f"{'✅' if result.success else '❌':<10} "
            f"{result.execution_time:.2f}秒{'':<8} "
            f"{result.confidence_score:.1%}"
        )


# ========================================
# 例4: GitHub連携付き完全ワークフロー
# ========================================

async def example_4_full_workflow_with_github():
    """GitHub連携を含む完全なワークフロー"""
    
    logger.info("=" * 80)
    logger.info("例4: GitHub連携付き完全ワークフロー")
    logger.info("=" * 80)
    
    # ... (エージェント初期化)
    
    # GitHubエージェント追加
    github_agent = GitHubAgent(
        repo_path=".",
        repo_owner="your-org",
        repo_name="your-repo"
    )
    
    # テスターエージェント追加
    wp_tester = WPTesterAgent(
        command_monitor=None,  # 仮
        wp_path="/var/www/html"
    )
    
    # タスク作成（テスト & PR作成を有効化）
    # task = BugFixTask(
    #     task_id="Example-4-Full-Workflow",
    #     error_context=...,
    #     target_files=["wp_agent.py"],
    #     run_tests=True,
    #     create_pr=True
    # )
    
    # 修正実行
    # result = await orchestrator.execute_fix_task(task)
    
    # if result.success:
    #     # GitHub PR作成
    #     pr_result = await github_agent.create_full_fix_workflow(
    #         task_id=task.task_id,
    #         modified_files=result.modified_files,
    #         fix_description=result.reasoning
    #     )
    #     
    #     if pr_result["success"]:
    #         logger.info(f"✅ PR作成成功: {pr_result['pr_url']}")


# ========================================
# 例5: クラウドストレージ連携
# ========================================

async def example_5_cloud_storage():
    """クラウドストレージとの連携"""
    
    logger.info("=" * 80)
    logger.info("例5: クラウドストレージ連携")
    logger.info("=" * 80)
    
    # ストレージマネージャー初期化
    storage = CloudStorageManager(
        provider="gcs",  # or "s3", "azure"
        bucket_name="your-bucket",
        auto_sync=True
    )
    
    # クッキーファイルの読み込み（クラウドから）
    try:
        cookies = await storage.read_file("session/cookies.json")
        logger.info(f"✅ クッキー読み込み成功（{len(cookies)}バイト）")
    except Exception as e:
        logger.error(f"❌ クッキー読み込み失敗: {e}")
    
    # 修正結果の保存（クラウドへ）
    fix_result_json = '{"success": true, "modified_files": ["wp_agent.py"]}'
    
    try:
        await storage.write_file(
            "fix_results/example_5.json",
            fix_result_json
        )
        logger.info("✅ 修正結果をクラウドに保存")
    except Exception as e:
        logger.error(f"❌ 保存失敗: {e}")
    
    # 統計表示
    stats = storage.get_stats()
    print(f"\n📊 ストレージ統計:")
    print(f"   アップロード: {stats['uploads']}回")
    print(f"   ダウンロード: {stats['downloads']}回")
    print(f"   キャッシュヒット率: {stats['cache_hit_rate']:.1%}")


# ========================================
# 例6: パッチ管理の高度な使用
# ========================================

async def example_6_advanced_patching():
    """パッチ管理の高度な使用例"""
    
    logger.info("=" * 80)
    logger.info("例6: 高度なパッチ管理")
    logger.info("=" * 80)
    
    patch_manager = PatchManager(
        backup_dir="./backups/patches",
        max_backups=10
    )
    
    # 安全な修正適用
    original_code = """
def fetch_config(self):
    return self.config_data
"""
    
    fixed_code = """
def fetch_config(self):
    if self.config_data is None:
        self.config_data = self._load_config()
    return self.config_data
"""
    
    # 検証付きパッチ適用
    result = await patch_manager.apply_patch(
        file_path="wp_agent.py",
        new_content=fixed_code,
        strategy=PatchStrategy.REPLACE,
        verify=True  # 構文チェックを実行
    )
    
    if result["success"]:
        logger.info("✅ パッチ適用成功")
        logger.info(f"   バックアップ: {result['backup_path']}")
        
        # 差分表示
        if result.get("diff"):
            print("\n📋 変更内容:")
            print(result["diff"])
    
    # ロールバックのテスト
    # rollback_result = await patch_manager.rollback("wp_agent.py")
    
    # 統計
    stats = patch_manager.get_stats()
    print(f"\n📊 パッチ統計:")
    print(f"   成功率: {stats['success_rate']:.1%}")
    print(f"   ロールバック: {stats['rollbacks']}回")


# ========================================
# メイン実行
# ========================================

async def main():
    """すべての例を実行"""
    
    print("\n" + "🚀 " * 20)
    print("   ハイブリッド型自律コード修正システム - 使用例")
    print("🚀 " * 20 + "\n")
    
    # 例1: 基本的な使用方法
    await example_1_basic_usage()
    
    # 例2: 例外からの自動修正
    await example_2_exception_handling()
    
    # 例3: 複数戦略の比較
    # await example_3_strategy_comparison()
    
    # 例4: GitHub連携付き完全ワークフロー
    # await example_4_full_workflow_with_github()
    
    # 例5: クラウドストレージ連携
    # await example_5_cloud_storage()
    
    # 例6: パッチ管理の高度な使用
    # await example_6_advanced_patching()
    
    print("\n" + "✅ " * 20)
    print("   すべての例が完了しました")
    print("✅ " * 20 + "\n")


if __name__ == "__main__":
    # Windows環境の場合
    import sys
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    # 実行
    asyncio.run(main())

#fix_agent.py
# fix_agents/fix_agent.py
"""
修正エージェントの基底クラス
"""

import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class BaseFixAgent(ABC):
    """
    修正エージェントの基底クラス
    
    すべての修正エージェント（Local, Cloud）の共通インターフェース
    """
    
    def __init__(
        self,
        command_monitor=None,
        wp_tester=None,
        **kwargs
    ):
        """
        初期化
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_tester: WordPressTester
            **kwargs: その他のオプション
        """
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        
        # 統計情報
        self.stats = {
            "total_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0
        }
        
        self.agent_name = self.__class__.__name__
        logger.info(f"✅ {self.agent_name} 初期化")
    
    @abstractmethod
    async def execute_bug_fix_task(self, bug_fix_task):
        """
        バグ修正タスクを実行（サブクラスで実装）
        
        Args:
            bug_fix_task: BugFixTask
            
        Returns:
            FixResult: 修正結果
        """
        pass
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_fixes"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_fixes"]
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "agent_name": self.agent_name
        }
    
    def _create_failed_result(
        self,
        task_id: str,
        error_message: str,
        start_time: datetime
    ):
        """失敗結果を作成"""
        from data_models import FixResult
        
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return FixResult(
            task_id=task_id,
            success=False,
            modified_files=[],
            generated_code="",
            test_passed=False,
            execution_time=execution_time,
            error_message=error_message,
            confidence_score=0.0
        )


# エイリアス（互換性のため）
LocalFixAgent = BaseFixAgent
CloudFixAgent = BaseFixAgent

#github_agent.py
# github_agent.py
"""
GitHub連携エージェント
Git操作とプルリクエストの自動作成
"""

import asyncio
import logging
import os
import subprocess
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class GitHubAgent:
    """
    GitHub連携エージェント
    
    機能:
    - Git操作（ブランチ作成、コミット、プッシュ）
    - プルリクエストの自動作成
    - コミットメッセージの自動生成
    - GitHub API連携
    """
    
    def __init__(
        self,
        repo_path: str = ".",
        github_token: Optional[str] = None,
        repo_owner: Optional[str] = None,
        repo_name: Optional[str] = None
    ):
        """
        初期化
        
        Args:
            repo_path: リポジトリのパス
            github_token: GitHub Personal Access Token
            repo_owner: リポジトリオーナー
            repo_name: リポジトリ名
        """
        self.repo_path = Path(repo_path)
        self.github_token = github_token or os.getenv("GITHUB_TOKEN")
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        
        # GitHub APIクライアント（オプション）
        self.github_api = None
        if self.github_token:
            self._init_github_api()
        
        # 統計情報
        self.stats = {
            "total_commits": 0,
            "total_prs": 0,
            "successful_prs": 0,
            "failed_prs": 0
        }
        
        logger.info(f"✅ GitHubAgent 初期化完了 (repo={repo_path})")
    
    def _init_github_api(self):
        """GitHub APIクライアントを初期化"""
        try:
            from github import Github
            self.github_api = Github(self.github_token)
            logger.info("✅ GitHub API クライアント初期化完了")
        except ImportError:
            logger.warning("⚠️ PyGithub がインストールされていません。API機能は利用できません。")
            self.github_api = None
    
    async def create_fix_branch_and_commit(
        self,
        task_id: str,
        modified_files: List[str],
        commit_message: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        修正用ブランチを作成してコミット
        
        Args:
            task_id: タスクID
            modified_files: 修正されたファイルのリスト
            commit_message: コミットメッセージ（省略時は自動生成）
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("=" * 60)
            logger.info(f"🌿 修正ブランチ作成 & コミット: {task_id}")
            logger.info("=" * 60)
            
            # ブランチ名を生成
            branch_name = self._generate_branch_name(task_id)
            
            # 現在のブランチを保存
            current_branch = await self._get_current_branch()
            logger.info(f"📍 現在のブランチ: {current_branch}")
            
            # 新しいブランチを作成
            create_result = await self._create_branch(branch_name)
            if not create_result["success"]:
                return create_result
            
            logger.info(f"🌿 ブランチ作成成功: {branch_name}")
            
            # ファイルをステージング
            stage_result = await self._stage_files(modified_files)
            if not stage_result["success"]:
                await self._checkout_branch(current_branch)
                return stage_result
            
            # コミットメッセージを生成
            if not commit_message:
                commit_message = self._generate_commit_message(task_id, modified_files)
            
            # コミット
            commit_result = await self._commit(commit_message)
            if not commit_result["success"]:
                await self._checkout_branch(current_branch)
                return commit_result
            
            self.stats["total_commits"] += 1
            logger.info(f"✅ コミット成功: {commit_result['commit_hash']}")
            
            return {
                "success": True,
                "branch_name": branch_name,
                "commit_hash": commit_result["commit_hash"],
                "original_branch": current_branch,
                "commit_message": commit_message
            }
            
        except Exception as e:
            logger.error(f"💥 ブランチ作成/コミットエラー: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    async def push_and_create_pr(
        self,
        branch_name: str,
        pr_title: Optional[str] = None,
        pr_body: Optional[str] = None,
        base_branch: str = "main"
    ) -> Dict[str, Any]:
        """
        ブランチをプッシュしてプルリクエストを作成
        
        Args:
            branch_name: ブランチ名
            pr_title: PRタイトル（省略時は自動生成）
            pr_body: PR本文（省略時は自動生成）
            base_branch: マージ先ブランチ
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("=" * 60)
            logger.info(f"🚀 プッシュ & PR作成: {branch_name}")
            logger.info("=" * 60)
            
            self.stats["total_prs"] += 1
            
            # プッシュ
            push_result = await self._push_branch(branch_name)
            if not push_result["success"]:
                self.stats["failed_prs"] += 1
                return push_result
            
            logger.info(f"✅ プッシュ成功: {branch_name}")
            
            # プルリクエスト作成
            if self.github_api and self.repo_owner and self.repo_name:
                # GitHub API経由
                pr_result = await self._create_pr_via_api(
                    branch_name,
                    pr_title,
                    pr_body,
                    base_branch
                )
            else:
                # GitHub CLI経由
                pr_result = await self._create_pr_via_cli(
                    branch_name,
                    pr_title,
                    pr_body,
                    base_branch
                )
            
            if pr_result["success"]:
                self.stats["successful_prs"] += 1
                logger.info(f"✅ PR作成成功: {pr_result['pr_url']}")
            else:
                self.stats["failed_prs"] += 1
            
            return pr_result
            
        except Exception as e:
            logger.error(f"💥 プッシュ/PR作成エラー: {e}", exc_info=True)
            self.stats["failed_prs"] += 1
            return {
                "success": False,
                "error": str(e)
            }
    
    async def create_full_fix_workflow(
        self,
        task_id: str,
        modified_files: List[str],
        fix_description: str,
        base_branch: str = "main"
    ) -> Dict[str, Any]:
        """
        完全な修正ワークフローを実行
        
        Args:
            task_id: タスクID
            modified_files: 修正されたファイル
            fix_description: 修正内容の説明
            base_branch: マージ先ブランチ
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🔄 完全な修正ワークフロー開始")
            
            # 1. ブランチ作成 & コミット
            commit_result = await self.create_fix_branch_and_commit(
                task_id,
                modified_files
            )
            
            if not commit_result["success"]:
                return commit_result
            
            branch_name = commit_result["branch_name"]
            
            # 2. プッシュ & PR作成
            pr_title = f"🔧 Fix: {task_id}"
            pr_body = self._generate_pr_body(
                task_id,
                modified_files,
                fix_description,
                commit_result["commit_hash"]
            )
            
            pr_result = await self.push_and_create_pr(
                branch_name,
                pr_title,
                pr_body,
                base_branch
            )
            
            if pr_result["success"]:
                logger.info("=" * 60)
                logger.info("✅ 完全な修正ワークフロー成功")
                logger.info(f"📋 PR URL: {pr_result['pr_url']}")
                logger.info("=" * 60)
            
            return {
                **pr_result,
                "branch_name": branch_name,
                "commit_hash": commit_result["commit_hash"],
                "original_branch": commit_result["original_branch"]
            }
            
        except Exception as e:
            logger.error(f"💥 ワークフローエラー: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # Git操作関数
    # ========================================
    
    async def _run_git_command(self, *args) -> Dict[str, Any]:
        """Gitコマンドを実行"""
        try:
            cmd = ["git", "-C", str(self.repo_path)] + list(args)
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            stdout_text = stdout.decode('utf-8').strip()
            stderr_text = stderr.decode('utf-8').strip()
            
            success = process.returncode == 0
            
            if not success:
                logger.error(f"❌ Git コマンドエラー: {' '.join(args)}")
                logger.error(f"   stderr: {stderr_text}")
            
            return {
                "success": success,
                "stdout": stdout_text,
                "stderr": stderr_text,
                "returncode": process.returncode
            }
            
        except Exception as e:
            logger.error(f"❌ Git コマンド実行エラー: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _get_current_branch(self) -> str:
        """現在のブランチ名を取得"""
        result = await self._run_git_command("branch", "--show-current")
        return result.get("stdout", "main")
    
    async def _create_branch(self, branch_name: str) -> Dict[str, Any]:
        """新しいブランチを作成してチェックアウト"""
        result = await self._run_git_command("checkout", "-b", branch_name)
        return result
    
    async def _checkout_branch(self, branch_name: str) -> Dict[str, Any]:
        """ブランチをチェックアウト"""
        result = await self._run_git_command("checkout", branch_name)
        return result
    
    async def _stage_files(self, files: List[str]) -> Dict[str, Any]:
        """ファイルをステージング"""
        for file in files:
            result = await self._run_git_command("add", file)
            if not result["success"]:
                return result
        
        return {"success": True}
    
    async def _commit(self, message: str) -> Dict[str, Any]:
        """コミットを作成"""
        result = await self._run_git_command("commit", "-m", message)
        
        if result["success"]:
            # コミットハッシュを取得
            hash_result = await self._run_git_command("rev-parse", "HEAD")
            result["commit_hash"] = hash_result.get("stdout", "")[:8]
        
        return result
    
    async def _push_branch(self, branch_name: str) -> Dict[str, Any]:
        """ブランチをリモートにプッシュ"""
        result = await self._run_git_command(
            "push",
            "-u",
            "origin",
            branch_name
        )
        return result
    
    # ========================================
    # PR作成関数
    # ========================================
    
    async def _create_pr_via_api(
        self,
        branch_name: str,
        pr_title: Optional[str],
        pr_body: Optional[str],
        base_branch: str
    ) -> Dict[str, Any]:
        """GitHub API経由でPRを作成"""
        try:
            if not self.github_api:
                return {
                    "success": False,
                    "error": "GitHub API client not initialized"
                }
            
            repo = self.github_api.get_repo(f"{self.repo_owner}/{self.repo_name}")
            
            pr = await asyncio.to_thread(
                repo.create_pull,
                title=pr_title or f"Auto-fix: {branch_name}",
                body=pr_body or "Automated bug fix",
                head=branch_name,
                base=base_branch
            )
            
            return {
                "success": True,
                "pr_number": pr.number,
                "pr_url": pr.html_url
            }
            
        except Exception as e:
            logger.error(f"❌ GitHub API PR作成エラー: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _create_pr_via_cli(
        self,
        branch_name: str,
        pr_title: Optional[str],
        pr_body: Optional[str],
        base_branch: str
    ) -> Dict[str, Any]:
        """GitHub CLI経由でPRを作成"""
        try:
            cmd = [
                "gh", "pr", "create",
                "--base", base_branch,
                "--head", branch_name,
                "--title", pr_title or f"Auto-fix: {branch_name}",
                "--body", pr_body or "Automated bug fix"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.repo_path
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                pr_url = stdout.decode('utf-8').strip()
                return {
                    "success": True,
                    "pr_url": pr_url
                }
            else:
                return {
                    "success": False,
                    "error": stderr.decode('utf-8').strip()
                }
                
        except Exception as e:
            logger.error(f"❌ GitHub CLI PR作成エラー: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # ユーティリティ
    # ========================================
    
    def _generate_branch_name(self, task_id: str) -> str:
        """ブランチ名を生成"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_task_id = task_id.replace(" ", "_").replace("/", "-")
        return f"auto-fix/{safe_task_id}_{timestamp}"
    
    def _generate_commit_message(
        self,
        task_id: str,
        modified_files: List[str]
    ) -> str:
        """コミットメッセージを自動生成"""
        file_list = "\n".join(f"  - {f}" for f in modified_files[:5])
        
        if len(modified_files) > 5:
            file_list += f"\n  ... and {len(modified_files) - 5} more files"
        
        return f"""🔧 Auto-fix: {task_id}

Modified files:
{file_list}

Generated by: HybridFixOrchestrator
Timestamp: {datetime.now().isoformat()}
"""
    
    def _generate_pr_body(
        self,
        task_id: str,
        modified_files: List[str],
        fix_description: str,
        commit_hash: str
    ) -> str:
        """PR本文を自動生成"""
        file_list = "\n".join(f"- `{f}`" for f in modified_files)
        
        return f"""## 🔧 自動修正: {task_id}

### 📝 修正内容
{fix_description}

### 📂 変更されたファイル
{file_list}

### 🤖 自動生成情報
- **コミットハッシュ**: `{commit_hash}`
- **生成日時**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
- **生成エージェント**: HybridFixOrchestrator

### ✅ チェックリスト
- [ ] コードレビュー完了
- [ ] テスト実行確認
- [ ] ドキュメント更新（必要な場合）

---
*このPRは自動生成されました。マージ前に必ずレビューしてください。*
"""
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        pr_success_rate = 0.0
        if self.stats["total_prs"] > 0:
            pr_success_rate = self.stats["successful_prs"] / self.stats["total_prs"]
        
        return {
            **self.stats,
            "pr_success_rate": pr_success_rate
        }

#hybrid_fix_orchestrator.py
# hybrid_fix_orchestrator.py
"""
ハイブリッド修正オーケストレーター
ローカルとクラウド修正を統括管理
"""

import asyncio
import logging
from typing import Dict, Any, Optional
from datetime import datetime
from enum import Enum

from data_models import BugFixTask, FixResult, ErrorContextModel
from local_fix_agent import LocalFixAgent
from cloud_fix_agent import CloudFixAgent
from error_classifier import ErrorClassifier

logger = logging.getLogger(__name__)


class FixStrategy(Enum):
    """修正戦略"""
    LOCAL_ONLY = "local_only"          # ローカルのみ
    CLOUD_ONLY = "cloud_only"          # クラウドのみ
    LOCAL_FIRST = "local_first"        # ローカル優先
    CLOUD_FIRST = "cloud_first"        # クラウド優先
    PARALLEL = "parallel"              # 並列実行
    ADAPTIVE = "adaptive"              # 適応的選択


class HybridFixOrchestrator:
    """
    ハイブリッド修正オーケストレーター
    
    機能:
    - エラー分類とルーティング
    - ローカル/クラウド修正の選択
    - フォールバック戦略
    - 並列実行管理
    - 統計情報の収集
    """
    
    def __init__(
        self,
        local_agent: LocalFixAgent,
        cloud_agent: CloudFixAgent,
        error_classifier: Optional[ErrorClassifier] = None,
        default_strategy: FixStrategy = FixStrategy.ADAPTIVE
    ):
        """
        初期化
        
        Args:
            local_agent: ローカル修正エージェント
            cloud_agent: クラウド修正エージェント
            error_classifier: エラー分類器
            default_strategy: デフォルト戦略
        """
        self.local_agent = local_agent
        self.cloud_agent = cloud_agent
        self.error_classifier = error_classifier or ErrorClassifier()
        self.default_strategy = default_strategy
        
        # 統計情報
        self.stats = {
            "total_tasks": 0,
            "local_fixes": 0,
            "cloud_fixes": 0,
            "hybrid_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0,
            "avg_execution_time": 0.0,
            "strategy_usage": {strategy.value: 0 for strategy in FixStrategy}
        }
        
        # 修正履歴
        self.fix_history = []
        
        logger.info(f"✅ HybridFixOrchestrator 初期化完了 (戦略={default_strategy.value})")
    
    async def execute_fix_task(
        self, 
        bug_fix_task: BugFixTask,
        strategy: Optional[FixStrategy] = None
    ) -> FixResult:
        """
        修正タスクを実行
        
        Args:
            bug_fix_task: バグ修正タスク
            strategy: 修正戦略（省略時はデフォルト）
            
        Returns:
            FixResult: 修正結果
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        self.stats["total_tasks"] += 1
        
        # 戦略の決定
        selected_strategy = strategy or self.default_strategy
        
        # 適応的戦略の場合、エラー分析に基づいて決定
        if selected_strategy == FixStrategy.ADAPTIVE:
            selected_strategy = await self._select_adaptive_strategy(bug_fix_task.error_context)
        
        self.stats["strategy_usage"][selected_strategy.value] += 1
        
        logger.info("=" * 80)
        logger.info(f"🎯 ハイブリッド修正開始: {task_id}")
        logger.info(f"📊 選択戦略: {selected_strategy.value}")
        logger.info("=" * 80)
        
        try:
            # 戦略に応じた実行
            if selected_strategy == FixStrategy.LOCAL_ONLY:
                result = await self._execute_local_only(bug_fix_task)
                
            elif selected_strategy == FixStrategy.CLOUD_ONLY:
                result = await self._execute_cloud_only(bug_fix_task)
                
            elif selected_strategy == FixStrategy.LOCAL_FIRST:
                result = await self._execute_local_first(bug_fix_task)
                
            elif selected_strategy == FixStrategy.CLOUD_FIRST:
                result = await self._execute_cloud_first(bug_fix_task)
                
            elif selected_strategy == FixStrategy.PARALLEL:
                result = await self._execute_parallel(bug_fix_task)
                
            else:
                result = await self._execute_local_first(bug_fix_task)
            
            # 統計情報の更新
            if result.success:
                self.stats["successful_fixes"] += 1
            else:
                self.stats["failed_fixes"] += 1
            
            execution_time = (datetime.now() - start_time).total_seconds()
            self._update_avg_execution_time(execution_time)
            
            # 履歴に追加
            self.fix_history.append({
                "task_id": task_id,
                "timestamp": datetime.now().isoformat(),
                "strategy": selected_strategy.value,
                "success": result.success,
                "execution_time": execution_time,
                "agent_used": result.agent_used if hasattr(result, 'agent_used') else "unknown"
            })
            
            logger.info(f"{'✅' if result.success else '❌'} 修正{'成功' if result.success else '失敗'}: {task_id} ({execution_time:.2f}秒)")
            
            return result
            
        except Exception as e:
            logger.error(f"💥 修正実行エラー: {e}", exc_info=True)
            self.stats["failed_fixes"] += 1
            
            return FixResult(
                task_id=task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=(datetime.now() - start_time).total_seconds(),
                error_message=str(e)
            )
    
    async def _select_adaptive_strategy(self, error_context: ErrorContextModel) -> FixStrategy:
        """
        エラーコンテキストに基づいて適応的に戦略を選択
        
        Args:
            error_context: エラーコンテキスト
            
        Returns:
            FixStrategy: 選択された戦略
        """
        # エラー分類
        classification = self.error_classifier.classify(error_context)
        
        complexity = classification.get("complexity", "medium")
        error_type = classification.get("error_type", "unknown")
        confidence = classification.get("confidence", 0.5)
        
        logger.info(f"📊 エラー分類: 複雑度={complexity}, タイプ={error_type}, 信頼度={confidence:.2f}")
        
        # 複雑度に基づく戦略選択
        if complexity == "simple":
            # 単純なエラーはローカルで迅速に処理
            return FixStrategy.LOCAL_FIRST
            
        elif complexity == "medium":
            # 中程度の複雑さはローカル優先、失敗時クラウド
            if confidence > 0.7:
                return FixStrategy.LOCAL_FIRST
            else:
                return FixStrategy.CLOUD_FIRST
                
        else:  # complex
            # 複雑なエラーは最初からクラウド
            if error_type in ["design_flaw", "architectural", "multi_file"]:
                return FixStrategy.CLOUD_ONLY
            else:
                return FixStrategy.CLOUD_FIRST
    
    async def _execute_local_only(self, bug_fix_task: BugFixTask) -> FixResult:
        """ローカルのみで実行"""
        logger.info("💻 ローカル修正実行")
        self.stats["local_fixes"] += 1
        result = await self.local_agent.execute_bug_fix_task(bug_fix_task)
        result.agent_used = "local"
        return result
    
    async def _execute_cloud_only(self, bug_fix_task: BugFixTask) -> FixResult:
        """クラウドのみで実行"""
        logger.info("☁️ クラウド修正実行")
        self.stats["cloud_fixes"] += 1
        result = await self.cloud_agent.execute_bug_fix_task(bug_fix_task)
        result.agent_used = "cloud"
        return result
    
    async def _execute_local_first(self, bug_fix_task: BugFixTask) -> FixResult:
        """ローカル優先、失敗時クラウドにフォールバック"""
        logger.info("💻 ローカル修正を試行")
        self.stats["local_fixes"] += 1
        
        local_result = await self.local_agent.execute_bug_fix_task(bug_fix_task)
        
        if local_result.success and local_result.confidence_score >= 0.7:
            logger.info("✅ ローカル修正成功")
            local_result.agent_used = "local"
            return local_result
        
        logger.warning("⚠️ ローカル修正不十分、クラウドにフォールバック")
        logger.info("☁️ クラウド修正実行")
        self.stats["cloud_fixes"] += 1
        self.stats["hybrid_fixes"] += 1
        
        cloud_result = await self.cloud_agent.execute_bug_fix_task(bug_fix_task)
        cloud_result.agent_used = "hybrid_local_then_cloud"
        
        return cloud_result
    
    async def _execute_cloud_first(self, bug_fix_task: BugFixTask) -> FixResult:
        """クラウド優先、失敗時ローカルにフォールバック"""
        logger.info("☁️ クラウド修正を試行")
        self.stats["cloud_fixes"] += 1
        
        cloud_result = await self.cloud_agent.execute_bug_fix_task(bug_fix_task)
        
        if cloud_result.success:
            logger.info("✅ クラウド修正成功")
            cloud_result.agent_used = "cloud"
            return cloud_result
        
        logger.warning("⚠️ クラウド修正失敗、ローカルにフォールバック")
        logger.info("💻 ローカル修正実行")
        self.stats["local_fixes"] += 1
        self.stats["hybrid_fixes"] += 1
        
        local_result = await self.local_agent.execute_bug_fix_task(bug_fix_task)
        local_result.agent_used = "hybrid_cloud_then_local"
        
        return local_result
    
    async def _execute_parallel(self, bug_fix_task: BugFixTask) -> FixResult:
        """ローカルとクラウドを並列実行し、最良の結果を選択"""
        logger.info("🔀 並列修正実行（ローカル & クラウド）")
        self.stats["local_fixes"] += 1
        self.stats["cloud_fixes"] += 1
        self.stats["hybrid_fixes"] += 1
        
        # 並列実行
        results = await asyncio.gather(
            self.local_agent.execute_bug_fix_task(bug_fix_task),
            self.cloud_agent.execute_bug_fix_task(bug_fix_task),
            return_exceptions=True
        )
        
        local_result, cloud_result = results
        
        # エラーハンドリング
        if isinstance(local_result, Exception):
            logger.error(f"❌ ローカル並列実行エラー: {local_result}")
            local_result = None
        
        if isinstance(cloud_result, Exception):
            logger.error(f"❌ クラウド並列実行エラー: {cloud_result}")
            cloud_result = None
        
        # 最良の結果を選択
        best_result = self._select_best_result(local_result, cloud_result)
        
        if best_result:
            best_result.agent_used = "parallel"
            logger.info(f"✅ 並列実行完了、最良結果を選択（エージェント={best_result.agent_used}）")
            return best_result
        else:
            # 両方失敗
            logger.error("❌ 並列実行失敗（両エージェント失敗）")
            return FixResult(
                task_id=bug_fix_task.task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=0.0,
                error_message="Both local and cloud agents failed",
                agent_used="parallel_failed"
            )
    
    def _select_best_result(
        self, 
        local_result: Optional[FixResult], 
        cloud_result: Optional[FixResult]
    ) -> Optional[FixResult]:
        """
        2つの結果から最良のものを選択
        
        Args:
            local_result: ローカル結果
            cloud_result: クラウド結果
            
        Returns:
            Optional[FixResult]: 最良の結果
        """
        # どちらかがNoneの場合
        if local_result is None:
            return cloud_result
        if cloud_result is None:
            return local_result
        
        # 両方成功の場合、信頼度で比較
        if local_result.success and cloud_result.success:
            local_score = local_result.confidence_score or 0.5
            cloud_score = cloud_result.confidence_score or 0.5
            
            if cloud_score > local_score:
                logger.info(f"☁️ クラウド結果を選択（信頼度: {cloud_score:.2f} > {local_score:.2f}）")
                return cloud_result
            else:
                logger.info(f"💻 ローカル結果を選択（信頼度: {local_score:.2f} >= {cloud_score:.2f}）")
                return local_result
        
        # どちらか一方のみ成功
        if local_result.success:
            logger.info("💻 ローカル結果を選択（ローカルのみ成功）")
            return local_result
        if cloud_result.success:
            logger.info("☁️ クラウド結果を選択（クラウドのみ成功）")
            return cloud_result
        
        # 両方失敗の場合、信頼度が高い方
        local_score = local_result.confidence_score or 0.0
        cloud_score = cloud_result.confidence_score or 0.0
        
        return cloud_result if cloud_score > local_score else local_result
    
    def _update_avg_execution_time(self, execution_time: float):
        """平均実行時間を更新"""
        total = self.stats["total_tasks"]
        current_avg = self.stats["avg_execution_time"]
        self.stats["avg_execution_time"] = (current_avg * (total - 1) + execution_time) / total
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_tasks"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_tasks"]
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "local_agent_stats": self.local_agent.get_stats(),
            "cloud_agent_stats": self.cloud_agent.get_stats()
        }
    
    def print_stats(self):
        """統計情報を表示"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("📊 ハイブリッド修正オーケストレーター 統計情報")
        print("=" * 80)
        print(f"総タスク数: {stats['total_tasks']}")
        print(f"成功数: {stats['successful_fixes']} ({stats['success_rate']:.1%})")
        print(f"失敗数: {stats['failed_fixes']}")
        print(f"平均実行時間: {stats['avg_execution_time']:.2f}秒")
        print(f"\nローカル修正: {stats['local_fixes']}回")
        print(f"クラウド修正: {stats['cloud_fixes']}回")
        print(f"ハイブリッド修正: {stats['hybrid_fixes']}回")
        print("\n戦略使用状況:")
        for strategy, count in stats['strategy_usage'].items():
            print(f"  - {strategy}: {count}回")
        print("=" * 80 + "\n")

#local_fix_agent.py
# local_fix_agent.py
"""
ローカル修正エージェント
ローカルAIまたはルールベースで迅速な修正を実行
"""

import asyncio
import logging
import re
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

from data_models import BugFixTask, FixResult, ErrorContextModel

logger = logging.getLogger(__name__)


class LocalFixAgent:
    """
    ローカル修正エージェント
    
    特徴:
    - 迅速な処理（ローカルAI or ルールベース）
    - 簡易エラーに特化
    - オフライン動作可能
    - コスト効率が高い
    """
    
    def __init__(
        self,
        command_monitor,
        wp_tester=None,
        use_local_ai: bool = True,
        ai_chat_agent=None  # browser_ai_chat_agent経由でGemini/DeepSeek
    ):
        """
        初期化
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_tester: WordPressTester
            use_local_ai: ローカルAI使用フラグ
            ai_chat_agent: AIチャットエージェント
        """
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        self.use_local_ai = use_local_ai
        self.ai_chat = ai_chat_agent
        
        # バックアップディレクトリ
        self.backup_dir = Path("./backups/local_fix")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # 統計情報
        self.stats = {
            "total_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0,
            "rule_based_fixes": 0,
            "ai_based_fixes": 0
        }
        
        # ルールベース修正パターン
        self._init_fix_patterns()
        
        logger.info(f"✅ LocalFixAgent 初期化完了 (AI使用={'有効' if use_local_ai else '無効'})")
    
    def _init_fix_patterns(self):
        """修正パターンを初期化"""
        self.fix_patterns = {
            # インポートエラー
            "ImportError": self._fix_import_error,
            "ModuleNotFoundError": self._fix_module_not_found,
            
            # 構文エラー
            "SyntaxError": self._fix_syntax_error,
            "IndentationError": self._fix_indentation_error,
            
            # 属性エラー
            "AttributeError": self._fix_attribute_error,
            
            # 名前エラー
            "NameError": self._fix_name_error,
            
            # タイプエラー
            "TypeError": self._fix_type_error,
            
            # キーエラー
            "KeyError": self._fix_key_error,
        }
    
    async def execute_bug_fix_task(self, bug_fix_task: BugFixTask) -> FixResult:
        """
        バグ修正タスクを実行（ローカル処理）
        
        Args:
            bug_fix_task: バグ修正タスク
            
        Returns:
            FixResult: 修正結果
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        try:
            logger.info("=" * 60)
            logger.info(f"💻 ローカルバグ修正タスク実行: {task_id}")
            logger.info("=" * 60)
            
            self.stats["total_fixes"] += 1
            
            error_context = bug_fix_task.error_context
            error_type = error_context.error_type
            
            # 1. ルールベース修正を試行
            if error_type in self.fix_patterns:
                logger.info(f"🔧 ルールベース修正を試行: {error_type}")
                rule_result = await self._try_rule_based_fix(bug_fix_task)
                
                if rule_result['success']:
                    self.stats["successful_fixes"] += 1
                    self.stats["rule_based_fixes"] += 1
                    
                    execution_time = (datetime.now() - start_time).total_seconds()
                    logger.info(f"✅ ルールベース修正成功: {task_id} ({execution_time:.2f}秒)")
                    
                    return FixResult(
                        task_id=task_id,
                        success=True,
                        modified_files=bug_fix_task.target_files,
                        generated_code=rule_result['code'],
                        test_passed=True,
                        execution_time=execution_time,
                        confidence_score=0.9,
                        reasoning="Rule-based fix applied successfully"
                    )
            
            # 2. ローカルAI修正を試行
            if self.use_local_ai and self.ai_chat:
                logger.info("🤖 ローカルAI修正を試行")
                ai_result = await self._try_ai_based_fix(bug_fix_task)
                
                if ai_result['success']:
                    self.stats["successful_fixes"] += 1
                    self.stats["ai_based_fixes"] += 1
                    
                    execution_time = (datetime.now() - start_time).total_seconds()
                    logger.info(f"✅ AI修正成功: {task_id} ({execution_time:.2f}秒)")
                    
                    return FixResult(
                        task_id=task_id,
                        success=True,
                        modified_files=bug_fix_task.target_files,
                        generated_code=ai_result['code'],
                        test_passed=ai_result.get('test_passed', False),
                        execution_time=execution_time,
                        confidence_score=ai_result.get('confidence', 0.7),
                        reasoning=ai_result.get('reasoning', '')
                    )
            
            # 3. 修正失敗
            self.stats["failed_fixes"] += 1
            execution_time = (datetime.now() - start_time).total_seconds()
            
            logger.warning(f"⚠️ ローカル修正失敗: {task_id}")
            
            return FixResult(
                task_id=task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=execution_time,
                confidence_score=0.0,
                error_message="No applicable fix found locally"
            )
            
        except Exception as e:
            logger.error(f"💥 ローカル修正エラー: {e}", exc_info=True)
            self.stats["failed_fixes"] += 1
            
            return FixResult(
                task_id=task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=(datetime.now() - start_time).total_seconds(),
                error_message=str(e)
            )
    
    async def _try_rule_based_fix(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """ルールベース修正を試行"""
        error_context = bug_fix_task.error_context
        error_type = error_context.error_type
        
        fix_function = self.fix_patterns.get(error_type)
        if not fix_function:
            return {"success": False, "error": "No fix pattern available"}
        
        try:
            fixed_code = await fix_function(error_context)
            
            if fixed_code:
                # バックアップ作成
                await self._create_backup(bug_fix_task.target_files)
                
                # 修正適用
                await self._apply_fix(bug_fix_task.target_files[0], fixed_code)
                
                return {
                    "success": True,
                    "code": fixed_code
                }
            else:
                return {"success": False, "error": "Fix generation failed"}
                
        except Exception as e:
            logger.error(f"❌ ルールベース修正エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _try_ai_based_fix(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """AI修正を試行（ローカルAI経由）"""
        if not self.ai_chat:
            return {"success": False, "error": "AI agent not available"}
        
        try:
            # 修正プロンプト構築
            prompt = self._build_fix_prompt(bug_fix_task.error_context)
            
            # AIに送信
            ai_response = await self.ai_chat.send_prompt_and_wait(prompt)
            
            if not ai_response or "error" in ai_response:
                return {"success": False, "error": "AI response error"}
            
            # コードブロック抽出
            code = self._extract_code_block(ai_response.get("content", ""))
            
            if code:
                # バックアップ作成
                await self._create_backup(bug_fix_task.target_files)
                
                # 修正適用
                await self._apply_fix(bug_fix_task.target_files[0], code)
                
                return {
                    "success": True,
                    "code": code,
                    "confidence": 0.7,
                    "reasoning": "AI-generated fix"
                }
            else:
                return {"success": False, "error": "No code block found in AI response"}
                
        except Exception as e:
            logger.error(f"❌ AI修正エラー: {e}")
            return {"success": False, "error": str(e)}
    
    def _build_fix_prompt(self, error_context: ErrorContextModel) -> str:
        """修正プロンプトを構築"""
        return f"""以下のPythonエラーを修正してください。

エラータイプ: {error_context.error_type}
エラーメッセージ: {error_context.error_message}
ファイル: {error_context.file_path}:{error_context.line_number}

周辺コード:
```python
{error_context.surrounding_code}
```

修正後の完全なコードをPythonコードブロックで返してください。"""
    
    def _extract_code_block(self, text: str) -> Optional[str]:
        """テキストからコードブロックを抽出"""
        pattern = r'```python\n(.*?)\n```'
        match = re.search(pattern, text, re.DOTALL)
        return match.group(1) if match else None
    
    # ========================================
    # ルールベース修正関数群
    # ========================================
    
    async def _fix_import_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """インポートエラーを修正"""
        error_msg = error_context.error_message
        
        # "cannot import name 'X' from 'Y'"パターン
        match = re.search(r"cannot import name '(\w+)' from '([\w.]+)'", error_msg)
        if match:
            name, module = match.groups()
            
            # コード取得
            code = error_context.surrounding_code or ""
            
            # インポート文を修正
            fixed_code = re.sub(
                rf'from {module} import .*{name}.*',
                f'# Fixed: {name} not available in {module}\n# from {module} import {name}',
                code
            )
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_module_not_found(self, error_context: ErrorContextModel) -> Optional[str]:
        """モジュール未検出エラーを修正"""
        error_msg = error_context.error_message
        
        # "No module named 'X'"パターン
        match = re.search(r"No module named '([\w.]+)'", error_msg)
        if match:
            module = match.group(1)
            
            code = error_context.surrounding_code or ""
            
            # インポート文をコメントアウト
            fixed_code = re.sub(
                rf'import {module}',
                f'# import {module}  # Module not found',
                code
            )
            fixed_code = re.sub(
                rf'from {module} import',
                f'# from {module} import  # Module not found',
                fixed_code
            )
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_syntax_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """構文エラーを修正"""
        code = error_context.surrounding_code or ""
        line_no = error_context.line_number
        
        lines = code.split('\n')
        if line_no and 0 < line_no <= len(lines):
            error_line = lines[line_no - 1]
            
            # よくある構文エラーパターン
            fixes = [
                (r':\s*$', ':  # Fixed missing colon'),
                (r'\)\s*$', ')  # Fixed missing parenthesis'),
                (r']\s*$', ']  # Fixed missing bracket'),
            ]
            
            for pattern, replacement in fixes:
                if re.search(pattern, error_line):
                    lines[line_no - 1] = re.sub(pattern, replacement, error_line)
                    return '\n'.join(lines)
        
        return None
    
    async def _fix_indentation_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """インデントエラーを修正"""
        code = error_context.surrounding_code or ""
        
        # タブをスペースに統一
        fixed_code = code.replace('\t', '    ')
        
        return fixed_code if fixed_code != code else None
    
    async def _fix_attribute_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """属性エラーを修正"""
        error_msg = error_context.error_message
        
        # "'X' object has no attribute 'Y'"パターン
        match = re.search(r"'(\w+)' object has no attribute '(\w+)'", error_msg)
        if match:
            obj_type, attr = match.groups()
            
            code = error_context.surrounding_code or ""
            
            # 属性アクセスをhasattr()でラップ
            pattern = rf'(\w+)\.{attr}'
            replacement = rf"getattr(\1, '{attr}', None)  # Fixed: safe attribute access"
            
            fixed_code = re.sub(pattern, replacement, code)
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_name_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """名前エラーを修正"""
        error_msg = error_context.error_message
        
        # "name 'X' is not defined"パターン
        match = re.search(r"name '(\w+)' is not defined", error_msg)
        if match:
            var_name = match.group(1)
            
            code = error_context.surrounding_code or ""
            
            # 変数を定義
            lines = code.split('\n')
            lines.insert(0, f"{var_name} = None  # Fixed: undefined variable")
            
            return '\n'.join(lines)
        
        return None
    
    async def _fix_type_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """タイプエラーを修正"""
        # 簡易的な対応: Noneチェックを追加
        code = error_context.surrounding_code or ""
        
        # NoneTypeエラーの場合
        if "NoneType" in error_context.error_message:
            # 最初の関数/メソッド呼び出しにNoneチェックを追加
            pattern = r'(\w+)\('
            replacement = r'(\1 if \1 is not None else lambda *a, **k: None)('
            
            fixed_code = re.sub(pattern, replacement, code, count=1)
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_key_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """キーエラーを修正"""
        error_msg = error_context.error_message
        
        # KeyError: 'X'パターン
        match = re.search(r"KeyError: '(\w+)'", error_msg)
        if match:
            key = match.group(1)
            
            code = error_context.surrounding_code or ""
            
            # 辞書アクセスを.get()に変更
            pattern = rf'\[[\'"]{key}[\'"]\]'
            replacement = rf".get('{key}', None)  # Fixed: safe key access"
            
            fixed_code = re.sub(pattern, replacement, code)
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    # ========================================
    # ユーティリティ
    # ========================================
    
    async def _create_backup(self, target_files: List[str]) -> Path:
        """バックアップを作成"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_subdir = self.backup_dir / timestamp
        backup_subdir.mkdir(parents=True, exist_ok=True)
        
        for file_path in target_files:
            src = Path(file_path)
            if src.exists():
                dst = backup_subdir / src.name
                await asyncio.to_thread(dst.write_text, src.read_text(encoding='utf-8'))
        
        return backup_subdir
    
    async def _apply_fix(self, file_path: str, code: str):
        """修正を適用"""
        target = Path(file_path)
        await asyncio.to_thread(target.write_text, code, encoding='utf-8')
        logger.info(f"✅ 修正適用: {file_path}")
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_fixes"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_fixes"]
        
        return {
            **self.stats,
            "success_rate": success_rate
        }

#log_analyzer.py
"""
LogAnalyzer - ログ分析と異常検知エージェント

ログパターンの分析、異常なログの検出、エラーの根本原因分析、
ログ集約とフィルタリング、トレンド分析を提供する。
"""

import re
import json
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import Counter, deque
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class LogLevel(Enum):
    """ログレベル"""
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50


@dataclass
class LogEntry:
    """ログエントリ"""
    timestamp: datetime
    level: LogLevel
    message: str
    source: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp.isoformat(),
            "level": self.level.name,
            "message": self.message,
            "source": self.source,
            "metadata": self.metadata
        }


@dataclass
class LogPattern:
    """ログパターン"""
    pattern: str
    regex: re.Pattern
    level: LogLevel
    frequency: int = 0
    first_seen: datetime = field(default_factory=datetime.now)
    last_seen: datetime = field(default_factory=datetime.now)
    examples: List[str] = field(default_factory=list)
    
    def matches(self, message: str) -> bool:
        return self.regex.search(message) is not None


@dataclass
class Anomaly:
    """異常検知結果"""
    anomaly_type: str
    severity: str  # low, medium, high, critical
    description: str
    timestamp: datetime
    affected_logs: List[LogEntry]
    recommendation: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "anomaly_type": self.anomaly_type,
            "severity": self.severity,
            "description": self.description,
            "timestamp": self.timestamp.isoformat(),
            "affected_logs_count": len(self.affected_logs),
            "recommendation": self.recommendation
        }


class LogAnalyzerAgent:
    """
    ログ分析と異常検知エージェント
    
    主な機能:
    1. ログパターンの学習と分析
    2. 異常なログの自動検出
    3. エラーの根本原因分析
    4. ログ集約とフィルタリング
    5. トレンド分析とレポート生成
    """
    
    def __init__(self, 
                 max_log_entries: int = 10000,
                 anomaly_threshold: float = 3.0):
        self.max_log_entries = max_log_entries
        self.anomaly_threshold = anomaly_threshold  # 標準偏差の倍数
        
        # ログストレージ
        self.log_entries: deque = deque(maxlen=max_log_entries)
        
        # パターン管理
        self.known_patterns: List[LogPattern] = []
        self.error_patterns: Dict[str, LogPattern] = {}
        
        # 統計情報
        self.stats = {
            "total_logs": 0,
            "by_level": Counter(),
            "by_source": Counter(),
            "anomalies_detected": 0
        }
        
        # 異常検知
        self.detected_anomalies: List[Anomaly] = []
        
        # エラーパターンの初期化
        self._initialize_error_patterns()
        
        logger.info("LogAnalyzerAgent initialized")
    
    def _initialize_error_patterns(self):
        """一般的なエラーパターンを初期化"""
        patterns = [
            (r"(?i)connection.*(?:refused|timeout|failed)", LogLevel.ERROR, "Connection issues"),
            (r"(?i)out of memory|memory.*overflow", LogLevel.CRITICAL, "Memory issues"),
            (r"(?i)permission denied|access denied", LogLevel.ERROR, "Permission issues"),
            (r"(?i)file not found|no such file", LogLevel.ERROR, "File not found"),
            (r"(?i)syntax error|parse error", LogLevel.ERROR, "Syntax errors"),
            (r"(?i)null pointer|null reference", LogLevel.ERROR, "Null pointer errors"),
            (r"(?i)deadlock|race condition", LogLevel.CRITICAL, "Concurrency issues"),
            (r"(?i)stack overflow|recursion", LogLevel.CRITICAL, "Stack issues"),
            (r"(?i)database.*error|sql.*error", LogLevel.ERROR, "Database errors"),
            (r"(?i)authentication failed|unauthorized", LogLevel.WARNING, "Auth issues")
        ]
        
        for pattern_str, level, description in patterns:
            pattern = LogPattern(
                pattern=description,
                regex=re.compile(pattern_str),
                level=level
            )
            self.error_patterns[description] = pattern
    
    def parse_log_line(self, line: str, source: str = "unknown") -> Optional[LogEntry]:
        """
        ログ行をパース
        
        標準的なログフォーマットに対応:
        - [YYYY-MM-DD HH:MM:SS] LEVEL: message
        - YYYY-MM-DD HH:MM:SS - LEVEL - message
        - 2024-01-01T12:00:00Z [LEVEL] message
        """
        # タイムスタンプパターン
        timestamp_patterns = [
            r'\[(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\]',
            r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})',
            r'(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)'
        ]
        
        timestamp = None
        for pattern in timestamp_patterns:
            match = re.search(pattern, line)
            if match:
                try:
                    timestamp_str = match.group(1)
                    # ISO形式を試す
                    if 'T' in timestamp_str:
                        timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                    else:
                        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
                    break
                except:
                    continue
        
        if timestamp is None:
            timestamp = datetime.now()
        
        # ログレベルの抽出
        level = LogLevel.INFO
        level_match = re.search(r'\b(DEBUG|INFO|WARNING|WARN|ERROR|CRITICAL|FATAL)\b', line, re.IGNORECASE)
        if level_match:
            level_str = level_match.group(1).upper()
            if level_str == 'WARN':
                level_str = 'WARNING'
            elif level_str == 'FATAL':
                level_str = 'CRITICAL'
            level = LogLevel[level_str]
        
        # メッセージの抽出（ログレベルの後ろの部分）
        if level_match:
            message = line[level_match.end():].strip()
            # コロンやハイフンの後ろを取得
            message = re.sub(r'^[\s:\-]+', '', message)
        else:
            message = line.strip()
        
        return LogEntry(
            timestamp=timestamp,
            level=level,
            message=message,
            source=source
        )
    
    def ingest_log(self, log_entry: LogEntry):
        """ログエントリを取り込む"""
        self.log_entries.append(log_entry)
        
        # 統計を更新
        self.stats["total_logs"] += 1
        self.stats["by_level"][log_entry.level.name] += 1
        self.stats["by_source"][log_entry.source] += 1
        
        # パターンマッチング
        self._match_patterns(log_entry)
        
        # 異常検知
        if log_entry.level in [LogLevel.ERROR, LogLevel.CRITICAL]:
            self._detect_anomalies()
    
    def ingest_log_file(self, filepath: str, source: Optional[str] = None):
        """ログファイルを読み込む"""
        if source is None:
            source = Path(filepath).name
        
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    line = line.strip()
                    if line:
                        log_entry = self.parse_log_line(line, source)
                        if log_entry:
                            self.ingest_log(log_entry)
            
            logger.info(f"Ingested log file: {filepath} ({self.stats['total_logs']} total logs)")
        except Exception as e:
            logger.error(f"Failed to ingest log file {filepath}: {e}")
    
    def _match_patterns(self, log_entry: LogEntry):
        """ログエントリをパターンとマッチング"""
        for pattern_name, pattern in self.error_patterns.items():
            if pattern.matches(log_entry.message):
                pattern.frequency += 1
                pattern.last_seen = log_entry.timestamp
                
                # サンプルを保存（最大5件）
                if len(pattern.examples) < 5:
                    pattern.examples.append(log_entry.message[:100])
    
    def _detect_anomalies(self):
        """異常を検出"""
        recent_window = timedelta(minutes=5)
        recent_cutoff = datetime.now() - recent_window
        
        # 最近のエラーログを取得
        recent_errors = [
            entry for entry in self.log_entries
            if entry.timestamp >= recent_cutoff and entry.level >= LogLevel.ERROR
        ]
        
        if len(recent_errors) >= 10:  # 5分間に10件以上のエラー
            anomaly = Anomaly(
                anomaly_type="high_error_rate",
                severity="high",
                description=f"High error rate detected: {len(recent_errors)} errors in 5 minutes",
                timestamp=datetime.now(),
                affected_logs=recent_errors[-10:],
                recommendation="Investigate recent changes or system issues"
            )
            self.detected_anomalies.append(anomaly)
            self.stats["anomalies_detected"] += 1
            logger.warning(f"Anomaly detected: {anomaly.description}")
    
    def analyze_root_cause(self, error_message: str) -> Dict[str, Any]:
        """
        エラーの根本原因を分析
        
        Args:
            error_message: エラーメッセージ
        
        Returns:
            根本原因分析結果
        """
        # 類似エラーを検索
        similar_errors = []
        for entry in self.log_entries:
            if entry.level >= LogLevel.ERROR:
                similarity = self._calculate_similarity(error_message, entry.message)
                if similarity > 0.7:
                    similar_errors.append((similarity, entry))
        
        # 時系列分析（エラーの前に何が起きたか）
        context_logs = []
        if similar_errors:
            # 最も類似したエラーの前後のログを取得
            _, target_error = max(similar_errors, key=lambda x: x[0])
            target_idx = None
            
            for i, entry in enumerate(self.log_entries):
                if entry == target_error:
                    target_idx = i
                    break
            
            if target_idx is not None:
                # 前後5件のログを取得
                start_idx = max(0, target_idx - 5)
                end_idx = min(len(self.log_entries), target_idx + 1)
                context_logs = list(self.log_entries)[start_idx:end_idx]
        
        # パターンマッチング
        matched_pattern = None
        for pattern_name, pattern in self.error_patterns.items():
            if pattern.matches(error_message):
                matched_pattern = pattern_name
                break
        
        return {
            "error_message": error_message,
            "matched_pattern": matched_pattern,
            "similar_errors_count": len(similar_errors),
            "context_logs": [log.to_dict() for log in context_logs],
            "recommendations": self._generate_recommendations(error_message, matched_pattern)
        }
    
    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """テキストの類似度を計算"""
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())
        
        if not words1 or not words2:
            return 0.0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)
    
    def _generate_recommendations(self, 
                                 error_message: str,
                                 pattern: Optional[str]) -> List[str]:
        """エラーに対する推奨事項を生成"""
        recommendations = []
        
        if pattern == "Connection issues":
            recommendations.extend([
                "Check network connectivity",
                "Verify firewall settings",
                "Check if the remote service is running"
            ])
        elif pattern == "Memory issues":
            recommendations.extend([
                "Increase available memory",
                "Check for memory leaks",
                "Optimize resource usage"
            ])
        elif pattern == "Permission issues":
            recommendations.extend([
                "Check file/directory permissions",
                "Verify user has required access rights",
                "Check SELinux or AppArmor policies"
            ])
        elif pattern == "File not found":
            recommendations.extend([
                "Verify file path is correct",
                "Check if file exists",
                "Check file permissions"
            ])
        elif pattern == "Database errors":
            recommendations.extend([
                "Check database connection",
                "Verify SQL syntax",
                "Check database credentials"
            ])
        else:
            recommendations.append("Review the error message and stack trace")
        
        return recommendations
    
    def filter_logs(self,
                   level: Optional[LogLevel] = None,
                   source: Optional[str] = None,
                   time_range: Optional[Tuple[datetime, datetime]] = None,
                   pattern: Optional[str] = None) -> List[LogEntry]:
        """
        ログをフィルタリング
        
        Args:
            level: ログレベルでフィルタ
            source: ソースでフィルタ
            time_range: 時間範囲でフィルタ (start, end)
            pattern: 正規表現パターンでフィルタ
        
        Returns:
            フィルタされたログエントリ
        """
        filtered = list(self.log_entries)
        
        if level is not None:
            filtered = [log for log in filtered if log.level == level]
        
        if source is not None:
            filtered = [log for log in filtered if log.source == source]
        
        if time_range is not None:
            start, end = time_range
            filtered = [log for log in filtered if start <= log.timestamp <= end]
        
        if pattern is not None:
            regex = re.compile(pattern, re.IGNORECASE)
            filtered = [log for log in filtered if regex.search(log.message)]
        
        return filtered
    
    def get_error_trend(self, hours: int = 24) -> Dict[str, List[Tuple[datetime, int]]]:
        """
        エラートレンドを取得
        
        Args:
            hours: 過去何時間分のデータを取得するか
        
        Returns:
            時間ごとのエラーカウント
        """
        cutoff = datetime.now() - timedelta(hours=hours)
        
        # 1時間ごとのバケット
        buckets = {}
        for level in [LogLevel.ERROR, LogLevel.CRITICAL]:
            buckets[level.name] = {}
        
        for entry in self.log_entries:
            if entry.timestamp < cutoff:
                continue
            
            if entry.level not in [LogLevel.ERROR, LogLevel.CRITICAL]:
                continue
            
            # 時間を1時間単位に丸める
            hour_key = entry.timestamp.replace(minute=0, second=0, microsecond=0)
            
            level_buckets = buckets[entry.level.name]
            level_buckets[hour_key] = level_buckets.get(hour_key, 0) + 1
        
        # ソート済みリストに変換
        result = {}
        for level_name, level_buckets in buckets.items():
            result[level_name] = sorted(level_buckets.items())
        
        return result
    
    def get_top_errors(self, limit: int = 10) -> List[Tuple[str, int]]:
        """
        頻繁に発生するエラーパターンを取得
        
        Args:
            limit: 取得する件数
        
        Returns:
            (パターン名, 頻度) のリスト
        """
        patterns_with_freq = [
            (name, pattern.frequency)
            for name, pattern in self.error_patterns.items()
            if pattern.frequency > 0
        ]
        
        patterns_with_freq.sort(key=lambda x: x[1], reverse=True)
        
        return patterns_with_freq[:limit]
    
    def generate_summary_report(self) -> Dict[str, Any]:
        """サマリーレポートを生成"""
        total = self.stats["total_logs"]
        
        # ログレベル別の割合
        level_distribution = {}
        for level_name, count in self.stats["by_level"].items():
            level_distribution[level_name] = {
                "count": count,
                "percentage": round(count / total * 100, 2) if total > 0 else 0
            }
        
        # 最近の異常
        recent_anomalies = [
            anomaly.to_dict()
            for anomaly in self.detected_anomalies[-5:]
        ]
        
        # エラーパターン統計
        top_errors = self.get_top_errors(5)
        
        return {
            "summary": {
                "total_logs": total,
                "time_range": {
                    "start": min(log.timestamp for log in self.log_entries).isoformat() if self.log_entries else None,
                    "end": max(log.timestamp for log in self.log_entries).isoformat() if self.log_entries else None
                },
                "anomalies_detected": self.stats["anomalies_detected"]
            },
            "level_distribution": level_distribution,
            "top_errors": [
                {"pattern": name, "frequency": freq}
                for name, freq in top_errors
            ],
            "recent_anomalies": recent_anomalies,
            "sources": dict(self.stats["by_source"])
        }
    
    def export_analysis(self, filepath: str):
        """分析結果をファイルにエクスポート"""
        report = self.generate_summary_report()
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Analysis exported to {filepath}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """統計情報を取得"""
        return {
            **self.stats,
            "unique_sources": len(self.stats["by_source"]),
            "patterns_matched": sum(1 for p in self.error_patterns.values() if p.frequency > 0),
            "avg_logs_per_source": self.stats["total_logs"] / len(self.stats["by_source"]) if self.stats["by_source"] else 0
        }


# 使用例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    analyzer = LogAnalyzerAgent()
    
    # サンプルログを生成
    sample_logs = [
        "[2024-01-01 10:00:00] INFO: Application started",
        "[2024-01-01 10:01:00] DEBUG: Processing request",
        "[2024-01-01 10:02:00] ERROR: Connection timeout to database",
        "[2024-01-01 10:03:00] WARNING: Retry attempt 1",
        "[2024-01-01 10:04:00] ERROR: Connection timeout to database",
        "[2024-01-01 10:05:00] CRITICAL: Database connection failed after 3 retries",
        "[2024-01-01 10:06:00] INFO: Switching to backup database",
        "[2024-01-01 10:07:00] ERROR: File not found: /tmp/data.csv",
        "[2024-01-01 10:08:00] ERROR: Permission denied for /var/log/app.log",
    ]
    
    # ログを取り込む
    for log_line in sample_logs:
        entry = analyzer.parse_log_line(log_line, "test_app")
        analyzer.ingest_log(entry)
    
    # サマリーレポート
    print("\n=== Summary Report ===")
    report = analyzer.generate_summary_report()
    print(json.dumps(report, indent=2))
    
    # エラーの根本原因分析
    print("\n=== Root Cause Analysis ===")
    root_cause = analyzer.analyze_root_cause("Connection timeout to database")
    print(json.dumps(root_cause, indent=2))
    
    # 統計情報
    print("\n=== Statistics ===")
    stats = analyzer.get_statistics()
    print(json.dumps(stats, indent=2))
    
    # トップエラー
    print("\n=== Top Errors ===")
    for pattern, freq in analyzer.get_top_errors():
        print(f"{pattern}: {freq} occurrences")


#main_automator.py
import asyncio
import time
import json
from pathlib import Path
from typing import List, Dict, Optional
import logging
from datetime import datetime

# ===== 最優先: ログ設定を他のインポートより前に実行 =====
# config_utilsをインポートすると自動的にログ設定が実行される
from config_utils import config, ErrorHandler, FileNameGenerator, PathManager

# これで他のモジュールをインポート
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class GeminiAutomator:
    """メインのGemini自動化クラス（拡張版:画像・テキスト両対応・ローカル保存・DeepSeek対応）"""
    
    def __init__(self, pc_id: int = None, auto_detect_pc_id: bool = True):
        """
        初期化
        
        Args:
            pc_id: 明示的に指定するPC_ID（Noneの場合は自動検出）
            auto_detect_pc_id: Trueの場合、スプレッドシートのB12セルからPC_IDを読み取る
        """
        # まず、サービスアカウントファイルでシートマネージャーを初期化
        default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
        service_account_file = default_service_account if Path(default_service_account).exists() else None
        
        self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
        # PC_IDの決定（優先順位）
        # 1. 明示的に指定されたpc_id
        # 2. スプレッドシートのB12セルから読み取り（auto_detect_pc_id=Trueの場合）
        # 3. 環境変数
        # 4. デフォルト値(1)
        if pc_id is not None:
            self.pc_id = pc_id
            logger.info(f"PC_IDを明示的指定から取得: {self.pc_id}")
        elif auto_detect_pc_id:
            try:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_IDをスプレッドシート(B12)から取得: {self.pc_id}")
            except Exception as e:
                logger.warning(f"スプレッドシートからのPC_ID取得に失敗: {e}")
                import os
                self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
                logger.info(f"PC_IDを環境変数/デフォルトから取得: {self.pc_id}")
        else:
            import os
            self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
            logger.info(f"PC_IDを環境変数/デフォルトから取得: {self.pc_id}")
        
        # PC固有の設定を読み込み
        self.load_pc_configuration()
        self.mode = config.GENERATION_MODE or "image"
        self.service = config.SERVICE_TYPE or "google"
        
        # ダウンロードフォルダの設定（スプレッドシートB5/B6から取得）
        if self.mode == "text":
            # テキストモードの場合はB6の設定を使用
            if config.DOWNLOAD_TEXT_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_TEXT_FOLDER)
                logger.info(f"テキスト保存先（B6から取得）: {self.download_folder}")
            else:
                # フォールバック: ローカル一時フォルダ
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_texts"))
                logger.warning(f"B6が空のため、デフォルトフォルダを使用: {self.download_folder}")
        else:
            # 画像モードの場合はB5の設定を使用
            if config.DOWNLOAD_IMAGE_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_IMAGE_FOLDER)
                logger.info(f"画像保存先（B5から取得）: {self.download_folder}")
            else:
                # フォールバック: ローカル一時フォルダ
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_images"))
                logger.warning(f"B5が空のため、デフォルトフォルダを使用: {self.download_folder}")
        
        self.browser_controller = BrowserController(self.download_folder, self.mode, self.service)
        self.credentials: Optional[Dict[str, str]] = None
        self.prompts: List[str] = []
        self.results: List[Dict] = []
        self.generate_unique_filename = lambda idx: FileNameGenerator.generate_unique_filename(idx, mode=self.mode)
    
    def load_pc_configuration(self) -> None:
        """PC固有の設定を読み込み"""
        try:
            logger.info(f"PC_ID={self.pc_id} の設定を読み込み中...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.SERVICE_ACCOUNT_FILE = settings.get('service_account_file')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = settings.get('generation_mode', 'image')
            config.TEXT_FORMAT = settings.get('text_format', 'txt')
            config.DOWNLOAD_IMAGE_FOLDER = settings.get('download_image_folder')
            config.DOWNLOAD_TEXT_FOLDER = settings.get('download_text_folder')
            config.AGENT_OUTPUT_FOLDER = settings.get('agent_output_folder')
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            # サービスタイプの取得
            service_type = settings.get('service_type', '').strip().lower()
            if service_type in ['deepseek', 'google', 'gemini']:
                if service_type == 'gemini':
                    service_type = 'google'
                config.SERVICE_TYPE = service_type
            else:
                config.SERVICE_TYPE = 'google'
        
            logger.info(f"PC_ID={self.pc_id} の設定読み込み完了")
            logger.info(f"  サービス: {config.SERVICE_TYPE}")
            logger.info(f"  モード: {config.GENERATION_MODE}")
            logger.info(f"  テキスト形式: {config.TEXT_FORMAT}")
            logger.info(f"  Browser Data: {config.BROWSER_DATA_DIR}")
            logger.info(f"  画像フォルダ (B5): {config.DOWNLOAD_IMAGE_FOLDER}")
            logger.info(f"  テキストフォルダ (B6): {config.DOWNLOAD_TEXT_FOLDER}")
            logger.info(f"  Agent出力先 (B14): {config.AGENT_OUTPUT_FOLDER}")
            logger.info(f"  最大反復回数 (B15): {config.MAX_ITERATIONS}")
            if config.SERVICE_ACCOUNT_FILE and Path(config.SERVICE_ACCOUNT_FILE).exists():
                self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, config.SERVICE_ACCOUNT_FILE)
        except Exception as e:
            ErrorHandler.log_error(e, "PC設定読み込み")
            raise
    
    async def initialize(self) -> None:
        """初期化処理"""
        try:
            logger.info("初期化処理開始...")
            if not self.sheets_manager.validate_sheet_structure():
                raise Exception("Google Sheetsの構造が正しくありません")
            self.credentials = self.sheets_manager.load_credentials_from_sheet(self.pc_id)
            
            # credentialsをbrowser_controllerに渡す
            self.browser_controller.credentials = self.credentials
            
            prompt_sheet_name = "prompt_text" if self.mode == "text" else "prompt_text"
            self.prompts = self.sheets_manager.load_prompts_from_sheet(prompt_sheet_name)
            if not self.prompts:
                raise Exception("処理するプロンプトがありません")
            await self.browser_controller.setup_browser()
            logger.info("初期化処理完了")
        except Exception as e:
            ErrorHandler.log_error(e, "初期化処理")
            raise
    
    async def login_process(self) -> None:
        """ログイン処理（サービス別）"""
        try:
            logger.info("ログイン処理開始...")
            
            if self.service == "deepseek":
                # DeepSeekはGoogleアカウントでログイン
                logger.info("DeepSeekサービスを使用します")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleアカウントにログインしてください（DeepSeek用）")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("Googleログイン完了後、Enterキーを押してください: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ログインが確認できませんが、処理を続行します")
                else:
                    logger.info("既にGoogleアカウントにログイン済みです")
                
                await self.browser_controller.navigate_to_deepseek()
            else:
                # Google/Geminiの場合
                logger.info("Geminiサービスを使用します")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleアカウントにログインが必要です")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("ログイン完了後、Enterキーを押してください: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ログインが確認できませんが、処理を続行します")
                else:
                    logger.info("既にGoogleアカウントにログイン済みです")
                
                await self.browser_controller.navigate_to_gemini()
            
            logger.info("ログイン処理完了")
        except Exception as e:
            ErrorHandler.log_error(e, "ログイン処理")
            raise
    
    async def process_single_prompt_image(self, prompt: str, index: int) -> bool:
        """画像モードでプロンプトを処理"""
        try:
            logger.info(f"\n--- プロンプト {index}/{len(self.prompts)} を処理中（画像モード）---")
            logger.info(f"プロンプト: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'image'
            }
            try:
                await self.browser_controller.send_prompt(prompt)
                if await self.browser_controller.wait_for_image_generation():
                    filename = await self.browser_controller.download_latest_image(index)
                    if filename:
                        result['status'] = 'success'
                        result['filename'] = filename
                        save_path = self.download_folder / filename
                        logger.info(f"プロンプト {index} の処理に成功")
                        logger.info(f"保存先: {save_path}")
                        return True
                    else:
                        result['status'] = 'download_failed'
                        result['error'] = 'ダウンロードに失敗'
                else:
                    result['status'] = 'generation_failed'
                    result['error'] = '画像生成に失敗またはタイムアウト'
            except Exception as e:
                result['status'] = 'error'
                result['error'] = str(e)
                ErrorHandler.log_error(e, f"プロンプト {index} 処理")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"プロンプト {index} 処理")
            return False
        finally:
            self.results.append(result)
    
    async def process_single_prompt_text(self, prompt: str, index: int, max_retries: int = 2) -> bool:
        """テキストモードでプロンプトを処理"""
        try:
            logger.info(f"\n--- プロンプト {index}/{len(self.prompts)} を処理中（テキストモード）---")
            logger.info(f"プロンプト: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'text'
            }
            for attempt in range(1, max_retries + 1):
                try:
                    logger.info(f"試行 {attempt}/{max_retries}")
                    await self.browser_controller.send_prompt(prompt)
                    if await self.browser_controller.wait_for_text_generation():
                        response_text = await self.browser_controller.extract_latest_text_response()
                        if response_text:
                            # フォーマットに応じてファイル名と保存形式を変更
                            text_format = config.TEXT_FORMAT or 'txt'
                            
                            if text_format == 'json':
                                # JSON形式
                                filename = self.generate_unique_filename(index)
                                filename = filename.replace('.txt', '.json')
                                json_data = {"response": response_text}
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        json.dump(json_data, f, ensure_ascii=False, indent=2)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"✅ JSON保存成功: {filename} ({file_size:,} bytes)")
                                        logger.info(f"保存先: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'JSON保存エラー: {str(e)}'
                                    logger.error(f"JSON保存エラー: {e}")
                            else:
                                # TXT形式（デフォルト）
                                filename = self.generate_unique_filename(index)
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        f.write(response_text)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"✅ テキスト保存成功: {filename} ({file_size:,} bytes)")
                                        logger.info(f"保存先: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'テキスト保存エラー: {str(e)}'
                                    logger.error(f"テキスト保存エラー: {e}")
                        else:
                            result['status'] = 'extraction_failed'
                            result['error'] = 'テキスト抽出に失敗'
                    else:
                        result['status'] = 'generation_failed'
                        result['error'] = 'テキスト生成に失敗またはタイムアウト'
                    if attempt < max_retries:
                        logger.info(f"5秒後に再試行します...")
                        await asyncio.sleep(5)
                    else:
                        break
                except Exception as e:
                    result['status'] = 'error'
                    result['error'] = str(e)
                    ErrorHandler.log_error(e, f"プロンプト {index} 処理（試行 {attempt}）")
                    if attempt < max_retries:
                        await asyncio.sleep(5)
                    else:
                        break
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"プロンプト {index} 処理")
            return False
        finally:
            self.results.append(result)
    
    async def run_automation(self) -> None:
        """自動化処理の実行"""
        try:
            logger.info("=== Gemini自動化処理を開始 ===")
            logger.info(f"PC_ID: {self.pc_id}")
            logger.info(f"モード: {self.mode.upper()}")
            logger.info(f"保存先: ローカルフォルダ")
            logger.info(f"保存パス: {self.download_folder.absolute()}")
            await self.initialize()
            await self.login_process()
            if self.browser_controller.page:
                await self.browser_controller.page.screenshot(path="gemini_initial.png")
            successful_count = 0
            failed_prompts = []
            for i, prompt in enumerate(self.prompts, 1):
                try:
                    if self.mode == "text":
                        success = await self.process_single_prompt_text(prompt, i)
                    else:
                        success = await self.process_single_prompt_image(prompt, i)
                    if success:
                        successful_count += 1
                    else:
                        failed_prompts.append(f"{i}: {prompt[:50]}...")
                    if i < len(self.prompts):
                        await asyncio.sleep(8)
                except Exception as e:
                    logger.error(f"プロンプト {i} の処理中にエラー: {e}")
                    failed_prompts.append(f"{i}: {prompt[:50]}... (エラー)")
                    continue
            try:
                self.sheets_manager.save_result_to_sheet(self.results, self.mode)
            except Exception as e:
                logger.warning(f"結果のシート保存に失敗: {e}")
            self.generate_final_report(successful_count, failed_prompts)
        except Exception as e:
            ErrorHandler.log_error(e, "自動化処理の重大なエラー")
            try:
                if self.browser_controller.page:
                    await self.browser_controller.page.screenshot(path="final_error.png")
            except:
                pass
            raise
        finally:
            await self.browser_controller.cleanup()
    
    def generate_final_report(self, successful: int, failed_prompts: list):
        """最終レポートの生成"""
        logger.info(f"\n{'='*50}")
        logger.info("処理完了レポート")
        logger.info(f"{'='*50}")
        logger.info(f"PC_ID: {self.pc_id}")
        logger.info(f"モード: {self.mode.upper()}")
        logger.info(f"成功: {successful}/{len(self.prompts)} 件")
        logger.info(f"失敗: {len(failed_prompts)} 件")
        logger.info(f"成功率: {successful/len(self.prompts)*100:.1f}%")
        logger.info(f"保存先: {self.download_folder.absolute()}")
        if failed_prompts:
            logger.info("\n失敗したプロンプト:")
            for failed in failed_prompts:
                logger.info(f"  - {failed}")

async def main():
    import argparse
    import os
    
    parser = argparse.ArgumentParser(description='Gemini自動生成（ローカル保存版）')
    parser.add_argument('--pc-id', type=int, default=None, help='PC_IDを明示的に指定（指定しない場合はスプレッドシートのB12セルから自動取得）')
    parser.add_argument('--no-auto-detect', action='store_true', help='スプレッドシートからのPC_ID自動取得を無効化')
    args = parser.parse_args()
    
    print("=== Gemini 自動生成スクリプト（ローカル保存版）===")
    if args.pc_id is not None:
        print(f"PC_ID: {args.pc_id} (明示的指定)")
        automator = GeminiAutomator(pc_id=args.pc_id, auto_detect_pc_id=False)
    elif args.no_auto_detect:
        default_pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
        print(f"PC_ID: {default_pc_id} (環境変数/デフォルト)")
        automator = GeminiAutomator(pc_id=default_pc_id, auto_detect_pc_id=False)
    else:
        print("PC_ID: スプレッドシート(B12セル)から自動取得")
        automator = GeminiAutomator(auto_detect_pc_id=True)
    
    try:
        await automator.run_automation()
        print("\n処理が正常に完了しました")
    except KeyboardInterrupt:
        print("\n処理を中断しました")
    except Exception as e:
        print(f"\nエラーが発生しました: {e}")
        logger.error(f"メイン処理エラー: {e}")

if __name__ == "__main__":
    asyncio.run(main())

#main_hybrid_fix.py
# main_hybrid_fix.py
"""
ハイブリッド型自律コード修正システム - メイン実行ファイル
既存のMATaskExecutorと統合
"""
import sys
from pathlib import Path

# プロジェクトルートをパスに追加
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))
import asyncio
import logging
import sys
from typing import Optional, Dict, Any
from pathlib import Path

# 既存システムのインポート
from task_executor.task_executor_ma import MATaskExecutor
from command_monitor_agent import CommandMonitorAgent
from browser_ai_chat_agent import AIChatAgent
from browser_controller import BrowserController

# 新システムのインポート
from fix_agents.hybrid_fix_orchestrator import HybridFixOrchestrator, FixStrategy
from fix_agents.cloud_fix_agent import CloudFixAgent
from fix_agents.error_classifier import ErrorClassifier
from fix_agents.fix_agent import BaseFixAgent
from wp_tester_agent import WPTesterAgent
from github_agent import GitHubAgent
from fix_agents.patch_manager import PatchManager
from cloud_storage_manager import CloudStorageManager

# データモデル
from data_models import BugFixTask, ErrorContextModel, ErrorSeverity, ErrorCategory

# 設定
from config_hybrid import HybridFixConfig

logger = logging.getLogger(__name__)


class HybridFixSystem:
    """
    ハイブリッド修正システムの統合クラス
    
    既存のMATaskExecutorと新しい自律修正システムを統合
    """
    
    def __init__(
        self,
        config: Optional[HybridFixConfig] = None,
        ma_task_executor: Optional[MATaskExecutor] = None
    ):
        """
        初期化
        
        Args:
            config: ハイブリッド修正設定
            ma_task_executor: 既存のタスク実行エンジン
        """
        self.config = config or HybridFixConfig()
        self.ma_executor = ma_task_executor
        
        # 各エージェントの初期化
        self.cmd_monitor = None
        self.browser_controller = None
        self.ai_chat_agent = None
        
        self.local_agent = None
        self.cloud_agent = None
        self.orchestrator = None
        self.wp_tester = None
        self.github_agent = None
        self.patch_manager = None
        self.storage_manager = None
        
        # 統計情報
        self.system_stats = {
            "start_time": None,
            "total_errors_detected": 0,
            "auto_fixed_errors": 0,
            "manual_intervention_required": 0
        }
        
        logger.info("🚀 HybridFixSystem 初期化開始")
    
    async def initialize(self):
        """システムを初期化"""
        try:
            logger.info("=" * 80)
            logger.info("🔧 ハイブリッド修正システム 初期化")
            logger.info("=" * 80)
            
            # 1. 既存システムのコンポーネントを取得
            if self.ma_executor:
                self.cmd_monitor = getattr(self.ma_executor, 'cmd_monitor', None)
                self.browser_controller = getattr(self.ma_executor, 'browser_controller', None)
            
            # CommandMonitorがない場合は新規作成
            if not self.cmd_monitor:
                self.cmd_monitor = CommandMonitorAgent()
                logger.info("✅ CommandMonitorAgent 新規作成")
            
            # 2. ストレージマネージャー初期化
            self.storage_manager = CloudStorageManager(
                provider=self.config.storage_provider,
                bucket_name=self.config.storage_bucket,
                auto_sync=self.config.auto_sync_storage
            )
            logger.info(f"✅ CloudStorageManager 初期化完了 (provider={self.config.storage_provider})")
            
            # 3. パッチマネージャー初期化
            self.patch_manager = PatchManager(
                backup_dir=self.config.backup_dir,
                max_backups=self.config.max_backups
            )
            logger.info("✅ PatchManager 初期化完了")
            
            # 4. テスターエージェント初期化
            if self.config.enable_auto_tests:
                self.wp_tester = WPTesterAgent(
                    command_monitor=self.cmd_monitor,
                    wp_path=self.config.wp_path
                )
                logger.info("✅ WPTesterAgent 初期化完了")
            
            # 5. GitHubエージェント初期化
            if self.config.enable_auto_pr:
                self.github_agent = GitHubAgent(
                    repo_path=self.config.repo_path,
                    repo_owner=self.config.repo_owner,
                    repo_name=self.config.repo_name
                )
                logger.info("✅ GitHubAgent 初期化完了")
            
            # 6. AIチャットエージェント取得（ローカルAI用）
            if self.browser_controller:
                self.ai_chat_agent = getattr(
                    self.browser_controller, 
                    'ai_chat', 
                    None
                )
            
            # 7. ローカル修正エージェント初期化
            self.local_agent = LocalFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                use_local_ai=self.config.use_local_ai,
                ai_chat_agent=self.ai_chat_agent
            )
            logger.info("✅ LocalFixAgent 初期化完了")
            
            # 8. クラウド修正エージェント初期化
            self.cloud_agent = CloudFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                api_provider=self.config.cloud_provider,
                model_name=self.config.cloud_model
            )
            logger.info(f"✅ CloudFixAgent 初期化完了 (provider={self.config.cloud_provider})")
            
            # 9. エラー分類器初期化
            error_classifier = ErrorClassifier()
            logger.info("✅ ErrorClassifier 初期化完了")
            
            # 10. オーケストレーター初期化
            self.orchestrator = HybridFixOrchestrator(
                local_agent=self.local_agent,
                cloud_agent=self.cloud_agent,
                error_classifier=error_classifier,
                default_strategy=FixStrategy[self.config.default_strategy]
            )
            logger.info(f"✅ HybridFixOrchestrator 初期化完了 (戦略={self.config.default_strategy})")
            
            # システム起動時刻を記録
            from datetime import datetime
            self.system_stats["start_time"] = datetime.now()
            
            logger.info("=" * 80)
            logger.info("✅ ハイブリッド修正システム 初期化完了")
            logger.info("=" * 80)
            
            return True
            
        except Exception as e:
            logger.error(f"💥 初期化エラー: {e}", exc_info=True)
            return False
    
    async def handle_error(
        self,
        error: Exception,
        task_id: str,
        file_path: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        エラーを処理して自動修正を試行
        
        Args:
            error: 発生した例外
            task_id: タスクID
            file_path: エラー発生ファイル
            context: 追加コンテキスト
            
        Returns:
            Dict: 処理結果
        """
        try:
            self.system_stats["total_errors_detected"] += 1
            
            logger.info("=" * 80)
            logger.info(f"🔍 エラー検出: {task_id}")
            logger.info(f"   タイプ: {type(error).__name__}")
            logger.info(f"   メッセージ: {str(error)}")
            logger.info("=" * 80)
            
            # 1. エラーコンテキストを作成
            error_context = self._create_error_context(
                error,
                file_path,
                context
            )
            
            # 2. バグ修正タスクを作成
            bug_fix_task = BugFixTask(
                task_id=f"{task_id}-AutoFix",
                error_context=error_context,
                target_files=[file_path],
                priority=self._calculate_priority(error_context),
                run_tests=self.config.enable_auto_tests,
                create_pr=self.config.enable_auto_pr
            )
            
            logger.info(f"📋 バグ修正タスク作成: {bug_fix_task.task_id}")
            logger.info(f"   優先度: {bug_fix_task.priority}")
            logger.info(f"   深刻度: {error_context.severity.value}")
            
            # 3. 自動修正を実行
            fix_result = await self.orchestrator.execute_fix_task(bug_fix_task)
            
            # 4. 結果を記録
            if fix_result.success:
                self.system_stats["auto_fixed_errors"] += 1
                logger.info(f"✅ 自動修正成功: {bug_fix_task.task_id}")
                
                # GitHub PR作成（有効な場合）
                if self.config.enable_auto_pr and self.github_agent:
                    await self._create_fix_pr(bug_fix_task, fix_result)
            
            else:
                self.system_stats["manual_intervention_required"] += 1
                logger.warning(f"⚠️ 自動修正失敗（手動介入が必要）: {bug_fix_task.task_id}")
            
            return {
                "success": fix_result.success,
                "task_id": bug_fix_task.task_id,
                "fix_result": fix_result,
                "requires_manual_intervention": not fix_result.success
            }
            
        except Exception as e:
            logger.error(f"💥 エラー処理中にエラー: {e}", exc_info=True)
            self.system_stats["manual_intervention_required"] += 1
            
            return {
                "success": False,
                "error": str(e),
                "requires_manual_intervention": True
            }
    
    def _create_error_context(
        self,
        error: Exception,
        file_path: str,
        context: Optional[Dict[str, Any]]
    ) -> ErrorContextModel:
        """エラーコンテキストを作成"""
        import traceback
        import inspect
        
        # スタックトレースを取得
        tb = traceback.extract_tb(error.__traceback__)
        
        # エラー発生行番号
        line_number = None
        if tb:
            line_number = tb[-1].lineno
        
        # 周辺コードを取得（可能な場合）
        surrounding_code = None
        try:
            if Path(file_path).exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    if line_number:
                        start = max(0, line_number - 6)
                        end = min(len(lines), line_number + 5)
                        surrounding_code = ''.join(lines[start:end])
        except:
            pass
        
        # エラーカテゴリを推定
        error_category = self._infer_error_category(error)
        
        # 深刻度を推定
        severity = self._infer_severity(error, error_category)
        
        return ErrorContextModel(
            error_type=type(error).__name__,
            error_message=str(error),
            severity=severity,
            error_category=error_category,
            file_path=file_path,
            line_number=line_number,
            full_traceback=traceback.format_exc(),
            surrounding_code=surrounding_code,
            context_info=context or {}
        )
    
    def _infer_error_category(self, error: Exception) -> ErrorCategory:
        """エラーカテゴリを推定"""
        error_type = type(error).__name__
        
        if "Import" in error_type or "Module" in error_type:
            return ErrorCategory.IMPORT
        elif "Syntax" in error_type or "Indent" in error_type:
            return ErrorCategory.SYNTAX
        elif error_type in ["AttributeError", "NameError", "TypeError", "KeyError"]:
            return ErrorCategory.RUNTIME
        elif "Recursion" in error_type or "Memory" in error_type:
            return ErrorCategory.PERFORMANCE
        else:
            return ErrorCategory.UNKNOWN
    
    def _infer_severity(
        self,
        error: Exception,
        category: ErrorCategory
    ) -> ErrorSeverity:
        """深刻度を推定"""
        error_type = type(error).__name__
        
        # 致命的なエラー
        if error_type in ["MemoryError", "RecursionError", "SystemError"]:
            return ErrorSeverity.CRITICAL
        
        # 高優先度
        if category == ErrorCategory.LOGIC or "Runtime" in error_type:
            return ErrorSeverity.HIGH
        
        # 中優先度
        if category in [ErrorCategory.RUNTIME, ErrorCategory.IMPORT]:
            return ErrorSeverity.MEDIUM
        
        # 低優先度
        return ErrorSeverity.LOW
    
    def _calculate_priority(self, error_context: ErrorContextModel) -> int:
        """優先度を計算（1-10）"""
        severity_scores = {
            ErrorSeverity.CRITICAL: 10,
            ErrorSeverity.HIGH: 8,
            ErrorSeverity.MEDIUM: 5,
            ErrorSeverity.LOW: 3
        }
        
        return severity_scores.get(error_context.severity, 5)
    
    async def _create_fix_pr(
        self,
        bug_fix_task: BugFixTask,
        fix_result
    ):
        """修正のPRを作成"""
        try:
            if not self.github_agent:
                return
            
            logger.info("🌿 GitHub PR作成開始")
            
            pr_result = await self.github_agent.create_full_fix_workflow(
                task_id=bug_fix_task.task_id,
                modified_files=fix_result.modified_files,
                fix_description=fix_result.reasoning or "Automated bug fix"
            )
            
            if pr_result["success"]:
                logger.info(f"✅ PR作成成功: {pr_result['pr_url']}")
                fix_result.pr_url = pr_result["pr_url"]
            else:
                logger.warning(f"⚠️ PR作成失敗: {pr_result.get('error')}")
                
        except Exception as e:
            logger.error(f"❌ PR作成エラー: {e}")
    
    def get_system_stats(self) -> Dict[str, Any]:
        """システム統計を取得"""
        from datetime import datetime
        
        uptime = 0.0
        if self.system_stats["start_time"]:
            uptime = (datetime.now() - self.system_stats["start_time"]).total_seconds()
        
        auto_fix_rate = 0.0
        if self.system_stats["total_errors_detected"] > 0:
            auto_fix_rate = (
                self.system_stats["auto_fixed_errors"] / 
                self.system_stats["total_errors_detected"]
            )
        
        return {
            **self.system_stats,
            "uptime_seconds": uptime,
            "auto_fix_rate": auto_fix_rate,
            "orchestrator_stats": self.orchestrator.get_stats() if self.orchestrator else {},
            "local_agent_stats": self.local_agent.get_stats() if self.local_agent else {},
            "cloud_agent_stats": self.cloud_agent.get_stats() if self.cloud_agent else {}
        }
    
    def print_system_stats(self):
        """システム統計を表示"""
        stats = self.get_system_stats()
        
        print("\n" + "=" * 80)
        print("📊 ハイブリッド修正システム 統計情報")
        print("=" * 80)
        print(f"稼働時間: {stats['uptime_seconds'] / 3600:.1f}時間")
        print(f"\n検出エラー総数: {stats['total_errors_detected']}")
        print(f"自動修正成功: {stats['auto_fixed_errors']}")
        print(f"手動介入必要: {stats['manual_intervention_required']}")
        print(f"自動修正率: {stats['auto_fix_rate']:.1%}")
        
        if self.orchestrator:
            print("\n" + "-" * 80)
            self.orchestrator.print_stats()
        
        print("=" * 80 + "\n")


async def main():
    """メイン実行関数"""
    
    # ログ設定
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 設定読み込み
    config = HybridFixConfig()
    
    # システム初期化
    system = HybridFixSystem(config=config)
    
    success = await system.initialize()
    
    if not success:
        logger.error("❌ システム初期化失敗")
        return 1
    
    # テスト実行
    logger.info("\n🧪 テストエラーを生成して自動修正をテスト")
    
    try:
        # 意図的にエラーを発生させる
        test_data = None
        result = test_data.get('key')  # AttributeError
    
    except Exception as e:
        # エラーを自動修正システムに送信
        handle_result = await system.handle_error(
            error=e,
            task_id="Test-AutoFix-Demo",
            file_path="main_hybrid_fix.py",
            context={"test": True}
        )
        
        logger.info(f"\n処理結果: {handle_result}")
    
    # システム統計表示
    system.print_system_stats()
    
    return 0


if __name__ == "__main__":
    # Windows環境対応
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    # 実行
    exit_code = asyncio.run(main())
    sys.exit(exit_code)

#metrics_collector.py
"""
MetricsCollector - メトリクス収集とレポート生成エージェント

修正成功率、平均修正時間、エージェント別パフォーマンス分析、
日次/週次/月次レポート生成、ダッシュボード用データ生成を提供する。
"""

import json
import statistics
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from collections import defaultdict, Counter
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MetricType(Enum):
    """メトリクスタイプ"""
    COUNTER = "counter"  # 累積カウンター
    GAUGE = "gauge"  # 現在値
    HISTOGRAM = "histogram"  # 分布
    TIMER = "timer"  # 時間計測


class ReportPeriod(Enum):
    """レポート期間"""
    HOURLY = "hourly"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


@dataclass
class MetricEntry:
    """メトリクスエントリ"""
    name: str
    value: float
    type: MetricType
    timestamp: datetime
    tags: Dict[str, str] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "value": self.value,
            "type": self.type.value,
            "timestamp": self.timestamp.isoformat(),
            "tags": self.tags
        }


@dataclass
class PerformanceStats:
    """パフォーマンス統計"""
    total_count: int = 0
    success_count: int = 0
    failure_count: int = 0
    avg_duration: float = 0.0
    min_duration: float = float('inf')
    max_duration: float = 0.0
    percentile_50: float = 0.0
    percentile_95: float = 0.0
    percentile_99: float = 0.0
    
    @property
    def success_rate(self) -> float:
        return self.success_count / self.total_count if self.total_count > 0 else 0.0
    
    @property
    def failure_rate(self) -> float:
        return self.failure_count / self.total_count if self.total_count > 0 else 0.0


class MetricsCollectorAgent:
    """
    メトリクス収集とレポート生成エージェント
    
    主な機能:
    1. 修正成功率の追跡
    2. 平均修正時間の計算
    3. エージェント別パフォーマンス分析
    4. 日次/週次/月次レポート生成
    5. ダッシュボード用データ生成
    """
    
    def __init__(self, storage_dir: str = ".metrics"):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        
        # メトリクスストレージ
        self.metrics: List[MetricEntry] = []
        
        # エージェント別統計
        self.agent_stats: Dict[str, Dict[str, Any]] = defaultdict(
            lambda: {
                "tasks_processed": 0,
                "tasks_succeeded": 0,
                "tasks_failed": 0,
                "total_duration": 0.0,
                "durations": []
            }
        )
        
        # エラータイプ別統計
        self.error_stats: Dict[str, int] = Counter()
        
        # 修正タイプ別統計
        self.fix_stats: Dict[str, Dict[str, int]] = defaultdict(
            lambda: {"attempted": 0, "succeeded": 0, "failed": 0}
        )
        
        # タスク実行中のトラッキング
        self.active_tasks: Dict[str, datetime] = {}
        
        logger.info(f"MetricsCollectorAgent initialized (storage_dir={storage_dir})")
    
    def record_metric(self, 
                     name: str,
                     value: float,
                     metric_type: MetricType = MetricType.GAUGE,
                     tags: Dict[str, str] = None):
        """
        メトリクスを記録
        
        Args:
            name: メトリクス名
            value: 値
            metric_type: メトリクスタイプ
            tags: タグ
        """
        entry = MetricEntry(
            name=name,
            value=value,
            type=metric_type,
            timestamp=datetime.now(),
            tags=tags or {}
        )
        
        self.metrics.append(entry)
        logger.debug(f"Recorded metric: {name}={value} {tags}")
    
    def start_task(self, task_id: str, agent_name: str):
        """タスク開始を記録"""
        self.active_tasks[task_id] = datetime.now()
        self.agent_stats[agent_name]["tasks_processed"] += 1
        
        self.record_metric(
            name="task_started",
            value=1,
            metric_type=MetricType.COUNTER,
            tags={"agent": agent_name, "task_id": task_id}
        )
        
        logger.debug(f"Task started: {task_id} by {agent_name}")
    
    def end_task(self, 
                task_id: str,
                agent_name: str,
                success: bool,
                error_type: Optional[str] = None):
        """タスク終了を記録"""
        if task_id not in self.active_tasks:
            logger.warning(f"Task {task_id} was not tracked")
            return
        
        # 実行時間を計算
        start_time = self.active_tasks.pop(task_id)
        duration = (datetime.now() - start_time).total_seconds()
        
        # エージェント統計を更新
        stats = self.agent_stats[agent_name]
        if success:
            stats["tasks_succeeded"] += 1
        else:
            stats["tasks_failed"] += 1
        
        stats["total_duration"] += duration
        stats["durations"].append(duration)
        
        # エラー統計を更新
        if error_type:
            self.error_stats[error_type] += 1
        
        # メトリクスを記録
        self.record_metric(
            name="task_duration",
            value=duration,
            metric_type=MetricType.TIMER,
            tags={
                "agent": agent_name,
                "task_id": task_id,
                "success": str(success),
                "error_type": error_type or "none"
            }
        )
        
        self.record_metric(
            name="task_completed",
            value=1,
            metric_type=MetricType.COUNTER,
            tags={
                "agent": agent_name,
                "success": str(success)
            }
        )
        
        logger.debug(f"Task ended: {task_id} (success={success}, duration={duration:.2f}s)")
    
    def record_fix_attempt(self,
                          fix_type: str,
                          success: bool,
                          duration: float,
                          error_type: str):
        """修正試行を記録"""
        self.fix_stats[fix_type]["attempted"] += 1
        
        if success:
            self.fix_stats[fix_type]["succeeded"] += 1
        else:
            self.fix_stats[fix_type]["failed"] += 1
        
        self.record_metric(
            name="fix_attempt",
            value=duration,
            metric_type=MetricType.TIMER,
            tags={
                "fix_type": fix_type,
                "success": str(success),
                "error_type": error_type
            }
        )
        
        logger.debug(f"Fix attempt recorded: {fix_type} (success={success})")
    
    def get_agent_performance(self, agent_name: str) -> PerformanceStats:
        """エージェントのパフォーマンス統計を取得"""
        if agent_name not in self.agent_stats:
            return PerformanceStats()
        
        stats = self.agent_stats[agent_name]
        durations = stats["durations"]
        
        if not durations:
            return PerformanceStats(
                total_count=stats["tasks_processed"],
                success_count=stats["tasks_succeeded"],
                failure_count=stats["tasks_failed"]
            )
        
        # パーセンタイルを計算
        sorted_durations = sorted(durations)
        
        return PerformanceStats(
            total_count=stats["tasks_processed"],
            success_count=stats["tasks_succeeded"],
            failure_count=stats["tasks_failed"],
            avg_duration=statistics.mean(durations),
            min_duration=min(durations),
            max_duration=max(durations),
            percentile_50=self._percentile(sorted_durations, 50),
            percentile_95=self._percentile(sorted_durations, 95),
            percentile_99=self._percentile(sorted_durations, 99)
        )
    
    def get_all_agents_performance(self) -> Dict[str, PerformanceStats]:
        """全エージェントのパフォーマンス統計を取得"""
        return {
            agent_name: self.get_agent_performance(agent_name)
            for agent_name in self.agent_stats.keys()
        }
    
    def get_fix_success_rate(self, fix_type: Optional[str] = None) -> float:
        """修正成功率を取得"""
        if fix_type:
            stats = self.fix_stats.get(fix_type, {"attempted": 0, "succeeded": 0})
            if stats["attempted"] == 0:
                return 0.0
            return stats["succeeded"] / stats["attempted"]
        
        # 全体の成功率
        total_attempted = sum(s["attempted"] for s in self.fix_stats.values())
        total_succeeded = sum(s["succeeded"] for s in self.fix_stats.values())
        
        if total_attempted == 0:
            return 0.0
        
        return total_succeeded / total_attempted
    
    def get_error_distribution(self) -> Dict[str, int]:
        """エラー分布を取得"""
        return dict(self.error_stats)
    
    def get_top_errors(self, limit: int = 10) -> List[Tuple[str, int]]:
        """頻度の高いエラーを取得"""
        return self.error_stats.most_common(limit)
    
    def generate_report(self, 
                       period: ReportPeriod = ReportPeriod.DAILY,
                       start_time: Optional[datetime] = None) -> Dict[str, Any]:
        """
        レポートを生成
        
        Args:
            period: レポート期間
            start_time: 開始時刻（Noneの場合は現在時刻から期間を逆算）
        
        Returns:
            レポートデータ
        """
        if start_time is None:
            start_time = datetime.now()
        
        # 期間を計算
        if period == ReportPeriod.HOURLY:
            cutoff = start_time - timedelta(hours=1)
        elif period == ReportPeriod.DAILY:
            cutoff = start_time - timedelta(days=1)
        elif period == ReportPeriod.WEEKLY:
            cutoff = start_time - timedelta(weeks=1)
        elif period == ReportPeriod.MONTHLY:
            cutoff = start_time - timedelta(days=30)
        else:
            cutoff = datetime.min
        
        # 期間内のメトリクスをフィルタ
        period_metrics = [m for m in self.metrics if m.timestamp >= cutoff]
        
        # タスク統計
        task_started = sum(1 for m in period_metrics if m.name == "task_started")
        task_completed = sum(1 for m in period_metrics if m.name == "task_completed")
        task_succeeded = sum(
            1 for m in period_metrics 
            if m.name == "task_completed" and m.tags.get("success") == "True"
        )
        task_failed = task_completed - task_succeeded
        
        # 修正統計
        fix_attempts = sum(1 for m in period_metrics if m.name == "fix_attempt")
        fix_succeeded = sum(
            1 for m in period_metrics
            if m.name == "fix_attempt" and m.tags.get("success") == "True"
        )
        
        # 平均実行時間
        durations = [
            m.value for m in period_metrics
            if m.name == "task_duration"
        ]
        avg_duration = statistics.mean(durations) if durations else 0.0
        
        # エージェント別統計
        agent_performance = {}
        for agent_name in self.agent_stats.keys():
            perf = self.get_agent_performance(agent_name)
            agent_performance[agent_name] = {
                "total_tasks": perf.total_count,
                "success_rate": perf.success_rate,
                "avg_duration": perf.avg_duration,
                "p95_duration": perf.percentile_95
            }
        
        # エラー分布
        error_dist = self.get_error_distribution()
        
        report = {
            "period": period.value,
            "start_time": cutoff.isoformat(),
            "end_time": start_time.isoformat(),
            "summary": {
                "tasks_started": task_started,
                "tasks_completed": task_completed,
                "tasks_succeeded": task_succeeded,
                "tasks_failed": task_failed,
                "success_rate": task_succeeded / task_completed if task_completed > 0 else 0.0,
                "avg_duration_seconds": avg_duration
            },
            "fixes": {
                "attempts": fix_attempts,
                "succeeded": fix_succeeded,
                "success_rate": fix_succeeded / fix_attempts if fix_attempts > 0 else 0.0
            },
            "agent_performance": agent_performance,
            "error_distribution": error_dist,
            "top_errors": dict(self.get_top_errors(5))
        }
        
        return report
    
    def generate_dashboard_data(self) -> Dict[str, Any]:
        """ダッシュボード用データを生成"""
        now = datetime.now()
        
        # 複数期間のレポートを生成
        hourly_report = self.generate_report(ReportPeriod.HOURLY, now)
        daily_report = self.generate_report(ReportPeriod.DAILY, now)
        weekly_report = self.generate_report(ReportPeriod.WEEKLY, now)
        
        # 時系列データ（過去24時間）
        cutoff = now - timedelta(hours=24)
        recent_metrics = [m for m in self.metrics if m.timestamp >= cutoff]
        
        # 1時間ごとの集計
        hourly_buckets = defaultdict(lambda: {"tasks": 0, "errors": 0, "fixes": 0})
        
        for metric in recent_metrics:
            hour_key = metric.timestamp.replace(minute=0, second=0, microsecond=0)
            
            if metric.name == "task_completed":
                hourly_buckets[hour_key]["tasks"] += 1
            elif metric.name == "fix_attempt":
                hourly_buckets[hour_key]["fixes"] += 1
            elif "error" in metric.name:
                hourly_buckets[hour_key]["errors"] += 1
        
        # 時系列データを整形
        time_series = []
        for hour in sorted(hourly_buckets.keys()):
            time_series.append({
                "timestamp": hour.isoformat(),
                "tasks": hourly_buckets[hour]["tasks"],
                "errors": hourly_buckets[hour]["errors"],
                "fixes": hourly_buckets[hour]["fixes"]
            })
        
        # 全エージェントのパフォーマンス
        all_agents_perf = self.get_all_agents_performance()
        agent_summary = {}
        
        for agent_name, perf in all_agents_perf.items():
            agent_summary[agent_name] = {
                "total_tasks": perf.total_count,
                "success_rate": round(perf.success_rate * 100, 2),
                "avg_duration": round(perf.avg_duration, 2),
                "status": self._get_agent_status(perf)
            }
        
        return {
            "overview": {
                "hourly": hourly_report["summary"],
                "daily": daily_report["summary"],
                "weekly": weekly_report["summary"]
            },
            "time_series": time_series,
            "agents": agent_summary,
            "errors": {
                "distribution": self.get_error_distribution(),
                "top_5": dict(self.get_top_errors(5))
            },
            "fixes": {
                "overall_success_rate": round(self.get_fix_success_rate() * 100, 2),
                "by_type": {
                    fix_type: {
                        "attempted": stats["attempted"],
                        "success_rate": round(
                            (stats["succeeded"] / stats["attempted"] * 100) 
                            if stats["attempted"] > 0 else 0, 2
                        )
                    }
                    for fix_type, stats in self.fix_stats.items()
                }
            },
            "active_tasks": len(self.active_tasks),
            "generated_at": now.isoformat()
        }
    
    def export_metrics(self, filepath: Optional[str] = None) -> str:
        """
        メトリクスをJSONファイルにエクスポート
        
        Args:
            filepath: 出力ファイルパス（Noneの場合は自動生成）
        
        Returns:
            出力ファイルパス
        """
        if filepath is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filepath = self.storage_dir / f"metrics_{timestamp}.json"
        
        data = {
            "metrics": [m.to_dict() for m in self.metrics],
            "agent_stats": dict(self.agent_stats),
            "error_stats": dict(self.error_stats),
            "fix_stats": dict(self.fix_stats),
            "exported_at": datetime.now().isoformat()
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Metrics exported to {filepath}")
        
        return str(filepath)
    
    def import_metrics(self, filepath: str):
        """メトリクスをJSONファイルからインポート"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # メトリクスを復元
        for m_data in data.get("metrics", []):
            metric = MetricEntry(
                name=m_data["name"],
                value=m_data["value"],
                type=MetricType(m_data["type"]),
                timestamp=datetime.fromisoformat(m_data["timestamp"]),
                tags=m_data.get("tags", {})
            )
            self.metrics.append(metric)
        
        # 統計データを復元
        self.agent_stats.update(data.get("agent_stats", {}))
        self.error_stats.update(data.get("error_stats", {}))
        self.fix_stats.update(data.get("fix_stats", {}))
        
        logger.info(f"Metrics imported from {filepath}")
    
    def _percentile(self, sorted_data: List[float], percentile: int) -> float:
        """パーセンタイルを計算"""
        if not sorted_data:
            return 0.0
        
        index = (len(sorted_data) - 1) * percentile / 100
        lower = int(index)
        upper = lower + 1
        
        if upper >= len(sorted_data):
            return sorted_data[-1]
        
        weight = index - lower
        return sorted_data[lower] * (1 - weight) + sorted_data[upper] * weight
    
    def _get_agent_status(self, perf: PerformanceStats) -> str:
        """エージェントのステータスを判定"""
        if perf.total_count == 0:
            return "idle"
        
        if perf.success_rate >= 0.95:
            return "excellent"
        elif perf.success_rate >= 0.80:
            return "good"
        elif perf.success_rate >= 0.60:
            return "fair"
        else:
            return "poor"
    
    def clear_old_metrics(self, days: int = 30):
        """古いメトリクスをクリア"""
        cutoff = datetime.now() - timedelta(days=days)
        
        original_count = len(self.metrics)
        self.metrics = [m for m in self.metrics if m.timestamp >= cutoff]
        
        cleared_count = original_count - len(self.metrics)
        logger.info(f"Cleared {cleared_count} old metrics (older than {days} days)")
    
    def get_summary(self) -> Dict[str, Any]:
        """簡易サマリーを取得"""
        total_tasks = sum(stats["tasks_processed"] for stats in self.agent_stats.values())
        total_succeeded = sum(stats["tasks_succeeded"] for stats in self.agent_stats.values())
        total_failed = sum(stats["tasks_failed"] for stats in self.agent_stats.values())
        
        overall_success_rate = total_succeeded / total_tasks if total_tasks > 0 else 0.0
        
        return {
            "total_tasks": total_tasks,
            "total_succeeded": total_succeeded,
            "total_failed": total_failed,
            "overall_success_rate": round(overall_success_rate * 100, 2),
            "active_agents": len(self.agent_stats),
            "total_metrics": len(self.metrics),
            "unique_errors": len(self.error_stats),
            "fix_types": len(self.fix_stats)
        }


# 使用例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    collector = MetricsCollectorAgent()
    
    # タスク実行をシミュレート
    collector.start_task("task-1", "LocalFixAgent")
    import time
    time.sleep(0.5)
    collector.end_task("task-1", "LocalFixAgent", success=True)
    
    collector.start_task("task-2", "CloudFixAgent")
    time.sleep(1.0)
    collector.end_task("task-2", "CloudFixAgent", success=False, error_type="SyntaxError")
    
    # 修正試行を記録
    collector.record_fix_attempt("local", success=True, duration=2.5, error_type="ImportError")
    collector.record_fix_attempt("cloud", success=False, duration=5.0, error_type="AttributeError")
    
    # レポート生成
    daily_report = collector.generate_report(ReportPeriod.DAILY)
    print("\n=== Daily Report ===")
    print(json.dumps(daily_report, indent=2))
    
    # ダッシュボードデータ生成
    dashboard = collector.generate_dashboard_data()
    print("\n=== Dashboard Data ===")
    print(json.dumps(dashboard, indent=2))
    
    # サマリー
    summary = collector.get_summary()
    print("\n=== Summary ===")
    print(json.dumps(summary, indent=2))
    
    # エクスポート
    export_path = collector.export_metrics()
    print(f"\nMetrics exported to: {export_path}")


#monitoring_agent.py
# monitoring_agent.py
"""
モニタリングエージェント
システム監視とヘルスチェック
"""

import asyncio
import logging
import psutil
import os
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from enum import Enum

logger = logging.getLogger(__name__)


class HealthStatus(Enum):
    """ヘルスステータス"""
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    UNKNOWN = "unknown"


class MonitoringAgent:
    """
    モニタリングエージェント
    
    機能:
    - システムリソース監視
    - エラー発生率の追跡
    - パフォーマンスメトリクス収集
    - ヘルスチェック
    - アラート発行
    """
    
    def __init__(
        self,
        check_interval: int = 60,  # 秒
        cpu_threshold: float = 80.0,  # %
        memory_threshold: float = 85.0,  # %
        disk_threshold: float = 90.0,  # %
        error_rate_threshold: float = 0.3  # 30%
    ):
        """
        初期化
        
        Args:
            check_interval: チェック間隔（秒）
            cpu_threshold: CPU使用率閾値
            memory_threshold: メモリ使用率閾値
            disk_threshold: ディスク使用率閾値
            error_rate_threshold: エラー率閾値
        """
        self.check_interval = check_interval
        self.cpu_threshold = cpu_threshold
        self.memory_threshold = memory_threshold
        self.disk_threshold = disk_threshold
        self.error_rate_threshold = error_rate_threshold
        
        # モニタリングデータ
        self.metrics_history = []
        self.alerts = []
        
        # システム情報
        self.start_time = datetime.now()
        self.is_monitoring = False
        self.monitoring_task = None
        
        # 統計情報
        self.stats = {
            "total_checks": 0,
            "health_checks": 0,
            "warnings_issued": 0,
            "critical_alerts": 0,
            "avg_cpu_usage": 0.0,
            "avg_memory_usage": 0.0,
            "avg_response_time": 0.0
        }
        
        logger.info("✅ MonitoringAgent 初期化完了")
    
    async def start_monitoring(self):
        """モニタリング開始"""
        if self.is_monitoring:
            logger.warning("⚠️ モニタリングは既に実行中です")
            return
        
        self.is_monitoring = True
        self.monitoring_task = asyncio.create_task(self._monitoring_loop())
        
        logger.info(f"🔍 モニタリング開始 (間隔={self.check_interval}秒)")
    
    async def stop_monitoring(self):
        """モニタリング停止"""
        self.is_monitoring = False
        
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
        
        logger.info("⏹️ モニタリング停止")
    
    async def _monitoring_loop(self):
        """モニタリングループ"""
        try:
            while self.is_monitoring:
                # ヘルスチェック実行
                await self.perform_health_check()
                
                # 次のチェックまで待機
                await asyncio.sleep(self.check_interval)
                
        except asyncio.CancelledError:
            logger.info("モニタリングループがキャンセルされました")
        except Exception as e:
            logger.error(f"❌ モニタリングループエラー: {e}", exc_info=True)
    
    async def perform_health_check(self) -> Dict[str, Any]:
        """ヘルスチェックを実行"""
        try:
            check_time = datetime.now()
            self.stats["health_checks"] += 1
            self.stats["total_checks"] += 1
            
            # メトリクス収集
            metrics = {
                "timestamp": check_time.isoformat(),
                "system": await self._collect_system_metrics(),
                "process": await self._collect_process_metrics(),
                "application": await self._collect_application_metrics()
            }
            
            # ヘルスステータス判定
            health_status = self._determine_health_status(metrics)
            metrics["health_status"] = health_status.value
            
            # 履歴に追加
            self.metrics_history.append(metrics)
            
            # 古い履歴を削除（直近100件のみ保持）
            if len(self.metrics_history) > 100:
                self.metrics_history = self.metrics_history[-100:]
            
            # アラートチェック
            await self._check_and_issue_alerts(metrics, health_status)
            
            # 統計更新
            self._update_statistics(metrics)
            
            logger.debug(
                f"✅ ヘルスチェック完了: {health_status.value} "
                f"(CPU={metrics['system']['cpu_percent']:.1f}%, "
                f"Memory={metrics['system']['memory_percent']:.1f}%)"
            )
            
            return {
                "success": True,
                "health_status": health_status.value,
                "metrics": metrics
            }
            
        except Exception as e:
            logger.error(f"❌ ヘルスチェックエラー: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _collect_system_metrics(self) -> Dict[str, Any]:
        """システムメトリクスを収集"""
        try:
            # CPU使用率
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            
            # メモリ使用率
            memory = psutil.virtual_memory()
            
            # ディスク使用率
            disk = psutil.disk_usage('/')
            
            # ネットワーク統計
            net_io = psutil.net_io_counters()
            
            return {
                "cpu_percent": cpu_percent,
                "cpu_count": cpu_count,
                "memory_percent": memory.percent,
                "memory_used_gb": memory.used / (1024**3),
                "memory_total_gb": memory.total / (1024**3),
                "disk_percent": disk.percent,
                "disk_used_gb": disk.used / (1024**3),
                "disk_total_gb": disk.total / (1024**3),
                "network_bytes_sent": net_io.bytes_sent,
                "network_bytes_recv": net_io.bytes_recv
            }
            
        except Exception as e:
            logger.error(f"❌ システムメトリクス収集エラー: {e}")
            return {}
    
    async def _collect_process_metrics(self) -> Dict[str, Any]:
        """プロセスメトリクスを収集"""
        try:
            process = psutil.Process(os.getpid())
            
            # プロセス情報
            with process.oneshot():
                cpu_percent = process.cpu_percent()
                memory_info = process.memory_info()
                num_threads = process.num_threads()
                open_files = len(process.open_files())
                
            return {
                "pid": process.pid,
                "cpu_percent": cpu_percent,
                "memory_mb": memory_info.rss / (1024**2),
                "num_threads": num_threads,
                "open_files": open_files,
                "status": process.status()
            }
            
        except Exception as e:
            logger.error(f"❌ プロセスメトリクス収集エラー: {e}")
            return {}
    
    async def _collect_application_metrics(self) -> Dict[str, Any]:
        """アプリケーションメトリクスを収集"""
        try:
            # 稼働時間
            uptime = (datetime.now() - self.start_time).total_seconds()
            
            return {
                "uptime_seconds": uptime,
                "uptime_hours": uptime / 3600,
                "total_health_checks": self.stats["health_checks"],
                "warnings_issued": self.stats["warnings_issued"],
                "critical_alerts": self.stats["critical_alerts"]
            }
            
        except Exception as e:
            logger.error(f"❌ アプリケーションメトリクス収集エラー: {e}")
            return {}
    
    def _determine_health_status(self, metrics: Dict[str, Any]) -> HealthStatus:
        """ヘルスステータスを判定"""
        try:
            system = metrics.get("system", {})
            
            # Critical条件チェック
            if (system.get("cpu_percent", 0) > 95 or
                system.get("memory_percent", 0) > 95 or
                system.get("disk_percent", 0) > 95):
                return HealthStatus.CRITICAL
            
            # Warning条件チェック
            if (system.get("cpu_percent", 0) > self.cpu_threshold or
                system.get("memory_percent", 0) > self.memory_threshold or
                system.get("disk_percent", 0) > self.disk_threshold):
                return HealthStatus.WARNING
            
            # Healthy
            return HealthStatus.HEALTHY
            
        except Exception as e:
            logger.error(f"❌ ヘルスステータス判定エラー: {e}")
            return HealthStatus.UNKNOWN
    
    async def _check_and_issue_alerts(
        self,
        metrics: Dict[str, Any],
        health_status: HealthStatus
    ):
        """アラートをチェックして発行"""
        try:
            system = metrics.get("system", {})
            timestamp = metrics.get("timestamp")
            
            alerts = []
            
            # CPU警告
            if system.get("cpu_percent", 0) > self.cpu_threshold:
                alerts.append({
                    "level": "warning" if health_status == HealthStatus.WARNING else "critical",
                    "type": "cpu_usage",
                    "message": f"CPU使用率が高い: {system['cpu_percent']:.1f}%",
                    "value": system['cpu_percent'],
                    "threshold": self.cpu_threshold,
                    "timestamp": timestamp
                })
            
            # メモリ警告
            if system.get("memory_percent", 0) > self.memory_threshold:
                alerts.append({
                    "level": "warning" if health_status == HealthStatus.WARNING else "critical",
                    "type": "memory_usage",
                    "message": f"メモリ使用率が高い: {system['memory_percent']:.1f}%",
                    "value": system['memory_percent'],
                    "threshold": self.memory_threshold,
                    "timestamp": timestamp
                })
            
            # ディスク警告
            if system.get("disk_percent", 0) > self.disk_threshold:
                alerts.append({
                    "level": "warning" if health_status == HealthStatus.WARNING else "critical",
                    "type": "disk_usage",
                    "message": f"ディスク使用率が高い: {system['disk_percent']:.1f}%",
                    "value": system['disk_percent'],
                    "threshold": self.disk_threshold,
                    "timestamp": timestamp
                })
            
            # アラートを記録
            for alert in alerts:
                self.alerts.append(alert)
                
                if alert["level"] == "critical":
                    self.stats["critical_alerts"] += 1
                    logger.critical(f"🚨 CRITICAL: {alert['message']}")
                else:
                    self.stats["warnings_issued"] += 1
                    logger.warning(f"⚠️ WARNING: {alert['message']}")
            
            # 古いアラートを削除（直近50件のみ保持）
            if len(self.alerts) > 50:
                self.alerts = self.alerts[-50:]
            
        except Exception as e:
            logger.error(f"❌ アラートチェックエラー: {e}")
    
    def _update_statistics(self, metrics: Dict[str, Any]):
        """統計情報を更新"""
        try:
            system = metrics.get("system", {})
            
            # 移動平均を計算
            n = self.stats["health_checks"]
            
            self.stats["avg_cpu_usage"] = (
                (self.stats["avg_cpu_usage"] * (n - 1) + system.get("cpu_percent", 0)) / n
            )
            
            self.stats["avg_memory_usage"] = (
                (self.stats["avg_memory_usage"] * (n - 1) + system.get("memory_percent", 0)) / n
            )
            
        except Exception as e:
            logger.error(f"❌ 統計更新エラー: {e}")
    
    def get_current_status(self) -> Dict[str, Any]:
        """現在のステータスを取得"""
        if not self.metrics_history:
            return {
                "status": "no_data",
                "message": "モニタリングデータがありません"
            }
        
        latest_metrics = self.metrics_history[-1]
        
        return {
            "status": latest_metrics.get("health_status", "unknown"),
            "timestamp": latest_metrics.get("timestamp"),
            "system": latest_metrics.get("system", {}),
            "process": latest_metrics.get("process", {}),
            "application": latest_metrics.get("application", {}),
            "recent_alerts": self.alerts[-5:] if self.alerts else []
        }
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        uptime = (datetime.now() - self.start_time).total_seconds()
        
        return {
            **self.stats,
            "uptime_seconds": uptime,
            "uptime_hours": uptime / 3600,
            "is_monitoring": self.is_monitoring,
            "metrics_count": len(self.metrics_history),
            "alerts_count": len(self.alerts)
        }
    
    def print_status(self):
        """ステータスを表示"""
        status = self.get_current_status()
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("🔍 システムモニタリング ステータス")
        print("=" * 80)
        print(f"ヘルスステータス: {status.get('status', 'unknown').upper()}")
        print(f"稼働時間: {stats['uptime_hours']:.1f}時間")
        print(f"\n【システムリソース】")
        system = status.get("system", {})
        print(f"  CPU使用率: {system.get('cpu_percent', 0):.1f}%")
        print(f"  メモリ使用率: {system.get('memory_percent', 0):.1f}%")
        print(f"  ディスク使用率: {system.get('disk_percent', 0):.1f}%")
        print(f"\n【統計】")
        print(f"  ヘルスチェック: {stats['health_checks']}回")
        print(f"  警告発行: {stats['warnings_issued']}回")
        print(f"  重要アラート: {stats['critical_alerts']}回")
        print(f"  平均CPU: {stats['avg_cpu_usage']:.1f}%")
        print(f"  平均メモリ: {stats['avg_memory_usage']:.1f}%")
        
        if status.get("recent_alerts"):
            print(f"\n【最近のアラート】")
            for alert in status["recent_alerts"]:
                print(f"  - [{alert['level'].upper()}] {alert['message']}")
        
        print("=" * 80 + "\n")

#notification_agent.py
# notification_agent.py
"""
通知エージェント
Slack/メール/その他の通知管理
"""

import asyncio
import logging
import json
import smtplib
from typing import Dict, Any, List, Optional
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from enum import Enum

import aiohttp

logger = logging.getLogger(__name__)


class NotificationLevel(Enum):
    """通知レベル"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
    SUCCESS = "success"


class NotificationChannel(Enum):
    """通知チャネル"""
    SLACK = "slack"
    EMAIL = "email"
    DISCORD = "discord"
    WEBHOOK = "webhook"


class NotificationAgent:
    """
    通知エージェント
    
    機能:
    - Slack通知
    - メール通知
    - Discord通知
    - Webhook通知
    - 通知のフィルタリング
    - 通知テンプレート管理
    """
    
    def __init__(
        self,
        slack_webhook_url: Optional[str] = None,
        email_config: Optional[Dict[str, str]] = None,
        discord_webhook_url: Optional[str] = None,
        min_notification_level: NotificationLevel = NotificationLevel.WARNING
    ):
        """
        初期化
        
        Args:
            slack_webhook_url: Slack Webhook URL
            email_config: メール設定（smtp_server, smtp_port, username, password, recipients）
            discord_webhook_url: Discord Webhook URL
            min_notification_level: 最小通知レベル
        """
        self.slack_webhook_url = slack_webhook_url
        self.email_config = email_config or {}
        self.discord_webhook_url = discord_webhook_url
        self.min_notification_level = min_notification_level
        
        # 通知履歴
        self.notification_history = []
        
        # 統計情報
        self.stats = {
            "total_notifications": 0,
            "slack_notifications": 0,
            "email_notifications": 0,
            "discord_notifications": 0,
            "failed_notifications": 0
        }
        
        # 通知テンプレート
        self._init_templates()
        
        logger.info("✅ NotificationAgent 初期化完了")
    
    def _init_templates(self):
        """通知テンプレートを初期化"""
        self.templates = {
            "fix_success": {
                "title": "✅ 自動修正成功",
                "color": "#36a64f",
                "emoji": "✅"
            },
            "fix_failure": {
                "title": "❌ 自動修正失敗",
                "color": "#ff0000",
                "emoji": "❌"
            },
            "error_detected": {
                "title": "🔍 エラー検出",
                "color": "#ff9900",
                "emoji": "🔍"
            },
            "system_warning": {
                "title": "⚠️ システム警告",
                "color": "#ffcc00",
                "emoji": "⚠️"
            },
            "system_critical": {
                "title": "🚨 システム重大",
                "color": "#cc0000",
                "emoji": "🚨"
            },
            "pr_created": {
                "title": "🌿 PR作成完了",
                "color": "#0366d6",
                "emoji": "🌿"
            }
        }
    
    async def send_notification(
        self,
        message: str,
        level: NotificationLevel = NotificationLevel.INFO,
        channels: Optional[List[NotificationChannel]] = None,
        template_name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        通知を送信
        
        Args:
            message: 通知メッセージ
            level: 通知レベル
            channels: 通知チャネル（省略時は全チャネル）
            template_name: テンプレート名
            metadata: 追加メタデータ
            
        Returns:
            Dict: 送信結果
        """
        try:
            # レベルフィルタリング
            if not self._should_notify(level):
                logger.debug(f"通知スキップ: レベル={level.value}")
                return {"success": True, "skipped": True}
            
            self.stats["total_notifications"] += 1
            
            # チャネルの決定
            if channels is None:
                channels = self._get_available_channels()
            
            # 通知内容を構築
            notification = self._build_notification(
                message=message,
                level=level,
                template_name=template_name,
                metadata=metadata
            )
            
            # 各チャネルに送信
            results = {}
            
            for channel in channels:
                try:
                    if channel == NotificationChannel.SLACK:
                        result = await self._send_slack_notification(notification)
                        results["slack"] = result
                        
                    elif channel == NotificationChannel.EMAIL:
                        result = await self._send_email_notification(notification)
                        results["email"] = result
                        
                    elif channel == NotificationChannel.DISCORD:
                        result = await self._send_discord_notification(notification)
                        results["discord"] = result
                        
                except Exception as e:
                    logger.error(f"❌ {channel.value}通知エラー: {e}")
                    results[channel.value] = {"success": False, "error": str(e)}
                    self.stats["failed_notifications"] += 1
            
            # 履歴に追加
            self.notification_history.append({
                "timestamp": datetime.now().isoformat(),
                "message": message,
                "level": level.value,
                "channels": [c.value for c in channels],
                "results": results
            })
            
            # 古い履歴を削除（直近100件のみ）
            if len(self.notification_history) > 100:
                self.notification_history = self.notification_history[-100:]
            
            logger.info(f"📤 通知送信完了: {message[:50]}...")
            
            return {
                "success": True,
                "channels": results
            }
            
        except Exception as e:
            logger.error(f"❌ 通知送信エラー: {e}", exc_info=True)
            self.stats["failed_notifications"] += 1
            return {
                "success": False,
                "error": str(e)
            }
    
    async def notify_fix_success(
        self,
        task_id: str,
        modified_files: List[str],
        execution_time: float,
        confidence: float
    ):
        """修正成功の通知"""
        message = (
            f"タスク {task_id} の自動修正が成功しました\n"
            f"修正ファイル: {', '.join(modified_files)}\n"
            f"実行時間: {execution_time:.2f}秒\n"
            f"信頼度: {confidence:.1%}"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.SUCCESS,
            template_name="fix_success",
            metadata={
                "task_id": task_id,
                "modified_files": modified_files,
                "execution_time": execution_time,
                "confidence": confidence
            }
        )
    
    async def notify_fix_failure(
        self,
        task_id: str,
        error_message: str
    ):
        """修正失敗の通知"""
        message = (
            f"タスク {task_id} の自動修正が失敗しました\n"
            f"エラー: {error_message}\n"
            f"手動介入が必要です"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.ERROR,
            template_name="fix_failure",
            metadata={
                "task_id": task_id,
                "error_message": error_message
            }
        )
    
    async def notify_system_warning(
        self,
        warning_type: str,
        details: str
    ):
        """システム警告の通知"""
        message = f"システム警告: {warning_type}\n詳細: {details}"
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.WARNING,
            template_name="system_warning",
            metadata={
                "warning_type": warning_type,
                "details": details
            }
        )
    
    async def notify_pr_created(
        self,
        task_id: str,
        pr_url: str,
        branch_name: str
    ):
        """PR作成の通知"""
        message = (
            f"タスク {task_id} の修正PRが作成されました\n"
            f"ブランチ: {branch_name}\n"
            f"PR URL: {pr_url}"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.INFO,
            template_name="pr_created",
            metadata={
                "task_id": task_id,
                "pr_url": pr_url,
                "branch_name": branch_name
            }
        )
    
    # ========================================
    # 内部メソッド
    # ========================================
    
    def _should_notify(self, level: NotificationLevel) -> bool:
        """通知すべきかチェック"""
        level_priority = {
            NotificationLevel.INFO: 0,
            NotificationLevel.SUCCESS: 1,
            NotificationLevel.WARNING: 2,
            NotificationLevel.ERROR: 3,
            NotificationLevel.CRITICAL: 4
        }
        
        return level_priority.get(level, 0) >= level_priority.get(self.min_notification_level, 0)
    
    def _get_available_channels(self) -> List[NotificationChannel]:
        """利用可能なチャネルを取得"""
        channels = []
        
        if self.slack_webhook_url:
            channels.append(NotificationChannel.SLACK)
        
        if self.email_config.get("smtp_server"):
            channels.append(NotificationChannel.EMAIL)
        
        if self.discord_webhook_url:
            channels.append(NotificationChannel.DISCORD)
        
        return channels
    
    def _build_notification(
        self,
        message: str,
        level: NotificationLevel,
        template_name: Optional[str],
        metadata: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """通知内容を構築"""
        template = self.templates.get(template_name, {}) if template_name else {}
        
        return {
            "message": message,
            "level": level.value,
            "title": template.get("title", f"{level.value.upper()} Notification"),
            "color": template.get("color", "#cccccc"),
            "emoji": template.get("emoji", "📢"),
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {}
        }
    
    async def _send_slack_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """Slack通知を送信"""
        if not self.slack_webhook_url:
            return {"success": False, "error": "Slack webhook URL not configured"}
        
        try:
            # Slackペイロード構築
            payload = {
                "text": f"{notification['emoji']} {notification['title']}",
                "attachments": [{
                    "color": notification['color'],
                    "text": notification['message'],
                    "footer": "Hybrid Fix System",
                    "ts": int(datetime.now().timestamp())
                }]
            }
            
            # メタデータを追加
            if notification.get('metadata'):
                fields = []
                for key, value in notification['metadata'].items():
                    fields.append({
                        "title": key,
                        "value": str(value),
                        "short": True
                    })
                payload["attachments"][0]["fields"] = fields
            
            # Webhook送信
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.slack_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        self.stats["slack_notifications"] += 1
                        return {"success": True}
                    else:
                        error_text = await response.text()
                        return {"success": False, "error": f"HTTP {response.status}: {error_text}"}
            
        except Exception as e:
            logger.error(f"❌ Slack通知エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _send_email_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """メール通知を送信"""
        if not self.email_config.get("smtp_server"):
            return {"success": False, "error": "Email not configured"}
        
        try:
            # メール作成
            msg = MIMEMultipart()
            msg['From'] = self.email_config.get("username", "noreply@example.com")
            msg['To'] = self.email_config.get("recipients", "admin@example.com")
            msg['Subject'] = f"{notification['emoji']} {notification['title']}"
            
            # 本文
            body = f"""
{notification['title']}

{notification['message']}

---
Timestamp: {notification['timestamp']}
System: Hybrid Fix System
"""
            
            if notification.get('metadata'):
                body += "\nDetails:\n"
                for key, value in notification['metadata'].items():
                    body += f"  {key}: {value}\n"
            
            msg.attach(MIMEText(body, 'plain'))
            
            # SMTP送信
            await asyncio.to_thread(self._send_smtp_email, msg)
            
            self.stats["email_notifications"] += 1
            return {"success": True}
            
        except Exception as e:
            logger.error(f"❌ メール通知エラー: {e}")
            return {"success": False, "error": str(e)}
    
    def _send_smtp_email(self, msg: MIMEMultipart):
        """SMTP経由でメール送信（同期）"""
        server = smtplib.SMTP(
            self.email_config["smtp_server"],
            int(self.email_config.get("smtp_port", 587))
        )
        server.starttls()
        server.login(
            self.email_config["username"],
            self.email_config["password"]
        )
        server.send_message(msg)
        server.quit()
    
    async def _send_discord_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """Discord通知を送信"""
        if not self.discord_webhook_url:
            return {"success": False, "error": "Discord webhook URL not configured"}
        
        try:
            # Discordペイロード構築
            payload = {
                "content": f"{notification['emoji']} **{notification['title']}**",
                "embeds": [{
                    "description": notification['message'],
                    "color": int(notification['color'].replace('#', ''), 16),
                    "timestamp": notification['timestamp'],
                    "footer": {
                        "text": "Hybrid Fix System"
                    }
                }]
            }
            
            # メタデータを追加
            if notification.get('metadata'):
                fields = []
                for key, value in notification['metadata'].items():
                    fields.append({
                        "name": key,
                        "value": str(value),
                        "inline": True
                    })
                payload["embeds"][0]["fields"] = fields
            
            # Webhook送信
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.discord_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status in [200, 204]:
                        self.stats["discord_notifications"] += 1
                        return {"success": True}
                    else:
                        error_text = await response.text()
                        return {"success": False, "error": f"HTTP {response.status}: {error_text}"}
            
        except Exception as e:
            logger.error(f"❌ Discord通知エラー: {e}")
            return {"success": False, "error": str(e)}
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_notifications"] > 0:
            success_rate = (
                (self.stats["total_notifications"] - self.stats["failed_notifications"]) /
                self.stats["total_notifications"]
            )
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "recent_notifications": self.notification_history[-10:]
        }
    
    def print_stats(self):
        """統計情報を表示"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("📤 通知エージェント 統計情報")
        print("=" * 80)
        print(f"総通知数: {stats['total_notifications']}")
        print(f"成功率: {stats['success_rate']:.1%}")
        print(f"\nチャネル別:")
        print(f"  Slack: {stats['slack_notifications']}回")
        print(f"  メール: {stats['email_notifications']}回")
        print(f"  Discord: {stats['discord_notifications']}回")
        print(f"\n失敗: {stats['failed_notifications']}回")
        print("=" * 80 + "\n")

#patch_manager.py
# patch_manager.py
"""
パッチマネージャー
コードパッチの安全な適用と管理
"""

import asyncio
import logging
import difflib
import hashlib
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from pathlib import Path
from enum import Enum

logger = logging.getLogger(__name__)


class PatchStrategy(Enum):
    """パッチ適用戦略"""
    REPLACE = "replace"          # ファイル全体を置換
    DIFF = "diff"                # 差分パッチを適用
    MERGE = "merge"              # マージ
    SAFE_INSERT = "safe_insert"  # 安全な挿入


class PatchManager:
    """
    パッチマネージャー
    
    機能:
    - 安全なコードパッチ適用
    - バックアップ管理
    - 差分生成
    - ロールバック機能
    - パッチ検証
    """
    
    def __init__(
        self,
        backup_dir: str = "./backups/patches",
        max_backups: int = 10
    ):
        """
        初期化
        
        Args:
            backup_dir: バックアップディレクトリ
            max_backups: 保持する最大バックアップ数
        """
        self.backup_dir = Path(backup_dir)
        self.max_backups = max_backups
        
        # バックアップディレクトリ作成
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # パッチ履歴
        self.patch_history = []
        
        # 統計情報
        self.stats = {
            "total_patches": 0,
            "successful_patches": 0,
            "failed_patches": 0,
            "rollbacks": 0
        }
        
        logger.info(f"✅ PatchManager 初期化完了 (backup_dir={backup_dir})")
    
    async def apply_patch(
        self,
        file_path: str,
        new_content: str,
        strategy: PatchStrategy = PatchStrategy.REPLACE,
        verify: bool = True
    ) -> Dict[str, Any]:
        """
        パッチを適用
        
        Args:
            file_path: 対象ファイルパス
            new_content: 新しい内容
            strategy: 適用戦略
            verify: 適用前の検証フラグ
            
        Returns:
            Dict: 適用結果
        """
        start_time = datetime.now()
        file_path_obj = Path(file_path)
        
        try:
            logger.info("=" * 60)
            logger.info(f"🔧 パッチ適用開始: {file_path}")
            logger.info(f"📊 戦略: {strategy.value}")
            logger.info("=" * 60)
            
            self.stats["total_patches"] += 1
            
            # ファイルが存在しない場合
            if not file_path_obj.exists():
                logger.warning(f"⚠️ ファイルが存在しません: {file_path}")
                return await self._create_new_file(file_path, new_content)
            
            # 現在の内容を読み込み
            old_content = await asyncio.to_thread(
                file_path_obj.read_text,
                encoding='utf-8'
            )
            
            # 変更がない場合
            if old_content == new_content:
                logger.info("ℹ️ 内容に変更はありません")
                return {
                    "success": True,
                    "changed": False,
                    "message": "No changes"
                }
            
            # 検証
            if verify:
                validation_result = await self._validate_patch(
                    old_content,
                    new_content
                )
                
                if not validation_result["valid"]:
                    self.stats["failed_patches"] += 1
                    return {
                        "success": False,
                        "error": f"Validation failed: {validation_result['reason']}"
                    }
            
            # バックアップ作成
            backup_path = await self._create_backup(file_path, old_content)
            logger.info(f"💾 バックアップ作成: {backup_path}")
            
            # 戦略に応じてパッチ適用
            if strategy == PatchStrategy.REPLACE:
                apply_result = await self._apply_replace(file_path_obj, new_content)
            
            elif strategy == PatchStrategy.DIFF:
                apply_result = await self._apply_diff(
                    file_path_obj,
                    old_content,
                    new_content
                )
            
            elif strategy == PatchStrategy.MERGE:
                apply_result = await self._apply_merge(
                    file_path_obj,
                    old_content,
                    new_content
                )
            
            elif strategy == PatchStrategy.SAFE_INSERT:
                apply_result = await self._apply_safe_insert(
                    file_path_obj,
                    old_content,
                    new_content
                )
            
            else:
                self.stats["failed_patches"] += 1
                return {
                    "success": False,
                    "error": f"Unsupported strategy: {strategy}"
                }
            
            if apply_result["success"]:
                self.stats["successful_patches"] += 1
                
                # 差分情報を生成
                diff = self._generate_diff(old_content, new_content)
                
                # 履歴に追加
                self.patch_history.append({
                    "file_path": file_path,
                    "timestamp": datetime.now().isoformat(),
                    "strategy": strategy.value,
                    "backup_path": str(backup_path),
                    "success": True
                })
                
                execution_time = (datetime.now() - start_time).total_seconds()
                
                logger.info(f"✅ パッチ適用成功: {file_path} ({execution_time:.2f}秒)")
                
                return {
                    "success": True,
                    "changed": True,
                    "backup_path": str(backup_path),
                    "diff": diff,
                    "execution_time": execution_time
                }
            
            else:
                self.stats["failed_patches"] += 1
                
                # ロールバック
                await self._rollback_from_backup(file_path, backup_path)
                
                return apply_result
            
        except Exception as e:
            logger.error(f"💥 パッチ適用エラー: {e}", exc_info=True)
            self.stats["failed_patches"] += 1
            
            return {
                "success": False,
                "error": str(e)
            }
    
    async def rollback(
        self,
        file_path: str,
        backup_path: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        パッチをロールバック
        
        Args:
            file_path: 対象ファイル
            backup_path: バックアップパス（省略時は最新）
            
        Returns:
            Dict: ロールバック結果
        """
        try:
            logger.info(f"♻️ ロールバック開始: {file_path}")
            
            if not backup_path:
                # 最新のバックアップを検索
                backup_path = await self._find_latest_backup(file_path)
            
            if not backup_path:
                return {
                    "success": False,
                    "error": "No backup found"
                }
            
            backup_path_obj = Path(backup_path)
            
            if not backup_path_obj.exists():
                return {
                    "success": False,
                    "error": f"Backup not found: {backup_path}"
                }
            
            # バックアップから復元
            result = await self._rollback_from_backup(file_path, backup_path_obj)
            
            if result["success"]:
                self.stats["rollbacks"] += 1
                logger.info(f"✅ ロールバック成功: {file_path}")
            
            return result
            
        except Exception as e:
            logger.error(f"💥 ロールバックエラー: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # パッチ適用戦略
    # ========================================
    
    async def _apply_replace(
        self,
        file_path: Path,
        new_content: str
    ) -> Dict[str, Any]:
        """ファイル全体を置換"""
        try:
            await asyncio.to_thread(
                file_path.write_text,
                new_content,
                encoding='utf-8'
            )
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"❌ 置換エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _apply_diff(
        self,
        file_path: Path,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """差分パッチを適用"""
        try:
            # unified diffを生成
            diff = list(difflib.unified_diff(
                old_content.splitlines(keepends=True),
                new_content.splitlines(keepends=True),
                fromfile=str(file_path),
                tofile=str(file_path)
            ))
            
            if not diff:
                return {"success": True, "message": "No differences"}
            
            # 新しい内容を適用（実際にはunified diffの適用ロジックが必要）
            # 簡易版として全置換
            await asyncio.to_thread(
                file_path.write_text,
                new_content,
                encoding='utf-8'
            )
            
            return {
                "success": True,
                "diff_lines": len(diff)
            }
            
        except Exception as e:
            logger.error(f"❌ 差分適用エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _apply_merge(
        self,
        file_path: Path,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """マージ適用（3-way merge的な処理）"""
        try:
            # 簡易版: 行単位でマージ
            old_lines = old_content.splitlines()
            new_lines = new_content.splitlines()
            
            merged_lines = []
            
            # SequenceMatcherでマッチング
            matcher = difflib.SequenceMatcher(None, old_lines, new_lines)
            
            for tag, i1, i2, j1, j2 in matcher.get_opcodes():
                if tag == 'equal':
                    merged_lines.extend(old_lines[i1:i2])
                elif tag == 'replace':
                    merged_lines.extend(new_lines[j1:j2])
                elif tag == 'delete':
                    pass  # 削除
                elif tag == 'insert':
                    merged_lines.extend(new_lines[j1:j2])
            
            merged_content = '\n'.join(merged_lines)
            
            await asyncio.to_thread(
                file_path.write_text,
                merged_content,
                encoding='utf-8'
            )
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"❌ マージエラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _apply_safe_insert(
        self,
        file_path: Path,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """安全な挿入（既存コードを保護）"""
        try:
            # 既存の内容の終わりに追加
            combined_content = old_content + "\n\n# Auto-generated patch\n" + new_content
            
            await asyncio.to_thread(
                file_path.write_text,
                combined_content,
                encoding='utf-8'
            )
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"❌ 安全挿入エラー: {e}")
            return {"success": False, "error": str(e)}
    
    # ========================================
    # 検証
    # ========================================
    
    async def _validate_patch(
        self,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """パッチを検証"""
        try:
            # 基本的な構文チェック（Pythonの場合）
            try:
                compile(new_content, '<string>', 'exec')
            except SyntaxError as e:
                return {
                    "valid": False,
                    "reason": f"Syntax error: {e}"
                }
            
            # サイズチェック
            size_diff = len(new_content) - len(old_content)
            if abs(size_diff) > len(old_content) * 2:  # 2倍以上の変更
                logger.warning(f"⚠️ 大幅なサイズ変更: {size_diff}文字")
            
            # インデントチェック
            if '\t' in new_content and '    ' in new_content:
                logger.warning("⚠️ タブとスペースが混在しています")
            
            return {"valid": True}
            
        except Exception as e:
            logger.error(f"❌ 検証エラー: {e}")
            return {
                "valid": False,
                "reason": str(e)
            }
    
    # ========================================
    # バックアップ管理
    # ========================================
    
    async def _create_backup(
        self,
        file_path: str,
        content: str
    ) -> Path:
        """バックアップを作成"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = Path(file_path).name
            
            # ハッシュを生成（ファイル識別用）
            content_hash = hashlib.md5(content.encode()).hexdigest()[:8]
            
            backup_filename = f"{file_name}_{timestamp}_{content_hash}.bak"
            backup_path = self.backup_dir / backup_filename
            
            await asyncio.to_thread(
                backup_path.write_text,
                content,
                encoding='utf-8'
            )
            
            # 古いバックアップを削除
            await self._cleanup_old_backups(file_name)
            
            return backup_path
            
        except Exception as e:
            logger.error(f"❌ バックアップ作成エラー: {e}")
            raise
    
    async def _rollback_from_backup(
        self,
        file_path: str,
        backup_path: Path
    ) -> Dict[str, Any]:
        """バックアップから復元"""
        try:
            content = await asyncio.to_thread(
                backup_path.read_text,
                encoding='utf-8'
            )
            
            file_path_obj = Path(file_path)
            await asyncio.to_thread(
                file_path_obj.write_text,
                content,
                encoding='utf-8'
            )
            
            logger.info(f"♻️ 復元成功: {file_path} ← {backup_path}")
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"❌ 復元エラー: {e}")
            return {"success": False, "error": str(e)}
    
    async def _find_latest_backup(self, file_path: str) -> Optional[str]:
        """最新のバックアップを検索"""
        try:
            file_name = Path(file_path).name
            
            # ファイル名でフィルタリング
            backups = list(self.backup_dir.glob(f"{file_name}_*.bak"))
            
            if not backups:
                return None
            
            # 最新のものを取得（タイムスタンプでソート）
            latest_backup = max(backups, key=lambda p: p.stat().st_mtime)
            
            return str(latest_backup)
            
        except Exception as e:
            logger.error(f"❌ バックアップ検索エラー: {e}")
            return None
    
    async def _cleanup_old_backups(self, file_name: str):
        """古いバックアップを削除"""
        try:
            backups = sorted(
                self.backup_dir.glob(f"{file_name}_*.bak"),
                key=lambda p: p.stat().st_mtime,
                reverse=True
            )
            
            # 上限を超えたバックアップを削除
            for backup in backups[self.max_backups:]:
                await asyncio.to_thread(backup.unlink)
                logger.debug(f"🗑️ 古いバックアップを削除: {backup}")
                
        except Exception as e:
            logger.warning(f"⚠️ バックアップクリーンアップエラー: {e}")
    
    async def _create_new_file(
        self,
        file_path: str,
        content: str
    ) -> Dict[str, Any]:
        """新しいファイルを作成"""
        try:
            file_path_obj = Path(file_path)
            file_path_obj.parent.mkdir(parents=True, exist_ok=True)
            
            await asyncio.to_thread(
                file_path_obj.write_text,
                content,
                encoding='utf-8'
            )
            
            logger.info(f"✅ 新規ファイル作成: {file_path}")
            
            self.stats["successful_patches"] += 1
            
            return {
                "success": True,
                "new_file": True
            }
            
        except Exception as e:
            logger.error(f"❌ ファイル作成エラー: {e}")
            self.stats["failed_patches"] += 1
            
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # ユーティリティ
    # ========================================
    
    def _generate_diff(
        self,
        old_content: str,
        new_content: str
    ) -> str:
        """差分を生成"""
        diff = difflib.unified_diff(
            old_content.splitlines(keepends=True),
            new_content.splitlines(keepends=True),
            lineterm=''
        )
        
        return ''.join(diff)
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_patches"] > 0:
            success_rate = self.stats["successful_patches"] / self.stats["total_patches"]
        
        return {
            **self.stats,
            "success_rate": success_rate
        }

#pm_agent.py
import asyncio
import json
import logging
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime

from config_utils import config, ErrorHandler
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_system_prompts import PM_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class PMAgent:
    """PM AI - プロジェクト管理とタスク分解を担当"""
    
    def __init__(self, sheets_manager: GoogleSheetsManager, browser_controller: BrowserController):
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.current_goal = None
        self.generated_tasks = []
        self.system_prompt = PM_SYSTEM_PROMPT
    
    async def load_project_goal(self) -> Optional[Dict]:
        """project_goalシートから最新のアクティブな目標を読み込む"""
        try:
            logger.info("プロジェクト目標を読み込み中...")
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            
            try:
                goal_sheet = sheet.worksheet("project_goal")
            except:
                logger.error("'project_goal'シートが見つかりません")
                return None
            
            all_values = goal_sheet.get_all_values()
            
            if len(all_values) <= 1:
                logger.warning("目標が設定されていません")
                return None
            
            for row in all_values[1:]:
                if len(row) >= 3 and row[2].lower() == 'active':
                    goal = {
                        'goal_id': row[0],
                        'description': row[1],
                        'status': row[2],
                        'created_at': row[3] if len(row) > 3 else ''
                    }
                    logger.info(f"目標を読み込みました: {goal['description']}")
                    self.current_goal = goal
                    return goal
            
            logger.warning("アクティブな目標が見つかりません")
            return None
            
        except Exception as e:
            ErrorHandler.log_error(e, "目標読み込み")
            raise
    async def analyze_and_create_tasks(self, goal_description: str) -> Dict:
        """目標を分析してタスクを生成"""
        try:
            # === パート1: 開始ヘッダー表示 ===
            logger.info("="*60)
            logger.info("PM AI: タスク分解を開始します")
            logger.info("="*60)
    
            # === パート2: プロンプト構築 ===
            full_prompt = f"""{self.system_prompt}

    【プロジェクト目標】
    {goal_description}

    【重要な出力指示】
    1. **必ず有効なJSON形式のみで出力してください**
    2. 説明文、コメント、挨拶などは一切不要です
    3. 最初の文字が {{ で、最後の文字が }} の完全なJSON形式のみを出力してください
    4. **タスク数は最大15個まで**とし、JSONが長くなりすぎないようにしてください
    5. すべての文字列値は正しくダブルクォーテーションで囲んでください

    上記の目標を達成するために必要なタスクを、JSON形式で出力してください。"""
    
            # === パート3: Geminiへの送信 ===
            logger.info("Geminiに送信中...")
            await self.browser.send_prompt(full_prompt)
    
            # === パート4: 応答待機 ===
            logger.info("PM AIの分析を待機中...")
            success = await self.browser.wait_for_text_generation(max_wait=180)
    
            if not success:
                raise Exception("PM AIのタスク生成がタイムアウトしました")
    
            # === パート5: 応答テキストの抽出 ===
            response_text = await self.browser.extract_latest_text_response()
    
            if not response_text:
                raise Exception("PM AIからの応答が取得できませんでした")
    
            logger.info(f"PM AIの応答を取得しました（{len(response_text)}文字）")
            logger.info(f"応答の先頭500文字:\n{response_text[:500]}")
            logger.info(f"応答の末尾500文字:\n{response_text[-500:]}")
    
            # === パート6: JSONレスポンスの解析 ===
            task_plan = self._parse_json_response(response_text)
    
            if task_plan:
                # === パート7: 成功時の処理 ===
                logger.info("="*60)
                logger.info("PM AI: タスク分解完了")
                logger.info(f"生成されたタスク数: {len(task_plan.get('tasks', []))}")
                logger.info("="*60)
                self.generated_tasks = task_plan.get('tasks', [])
                return task_plan
            else:
                # === パート8: JSON解析失敗時のフォールバック処理 ===
                logger.error("JSON解析に失敗しました。応答全体を保存します。")
                fallback_path = Path("pm_ai_response_error.txt")
                with open(fallback_path, 'w', encoding='utf-8') as f:
                    f.write(response_text)
                logger.info(f"応答を保存しました: {fallback_path}")
        
                logger.error("="*60)
                logger.error("❌ 自動修復も失敗しました")
                logger.error("="*60)
        
                # === パート9: 修正済みファイルのチェック ===
                fixed_path = Path("pm_ai_response_fixed.json")
                if fixed_path.exists():
                    logger.info("修正済みファイルを検出しました!")
                    try:
                        with open(fixed_path, 'r', encoding='utf-8') as f:
                            task_plan = json.load(f)
                        logger.info(f"✅ 修正済みJSONを読み込みました: タスク数={len(task_plan.get('tasks', []))}")
                        self.generated_tasks = task_plan.get('tasks', [])
                        return task_plan
                    except Exception as e:
                        logger.error(f"修正済みファイルの読み込みに失敗: {e}")
        
                raise Exception("PM AIの応答をJSON形式でパースできませんでした")
    
        except Exception as e:
            ErrorHandler.log_error(e, "タスク生成")
            raise
        
        
    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """応答からJSON部分を抽出してパース（強化版）"""
        try:
            # === パート1: 入力検証 ===
            if not text:
                logger.warning("空の応答テキスト")
                return None
            
            # === パート2: 解析開始ヘッダー ===
            logger.info("="*60)
            logger.info("JSON解析開始")
            logger.info("="*60)
            logger.info(f"応答全体の長さ: {len(text)}文字")
            
            import re
            
            # === パート3: パターン1 - ```json ... ``` 形式の検出 ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                logger.info("✅ パターン1: ```json...``` 形式を検出")
                try:
                    result = json.loads(json_str)
                    logger.info(f"✅ JSON解析成功（パターン1）: タスク数={len(result.get('tasks', []))}")
                    return result
                except json.JSONDecodeError as e:
                    logger.warning(f"パターン1でJSON解析失敗: {e}")
            
            # === パート4: パターン2 - 中括弧のバランスを考慮した抽出 ===
            start_idx = text.find('{')
            if start_idx != -1:
                logger.info(f"✅ '{{' を位置 {start_idx} で検出")
                
                # === パート5: バランスの取れたJSONオブジェクトの検出 ===
                brace_count = 0
                in_string = False
                escape_next = False
                
                for i, char in enumerate(text[start_idx:], start=start_idx):
                    if escape_next:
                        escape_next = False
                        continue
                    
                    if char == '\\':
                        escape_next = True
                        continue
                    
                    if char == '"' and not escape_next:
                        in_string = not in_string
                        continue
                    
                    if not in_string:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                # === パート6: 完全なJSONオブジェクトの抽出と解析 ===
                                potential_json = text[start_idx:i+1]
                                logger.info(f"✅ 完全なJSONオブジェクトを抽出: {len(potential_json)}文字")
                                
                                try:
                                    result = json.loads(potential_json)
                                    logger.info(f"✅ JSON解析成功: タスク数={len(result.get('tasks', []))}")
                                    return result
                                except json.JSONDecodeError as e:
                                    # === パート7: 解析エラーの詳細ログ ===
                                    logger.error(f"❌ JSON解析エラー: {e}")
                                    logger.error(f"エラー位置: line {e.lineno}, column {e.colno}")
                                    
                                    error_pos = e.pos if hasattr(e, 'pos') else 0
                                    context_start = max(0, error_pos - 100)
                                    context_end = min(len(potential_json), error_pos + 100)
                                    logger.error(f"エラー周辺のテキスト:\n{potential_json[context_start:context_end]}")
                                    
                                    # === パート8: JSON修復の試行 ===
                                    repaired_json = self._attempt_json_repair(potential_json, e)
                                    if repaired_json:
                                        return repaired_json
            
            # === パート9: パターン3 - テキスト全体をJSONとして解析 ===
            logger.info("パターン3: テキスト全体をJSONとして解析")
            try:
                result = json.loads(text)
                logger.info(f"✅ JSON解析成功（全体解析）: タスク数={len(result.get('tasks', []))}")
                return result
            except json.JSONDecodeError as e:
                logger.error(f"❌ 全体解析も失敗: {e}")
            
            # === パート10: 全パターン失敗時のエラーログ ===
            logger.error("="*60)
            logger.error("❌ すべてのJSON解析パターンが失敗")
            logger.error("="*60)
            logger.error(f"応答の先頭500文字:\n{text[:500]}")
            logger.error(f"応答の末尾500文字:\n{text[-500:]}")
            
            return None
            
        except Exception as e:
            # === パート11: 予期しない例外の処理 ===
            logger.error(f"❌ JSON解析で予期しないエラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _attempt_json_repair(self, json_str: str, error: json.JSONDecodeError) -> Optional[Dict]:
        """壊れたJSONの修復を試みる"""
        try:
            # === パート1: 修復開始 ===
            logger.info("🔧 JSON修復を試みます...")
            
            error_pos = error.pos if hasattr(error, 'pos') else len(json_str)
            
            # === パート2: 修復試行1 - デリミタエラーの修正 ===
            if "Expecting ',' delimiter" in str(error) or "Expecting ':' delimiter" in str(error):
                last_complete_task = json_str.rfind('},', 0, error_pos)
                if last_complete_task > 0:
                    repaired = json_str[:last_complete_task + 1] + '], "risks": [], "success_criteria": []}'
                    logger.info(f"修復試行1: 位置{last_complete_task}で切り捨て")
                    try:
                        result = json.loads(repaired)
                        logger.info(f"✅ 修復成功! タスク数={len(result.get('tasks', []))}")
                        return result
                    except:
                        pass
            
            # === パート3: 修復試行2 - 行ベースの切り捨て ===
            lines = json_str.split('\n')
            error_line = error.lineno if hasattr(error, 'lineno') else len(lines)
            
            if error_line > 0 and error_line <= len(lines):
                truncated_lines = lines[:error_line-1]
                truncated = '\n'.join(truncated_lines)
                open_braces = truncated.count('{') - truncated.count('}')
                
                repaired = truncated
                if ',"tasks":[' in repaired and not repaired.rstrip().endswith(']'):
                    repaired += ']'
                
                # === パート4: 開いた中括弧を閉じる ===
                for _ in range(open_braces):
                    repaired += '}'
                
                logger.info("修復試行2: 不完全な部分を削除して閉じる")
                try:
                    result = json.loads(repaired)
                    logger.info(f"✅ 修復成功! タスク数={len(result.get('tasks', []))}")
                    return result
                except:
                    pass
            
            # === パート5: 修復失敗 ===
            logger.warning("❌ JSON修復に失敗")
            return None
            
        except Exception as e:
            logger.error(f"JSON修復中のエラー: {e}")
            return None
        
    async def save_tasks_to_sheet(self, task_plan: Dict) -> bool:
        """生成されたタスクをスプレッドシートに保存（追加方式）"""
        try:
            # === パート1: 保存開始 ===
            logger.info("タスクをスプレッドシートに保存中...")
        
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                # === パート2: 既存シートの読み込み ===
                task_sheet = sheet.worksheet("pm_tasks")
                existing_data = task_sheet.get_all_values()
                start_row = len(existing_data) + 1
            
                if len(existing_data) == 0:
                    # === パート3: 新規シートのヘッダー作成 ===
                    headers = [
                        "task_id", "parent_goal_id", "task_description", 
                        "required_role", "status", "priority", 
                        "estimated_time", "dependencies", "created_at", "batch_id"
                    ]
                    task_sheet.update('A1:J1', [headers])
                    start_row = 2
                
            except:
                # === パート4: シートが存在しない場合の作成 ===
                logger.info("'pm_tasks'シートを作成します")
                task_sheet = sheet.add_worksheet(title="pm_tasks", rows=1000, cols=10)
                headers = [
                    "task_id", "parent_goal_id", "task_description", 
                    "required_role", "status", "priority", 
                    "estimated_time", "dependencies", "created_at", "batch_id"
                ]
                task_sheet.update('A1:J1', [headers])
                start_row = 2
                existing_data = []
        
            # === パート5: バッチIDの生成 ===
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            # === パート6: 既存タスクIDの収集 ===
            existing_task_ids = []
            if len(existing_data) > 1:
                for row in existing_data[1:]:
                    if row and row[0].isdigit():
                        existing_task_ids.append(int(row[0]))
        
            # === パート7: 次のタスクIDの決定 ===
            next_task_id = max(existing_task_ids) + 1 if existing_task_ids else 1
        
            # === パート8: タスクデータの準備 ===
            tasks = task_plan.get('tasks', [])
            rows_data = []
        
            for i, task in enumerate(tasks):
                row = [
                    next_task_id + i,
                    self.current_goal['goal_id'] if self.current_goal else '',
                    task.get('description', ''),
                    task.get('required_role', 'dev'),
                    'pending',
                    task.get('priority', 'medium'),
                    task.get('estimated_time', ''),
                    ','.join(map(str, task.get('dependencies', []))),
                    datetime.now().isoformat(),
                    batch_id
                ]
                rows_data.append(row)
        
            # === パート9: スプレッドシートへの書き込み ===
            if rows_data:
                end_row = start_row + len(rows_data) - 1
                task_sheet.update(f'A{start_row}:J{end_row}', rows_data)
                logger.info(f"タスク {len(rows_data)} 件を追加しました（バッチ: {batch_id}）")
        
            # === パート10: メタデータの保存 ===
            self._save_project_metadata(task_plan)
        
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "タスク保存")
            return False
    
    def _save_project_metadata(self, task_plan: Dict):
        """プロジェクトのメタ情報（分析結果、リスク、成功基準）を保存（追加方式）"""
        try:
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                meta_sheet = sheet.worksheet("project_metadata")
                existing_data = meta_sheet.get_all_values()
                start_row = len(existing_data) + 2
            except:
                meta_sheet = sheet.add_worksheet(title="project_metadata", rows=100, cols=5)
                existing_data = []
                start_row = 1
        
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            data = [
                ["バッチID", batch_id],
                ["目標ID", self.current_goal['goal_id'] if self.current_goal else ''],
                ["分析結果", task_plan.get('project_analysis', '')],
                ["", ""],
                ["リスク", ""],
            ]
        
            for risk in task_plan.get('risks', []):
                data.append(["", risk])
        
            data.append(["", ""])
            data.append(["成功基準", ""])
        
            for criteria in task_plan.get('success_criteria', []):
                data.append(["", criteria])
        
            if existing_data:
                data = [["", ""], ["="*50, "="*50]] + data
        
            end_row = start_row + len(data) - 1
            meta_sheet.update(f'A{start_row}:B{end_row}', data)
            logger.info("プロジェクトメタデータを保存しました")
        
        except Exception as e:
            logger.warning(f"メタデータ保存に失敗: {e}")
    
    def display_task_summary(self, task_plan: Dict):
        """タスク概要を表示"""
        print("\n" + "="*60)
        print("PM AIによるタスク分解結果")
        print("="*60)
        
        print(f"\n【プロジェクト分析】")
        print(task_plan.get('project_analysis', ''))
        
        print(f"\n【生成されたタスク: {len(task_plan.get('tasks', []))}件】")
        for i, task in enumerate(task_plan.get('tasks', []), 1):
            role_icon = {
                'design': '📐',
                'dev': '💻',
                'ui': '🎨',
                'review': '✅'
            }.get(task.get('required_role', 'dev'), '📋')
            
            priority_icon = {
                'high': '🔴',
                'medium': '🟡',
                'low': '🟢'
            }.get(task.get('priority', 'medium'), '⚪')
            
            print(f"{i}. {priority_icon} {role_icon} {task.get('description', '')}")
            print(f"   担当: {task.get('required_role', 'dev')} | 優先度: {task.get('priority', 'medium')}")
            if task.get('dependencies'):
                print(f"   依存: タスク {task.get('dependencies')}")
            print()
        
        if task_plan.get('risks'):
            print(f"\n【想定リスク】")
            for risk in task_plan.get('risks', []):
                print(f"- {risk}")
        
        if task_plan.get('success_criteria'):
            print(f"\n【成功基準】")
            for criteria in task_plan.get('success_criteria', []):
                print(f"- {criteria}")
        
        print("="*60)

async def main():
    """PM AI単体テスト用のメイン関数"""
    import argparse
        
    # === パート1: 引数解析 ===
    parser = argparse.ArgumentParser(description='PM AI - タスク分解エージェント')
    parser.add_argument('--goal', type=str, help='直接目標を指定する（スプレッドシートを使わない場合）')
    args = parser.parse_args()
        
    # === パート2: 起動ヘッダー ===
    print("="*60)
    print("PM AI起動中...")
    print("="*60)
        
    # === パート3: サービスアカウント設定 ===
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
        
    # === パート4: シートマネージャー初期化 ===
    sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
    # === パート5: PC設定の読み込み ===
    pc_id = sheets_manager.get_current_pc_id()
    settings = sheets_manager.load_pc_settings(pc_id)
        
    config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
    config.COOKIES_FILE = settings.get('cookies_file')
    config.GENERATION_MODE = 'text'
    config.SERVICE_TYPE = 'google'
        
    # === パート6: ダウンロードフォルダ設定 ===
    download_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\temp_texts")
    download_folder.mkdir(exist_ok=True, parents=True)
        
    # === パート7: ブラウザコントローラーの初期化 ===
    browser = BrowserController(download_folder, mode='text', service='google')
    await browser.setup_browser()
        
    logger.info("Geminiにアクセス中...")
    await browser.navigate_to_gemini()
        
    # === パート8: PMエージェントの初期化 ===
    pm_agent = PMAgent(sheets_manager, browser)
        
    # === パート9: 目標の取得（コマンドライン or シート）===
    if args.goal:
        goal_description = args.goal
        logger.info(f"コマンドラインから目標を取得: {goal_description}")
    else:
        goal = await pm_agent.load_project_goal()
        if not goal:
            print("\nエラー: アクティブな目標が見つかりません")
            print("スプレッドシートの'project_goal'シートにstatusが'active'の目標を設定してください")
            await browser.cleanup()
            return
        goal_description = goal['description']
        
    try:
        # === パート10: タスク計画の生成 ===
        task_plan = await pm_agent.analyze_and_create_tasks(goal_description)
            
        # === パート11: タスク概要の表示 ===
        pm_agent.display_task_summary(task_plan)
            
        # === パート12: ユーザー確認と保存 ===
        save = input("\nタスクをスプレッドシートに保存しますか？ (y/n): ")
        if save.lower() == 'y':
            success = await pm_agent.save_tasks_to_sheet(task_plan)
            if success:
                print("タスクを保存しました")
            else:
                print("保存に失敗しました")
            
    except Exception as e:
        # === パート13: 例外処理 ===
        logger.error(f"PM AI実行エラー: {e}")
        import traceback
        traceback.print_exc()
        
    finally:
        # === パート14: クリーンアップ ===
        await browser.cleanup()
        print("\nPM AIを終了しました")

if __name__ == "__main__":
    asyncio.run(main())


#pm_system_prompts.py
"""
PM AIのシステムプロンプト定義（完全版）
ACF & Custom Post Type UI 対応
"""

PM_SYSTEM_PROMPT = """あなたは経験豊富なプロジェクトマネージャーAIです。

【あなたの役割】
- プロジェクトの目標を分析し、達成に必要なタスクに分解する
- 各タスクに適切な担当者（AI エージェント）を割り当てる
- **多言語対応プロジェクトでは、必ず言語とPolylang設定を明記する**
- **開発タスクは原則WordPressで実装可能か検討する**
- タスクの優先順位を決定する
- 実現可能で具体的なタスクを作成する

【重要: WordPress優先開発ポリシー】
このプロジェクトは **WordPress中心の開発スタイル** を採用しています。
以下の優先順位でエージェントを選択してください:

**優先度1: WordPress標準機能 + プラグイン実装**
- カスタム投稿タイプ → **wordpress**: Custom Post Type UI でGUI設定
- カスタムフィールド → **wordpress**: Advanced Custom Fields (ACF) でGUI設定
- データベース設計 → **design**: ACF設計書作成 → **wordpress**: ACF設定
- UI/画面デザイン → **ui**: デザイン設計 → **wordpress**: テーマカスタマイズ
- 検索・絞り込み → **wordpress**: FacetWP / SearchWP / Relevanssi設定
- フォーム作成 → **wordpress**: ACFフォーム / Contact Form 7設定
- ユーザー管理 → **wordpress**: User Role Editor / Members設定

**優先度2: 軽量カスタム開発（プラグイン活用後の微調整）**
- ACF連携カスタマイズ → **dev**: functions.php追記
- 検索クエリ調整 → **dev**: pre_get_posts フック実装
- 表示カスタマイズ → **dev**: テンプレートファイル作成

**優先度3: 高度な開発（WordPress標準で実現困難な場合のみ）**
- 複雑なビジネスロジック → **dev**: カスタムプラグイン開発
- 外部API連携 → **dev**: REST API統合
- 特殊なアーキテクチャ → **design**: システム設計 → **dev**: 実装

**判断基準:**
「WordPressの標準機能やプラグインで実現できるか？」
→ YES: wordpress / plugin エージェント
→ NO: design → dev エージェント

【利用可能なAIエージェント】

**開発・設計系エージェント:**
- **design** (設計AI): システム設計、アーキテクチャ設計、要件定義書作成、データベース設計、API仕様書作成、ACFフィールド設計書作成
- **dev** (開発AI): コーディング、テストコード作成、実装、複数言語対応（Python, JavaScript, PHP など）、functions.php カスタマイズ
- **ui** (UI/UX AI): ユーザーインターフェース設計、画面設計、UX最適化、ワイヤーフレーム作成

**コンテンツ作成系エージェント:**
- **writer** (汎用ライターAI): ブログ記事作成、HTML記事執筆、SEOコンテンツ作成（後方互換性のため残す）
- **writer_ja** (日本語ライターAI): 日本語記事作成、品質重視、日本のビジネスオーナー向け
- **writer_en** (英語ライターAI): 英語記事作成、SEO最適化、国際投資家向け
- **writer_ru** (ロシア語ライターAI): ロシア語記事作成、現地ビジネス向け
- **writer_uz** (ウズベク語ライターAI): ウズベク語記事作成、現地企業向け
- **writer_zh** (中国語ライターAI): 中国語記事作成、中国投資家向け
- **writer_ko** (韓国語ライターAI): 韓国語記事作成、韓国ビジネス向け
- **writer_tr** (トルコ語ライターAI): トルコ語記事作成、トルコビジネス向け
- **content** (コンテンツAI): writerのエイリアス（後方互換性）

**WordPress・プラグイン系エージェント:**
- **wordpress** (WordPressAI): WordPress投稿、記事公開、記事編集、Polylang言語設定、下書き保存、ACF設定、Custom Post Type UI設定、テーマカスタマイズ
- **plugin** (プラグインAI): WordPressプラグイン管理、インストール、設定変更、プラグイン選定

**品質管理系エージェント:**
- **review** (レビューAI): 品質チェック、コードレビュー、記事レビュー、出力物評価

【重要: インストール済みプラグイン】
以下のプラグインはすでにインストール済みです。これらを活用したタスクを作成してください：
- Advanced Custom Fields (ACF) Pro
- Custom Post Type UI
- Polylang Pro
- FacetWP（検索機能強化）
- User Role Editor（ユーザー権限管理）
- Wordfence Security（セキュリティ）
- WP Rocket（キャッシュ・パフォーマンス）

【重要: ACF & Custom Post Type UI 設定タスクのルール】

**ACF設定タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【ACF設定】M&A案件用カスタムフィールド作成",
  "acf_field_group_name": "M&A案件基本情報",
  "acf_fields": [
    {"name": "case_id", "type": "text", "label": "案件ID", "required": true},
    {"name": "ma_scheme", "type": "select", "label": "M&Aスキーム", "choices": ["株式譲渡", "事業譲渡"]},
    {"name": "desired_price", "type": "number", "label": "希望価格", "min": 0}
  ],
  "acf_location_rules": {
    "post_type": "ma_case"
  }
}
```

**使用可能なACFフィールドタイプ:**
- テキスト系: text, textarea, number, email, url, password
- 選択系: select, checkbox, radio, true_false
- 日付時刻系: date_picker, date_time_picker, time_picker
- ファイル系: file, image, gallery
- リレーション系: post_object, relationship, taxonomy, user
- レイアウト系: repeater, flexible_content, group
- その他: wysiwyg, oembed, google_map, color_picker

**Custom Post Type設定タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【Custom Post Type】M&A案件投稿タイプ作成",
  "cpt_slug": "ma_case",
  "cpt_labels": {
    "singular": "M&A案件",
    "plural": "M&A案件一覧"
  },
  "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"],
  "cpt_settings": {
    "public": true,
    "has_archive": true,
    "show_in_rest": true,
    "menu_icon": "dashicons-portfolio"
  }
}
```

**カスタムタクソノミー設定タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【タクソノミー】業種カテゴリ作成",
  "taxonomy_slug": "industry_category",
  "taxonomy_labels": {
    "singular": "業種",
    "plural": "業種一覧"
  },
  "taxonomy_post_types": ["ma_case"],
  "taxonomy_hierarchical": true
}
```

**M&A案件投稿タスクに必須の情報:**
```json
{
  "agent": "wordpress",
  "description": "【M&A案件登録】製造業の事業承継案件投稿",
  "post_title": "製造業・年商5億円・黒字企業の事業承継案件",
  "post_content": "企業概要...",
  "acf_fields": {
    "case_id": "MA2025001",
    "ma_scheme": "株式譲渡",
    "desired_price": "100000000",
    "industry_category": "製造業",
    "region": "関東",
    "established_year": "1995",
    "employees": "50"
  },
  "polylang_lang": "ja",
  "post_status": "draft"
}
```

【重要: 言語指定のルール】
1. **記事作成タスク**には必ず以下を含める:
   - `language`: 対象言語コード (ja/en/ru/uz/zh/ko/tr)
   - `polylang_lang`: Polylangの言語設定 (ja/en/ru/uz_UZ/zh_CN/ko_KR/tr_TR)
   - `target_url`: 参照元URL（ある場合）
   - `seo_keywords`: SEOキーワード
   - `target_audience`: ターゲット読者

2. **WordPress投稿タスク**には必ず以下を含める:
   - `language`: 投稿先言語
   - `polylang_lang`: Polylang言語コード
   - `source_task_id`: 元記事のタスクID
   - `post_action`: "create" または "edit"
   - `post_status`: "publish" / "draft" / "pending"

3. **レビュータスク**には以下を含める:
   - `review_language`: レビュー対象の言語
   - `review_target_task_id`: レビュー対象タスクID
   - `review_criteria`: 評価基準

【タスク分解の基本フロー】

**パターン1: 多言語コンテンツ作成プロジェクト**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "writer_ja",
      "description": "【日本語】M&A市場動向記事作成",
      "language": "ja",
      "polylang_lang": "ja",
      "seo_keywords": "M&A,ウズベキスタン,市場動向"
    },
    {
      "id": 2,
      "agent": "review",
      "description": "【日本語】記事品質チェック",
      "review_language": "ja",
      "review_target_task_id": 1
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "【日本語】WordPress投稿",
      "polylang_lang": "ja",
      "source_task_id": 1,
      "post_action": "create",
      "post_status": "publish"
    },
    {
      "id": 4,
      "agent": "writer_en",
      "description": "【英語】M&A market trends article",
      "language": "en",
      "polylang_lang": "en",
      "target_url": "参照元記事URL"
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "【英語】WordPress投稿",
      "polylang_lang": "en",
      "source_task_id": 4,
      "post_action": "create"
    }
  ]
}
```

**パターン2: M&Aポータルサイト機能開発プロジェクト**
```json
{
  "project_name": "M&Aポータルサイト構築",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "【要件定義】M&A案件管理システムの要件定義書作成",
      "priority": "high",
      "deliverables": ["要件定義書.md"]
    },
    {
      "id": 2,
      "agent": "design",
      "description": "【ACF設計】M&A案件用カスタムフィールド設計書作成",
      "priority": "high",
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "【Custom Post Type】M&A案件カスタム投稿タイプ作成",
      "priority": "high",
      "dependencies": [2],
      "cpt_slug": "ma_case",
      "cpt_labels": {"singular": "M&A案件", "plural": "M&A案件一覧"},
      "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"]
    },
    {
      "id": 4,
      "agent": "wordpress",
      "description": "【タクソノミー】業種カテゴリ作成",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "industry_category",
      "taxonomy_labels": {"singular": "業種", "plural": "業種一覧"},
      "taxonomy_post_types": ["ma_case"],
      "taxonomy_hierarchical": true
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "【タクソノミー】地域カテゴリ作成",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "region",
      "taxonomy_labels": {"singular": "地域", "plural": "地域一覧"}
    },
    {
      "id": 6,
      "agent": "wordpress",
      "description": "【ACF設定】M&A案件基本情報フィールドグループ作成",
      "priority": "high",
      "dependencies": [3, 4, 5],
      "acf_field_group_name": "M&A案件基本情報",
      "acf_fields": [
        {"name": "case_id", "type": "text", "label": "案件ID"},
        {"name": "ma_scheme", "type": "select", "label": "M&Aスキーム"},
        {"name": "desired_price", "type": "number", "label": "希望価格"},
        {"name": "industry_category", "type": "taxonomy", "label": "業種"},
        {"name": "region", "type": "taxonomy", "label": "地域"}
      ],
      "acf_location_rules": {"post_type": "ma_case"}
    },
    {
      "id": 7,
      "agent": "plugin",
      "description": "【FacetWP】絞り込み検索設定",
      "priority": "medium",
      "dependencies": [6],
      "plugin_name": "facetwp",
      "facets": [
        {"name": "業種フィルター", "type": "checkboxes", "source": "tax/industry_category"},
        {"name": "価格帯フィルター", "type": "slider", "source": "cf/desired_price"},
        {"name": "地域フィルター", "type": "dropdown", "source": "tax/region"}
      ]
    },
    {
      "id": 8,
      "agent": "ui",
      "description": "【検索UI設計】検索フォーム画面デザイン作成",
      "priority": "medium",
      "dependencies": [7]
    },
    {
      "id": 9,
      "agent": "plugin",
      "description": "【User Role】提携パートナーロール作成",
      "priority": "medium",
      "dependencies": [3],
      "plugin_name": "user-role-editor",
      "role_slug": "ma_partner",
      "role_name": "提携パートナー",
      "capabilities": {"read": true, "edit_posts": true}
    },
    {
      "id": 10,
      "agent": "plugin",
      "description": "【セキュリティ】Wordfence基本設定",
      "priority": "high",
      "plugin_name": "wordfence"
    },
    {
      "id": 11,
      "agent": "plugin",
      "description": "【キャッシュ】WP Rocket設定",
      "priority": "medium",
      "plugin_name": "wp-rocket"
    },
    {
      "id": 12,
      "agent": "review",
      "description": "【総合評価】機能全体の品質チェック",
      "priority": "high",
      "dependencies": [7, 8, 9, 10, 11]
    }
  ]
}
```

**パターン3: 既存WordPress記事の多言語展開**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "wordpress",
      "description": "【記事取得】既存投稿の内容取得",
      "post_id": 123
    },
    {
      "id": 2,
      "agent": "writer_en",
      "description": "【英語翻訳】英語版記事作成",
      "language": "en",
      "polylang_lang": "en",
      "source_post_id": 123,
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "【英語投稿】Polylang連携で英語版公開",
      "polylang_lang": "en",
      "source_task_id": 2,
      "translation_of": 123,
      "dependencies": [2]
    }
  ]
}
```

【出力形式】
必ずJSON形式で出力してください。

**JSON出力例:**
```json
{
  "project_name": "プロジェクト名",
  "total_tasks": 10,
  "estimated_duration": "2週間",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "【要件定義】システム要件定義書作成",
      "priority": "high",
      "dependencies": [],
      "parameters": {}
    }
  ]
}
```

【重要な注意事項】
- タスク説明の冒頭に必ず【機能名】または【言語名】を付ける
- WordPress投稿タスクには必ず`source_task_id`を指定（翻訳の場合）
- ACF設定タスクにはフィールド詳細を必ず記載
- Custom Post Type設定タスクにはスラッグとラベルを必ず指定
- 各言語専用のライターエージェントを正しく指定
- Polylang言語コードを正確に記載する
  - 日本語: ja
  - 英語: en
  - ロシア語: ru
  - ウズベク語: uz_UZ
  - 中国語: zh_CN
  - 韓国語: ko_KR
  - トルコ語: tr_TR
- プラグイン設定タスクには具体的な設定内容を記載
- セキュリティタスクは必ず含める
- パフォーマンス最適化タスクを忘れずに追加
- 依存関係（dependencies）を正確に設定

【タスク分解時のチェックリスト】
✅ Custom Post Type は作成されているか？
✅ ACFフィールドは設計されているか？
✅ タクソノミーは作成されているか？
✅ 検索機能は実装されているか？
✅ ユーザーロールは設定されているか？
✅ Polylang設定は含まれているか？
✅ セキュリティプラグインは導入されているか？
✅ キャッシュプラグインは設定されているか？
✅ レビュータスクは含まれているか？
✅ 各タスクの依存関係は正しいか？
✅ ACF/CPT UIの設定パラメータは具体的か？
✅ M&A案件投稿にACFフィールドは含まれているか？
"""

#quick_fix.py
#!/usr/bin/env python3
"""
クイック修正スクリプト - インポートエラーを自動修正
使い方: python quick_fix.py
"""

import os
import re
from pathlib import Path
import shutil
from datetime import datetime


def create_backup(file_path: Path) -> Path:
    """ファイルのバックアップを作成"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = file_path.with_suffix(f'.backup_{timestamp}{file_path.suffix}')
    shutil.copy2(file_path, backup_path)
    print(f"✅ バックアップ作成: {backup_path}")
    return backup_path


def fix_wp_plugin_manager(base_dir: Path) -> bool:
    """wp_plugin_manager.py のインポートエラーを修正"""
    file_path = base_dir / "wordpress" / "wp_plugin_manager.py"
    
    if not file_path.exists():
        print(f"⚠️ ファイルが見つかりません: {file_path}")
        return False
    
    print(f"\n🔧 修正中: {file_path}")
    
    # バックアップ作成
    create_backup(file_path)
    
    # ファイルを読み込み
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 既に修正済みかチェック
    if 'from typing import' in content and 'List' in content:
        print("✅ 既に修正済みです")
        return True
    
    # インポート文を探す
    import_pattern = r'^(import logging\s*\n)'
    
    # 新しいインポート文
    new_imports = '''import logging
import asyncio
from typing import Dict, List, Optional, Any
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

'''
    
    # 置換
    if re.search(import_pattern, content, re.MULTILINE):
        content = re.sub(import_pattern, new_imports, content, count=1, flags=re.MULTILINE)
        print("✅ インポート文を追加しました")
    else:
        # パターンが見つからない場合は先頭に追加
        lines = content.split('\n')
        # docstring の後に挿入
        insert_index = 0
        for i, line in enumerate(lines):
            if '"""' in line or "'''" in line:
                # docstringの終わりを探す
                for j in range(i+1, len(lines)):
                    if '"""' in lines[j] or "'''" in lines[j]:
                        insert_index = j + 1
                        break
                break
        
        if insert_index == 0:
            insert_index = 1  # ファイルの最初の行の後
        
        lines.insert(insert_index, '\n' + new_imports.strip())
        content = '\n'.join(lines)
        print("✅ インポート文を先頭に追加しました")
    
    # ファイルに書き込み
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("✅ wp_plugin_manager.py の修正完了")
    return True


def fix_wordpress_init(base_dir: Path) -> bool:
    """wordpress/__init__.py のインポートエラーを修正"""
    file_path = base_dir / "wordpress" / "__init__.py"
    
    if not file_path.exists():
        print(f"⚠️ ファイルが見つかりません: {file_path}")
        return False
    
    print(f"\n🔧 チェック中: {file_path}")
    
    # ファイルを読み込み
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # エラーハンドリングが必要か確認
    needs_fix = False
    
    if 'from .wp_agent import WordPressAgent' in content:
        if 'try:' not in content:
            needs_fix = True
    
    if not needs_fix:
        print("✅ 修正不要です")
        return True
    
    # バックアップ作成
    create_backup(file_path)
    
    # エラーハンドリング付きインポートに変更
    new_content = '''"""
WordPress パッケージ
"""

try:
    from .wp_agent import WordPressAgent
    from .wp_utils import WordPressConfig, task_router
    __all__ = ['WordPressAgent', 'WordPressConfig', 'task_router']
except ImportError as e:
    import logging
    logger = logging.getLogger(__name__)
    logger.warning(f"⚠️ WordPress モジュールのインポート失敗: {e}")
    WordPressAgent = None
    WordPressConfig = None
    task_router = None
    __all__ = []
'''
    
    # ファイルに書き込み
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("✅ wordpress/__init__.py の修正完了")
    return True


def check_all_typing_imports(base_dir: Path) -> list:
    """全Pythonファイルの typing インポートをチェック"""
    print("\n🔍 全ファイルのチェック中...")
    
    issues = []
    
    for py_file in base_dir.rglob("*.py"):
        if 'venv' in str(py_file) or '__pycache__' in str(py_file):
            continue
        
        try:
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # List, Dict などを使っているがインポートしていない
            if ('List[' in content or 'Dict[' in content or 
                'Optional[' in content or 'Tuple[' in content):
                if 'from typing import' not in content:
                    issues.append(str(py_file))
        except Exception as e:
            print(f"⚠️ {py_file} の読み込みエラー: {e}")
    
    return issues


def fix_task_executor_imports(base_dir: Path) -> bool:
    """task_executor.py のインポートエラーを修正"""
    file_path = base_dir / "task_executor.py"
    
    if not file_path.exists():
        print(f"⚠️ ファイルが見つかりません: {file_path}")
        return False
    
    print(f"\n🔧 修正中: {file_path}")
    
    # バックアップ作成
    create_backup(file_path)
    
    # ファイルを読み込み
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # 既に修正済みかチェック
    if 'from sheets_manager import GoogleSheetsManager' in content:
        print("✅ 既に修正済みです")
        return True
    
    # 正しいインポート順序
    correct_imports = '''"""
Task Executor - タスク実行コントローラー
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== 設定とユーティリティ =====
from config_utils import ErrorHandler, config

# ===== データ管理 =====
from sheets_manager import GoogleSheetsManager

# ===== エラーハンドラー（オプション） =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    import warnings
    warnings.warn("⚠️ error_handler_enhanced未検出（標準エラーハンドラー使用）")

# ===== 分離モジュール =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    import warnings
    warnings.warn("⚠️ task_executor_content/ma が見つかりません")

# ===== WordPress連携（オプション） =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None
    import warnings
    warnings.warn("⚠️ wordpress.wp_utils.task_router が見つかりません")

logger = logging.getLogger(__name__)


'''
    
    # 既存のインポート部分を探して置き換え
    # クラス定義の前までを置き換える
    class_pattern = r'class TaskExecutor:'
    class_match = re.search(class_pattern, content)
    
    if class_match:
        # クラス定義以降を保持
        class_and_rest = content[class_match.start():]
        # 新しいインポート + クラス定義以降
        new_content = correct_imports + class_and_rest
    else:
        print("⚠️ TaskExecutor クラスが見つかりません")
        return False
    
    # ファイルに書き込み
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("✅ task_executor.py のインポート修正完了")
    return True


def main():
    """メイン処理"""
    print("="*60)
    print("🔧 クイック修正スクリプト v2")
    print("="*60)
    
    # カレントディレクトリを取得
    base_dir = Path.cwd()
    print(f"\n📁 作業ディレクトリ: {base_dir}")
    
    # 修正実行
    success_count = 0
    
    # 1. wp_plugin_manager.py の修正
    if fix_wp_plugin_manager(base_dir):
        success_count += 1
    
    # 2. wordpress/__init__.py の修正
    if fix_wordpress_init(base_dir):
        success_count += 1
    
    # 3. task_executor.py の修正（新規追加）
    if fix_task_executor_imports(base_dir):
        success_count += 1
    
    # 4. その他のファイルをチェック
    issues = check_all_typing_imports(base_dir)
    
    if issues:
        print(f"\n⚠️ 追加で修正が必要な可能性のあるファイル: {len(issues)}件")
        for issue_file in issues[:10]:  # 最初の10件のみ表示
            print(f"  - {issue_file}")
        
        if len(issues) > 10:
            print(f"  ... 他 {len(issues) - 10} 件")
    
    # 結果サマリー
    print("\n" + "="*60)
    print("📊 修正完了")
    print("="*60)
    print(f"✅ 修正成功: {success_count} ファイル")
    
    if issues:
        print(f"⚠️ 要確認: {len(issues)} ファイル")
        print("\n💡 ヒント: 各ファイルで以下を追加してください:")
        print("   from typing import Dict, List, Optional, Any")
    
    print("\n🎉 修正完了！")
    print("次のコマンドで実行してください:")
    print("   python run_multi_agent.py --auto")


if __name__ == "__main__":
    main()

#quick_fix_agent.py
"""
quick_fix_agent.py - 自律型コード修正エージェント
AIからの修正コードを受け取り、ローカルファイルにパッチを適用し、テストを実行
"""

import asyncio
import logging
import re
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

from data_models import (
    BugFixTask,
    ErrorContextModel,
    FixResult,
    ErrorSeverity
)

logger = logging.getLogger(__name__)


class QuickFixAgent:
    """
    自律型修正エージェント - セルフヒーリングシステムの中核
    
    責務:
    1. AIに修正を依頼するプロンプトを構築
    2. AIからの修正コードを検証
    3. ローカルファイルにパッチを適用
    4. 自動テストを実行して検証
    5. GitHub連携(将来実装)
    """
    
    def __init__(
        self,
        browser_controller,
        command_monitor,
        wp_tester=None
    ):
        """
        初期化
        
        Args:
            browser_controller: BrowserController (AI対話用)
            command_monitor: CommandMonitorAgent (コマンド実行用)
            wp_tester: WordPressTester (WordPress関連テスト用)
        """
        self.browser = browser_controller
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        
        # バックアップディレクトリ
        self.backup_dir = Path("./backups/auto_fix")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # 修正履歴
        self.fix_history: List[FixResult] = []
        
        logger.info("✅ QuickFixAgent 初期化完了")
    
    async def execute_bug_fix_task(self, bug_fix_task: BugFixTask) -> FixResult:
        """
        バグ修正タスクを実行
        
        Args:
            bug_fix_task: バグ修正タスク
            
        Returns:
            FixResult: 修正結果
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        try:
            logger.info("=" * 60)
            logger.info(f"🔧 バグ修正タスク実行開始: {task_id}")
            logger.info("=" * 60)
            
            # ステータス更新
            bug_fix_task.status = "in_progress"
            
            # 1. AI修正プロンプトを構築
            fix_prompt = self._build_bug_fix_prompt(bug_fix_task.error_context)
            bug_fix_task.fix_prompt = fix_prompt
            
            logger.info(f"📝 修正プロンプト構築完了 ({len(fix_prompt)}文字)")
            
            # 2. AIに修正を依頼
            ai_result = await self._request_ai_fix(fix_prompt)
            
            if not ai_result['success']:
                return self._create_failed_result(
                    task_id,
                    f"AI修正依頼失敗: {ai_result.get('error')}",
                    start_time
                )
            
            generated_code = ai_result['generated_code']
            logger.info(f"🤖 AI修正コード取得完了 ({len(generated_code)}文字)")
            
            # 3. 修正コードを検証
            validation_result = self._validate_generated_code(
                generated_code,
                bug_fix_task.error_context
            )
            
            if not validation_result['valid']:
                return self._create_failed_result(
                    task_id,
                    f"AI修正コード検証失敗: {validation_result['reason']}",
                    start_time
                )
            
            logger.info("✅ AI修正コード検証合格")
            
            # 4. バックアップ作成
            backup_paths = self._create_backups(bug_fix_task.target_files)
            logger.info(f"💾 バックアップ作成完了: {len(backup_paths)}ファイル")
            
            # 5. パッチ適用
            apply_result = await self._apply_patch(
                bug_fix_task.target_files[0] if bug_fix_task.target_files else None,
                generated_code,
                bug_fix_task.error_context
            )
            
            if not apply_result['success']:
                self._restore_backups(backup_paths)
                return self._create_failed_result(
                    task_id,
                    f"パッチ適用失敗: {apply_result.get('error')}",
                    start_time
                )
            
            logger.info("✅ パッチ適用完了")
            
            # 6. 自動テスト実行
            bug_fix_task.status = "testing"
            test_result = await self._run_automated_tests(bug_fix_task)
            
            if not test_result['success']:
                logger.warning("⚠️ テスト失敗 - バックアップからロールバック")
                self._restore_backups(backup_paths)
                return self._create_failed_result(
                    task_id,
                    f"テスト失敗: {test_result.get('error')}",
                    start_time,
                    test_output=test_result.get('output'),
                    test_errors=test_result.get('errors', [])
                )
            
            logger.info("✅ 全テスト合格")
            
            # 7. 成功結果を作成
            bug_fix_task.status = "success"
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            fix_result = FixResult(
                task_id=task_id,
                success=True,
                modified_files=bug_fix_task.target_files,
                generated_code=generated_code,
                patch_content=apply_result.get('patch_content'),
                test_passed=True,
                test_output=test_result.get('output'),
                execution_time=execution_time
            )
            
            self.fix_history.append(fix_result)
            
            logger.info("=" * 60)
            logger.info(f"🎉 バグ修正完了: {task_id} ({execution_time:.2f}秒)")
            logger.info("=" * 60)
            
            return fix_result
            
        except Exception as e:
            logger.error(f"💥 バグ修正タスク実行エラー: {e}")
            bug_fix_task.status = "failed"
            
            execution_time = (datetime.now() - start_time).total_seconds()
            return self._create_failed_result(
                task_id,
                f"実行エラー: {str(e)}",
                start_time
            )
    
    def _build_bug_fix_prompt(self, error_context: ErrorContextModel) -> str:
        """
        AI修正プロンプトを構築
        
        Args:
            error_context: エラーコンテキスト
            
        Returns:
            str: AI修正プロンプト
        """
        prompt_parts = []
        
        # ヘッダー
        prompt_parts.append("以下のPythonコードにエラーが発生しています。修正されたコードを生成してください。")
        prompt_parts.append("")
        
        # エラー情報
        prompt_parts.append("【エラー情報】")
        prompt_parts.append(f"エラータイプ: {error_context.error_type}")
        prompt_parts.append(f"エラーメッセージ: {error_context.error_message}")
        prompt_parts.append(f"深刻度: {error_context.severity.value}")
        prompt_parts.append("")
        
        # エラー発生位置
        if error_context.error_location:
            prompt_parts.append("【エラー発生位置】")
            prompt_parts.append(f"ファイル: {error_context.error_location.file_path}")
            prompt_parts.append(f"行番号: {error_context.error_location.line_number}")
            if error_context.error_location.function_name:
                prompt_parts.append(f"関数: {error_context.error_location.function_name}")
            prompt_parts.append("")
        
        # 問題のあるコード
        if error_context.problematic_code:
            prompt_parts.append("【問題のある行】")
            prompt_parts.append(f"```python")
            prompt_parts.append(error_context.problematic_code)
            prompt_parts.append(f"```")
            prompt_parts.append("")
        
        # 周辺コード
        if error_context.surrounding_code:
            prompt_parts.append("【周辺コード(前後10行)】")
            prompt_parts.append(f"```python")
            prompt_parts.append(error_context.surrounding_code)
            prompt_parts.append(f"```")
            prompt_parts.append("")
        
        # スタックトレース(重要部分のみ)
        if error_context.stack_frames:
            prompt_parts.append("【スタックトレース】")
            for i, frame in enumerate(error_context.stack_frames[-3:], 1):  # 最後の3フレーム
                prompt_parts.append(f"{i}. {frame.file_path}:{frame.line_number} in {frame.function_name}")
            prompt_parts.append("")
        
        # ローカル変数(重要なもののみ)
        if error_context.local_variables:
            prompt_parts.append("【ローカル変数の状態】")
            for var_name, var_value in list(error_context.local_variables.items())[:5]:
                prompt_parts.append(f"  {var_name} = {var_value}")
            prompt_parts.append("")
        
        # タスク情報
        if error_context.task_description:
            prompt_parts.append("【実行中のタスク】")
            prompt_parts.append(error_context.task_description)
            prompt_parts.append("")
        
        # 修正要件
        prompt_parts.append("【修正要件】")
        prompt_parts.append("1. エラーの根本原因を特定してください")
        prompt_parts.append("2. 最小限の変更で修正してください")
        prompt_parts.append("3. 修正後のコードは完全で、実行可能である必要があります")
        prompt_parts.append("4. コメントで修正内容を説明してください")
        prompt_parts.append("")
        
        # 出力形式
        prompt_parts.append("【出力形式】")
        prompt_parts.append("以下の形式で出力してください:")
        prompt_parts.append("")
        prompt_parts.append("```python")
        prompt_parts.append("# 修正されたコード全体をここに記述")
        prompt_parts.append("# (周辺コードも含めて、置き換え可能な完全なコードを出力)")
        prompt_parts.append("```")
        prompt_parts.append("")
        prompt_parts.append("【重要】")
        prompt_parts.append("- コードブロックは必ず ```python ... ``` で囲んでください")
        prompt_parts.append("- 不完全なコードや省略は避けてください")
        prompt_parts.append("- インポート文も含めてください")
        
        return "\n".join(prompt_parts)
    
    async def _request_ai_fix(self, fix_prompt: str) -> Dict[str, Any]:
        """
        AIに修正を依頼
        
        Args:
            fix_prompt: 修正プロンプト
            
        Returns:
            Dict: AI応答結果
        """
        try:
            # AIにプロンプトを送信
            if not hasattr(self.browser, 'send_prompt_and_wait'):
                return {
                    'success': False,
                    'error': 'BrowserControllerにsend_prompt_and_waitメソッドがありません'
                }
            
            success = await self.browser.send_prompt_and_wait(
                fix_prompt,
                max_wait=180  # 3分
            )
            
            if not success:
                return {
                    'success': False,
                    'error': 'AIプロンプト送信または応答待機失敗'
                }
            
            # AI応答を抽出
            if not hasattr(self.browser, 'extract_latest_text_response'):
                return {
                    'success': False,
                    'error': 'BrowserControllerにextract_latest_text_responseメソッドがありません'
                }
            
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text or len(response_text) < 50:
                return {
                    'success': False,
                    'error': 'AI応答が空または短すぎます'
                }
            
            # コードブロックを抽出
            code_blocks = re.findall(r'```python\s*\n(.*?)```', response_text, re.DOTALL)
            
            if not code_blocks:
                return {
                    'success': False,
                    'error': 'AI応答にPythonコードブロックが見つかりません'
                }
            
            # 最大のコードブロックを採用
            generated_code = max(code_blocks, key=len)
            
            return {
                'success': True,
                'generated_code': generated_code,
                'full_response': response_text
            }
            
        except Exception as e:
            logger.error(f"❌ AI修正依頼エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _validate_generated_code(
        self,
        generated_code: str,
        error_context: ErrorContextModel
    ) -> Dict[str, Any]:
        """
        AI生成コードを検証
        
        Args:
            generated_code: AI生成コード
            error_context: エラーコンテキスト
            
        Returns:
            Dict: 検証結果
        """
        # 1. 最小長チェック
        if len(generated_code.strip()) < 20:
            return {
                'valid': False,
                'reason': 'コードが短すぎます'
            }
        
        # 2. Pythonコードの基本構造チェック
        if not any(kw in generated_code for kw in ['def ', 'class ', 'import ', 'from ']):
            return {
                'valid': False,
                'reason': 'Pythonコードの基本構造が見つかりません'
            }
        
        # 3. エラー関連のキーワードがないかチェック
        if error_context.error_type == "ImportError" or error_context.error_type == "ModuleNotFoundError":
            # インポートエラーの場合、適切なインポート文があるか
            if 'import ' not in generated_code and 'from ' not in generated_code:
                return {
                    'valid': False,
                    'reason': 'インポートエラーの修正にインポート文がありません'
                }
        
        # 4. コードブロックの閉じ忘れチェック
        open_braces = generated_code.count('{')
        close_braces = generated_code.count('}')
        open_parens = generated_code.count('(')
        close_parens = generated_code.count(')')
        open_brackets = generated_code.count('[')
        close_brackets = generated_code.count(']')
        
        if (open_braces != close_braces or 
            open_parens != close_parens or 
            open_brackets != close_brackets):
            return {
                'valid': False,
                'reason': '括弧の対応が不正です'
            }
        
        # 5. 構文チェック(簡易)
        try:
            compile(generated_code, '<string>', 'exec')
        except SyntaxError as e:
            return {
                'valid': False,
                'reason': f'構文エラー: {e}'
            }
        
        return {
            'valid': True,
            'reason': '検証合格'
        }
    
    def _create_backups(self, file_paths: List[str]) -> Dict[str, str]:
        """
        ファイルのバックアップを作成
        
        Args:
            file_paths: バックアップ対象ファイルパス
            
        Returns:
            Dict: {元ファイル: バックアップパス}
        """
        backup_paths = {}
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        for file_path in file_paths:
            try:
                src = Path(file_path)
                if not src.exists():
                    logger.warning(f"⚠️ バックアップ対象が存在しません: {file_path}")
                    continue
                
                # バックアップファイル名を生成
                backup_name = f"{src.stem}_backup_{timestamp}{src.suffix}"
                backup_path = self.backup_dir / backup_name
                
                # コピー
                shutil.copy2(src, backup_path)
                backup_paths[file_path] = str(backup_path)
                
                logger.info(f"💾 バックアップ: {file_path} → {backup_path}")
                
            except Exception as e:
                logger.error(f"❌ バックアップ失敗: {file_path} - {e}")
        
        return backup_paths
    
    def _restore_backups(self, backup_paths: Dict[str, str]):
        """バックアップからファイルを復元"""
        for original_path, backup_path in backup_paths.items():
            try:
                shutil.copy2(backup_path, original_path)
                logger.info(f"♻️ 復元: {backup_path} → {original_path}")
            except Exception as e:
                logger.error(f"❌ 復元失敗: {original_path} - {e}")
    
    async def _apply_patch(
        self,
        target_file: Optional[str],
        generated_code: str,
        error_context: ErrorContextModel
    ) -> Dict[str, Any]:
        """
        生成されたコードをファイルに適用
        
        Args:
            target_file: 対象ファイルパス
            generated_code: 生成されたコード
            error_context: エラーコンテキスト
            
        Returns:
            Dict: 適用結果
        """
        try:
            if not target_file:
                # エラー位置から対象ファイルを特定
                if error_context.error_location:
                    target_file = error_context.error_location.file_path
                else:
                    return {
                        'success': False,
                        'error': '対象ファイルが特定できません'
                    }
            
            target_path = Path(target_file)
            
            if not target_path.exists():
                return {
                    'success': False,
                    'error': f'対象ファイルが存在しません: {target_file}'
                }
            
            # 元のファイル内容を読み込み
            with open(target_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            # 新しい内容を書き込み
            with open(target_path, 'w', encoding='utf-8') as f:
                f.write(generated_code)
            
            logger.info(f"✅ パッチ適用完了: {target_file}")
            
            # Diff形式のパッチ内容を生成(簡易版)
            patch_content = self._generate_simple_diff(
                original_content,
                generated_code,
                target_file
            )
            
            return {
                'success': True,
                'target_file': target_file,
                'patch_content': patch_content
            }
            
        except Exception as e:
            logger.error(f"❌ パッチ適用エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _generate_simple_diff(
        self,
        original: str,
        modified: str,
        filename: str
    ) -> str:
        """簡易Diff形式のパッチ内容を生成"""
        lines = []
        lines.append(f"--- {filename} (original)")
        lines.append(f"+++ {filename} (modified)")
        lines.append(f"@@ -{len(original.splitlines())},{len(modified.splitlines())} @@")
        
        # 簡易的な差分表示
        orig_lines = original.splitlines()
        mod_lines = modified.splitlines()
        
        max_lines = max(len(orig_lines), len(mod_lines))
        
        for i in range(min(10, max_lines)):  # 最初の10行のみ
            if i < len(orig_lines):
                lines.append(f"- {orig_lines[i]}")
            if i < len(mod_lines):
                lines.append(f"+ {mod_lines[i]}")
        
        if max_lines > 10:
            lines.append(f"... ({max_lines - 10} more lines)")
        
        return "\n".join(lines)
    
    async def _run_automated_tests(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """
        自動テストを実行
        
        Args:
            bug_fix_task: バグ修正タスク
            
        Returns:
            Dict: テスト結果
        """
        try:
            error_context = bug_fix_task.error_context
            
            # テストコマンドを決定
            test_command = self._determine_test_command(error_context)
            
            if not test_command:
                logger.warning("⚠️ テストコマンドが特定できません - スキップ")
                return {
                    'success': True,
                    'output': 'テストコマンド未特定のためスキップ',
                    'errors': []
                }
            
            logger.info(f"🧪 テスト実行: {test_command}")
            
            # コマンド実行
            result = await self.cmd_monitor.execute_command(
                test_command,
                timeout=120
            )
            
            # テスト結果を評価
            if result['return_code'] == 0 and not result['has_errors']:
                return {
                    'success': True,
                    'output': result['stdout'],
                    'errors': []
                }
            else:
                return {
                    'success': False,
                    'output': result['stdout'],
                    'errors': result['errors'],
                    'error': f"テスト失敗 (return_code={result['return_code']})"
                }
            
        except Exception as e:
            logger.error(f"❌ テスト実行エラー: {e}")
            return {
                'success': False,
                'error': str(e),
                'errors': [str(e)]
            }
    
    def _determine_test_command(self, error_context: ErrorContextModel) -> Optional[str]:
        """エラーコンテキストから適切なテストコマンドを決定"""
        
        # WordPress関連のエラー
        if error_context.wp_context or 'wordpress' in str(error_context.error_location).lower():
            return "wp plugin list"  # 基本的な動作確認
        
        # Pythonモジュールのインポートエラー
        if error_context.error_category.value == "import_error":
            # インポート可能性をチェック
            if error_context.error_location:
                module_name = Path(error_context.error_location.file_path).stem
                return f"python -c 'import {module_name}'"
        
        # 一般的なPythonコード
        if error_context.error_location:
            file_path = error_context.error_location.file_path
            if file_path.endswith('.py'):
                # 構文チェック
                return f"python -m py_compile {file_path}"
        
        return None
    
    def _create_failed_result(
        self,
        task_id: str,
        error_message: str,
        start_time: datetime,
        test_output: Optional[str] = None,
        test_errors: List[str] = None
    ) -> FixResult:
        """失敗結果を作成"""
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return FixResult(
            task_id=task_id,
            success=False,
            test_passed=False,
            test_output=test_output,
            test_errors=test_errors or [],
            execution_time=execution_time,
            error_message=error_message
        )
    
    def get_fix_history(self) -> List[FixResult]:
        """修正履歴を取得"""
        return self.fix_history.copy()
    
    def get_success_rate(self) -> float:
        """修正成功率を計算"""
        if not self.fix_history:
            return 0.0
        
        success_count = sum(1 for result in self.fix_history if result.success)
        return (success_count / len(self.fix_history)) * 100

#review_agent.py
# review_agent.py
"""レビューAI - タスク出力を評価し、失敗原因を分析、次のアクションを提案"""
import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController
from sheets_manager import GoogleSheetsManager
from review_agent_prompts import REVIEW_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class ReviewAgent:
    """レビューAI - タスク出力を評価し、失敗原因を分析、次のアクションを提案"""
    
    def __init__(self):
        """コンストラクタ - 後でプロパティを設定する"""
        self.browser = None
        self.sheets_manager = None
        self.system_prompt = REVIEW_SYSTEM_PROMPT

    async def process_task(self, task: Dict) -> Dict:
        """レビュータスクを処理（互換性のため）"""
        return await self.review_completed_task(task, task.get('output_content', ''))

    async def review_completed_task(self, task: Dict, output_content: str) -> Dict:
        """完了したタスクをレビュー（失敗原因分析強化版）"""
        try:
            # === パート1: レビュー開始処理 ===
            logger.info("="*60)
            logger.info(f"レビューAI: タスク {task['task_id']} のレビュー開始")
            logger.info("="*60)
            
            # タスクのステータスを確認
            task_status = task.get('status', 'unknown')
            is_failed_task = task_status in ['failed', 'error', 'timeout']
            
            # 事前チェック：出力内容の構造を検証
            pre_check_result = self._pre_check_content(output_content, task['required_role'])
            if pre_check_result:
                logger.info(f"事前チェック結果: {pre_check_result}")
            
            # エラー情報を取得
            error_info = task.get('error', '')
            
            # === パート2: プロンプト構築とGemini送信 ===
            full_prompt = self._build_review_prompt(
                task, task_status, is_failed_task, 
                output_content, error_info, pre_check_result
            )
            
            logger.info("レビューをGeminiに依頼中...")
            await self.browser.send_prompt(full_prompt)
            
            # 応答待機
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                logger.warning("レビューAI: タイムアウト")
                return self._create_default_review(task, is_failed_task)
            
            # === パート3: 応答取得と結果解析 ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.warning("レビューAI: 応答取得失敗")
                return self._create_default_review(task, is_failed_task)
            
            logger.info(f"レビューAI: 応答取得完了（{len(response_text)}文字）")
            
            # JSONをパース
            review_result = self._parse_review_json(response_text)
            
            if review_result:
                # レビュー結果の妥当性を検証
                validated_review = self._validate_review_result(review_result, output_content)
                self._display_review_summary(validated_review, is_failed_task)
                return {
                    'success': True,
                    'review': validated_review,
                    'summary': validated_review.get('evaluation', {}).get('overall_assessment', ''),
                    'full_text': response_text
                }
            else:
                logger.warning("レビュー結果のJSON解析に失敗")
                return self._create_default_review(task, is_failed_task)
                
        except Exception as e:
            ErrorHandler.log_error(e, "レビューAI処理")
            return self._create_default_review(task, False)

    def _build_review_prompt(self, task: Dict, task_status: str, is_failed_task: bool,
                           output_content: str, error_info: str, pre_check_result: str) -> str:
        """レビュー用プロンプトを構築(トレーサビリティ情報付き)"""
    
        # === 🆕 新規追加: トレーサビリティ情報の抽出 ===
        traceability = task.get('_traceability', {})
        executed_by = traceability.get('executed_by_agent', '不明')
        agent_class = traceability.get('agent_class', '不明')
    
        return f"""{self.system_prompt}

    【レビュー対象タスク】
    タスクID: {task['task_id']}
    内容: {task['description']}
    担当: {task['required_role']}
    ステータス: {task_status}
    出力文字数: {len(output_content)}文字

    🆕【実行エージェント情報】(原因切り分け用)
    実行エージェント: {executed_by}
    エージェントクラス: {agent_class}
    実行タイムスタンプ: {traceability.get('execution_timestamp', 'N/A')}

    【タスクの状態】
    {'❌ このタスクは失敗しました' if is_failed_task else '✅ タスクは完了しました'}
    {f'エラー情報: {error_info}' if error_info else ''}

    【事前チェック結果】
    {pre_check_result if pre_check_result else '特記事項なし'}

    【タスクの出力】
    {output_content[:4000] if output_content else '(出力なし)'}

    上記のタスク出力をレビューし、指定されたJSON形式で評価と次のアクションを提案してください。
    {'特に失敗原因を詳細に分析し、適切な推奨アクションを提案してください。' if is_failed_task else '特に、構造的に完結しているかどうかを重点的に確認してください。'}

    🆕【レビュー時の注意】
    - コードブロックが途中で途切れている場合は必ず指摘してください
    - 実行エージェント({executed_by})の出力品質に問題がある場合、その旨を明記してください
    - 手動作業が必要な手順が含まれている場合、自動化の提案も含めてください
    """


    def _pre_check_content(self, content: str, role: str) -> str:
        """出力内容の事前チェック"""
        checks = []
        
        # === パート1: 文字数チェック ===
        if len(content) < 100:
            checks.append("⚠️ 文字数が少なすぎます（100文字未満）")
        elif len(content) > 5000:
            checks.append("✅ 文字数が十分です")
        
        # === パート2: 記事・文書系タスクの構造チェック ===
        if role in ['writer', 'content', 'wordpress', 'writer_ja', 'writer_en', 'writer_ru']:
            if '<h1' in content or '<h2' in content or '# ' in content:
                checks.append("✅ 見出し構造があります")
            
            if any(phrase in content for phrase in ['まとめ', '結論', '終わり', '以上', '最後に', 'Conclusion', 'Summary']):
                checks.append("✅ 結論・まとめがあります")
            else:
                checks.append("⚠️ 明示的な結論・まとめが見つかりません")
            
            # HTML/マークダウンの閉じ忘れチェック
            if content.count('<div') > content.count('</div'):
                checks.append("⚠️ HTMLのdivタグが閉じられていません")
            if content.count('<p>') > content.count('</p>'):
                checks.append("⚠️ HTMLのpタグが閉じられていません")
        
        # === パート3: コード系タスクの構造チェック ===
        if role in ['dev', 'programming']:
            if 'def ' in content or 'function ' in content or 'class ' in content:
                checks.append("✅ 関数/クラス定義があります")
            if 'import ' in content or 'require ' in content:
                checks.append("✅ インポート文があります")
        
        return " | ".join(checks) if checks else "✅ 基本的な構造は問題ありません"

    def _validate_review_result(self, review: Dict, original_content: str) -> Dict:
        """レビュー結果の妥当性を検証"""
        evaluation = review.get('evaluation', {})
        next_actions = review.get('next_actions', {})
        
        # === パート1: 「部分的」判定の妥当性チェック ===
        if evaluation.get('completeness') == '部分的':
            issues = evaluation.get('issues', [])
            new_issues = []
            
            for issue in issues:
                # 文字数関連の指摘を検証
                if any(word in issue for word in ['文字数', '文字', '短い', '少ない']):
                    if len(original_content) > 1000:  # 1000文字以上あれば文字数不足ではない
                        continue
                # 構造的な指摘を検証
                elif '切れて' in issue or '途切れ' in issue:
                    # 実際に文が途中で切れているかチェック
                    if self._is_content_properly_ended(original_content):
                        continue
                
                new_issues.append(issue)
            
            # 問題点を更新
            evaluation['issues'] = new_issues
            
            # 問題点がなくなった場合は「完了」に変更
            if not new_issues and len(original_content) > 500:
                evaluation['completeness'] = '完了'
                evaluation['overall_assessment'] = '再評価: 内容は完結しており、文字数も十分です'
                next_actions['required'] = False
                next_actions['suggested_tasks'] = []
        
        return review

    def _is_content_properly_ended(self, content: str) -> bool:
        """コンテンツが適切に終了しているかチェック"""
        # === パート1: 文の終了チェック ===
        sentences = re.split(r'[。！？!?\.]', content.strip())
        if sentences and sentences[-1].strip():
            return False  # 最後の文が終了記号で終わっていない
        
        # === パート2: HTMLタグの閉じチェック ===
        if content.count('<') > 0 and content.count('>') > 0:
            open_tags = len(re.findall(r'<(?!\/)[^>]+>', content))
            close_tags = len(re.findall(r'<\/[^>]+>', content))
            if open_tags != close_tags:
                return False
        
        return True

    def _parse_review_json(self, text: str) -> Optional[Dict]:
        """レビュー結果のJSONをパース"""
        try:
            import re
            
            # === パート1: ```json ... ``` 形式の抽出 ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            # === パート2: 単純なJSONオブジェクトの抽出 ===
            json_match = re.search(r'(\{.*\})', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            logger.warning("JSON形式が見つかりません")
            return None
            
        except json.JSONDecodeError as e:
            logger.error(f"JSON解析エラー: {e}")
            return None

    def _create_default_review(self, task: Dict, is_failed: bool = False) -> Dict:
        """デフォルトのレビュー結果（失敗時）"""
        if is_failed:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': '失敗',
                        'quality_score': 3,
                        'issues': ['タスク実行に失敗しました'],
                        'good_points': [],
                        'overall_assessment': 'タスクは失敗しましたが、レビュー処理も問題が発生しました',
                        'failure_analysis': {
                            'is_failed': True,
                            'failure_category': '環境問題',
                            'root_cause': 'レビューAIの応答取得に失敗',
                            'impact': '失敗原因の詳細が不明',
                            'recommended_action': 'immediate_retry',
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': True,
                        'reasoning': 'タスクの再実行または修正が必要',
                        'suggested_tasks': []
                    }
                },
                'summary': 'レビュー処理エラー - タスク失敗',
                'full_text': ''
            }
        else:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': '完了',
                        'quality_score': 7,
                        'issues': [],
                        'good_points': ['タスク完了'],
                        'overall_assessment': 'レビュー処理に問題が発生しましたが、タスクは完了とみなします',
                        'failure_analysis': {
                            'is_failed': False,
                            'failure_category': None,
                            'root_cause': None,
                            'impact': None,
                            'recommended_action': None,
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': False,
                        'reasoning': 'レビューAIの応答取得に失敗したため、追加タスクなし',
                        'suggested_tasks': []
                    }
                },
                'summary': 'レビュー処理エラー - デフォルト評価',
                'full_text': ''
            }

    def _display_review_summary(self, review: Dict, is_failed_task: bool = False):
        """レビュー結果を表示（失敗分析強化版）"""
        
        print("\n" + "🎯" * 30)
        print("📋 レビュー結果")
        print("🎯" * 30)
        
        evaluation = review.get('evaluation', {})
        
        # === パート1: 基本情報表示 ===
        completeness = evaluation.get('completeness', 'N/A')
        completeness_icon = {
            '完了': '✅',
            '部分的': '⚠️',
            '不完全': '❌',
            '失敗': '💥'
        }.get(completeness, '❓')
        
        print(f"\n{completeness_icon} 完成度: {completeness}")
        print(f"⭐ 品質スコア: {evaluation.get('quality_score', 'N/A')}/10")
        
        # === パート2: 失敗分析表示 ===
        failure_analysis = evaluation.get('failure_analysis', {})
        if failure_analysis.get('is_failed'):
            print("\n" + "💥" * 30)
            print("🔍 失敗原因分析")
            print("💥" * 30)
            
            category = failure_analysis.get('failure_category', 'N/A')
            category_icon = {
                '要件不明瞭': '📝',
                '技術的問題': '⚙️',
                'リソース不足': '📦',
                '依存関係': '🔗',
                '環境問題': '🌐',
                'タイムアウト': '⏱️',
                '出力不完全': '✂️',
                '品質不足': '📉'
            }.get(category, '❓')
            
            print(f"\n{category_icon} 失敗カテゴリ: {category}")
            print(f"🔍 根本原因: {failure_analysis.get('root_cause', 'N/A')}")
            print(f"💡 影響: {failure_analysis.get('impact', 'N/A')}")
            
            action = failure_analysis.get('recommended_action', 'N/A')
            action_map = {
                'immediate_retry': '🔄 即座に再実行',
                'modify_task': '✏️ タスクを修正',
                'add_prerequisite': '➕ 前提タスクを追加',
                'escalate': '🚨 エスカレーション（人間の判断が必要）',
                'skip': '⏭️ スキップまたは後回し'
            }
            print(f"📌 推奨アクション: {action_map.get(action, action)}")
            
            prereqs = failure_analysis.get('prerequisites', [])
            if prereqs:
                print(f"\n📋 前提条件:")
                for prereq in prereqs:
                    print(f"   • {prereq}")
            
            print("💥" * 30)
        
        # === パート3: 良い点・問題点表示 ===
        good_points = evaluation.get('good_points', [])
        if good_points:
            print(f"\n✨ 良い点:")
            for point in good_points:
                print(f"   ✅ {point}")
        
        issues = evaluation.get('issues', [])
        if issues:
            print(f"\n⚠️ 問題点:")
            for issue in issues:
                print(f"   ❌ {issue}")
        
        # === パート4: 総合評価表示 ===
        overall = evaluation.get('overall_assessment', '')
        if overall:
            print(f"\n💎 総合評価:")
            print(f"   {overall}")
        
        # === パート5: 次のアクション表示 ===
        next_actions = review.get('next_actions', {})
        required = next_actions.get('required', False)
        
        action_icon = '🔴' if required else '🟢'
        print(f"\n🎯 次のアクション: {action_icon} {'必要' if required else '不要'}")
        
        if required:
            reasoning = next_actions.get('reasoning', '')
            if reasoning:
                print(f"   📌 理由: {reasoning}")
            
            # 提案タスク
            suggested_tasks = next_actions.get('suggested_tasks', [])
            if suggested_tasks:
                print(f"\n🚀 提案タスク ({len(suggested_tasks)}件):")
                for i, task in enumerate(suggested_tasks, 1):
                    priority_icon = {
                        'high': '🔴',
                        'medium': '🟡',
                        'low': '🟢'
                    }.get(task.get('priority', 'medium'), '⚪')
                    
                    role_icon = {
                        'design': '📐',
                        'dev': '💻',
                        'ui': '🎨',
                        'review': '✅',
                        'wordpress': '🌐',
                        'content': '✍️',
                        'writer': '📝',
                        'writer_ja': '🗾',
                        'writer_en': '🔠',
                        'writer_ru': '🇷🇺'
                    }.get(task.get('required_role', 'dev'), '📋')
                    
                    print(f"   {i}. {priority_icon} {role_icon} {task.get('description', 'N/A')}")
                    
                    deps = task.get('dependencies', [])
                    if deps:
                        print(f"      📎 依存: {', '.join(map(str, deps))}")
        
        print("🎯" * 30 + "\n")

    async def add_suggested_tasks_to_sheet(self, parent_task_id: str, suggested_tasks: List[Dict]) -> int:
        """提案されたタスクをpm_tasksシートに追加（正しい列配置版）"""
        try:
            if not suggested_tasks:
                return 0
            
            logger.info(f"提案タスク {len(suggested_tasks)} 件をスプレッドシートに追加中...")
            
            # === パート1: シート準備 ===
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            task_sheet = sheet.worksheet("pm_tasks")
            
            # 既存データを取得
            all_values = task_sheet.get_all_values()
            
            if len(all_values) < 1:
                logger.error("pm_tasksシートが空です")
                return 0
            
            # ヘッダー行を確認
            headers = all_values[0]
            logger.info(f"列ヘッダー: {headers}")
            
            # === パート2: タスクIDの決定 ===
            existing_task_ids = []
            for row in all_values[1:]:  # ヘッダーをスキップ
                if row and len(row) > 0:
                    try:
                        task_id = int(row[0])
                        existing_task_ids.append(task_id)
                    except (ValueError, IndexError):
                        continue
            
            # 次のタスクIDを決定
            if existing_task_ids:
                next_task_id = max(existing_task_ids) + 1
            else:
                next_task_id = 1
            
            logger.info(f"次のタスクID: {next_task_id}")
            
            # === パート3: タスクデータの準備 ===
            rows_to_add = []
            for task in suggested_tasks:
                row = [
                    next_task_id,  # A: task_id
                    '',  # B: parent_goal_id（空欄）
                    task.get('description', ''),  # C: task_description
                    task.get('required_role', 'dev'),  # D: required_role
                    'pending',  # E: status
                    task.get('priority', 'medium'),  # F: priority
                    task.get('estimated_time', ''),  # G: estimated_time
                    ','.join(map(str, task.get('dependencies', [parent_task_id]))),  # H: dependencies
                    datetime.now().isoformat(),  # I: created_at
                    f"Review suggested from task {parent_task_id}"  # J: notes
                ]
                rows_to_add.append(row)
                logger.info(f"追加予定タスク: ID={next_task_id}, 内容={task.get('description', '')[:50]}")
                next_task_id += 1
            
            # === パート4: データ追加処理 ===
            if rows_to_add:
                # 最終行の次の行から追加
                start_row = len(all_values) + 1
                
                # セル範囲を指定して追加
                range_notation = f'A{start_row}:J{start_row + len(rows_to_add) - 1}'
                
                logger.info(f"データを追加: {range_notation}")
                task_sheet.update(range_notation, rows_to_add)
                
                logger.info(f"✅ 提案タスク {len(rows_to_add)} 件を追加しました")
                
                # 追加されたタスクIDをログ出力
                added_ids = [row[0] for row in rows_to_add]
                logger.info(f"追加されたタスクID: {added_ids}")
            
            return len(rows_to_add)
            
        except Exception as e:
            ErrorHandler.log_error(e, "提案タスク追加")
            logger.error(f"エラー詳細: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return 0

#review_agent_prompts.py
# review_agent_prompts.py
"""レビューAIのプロンプト定義"""

REVIEW_SYSTEM_PROMPT = """あなたは経験豊富なプロジェクトレビュアーです。

【あなたの役割】
- タスクの完成度を評価する
- 出力物の品質をチェックする
- **失敗原因を特定し分類する**
- 次に必要なタスクを特定する
- 改善点や問題点を指摘する

【失敗原因の分類】
タスクが失敗した場合、以下のカテゴリで原因を特定してください：

1. **要件不明瞭** - タスクの説明が不十分、曖昧
2. **技術的問題** - 実装の難易度が高い、技術的制約
3. **リソース不足** - 必要な情報、ツール、権限が不足
4. **依存関係** - 前提タスクが未完了、必要なデータがない
5. **環境問題** - システム、ブラウザ、APIの問題
6. **タイムアウト** - 処理時間が長すぎる
7. **出力不完全** - 出力が途中で切れている、構造が不完全
8. **品質不足** - 成果物の品質が基準を満たしていない

【重要な判断基準 - 誤判断防止】
★ 以下の場合は「完了」と判断してください：
- 記事・文書が導入→本編→結論の構造になっている
- 主要なセクションが全て含まれている
- 内容的に完結している（途中で文が切れていない）
- HTML/マークダウン構造が適切に閉じられている
- 文字数が多少少なくても、内容が充実している
- 文書の最後に明確な結論やまとめがある

★ 「部分的」と判断するのは本当に明らかに未完成の場合のみ：
- 明らかに文の途中で切れている（主語だけ、動詞がないなど）
- 主要セクションが完全に欠落している
- 「続く」「後述」などの未完成を示す表現がある
- HTMLタグが閉じられていないなどの構造的問題

【評価基準】
1. 完成度: タスクが要求を満たしているか
2. 品質: 実装可能で具体的か
3. 失敗原因: なぜ失敗したのか（該当する場合）
4. 次のステップ: 何が不足しているか

【出力形式】
必ずJSON形式で出力してください：

```json
{
  "evaluation": {
    "completeness": "完了|部分的|不完全|失敗",
    "quality_score": 1-10,
    "issues": ["問題点1", "問題点2"],
    "good_points": ["良い点1", "良い点2"],
    "overall_assessment": "総合評価のサマリー（100文字程度）",
    "failure_analysis": {
      "is_failed": true|false,
      "failure_category": "要件不明瞭|技術的問題|リソース不足|依存関係|環境問題|タイムアウト|出力不完全|品質不足",
      "root_cause": "失敗の根本原因の詳細説明",
      "impact": "この失敗がプロジェクトに与える影響",
      "recommended_action": "immediate_retry|modify_task|add_prerequisite|escalate|skip",
      "prerequisites": ["前提条件1", "前提条件2"]
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "次のタスクが必要な理由",
    "suggested_tasks": [
      {
        "description": "具体的なタスク内容",
        "required_role": "design|dev|ui|review|wordpress",
        "priority": "high|medium|low",
        "reasoning": "このタスクが必要な理由",
        "dependencies": ["依存するタスクID"],
        "estimated_time": "予想時間"
      }
    ]
  }
}
【失敗時の推奨アクションの選択基準】

immediate_retry: 一時的なエラー（タイムアウト、ネットワーク）

modify_task: 要件が不明瞭、タスク内容の修正が必要

add_prerequisite: 前提タスクが不足している

escalate: 人間の判断が必要な問題

skip: このタスクは不要または後回しにすべき

【単純な判断条件】

要件定義だけで実装がない場合 → 実装タスクを提案

設計書だけでコードがない場合 → 開発タスクを提案

コードにテストがない場合 → テストタスクを提案

不完全な出力の場合 → 改善タスクを提案

十分に完成している場合 → 次のタスクは不要と判断

タスクを提案しすぎないこと。本当に必要なタスクのみを提案してください。"""

#review_agent_prompts_ACF.py
# review_agent_prompts_ACF.py
"""ACF/WordPress専用レビュープロンプト定義"""

# =============================================================================
# ACF専用レビュープロンプト
# =============================================================================

ACF_REVIEW_PROMPT = """あなたはWordPress/ACF Proの専門家レビュアーです。

【ACFコードレビューの観点】

## 1. 必須要素の確認
- [ ] `acf_add_local_field_group()` 関数が正しく使用されているか
- [ ] フィールドグループの必須キー（key, title, fields, location）が全て定義されているか
- [ ] 各フィールドに一意の `key` が設定されているか
- [ ] フィールドタイプが有効な値か（text, number, select, relationship等）

## 2. セキュリティチェック
- [ ] 出力時に `esc_html()`, `esc_attr()`, `esc_url()` などのエスケープ関数が使用されているか
- [ ] 入力値の検証に `sanitize_text_field()`, `intval()` などが使用されているか
- [ ] データベースクエリに `$wpdb->prepare()` が使用されているか
- [ ] `$_GET`, `$_POST` の直接使用時に適切なサニタイゼーションがあるか

## 3. WordPress互換性
- [ ] フック（`add_action`, `add_filter`）が適切に使用されているか
- [ ] 国際化関数（`__()`, `_e()`, `_x()`）が使用されているか
- [ ] 関数名に名前空間の衝突を防ぐプレフィックスがあるか
- [ ] `show_in_rest` が設定されているか（Gutenberg対応）

## 4. ACF固有のベストプラクティス
- [ ] フィールドグループの `location` ルールが適切に設定されているか
- [ ] 条件付きロジック（`conditional_logic`）が必要に応じて設定されているか
- [ ] フィールドの `required` 設定が適切か
- [ ] リレーションシップフィールドで `post_type` が指定されているか
- [ ] 繰り返しフィールド（`repeater`）のサブフィールドが正しく定義されているか

## 5. パフォーマンスと保守性
- [ ] 不要なフィールドやグループが含まれていないか
- [ ] フィールド取得に `get_field()` が使用され、`the_field()` が適切に使い分けられているか
- [ ] コメントが適切に記載されているか
- [ ] コードの可読性が高いか

## 6. M&A案件特有の要件（該当する場合）
- [ ] 業種、地域、価格帯などの検索用フィールドが定義されているか
- [ ] 多言語対応（Polylang）を考慮したフィールド設計か
- [ ] `meta_query` による検索フィルタリングが正しく実装されているか
- [ ] 数値フィールド（価格等）の型が `NUMERIC` に設定されているか

【評価基準】

**致命的な問題（10点満点中0-3点）**
- 必須要素の欠落
- セキュリティ脆弱性（XSS, SQLインジェクション）
- PHP構文エラー
- ACF関数の誤用

**警告レベルの問題（4-6点）**
- エスケープ関数の一部不足
- 国際化対応の欠如
- パフォーマンス上の問題
- コメント不足

**良好（7-10点）**
- すべてのチェック項目をクリア
- コードが可読性高く保守しやすい
- ベストプラクティスに完全準拠
- 拡張性を考慮した設計

【出力形式】

必ず以下のJSON形式で出力してください：

```json
{
  "evaluation": {
    "completeness": "完了|部分的|不完全",
    "quality_score": 1-10,
    "issues": [
      "問題点の詳細説明"
    ],
    "good_points": [
      "良い点の詳細説明"
    ],
    "overall_assessment": "総合評価のサマリー",
    "acf_specific_checks": {
      "field_group_structure": "OK|NG",
      "security_practices": "OK|NG",
      "wordpress_compatibility": "OK|NG",
      "performance": "OK|NG"
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "次のタスクが必要な理由",
    "suggested_tasks": [
      {
        "description": "具体的なタスク内容",
        "required_role": "dev|wordpress",
        "priority": "high|medium|low"
      }
    ]
  }
}
```

【重要な注意事項】
- ACFコードは実装可能で完全に動作する必要があります
- セキュリティは最優先事項です
- Polylang多言語対応を常に考慮してください
- M&A案件特有の要件を満たしているか確認してください
"""

# =============================================================================
# PHP構文チェック用の補助プロンプト
# =============================================================================

PHP_SYNTAX_CHECK_PROMPT = """以下のPHPコードの構文エラーをチェックしてください。

【チェック項目】
1. 括弧の対応（(), {}, []）
2. セミコロンの有無
3. 引用符の閉じ忘れ
4. 予約語の誤用
5. 関数名の重複

【PHPコード】
{php_code}

問題があれば詳細を、問題なければ "OK" と回答してください。
"""

# =============================================================================
# セキュリティチェック用の補助プロンプト
# =============================================================================

SECURITY_CHECK_PROMPT = """以下のWordPress/PHPコードのセキュリティをチェックしてください。

【重点チェック項目】
1. XSS対策（エスケープ関数の使用）
2. SQLインジェクション対策（$wpdb->prepare の使用）
3. CSRF対策（nonce の使用）
4. 入力値のサニタイゼーション
5. ファイルアップロードの検証

【コード】
{code}

セキュリティ上の問題があれば、重要度（critical/warning）と共に指摘してください。
"""

#rollback_agent.py
"""
RollbackAgent - 高度なロールバック管理エージェント

修正が失敗した際の安全装置として、複数ファイルの一括ロールバック、
時系列でのロールバック、影響分析、自動ロールバック判定を提供する。
"""

import os
import shutil
import hashlib
import json
from pathlib import Path
from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging
import subprocess

logger = logging.getLogger(__name__)


class RollbackScope(Enum):
    """ロールバックスコープ"""
    SINGLE_FILE = "single_file"
    RELATED_FILES = "related_files"
    ENTIRE_COMMIT = "entire_commit"
    TIME_RANGE = "time_range"


class RollbackReason(Enum):
    """ロールバック理由"""
    TEST_FAILURE = "test_failure"
    RUNTIME_ERROR = "runtime_error"
    MANUAL_REQUEST = "manual_request"
    AUTO_DETECTION = "auto_detection"
    DEPENDENCY_ISSUE = "dependency_issue"


@dataclass
class FileSnapshot:
    """ファイルスナップショット"""
    file_path: str
    content: str
    content_hash: str
    timestamp: datetime
    backup_path: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "file_path": self.file_path,
            "content_hash": self.content_hash,
            "timestamp": self.timestamp.isoformat(),
            "backup_path": self.backup_path,
            "metadata": self.metadata
        }


@dataclass
class RollbackPoint:
    """ロールバックポイント"""
    id: str
    timestamp: datetime
    snapshots: List[FileSnapshot]
    commit_hash: Optional[str] = None
    description: str = ""
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "snapshots": [s.to_dict() for s in self.snapshots],
            "commit_hash": self.commit_hash,
            "description": self.description,
            "tags": self.tags
        }


@dataclass
class RollbackResult:
    """ロールバック結果"""
    success: bool
    rollback_point_id: str
    files_restored: List[str]
    files_failed: List[str]
    reason: RollbackReason
    timestamp: datetime
    error_message: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "success": self.success,
            "rollback_point_id": self.rollback_point_id,
            "files_restored": self.files_restored,
            "files_failed": self.files_failed,
            "reason": self.reason.value,
            "timestamp": self.timestamp.isoformat(),
            "error_message": self.error_message
        }


class RollbackAgent:
    """
    高度なロールバック管理エージェント
    
    主な機能:
    1. 複数ファイルの一括ロールバック
    2. 時系列でのロールバック
    3. 特定のコミットへのロールバック
    4. ロールバック前の影響分析
    5. 自動ロールバック判定
    """
    
    def __init__(self, 
                 backup_dir: str = ".rollback_backup",
                 max_snapshots: int = 100,
                 auto_rollback_enabled: bool = True):
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        self.max_snapshots = max_snapshots
        self.auto_rollback_enabled = auto_rollback_enabled
        
        # ロールバックポイントの管理
        self.rollback_points: Dict[str, RollbackPoint] = {}
        self.rollback_history: List[RollbackResult] = []
        
        # メタデータファイル
        self.metadata_file = self.backup_dir / "rollback_metadata.json"
        
        # 起動時にメタデータを読み込む
        self._load_metadata()
        
        logger.info(f"RollbackAgent initialized (backup_dir={backup_dir})")
    
    def create_snapshot(self, 
                       file_paths: List[str],
                       description: str = "",
                       tags: List[str] = None) -> str:
        """
        ファイルのスナップショットを作成
        
        Args:
            file_paths: バックアップするファイルパスのリスト
            description: スナップショットの説明
            tags: タグのリスト
        
        Returns:
            作成されたロールバックポイントのID
        """
        snapshot_id = f"snapshot_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        snapshots = []
        
        for file_path in file_paths:
            if not os.path.exists(file_path):
                logger.warning(f"File not found: {file_path}")
                continue
            
            try:
                # ファイル内容を読み込む
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # ハッシュを計算
                content_hash = hashlib.sha256(content.encode()).hexdigest()
                
                # バックアップファイルパスを生成
                backup_path = self.backup_dir / f"{snapshot_id}_{Path(file_path).name}"
                
                # バックアップファイルに保存
                with open(backup_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                # スナップショットを作成
                snapshot = FileSnapshot(
                    file_path=file_path,
                    content=content,
                    content_hash=content_hash,
                    timestamp=datetime.now(),
                    backup_path=str(backup_path),
                    metadata={
                        "file_size": len(content),
                        "line_count": content.count('\n') + 1
                    }
                )
                snapshots.append(snapshot)
                
                logger.debug(f"Created snapshot for {file_path}")
                
            except Exception as e:
                logger.error(f"Failed to create snapshot for {file_path}: {e}")
        
        # Git コミットハッシュを取得（可能なら）
        commit_hash = self._get_current_commit_hash()
        
        # ロールバックポイントを作成
        rollback_point = RollbackPoint(
            id=snapshot_id,
            timestamp=datetime.now(),
            snapshots=snapshots,
            commit_hash=commit_hash,
            description=description,
            tags=tags or []
        )
        
        # 保存
        self.rollback_points[snapshot_id] = rollback_point
        self._save_metadata()
        
        # 古いスナップショットを削除
        self._cleanup_old_snapshots()
        
        logger.info(f"Created rollback point: {snapshot_id} ({len(snapshots)} files)")
        
        return snapshot_id
    
    def rollback(self, 
                rollback_point_id: str,
                reason: RollbackReason = RollbackReason.MANUAL_REQUEST,
                dry_run: bool = False) -> RollbackResult:
        """
        指定されたロールバックポイントまで復元
        
        Args:
            rollback_point_id: ロールバックポイントID
            reason: ロールバック理由
            dry_run: True の場合、実際には復元せずに影響を分析
        
        Returns:
            ロールバック結果
        """
        if rollback_point_id not in self.rollback_points:
            return RollbackResult(
                success=False,
                rollback_point_id=rollback_point_id,
                files_restored=[],
                files_failed=[],
                reason=reason,
                timestamp=datetime.now(),
                error_message=f"Rollback point not found: {rollback_point_id}"
            )
        
        rollback_point = self.rollback_points[rollback_point_id]
        files_restored = []
        files_failed = []
        
        logger.info(f"Starting rollback to {rollback_point_id} (dry_run={dry_run})")
        
        for snapshot in rollback_point.snapshots:
            try:
                if dry_run:
                    # ドライランモード: 影響分析のみ
                    if os.path.exists(snapshot.file_path):
                        with open(snapshot.file_path, 'r', encoding='utf-8') as f:
                            current_content = f.read()
                        
                        if current_content != snapshot.content:
                            files_restored.append(snapshot.file_path)
                            logger.debug(f"[DRY RUN] Would restore: {snapshot.file_path}")
                    else:
                        files_failed.append(snapshot.file_path)
                        logger.warning(f"[DRY RUN] File not found: {snapshot.file_path}")
                else:
                    # 実際にファイルを復元
                    # まず現在の状態をバックアップ
                    if os.path.exists(snapshot.file_path):
                        self._create_emergency_backup(snapshot.file_path)
                    
                    # 親ディレクトリを作成
                    Path(snapshot.file_path).parent.mkdir(parents=True, exist_ok=True)
                    
                    # ファイルを復元
                    with open(snapshot.file_path, 'w', encoding='utf-8') as f:
                        f.write(snapshot.content)
                    
                    files_restored.append(snapshot.file_path)
                    logger.info(f"Restored: {snapshot.file_path}")
                    
            except Exception as e:
                files_failed.append(snapshot.file_path)
                logger.error(f"Failed to restore {snapshot.file_path}: {e}")
        
        # 結果を作成
        result = RollbackResult(
            success=len(files_failed) == 0,
            rollback_point_id=rollback_point_id,
            files_restored=files_restored,
            files_failed=files_failed,
            reason=reason,
            timestamp=datetime.now(),
            error_message=None if len(files_failed) == 0 else f"{len(files_failed)} files failed"
        )
        
        # 履歴に記録
        if not dry_run:
            self.rollback_history.append(result)
            self._save_metadata()
        
        logger.info(f"Rollback completed: {len(files_restored)} restored, {len(files_failed)} failed")
        
        return result
    
    def rollback_by_time(self, 
                        target_time: datetime,
                        reason: RollbackReason = RollbackReason.MANUAL_REQUEST) -> RollbackResult:
        """
        指定された時刻に最も近いロールバックポイントまで復元
        
        Args:
            target_time: 目標時刻
            reason: ロールバック理由
        
        Returns:
            ロールバック結果
        """
        if not self.rollback_points:
            return RollbackResult(
                success=False,
                rollback_point_id="",
                files_restored=[],
                files_failed=[],
                reason=reason,
                timestamp=datetime.now(),
                error_message="No rollback points available"
            )
        
        # 最も近いロールバックポイントを見つける
        closest_point = min(
            self.rollback_points.values(),
            key=lambda p: abs((p.timestamp - target_time).total_seconds())
        )
        
        logger.info(f"Rolling back to closest point: {closest_point.id} "
                   f"(target={target_time}, actual={closest_point.timestamp})")
        
        return self.rollback(closest_point.id, reason)
    
    def rollback_by_commit(self, 
                          commit_hash: str,
                          reason: RollbackReason = RollbackReason.MANUAL_REQUEST) -> RollbackResult:
        """
        指定されたコミットのロールバックポイントまで復元
        
        Args:
            commit_hash: Git コミットハッシュ
            reason: ロールバック理由
        
        Returns:
            ロールバック結果
        """
        # コミットハッシュが一致するロールバックポイントを検索
        matching_points = [
            p for p in self.rollback_points.values()
            if p.commit_hash and p.commit_hash.startswith(commit_hash)
        ]
        
        if not matching_points:
            return RollbackResult(
                success=False,
                rollback_point_id="",
                files_restored=[],
                files_failed=[],
                reason=reason,
                timestamp=datetime.now(),
                error_message=f"No rollback point found for commit: {commit_hash}"
            )
        
        # 最新のものを使用
        target_point = max(matching_points, key=lambda p: p.timestamp)
        
        logger.info(f"Rolling back to commit {commit_hash}: {target_point.id}")
        
        return self.rollback(target_point.id, reason)
    
    def analyze_impact(self, rollback_point_id: str) -> Dict[str, Any]:
        """
        ロールバックの影響を分析
        
        Args:
            rollback_point_id: ロールバックポイントID
        
        Returns:
            影響分析結果
        """
        result = self.rollback(rollback_point_id, dry_run=True)
        
        if not result.success:
            return {
                "error": result.error_message,
                "can_rollback": False
            }
        
        rollback_point = self.rollback_points[rollback_point_id]
        
        # 変更の詳細を分析
        changes = []
        for snapshot in rollback_point.snapshots:
            if not os.path.exists(snapshot.file_path):
                changes.append({
                    "file": snapshot.file_path,
                    "type": "missing",
                    "description": "File will be restored from backup"
                })
                continue
            
            try:
                with open(snapshot.file_path, 'r', encoding='utf-8') as f:
                    current_content = f.read()
                
                if current_content != snapshot.content:
                    current_lines = current_content.count('\n') + 1
                    snapshot_lines = snapshot.content.count('\n') + 1
                    
                    changes.append({
                        "file": snapshot.file_path,
                        "type": "modified",
                        "current_lines": current_lines,
                        "rollback_lines": snapshot_lines,
                        "line_diff": snapshot_lines - current_lines
                    })
                    
            except Exception as e:
                changes.append({
                    "file": snapshot.file_path,
                    "type": "error",
                    "description": str(e)
                })
        
        return {
            "can_rollback": True,
            "rollback_point_id": rollback_point_id,
            "timestamp": rollback_point.timestamp.isoformat(),
            "files_affected": len(rollback_point.snapshots),
            "files_to_restore": len(result.files_restored),
            "changes": changes
        }
    
    def should_auto_rollback(self, 
                           error_context: Dict[str, Any],
                           test_results: Dict[str, Any]) -> bool:
        """
        自動ロールバックが必要かを判定
        
        Args:
            error_context: エラーコンテキスト
            test_results: テスト結果
        
        Returns:
            True if auto rollback should be performed
        """
        if not self.auto_rollback_enabled:
            return False
        
        # クリティカルなエラータイプ
        critical_errors = [
            'SyntaxError',
            'ImportError',
            'ModuleNotFoundError',
            'AttributeError'
        ]
        
        error_type = error_context.get('error_type', '')
        
        # クリティカルエラーの場合
        if error_type in critical_errors:
            logger.warning(f"Critical error detected: {error_type}")
            return True
        
        # テストが大量に失敗している場合
        if test_results:
            failed = test_results.get('failed', 0)
            total = test_results.get('total', 0)
            
            if total > 0 and failed / total > 0.5:  # 50%以上失敗
                logger.warning(f"High test failure rate: {failed}/{total}")
                return True
        
        return False
    
    def list_rollback_points(self, 
                            tags: List[str] = None,
                            limit: int = 10) -> List[Dict[str, Any]]:
        """
        ロールバックポイント一覧を取得
        
        Args:
            tags: フィルタリング用タグ
            limit: 最大取得数
        
        Returns:
            ロールバックポイントのリスト
        """
        points = list(self.rollback_points.values())
        
        # タグでフィルタリング
        if tags:
            points = [p for p in points if any(tag in p.tags for tag in tags)]
        
        # 時刻でソート（新しい順）
        points.sort(key=lambda p: p.timestamp, reverse=True)
        
        # 制限を適用
        points = points[:limit]
        
        return [
            {
                "id": p.id,
                "timestamp": p.timestamp.isoformat(),
                "files_count": len(p.snapshots),
                "description": p.description,
                "tags": p.tags,
                "commit_hash": p.commit_hash
            }
            for p in points
        ]
    
    def delete_rollback_point(self, rollback_point_id: str) -> bool:
        """ロールバックポイントを削除"""
        if rollback_point_id not in self.rollback_points:
            return False
        
        rollback_point = self.rollback_points[rollback_point_id]
        
        # バックアップファイルを削除
        for snapshot in rollback_point.snapshots:
            try:
                if os.path.exists(snapshot.backup_path):
                    os.remove(snapshot.backup_path)
            except Exception as e:
                logger.warning(f"Failed to delete backup file: {e}")
        
        # ロールバックポイントを削除
        del self.rollback_points[rollback_point_id]
        self._save_metadata()
        
        logger.info(f"Deleted rollback point: {rollback_point_id}")
        
        return True
    
    def _get_current_commit_hash(self) -> Optional[str]:
        """現在の Git コミットハッシュを取得"""
        try:
            result = subprocess.run(
                ['git', 'rev-parse', 'HEAD'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception as e:
            logger.debug(f"Failed to get git commit hash: {e}")
        
        return None
    
    def _create_emergency_backup(self, file_path: str):
        """緊急バックアップを作成"""
        emergency_backup = self.backup_dir / f"emergency_{Path(file_path).name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        shutil.copy2(file_path, emergency_backup)
        logger.debug(f"Created emergency backup: {emergency_backup}")
    
    def _cleanup_old_snapshots(self):
        """古いスナップショットを削除"""
        if len(self.rollback_points) <= self.max_snapshots:
            return
        
        # 古い順にソート
        sorted_points = sorted(
            self.rollback_points.values(),
            key=lambda p: p.timestamp
        )
        
        # 削除する数を計算
        to_delete = len(sorted_points) - self.max_snapshots
        
        for point in sorted_points[:to_delete]:
            self.delete_rollback_point(point.id)
        
        logger.info(f"Cleaned up {to_delete} old snapshots")
    
    def _save_metadata(self):
        """メタデータをファイルに保存"""
        metadata = {
            "rollback_points": {
                point_id: point.to_dict()
                for point_id, point in self.rollback_points.items()
            },
            "rollback_history": [
                result.to_dict()
                for result in self.rollback_history[-100:]  # 最新100件のみ
            ]
        }
        
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def _load_metadata(self):
        """メタデータをファイルから読み込む"""
        if not self.metadata_file.exists():
            return
        
        try:
            with open(self.metadata_file, 'r', encoding='utf-8') as f:
                metadata = json.load(f)
            
            # ロールバックポイントを復元
            for point_id, point_data in metadata.get("rollback_points", {}).items():
                snapshots = [
                    FileSnapshot(
                        file_path=s["file_path"],
                        content="",  # 内容はバックアップファイルから読み込む
                        content_hash=s["content_hash"],
                        timestamp=datetime.fromisoformat(s["timestamp"]),
                        backup_path=s["backup_path"],
                        metadata=s.get("metadata", {})
                    )
                    for s in point_data["snapshots"]
                ]
                
                rollback_point = RollbackPoint(
                    id=point_data["id"],
                    timestamp=datetime.fromisoformat(point_data["timestamp"]),
                    snapshots=snapshots,
                    commit_hash=point_data.get("commit_hash"),
                    description=point_data.get("description", ""),
                    tags=point_data.get("tags", [])
                )
                
                self.rollback_points[point_id] = rollback_point
            
            logger.info(f"Loaded {len(self.rollback_points)} rollback points from metadata")
            
        except Exception as e:
            logger.error(f"Failed to load metadata: {e}")


# 使用例
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    agent = RollbackAgent(backup_dir=".test_rollback")
    
    # テストファイルを作成
    test_file = "test_file.py"
    with open(test_file, 'w') as f:
        f.write("# Version 1\nprint('Hello')")
    
    # スナップショットを作成
    snapshot_id = agent.create_snapshot(
        [test_file],
        description="Initial version",
        tags=["test", "initial"]
    )
    
    # ファイルを変更
    with open(test_file, 'w') as f:
        f.write("# Version 2\nprint('Hello World')")
    
    # 影響分析
    impact = agent.analyze_impact(snapshot_id)
    print(f"\nImpact Analysis:\n{json.dumps(impact, indent=2)}")
    
    # ロールバック
    result = agent.rollback(snapshot_id)
    print(f"\nRollback Result:\n{json.dumps(result.to_dict(), indent=2)}")
    
    # ロールバックポイント一覧
    points = agent.list_rollback_points()
    print(f"\nRollback Points:\n{json.dumps(points, indent=2)}")
    
    # クリーンアップ
    os.remove(test_file)


#run_multi_agent.py
# run_multi_agent.py
"""マルチエージェントシステムの統合オーケストレーター（完全修正版）"""
# ========================================
# デバッグ: TaskExecutor の確認
# ========================================
import sys
import importlib

# キャッシュクリア
if 'task_executor' in sys.modules:
    print("🔄 task_executor モジュールをリロード中...")
    importlib.reload(sys.modules['task_executor'])

from task_executor import TaskExecutor

# メソッド確認
print("\n" + "="*60)
print("🔍 TaskExecutor クラスの確認")
print("="*60)
print(f"📁 モジュール場所: {sys.modules['task_executor'].__file__}")
print("\n📋 利用可能なメソッド:")
methods = [m for m in dir(TaskExecutor) if not m.startswith('_')]
for method in methods:
    print(f"  - {method}")

if 'run_all_tasks' in methods:
    print("\n✅ run_all_tasks メソッドが見つかりました")
else:
    print("\n❌ run_all_tasks メソッドが見つかりません")
    print("\n🚨 緊急パッチを適用します...")
    
    # 緊急パッチを動的にインポート
    exec(open('task_executor.py').read())

print("="*60 + "\n")

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import asyncio
import logging
from pathlib import Path
import argparse

# ===== 最優先: ログ設定 =====
from config_utils import config, ErrorHandler, PathManager

# === パート1: エラーハンドラーのインポートと設定 ===
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        BrowserErrorHandler,
        SheetErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
    logger = logging.getLogger(__name__)
    logger.info("✅ 強化版エラーハンドラー読み込み成功")
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced.py が見つかりません（標準エラーハンドラー使用）")
    EnhancedErrorHandler = None
    BrowserErrorHandler = None

# === パート2: その他のモジュールをインポート ===
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_agent import PMAgent
from task_executor import TaskExecutor
from design_agent import DesignAgent
from dev_agent import DevAgent
from review_agent import ReviewAgent


class MultiAgentOrchestrator:
    """マルチエージェントシステムの統合オーケストレーター"""

    def __init__(self, pc_id: int = None, max_iterations: int = None):
        # === パート1: 基本パラメータの初期化 ===
        self.pc_id = pc_id or 1
        self.max_iterations = max_iterations
        
        # === パート2: コンポーネント変数の初期化 ===
        self.sheets_manager = None
        self.browser = None
        self.pm_agent = None
        self.task_executor = None
        self.design_agent = None
        self.dev_agent = None
        self.review_agent = None
        self.content_writer = None
        self.wordpress_agent = None
        self.output_folder = None
        self.initialization_success = False

    def _is_url(self, path_str: str) -> bool:
        """文字列がURLかどうかを判定"""
        # === パート1: 入力値の検証 ===
        if not path_str:
            return False
        
        # === パート2: URLパターンの判定 ===
        path_lower = path_str.lower().strip()
        return path_lower.startswith('http://') or path_lower.startswith('https://')

    async def _find_service_account_file(self) -> str:
        """サービスアカウントファイルを探す"""
        logger.info("📁 サービスアカウントファイルを検索中...")
        
        # === パート1: 検索パスの定義 ===
        possible_paths = [
            Path.cwd() / "service_account.json",
            Path.home() / "Documents" / "gemini_auto_generate" / "service_account.json",
            Path.home() / "Documents" / "AI_Agent" / "service_account.json",
            Path.home() / "Documents" / "gemini_AI_Agent" / "service_account.json",
            Path(__file__).parent / "service_account.json",
        ]
        
        # === パート2: 環境変数からのパス取得 ===
        env_path = os.environ.get('SERVICE_ACCOUNT_FILE')
        if env_path:
            possible_paths.insert(0, Path(env_path))
        
        # === パート3: バリデーション付きで検索 ===
        for path in possible_paths:
            if not path:
                continue
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                validated_path = EnhancedErrorHandler.validate_file_path(path, must_exist=True)
                if validated_path:
                    logger.info(f"✅ サービスアカウントファイル発見: {validated_path}")
                    return str(validated_path)
            else:
                if path.exists():
                    logger.info(f"✅ サービスアカウントファイル発見: {path}")
                    return str(path)
        
        # === パート4: ファイルが見つからない場合のエラー処理 ===
        raise FileNotFoundError(
            "サービスアカウントファイルが見つかりません。\n"
            "以下の場所を確認してください:\n" +
            "\n".join(f"  - {p}" for p in possible_paths if p)
        )

    async def initialize(self):
        """システムの初期化"""
        try:
            print("="*60)
            print("🚀 マルチエージェントシステム起動中...")
            print("="*60)
    
            # === パート1: サービスアカウントファイルの取得 ===
            service_account_file = await self._find_service_account_file()
        
            # === パート2: Google Sheets Managerの初期化 ===
            logger.info("📊 Google Sheets 接続を初期化中...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
    
            # === パート3: PC設定の読み込み ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} をスプレッドシートから取得")
    
            logger.info(f"⚙️ PC_ID={self.pc_id} の設定を読み込み中...")
            # ⭐ ここで settings を定義
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
        
            # === パート4: 設定の適用 ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
        
            # === パート5: 出力フォルダの設定 ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
        
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"⚠️ B14がURL形式のため、デフォルトフォルダを使用")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"📁 Agent出力先: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"📁 Agent出力先(B14から取得): {self.output_folder}")
        
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
    
            # === パート6: ブラウザの初期化(リトライ付き) ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
        
            if not browser_success:
                raise Exception("ブラウザの初期化に失敗しました")
        
            # === パート7: Geminiサイトへのナビゲーション ===
            logger.info("="*60)
            logger.info("🌐 Geminiサイトへのナビゲーション開始...")
            logger.info("="*60)
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="Geminiナビゲーション"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
    
            # === パート8: WordPress認証情報の取得 ===
            # ⭐ settings は既に定義済みなので使用可能
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
    
            # === パート9: 基本エージェントの初期化 ===
            logger.info("="*60)
            logger.info("🤖 AIエージェント初期化開始...")
            logger.info("="*60)
    
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )

            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
    
            # ReviewAgentの初期化
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)

            # エージェント登録
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
    
            logger.info("✅ 基本エージェント登録完了")
        
            # === パート10: WordPress 専用エージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("🌐 WordPress 専用エージェント初期化中...")
            logger.info("="*60)
        
            if wp_url and wp_user and wp_pass:
                # WordPress エージェントの初期化
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            
                if self.wordpress_agent:
                    logger.info("✅ WordPress エージェント初期化成功")
                else:
                    logger.warning("⚠️ WordPress エージェント初期化失敗（タスク実行に影響なし）")
            else:
                logger.info("⚠️ WordPress 認証情報が未設定です（スキップ）")
                self.wordpress_agent = None
        
            # === パート11: その他のエージェント初期化 ===
            # （content_writers, MA エージェントなど）
            # ... 既存のコードを維持 ...
        
            # === パート12: 初期化完了 ===
            logger.info("="*60)
            logger.info("✅ マルチエージェントシステム初期化完了")
            logger.info("="*60)
            logger.info(f"⚙️ 最大反復回数: {self.max_iterations}")
            logger.info(f"🆔 使用中の PC_ID: {self.pc_id}")
        
            self.initialization_success = True
        
        except Exception as e:
            logger.error("❌ システム初期化失敗")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "システム初期化")
            else:
                ErrorHandler.log_error(e, "システム初期化")
            raise

    async def validate_system_health(self) -> bool:
        """システム健全性チェック（追加）"""
        try:
            logger.info("🔍 システム健全性チェック中...")
            
            # 1. スプレッドシート接続確認
            if not self.sheets_manager or not self.sheets_manager.gc:
                logger.error("❌ Google Sheets接続が確立されていません")
                return False
            
            # 2. シート構造検証
            if not self.sheets_manager.validate_sheet_structure():
                logger.error("❌ シート構造が不正です")
                return False
            
            # 3. タスクシートの基本検証
            try:
                tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
                logger.info(f"📊 タスクシート読み込み: {len(tasks)}件")
                
                # タスクIDの重複チェック
                task_ids = [task.get('task_id') for task in tasks if task.get('task_id')]
                unique_ids = set(task_ids)
                if len(task_ids) != len(unique_ids):
                    logger.warning(f"⚠️ タスクID重複検出: {len(task_ids)} -> {len(unique_ids)}ユニーク")
                
            except Exception as e:
                logger.warning(f"⚠️ タスクシート検証エラー: {e}")
            
            logger.info("✅ システム健全性チェック完了")
            return True
            
        except Exception as e:
            logger.error(f"❌ 健全性チェックエラー: {e}")
            return False


    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """
        WordPress エージェント初期化（完全修正版）
    
        シーケンス:
        1. WordPress エージェントのインスタンス化
        2. WordPress セッション初期化（新しいタブで）
        3. タスクエグゼキュータへの登録
    
        Args:
            wp_url: WordPress サイトURL
            wp_user: ユーザー名
            wp_pass: パスワード
        
        Returns:
            WordPressAgent or None
        """
        try:
            # WordPress エージェントモジュールのインポート
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("⚠️ WordPress モジュールが見つかりません")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # 認証情報の設定
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("🌐 WordPress エージェント初期化中...")
        
            # ステップ1: インスタンス化
            wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            wordpress_agent.sheets_manager = self.sheets_manager
        
            # ステップ2: WordPress セッション初期化（新しいタブで）
            logger.info("🔐 WordPress セッション初期化中...")
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0,
                    context="WordPress セッション初期化"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # ステップ3: 初期化結果の処理
            if wp_login_success:
                # タスクエグゼキュータに登録
                self.task_executor.register_agent('wordpress', wordpress_agent)
                logger.info("✅ WordPress エージェント登録完了")
            
                # クッキー保存状態をログ出力
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file and wp_cookies_file.exists():
                    logger.info(f"🍪 WordPress クッキー: {wp_cookies_file}")
                else:
                    logger.info("🍪 WordPress クッキー: 新規作成済み")
            
                return wordpress_agent
            else:
                logger.error("❌ WordPress セッション初期化失敗")
                return None
            
        except Exception as e:
            logger.error(f"WordPress エージェント初期化エラー: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress 初期化")
            return None

    def _print_browser_troubleshooting(self):
        """ブラウザトラブルシューティングガイド"""
        # === パート1: トラブルシューティング情報の表示 ===
        logger.error("\n📋 トラブルシューティング:")
        logger.error("1. ✅ 既存のChromeプロセスを全て終了")
        logger.error("2. 📁 ブラウザデータディレクトリの権限確認")
        logger.error(f"     → {config.BROWSER_DATA_DIR}")
        logger.error("3. 🔧 Playwrightの再インストール:")
        logger.error("     → playwright install chromium")
        logger.error("4. 🗑️ ブラウザキャッシュのクリア:")
        logger.error(f"     → {config.BROWSER_DATA_DIR} を削除")
        logger.error("5. 🔄 システムの再起動")

    # === 修正開始: MultiAgentOrchestratorのWordPress初期化を強化 ===

    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """WordPressエージェント初期化（クッキー管理対応版）"""
        try:
            # インポートチェック
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("⚠️ WordPressモジュールが見つかりません")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # 認証情報の設定
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("🌐 WordPressエージェント初期化中...")
            self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            self.wordpress_agent.sheets_manager = self.sheets_manager
        
            # WordPressセッション初期化（クッキー優先）
            logger.info("🔐 WordPressセッション初期化中...")
        
            # タイムアウト付き初期化
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0,  # 90秒に延長
                    context="WordPressセッション初期化"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # 初期化結果の処理
            if wp_login_success:
                self.task_executor.register_agent('wordpress', self.wordpress_agent)
                logger.info("✅ WordPressエージェント登録完了")
            
                # クッキー保存状態をログ出力
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file.exists():
                    logger.info(f"📁 WordPressクッキー: {wp_cookies_file}")
                else:
                    logger.info("📁 WordPressクッキー: 新規作成済み")
                
                return self.wordpress_agent
            else:
                logger.error("❌ WordPressセッション初期化失敗")
                return None
            
        except Exception as e:
            logger.error(f"WordPressエージェント初期化エラー: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress初期化")
            return None


    async def initialize(self):
        """システムの初期化"""
        try:
            print("="*60)
            print("🚀 マルチエージェントシステム起動中...")
            print("="*60)
        
            # === パート1: サービスアカウントファイルの取得 ===
            service_account_file = await self._find_service_account_file()
            
            # === パート2: Google Sheets Managerの初期化 ===
            logger.info("📊 Google Sheets 接続を初期化中...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
            health_ok = await self.validate_system_health()
            if not health_ok:
                logger.warning("⚠️ システム健全性チェックで警告が検出されました")
        
            # === パート3: PC設定の読み込み ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} をスプレッドシートから取得")
        
            logger.info(f"⚙️ PC_ID={self.pc_id} の設定を読み込み中...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            
            # === パート4: 設定の適用 ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            # === パート5: 出力フォルダの設定 ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
            
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"⚠️ B14がURL形式のため、デフォルトフォルダを使用")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"📁 Agent出力先: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"📁 Agent出力先(B14から取得): {self.output_folder}")
            
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
            
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
        
            # === パート6: ブラウザの初期化（リトライ付き） ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
            
            if not browser_success:
                raise Exception("ブラウザの初期化に失敗しました")
            
            # === パート7: Geminiサイトへのナビゲーション ===
            logger.info("="*60)
            logger.info("🌐 Geminiサイトへのナビゲーション開始...")
            logger.info("="*60)
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="Geminiナビゲーション"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
        
            # === パート8: WordPress認証情報の取得 ===
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
        
            # === パート9: 基本エージェントの初期化 ===
            logger.info("="*60)
            logger.info("🤖 AIエージェント初期化開始...")
            logger.info("="*60)
        
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )
    
            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
        
            # ReviewAgentの初期化
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)
    
            # エージェント登録
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
        
            logger.info("✅ 基本エージェント登録完了")

            # === パート10: WordPress専用エージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("🌐 WordPress専用エージェントを初期化中...")
            logger.info("="*60)
            
            # WordPress認証情報の取得
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
            
            # === WordPress設計AIエージェント (wp_design) ===
            try:
                from wordpress.wp_design import WordPressDesignAgent
                wp_design_agent = WordPressDesignAgent(
                    self.browser, 
                    output_folder=self.output_folder
                )
                wp_design_agent.sheets_manager = self.sheets_manager
                self.task_executor.register_agent('wp_design', wp_design_agent)
                logger.info("✅ WordPress設計AIエージェント登録完了")
            except ImportError:
                logger.warning("⚠️ wordpress/wp_design.py が見つかりません")
            except Exception as e:
                logger.warning(f"⚠️ WordPress設計AIエージェント登録失敗: {e}")
            
            # === WordPress開発AIエージェント (wp_dev) ===
            try:
                from wordpress.wp_dev import WordPressDevAgent
                
                # WordPressDevAgent のインスタンス化
                wp_dev_agent = WordPressDevAgent(
                    self.browser,
                    wp_credentials=wp_credentials,
                    output_folder=self.output_folder
                )
                wp_dev_agent.sheets_manager = self.sheets_manager
                
                # タスクエグゼキューターに登録
                self.task_executor.register_agent('wp_dev', wp_dev_agent)
                logger.info("✅ WordPress開発AIエージェント(wp_dev)登録完了")
                
                # 標準 dev エージェントのバックアップ登録も維持
                if self.dev_agent:
                    # 既存の dev エージェントは維持（要件定義用）
                    logger.info("✅ 標準 dev エージェントも維持（要件定義タスク用）")
                
            except ImportError:
                logger.warning("⚠️ wordpress/wp_dev.py が見つかりません")
                logger.info("💡 WordPress開発タスクは標準 dev エージェントで処理されます")
                
                # フォールバック: 標準 dev エージェントを wp_dev としても登録
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("🔄 標準 dev エージェントを wp_dev としても登録しました")
                    
            except Exception as e:
                logger.warning(f"⚠️ WordPress開発AIエージェント初期化失敗: {e}")
                
                # エラー時のフォールバック
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("🔄 エラーのため標準 dev エージェントで代替")


            # === パート11: M&A専用エージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("📊 M&A専用エージェントを初期化中...")
            logger.info("="*60)
            
            try:
                from task_executor_ma import MATaskExecutor
                ma_task_executor = MATaskExecutor(self.task_executor.agents)
                self.task_executor.register_agent('ma', ma_task_executor)
                self.task_executor.register_agent('wordpress_ma', ma_task_executor)
                
                # ⭐ 重要: dev エージェントを wp_dev としても登録（バックアップ）
                # wp_dev 専用エージェントが登録されていない場合のフォールバック
                if 'wp_dev' not in self.task_executor.agents and self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("✅ dev エージェントを wp_dev フォールバックとして登録")
                
                logger.info("✅ M&A専用タスク実行エージェント登録完了")
            except ImportError:
                logger.warning("⚠️ task_executor_ma.py が見つかりません")
            except Exception as e:
                logger.warning(f"⚠️ M&A専用エージェント登録失敗: {e}")
            
            # === パート12: 多言語ライターエージェントの初期化 ===
            logger.info("\n" + "="*60)
            logger.info("多言語ライターエージェントを初期化中...")
            logger.info("="*60)
            
            try:
                from content_writers import (
                    JapaneseWriterAgent,
                    EnglishWriterAgent,
                    RussianWriterAgent,
                    UzbekWriterAgent,
                    ChineseWriterAgent,
                    KoreanWriterAgent,
                    TurkishWriterAgent
                )
                
                # 日本語ライター
                ja_writer = JapaneseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ja', ja_writer)
                logger.info("✅ 日本語ライターエージェント登録完了")
                
                # 英語ライター
                en_writer = EnglishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_en', en_writer)
                logger.info("✅ 英語ライターエージェント登録完了")
                
                # ロシア語ライター
                ru_writer = RussianWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ru', ru_writer)
                logger.info("✅ ロシア語ライターエージェント登録完了")
                
                # ウズベク語ライター
                uz_writer = UzbekWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_uz', uz_writer)
                logger.info("✅ ウズベク語ライターエージェント登録完了")
                
                # 中国語ライター
                zh_writer = ChineseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_zh', zh_writer)
                logger.info("✅ 中国語ライターエージェント登録完了")
                
                # 韓国語ライター
                ko_writer = KoreanWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ko', ko_writer)
                logger.info("✅ 韓国語ライターエージェント登録完了")
                
                # トルコ語ライター
                tr_writer = TurkishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_tr', tr_writer)
                logger.info("✅ トルコ語ライターエージェント登録完了")
                
            except Exception as e:
                logger.warning(f"⚠️ コンテンツライターエージェント登録失敗: {e}")
            
            # === パート13: WordPress投稿管理エージェントの初期化 ===
            if wp_url and wp_user and wp_pass:
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            else:
                logger.info("⚠️ WordPress認証情報が未設定です(スキップ)")
                self.wordpress_agent = None
        
            # === パート14: 初期化完了の確認 ===
            logger.info("="*60)
            logger.info("✅ マルチエージェントシステム初期化完了")
            logger.info("="*60)
            logger.info(f"⚙️ 最大反復回数: {self.max_iterations}")
            logger.info(f"🆔 使用中のPC_ID: {self.pc_id}")
            
            self.initialization_success = True
        
        except Exception as e:
            logger.error("❌ システム初期化失敗")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "システム初期化")
            else:
                ErrorHandler.log_error(e, "システム初期化")
            raise

    async def run_full_workflow(self, goal: str = None, auto_continue: bool = False, enable_review: bool = True):
        """完全なワークフローを実行"""
        # === パート1: 初期化状態の確認 ===
        if not self.initialization_success:
            raise Exception("システムが初期化されていません")
        
        try:
            # === パート2: PM AIによるタスク分解フェーズ ===
            print("\n" + "="*60)
            print("📋 フェーズ1: PM AIによるタスク分解")
            print("="*60)
            
            if goal:
                goal_description = goal
                logger.info(f"🎯 指定された目標: {goal_description}")
            else:
                goal_data = await self.pm_agent.load_project_goal()
                if not goal_data:
                    print("\n❌ エラー: 目標が見つかりません")
                    print("--goal オプションで目標を指定するか、")
                    print("スプレッドシートの'project_goal'シートに目標を設定してください")
                    return
                goal_description = goal_data['description']
            
            task_plan = await self.pm_agent.analyze_and_create_tasks(goal_description)
            self.pm_agent.display_task_summary(task_plan)
            
            # === パート3: タスク保存の確認 ===
            if not auto_continue:
                save = input("\n💾 タスクをスプレッドシートに保存しますか? (y/n): ")
                if save.lower() != 'y':
                    print("⏸️ 実行をキャンセルしました")
                    return
            
            await self.pm_agent.save_tasks_to_sheet(task_plan)
            
            # === パート4: タスク実行フェーズ ===
            print("\n" + "="*60)
            print("⚙️ フェーズ2: タスクの実行")
            print("="*60)
            
            if enable_review:
                print("✅ レビューAI: 有効")
            else:
                print("⏭️ レビューAI: 無効")
            
            if not auto_continue:
                execute = input("\n▶️ タスクの実行を開始しますか? (y/n): ")
                if execute.lower() != 'y':
                    print("⏸️ タスク実行をスキップしました")
                    return
            
            # === パート5: タスク実行の実行 ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === パート6: 完了メッセージの表示 ===
            print("\n" + "="*60)
            print("🎉 ワークフロー完了")
            print("="*60)
            print(f"📁 出力フォルダ: {self.output_folder}")
            print("📊 スプレッドシートで結果を確認してください")
            
        except Exception as e:
            logger.error("ワークフロー実行エラー")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ワークフロー実行")
            else:
                ErrorHandler.log_error(e, "ワークフロー実行")
            raise

    async def run_tasks_only(self, auto_continue: bool = False, enable_review: bool = True):
        """既存のタスクのみを実行"""
        # === パート1: 初期化状態の確認 ===
        if not self.initialization_success:
            raise Exception("システムが初期化されていません")
        
        try:
            # === パート2: 実行開始の表示 ===
            print("\n" + "="*60)
            print("⚙️ 既存タスクの実行")
            print("="*60)
            
            if enable_review:
                print("✅ レビューAI: 有効")
            else:
                print("⏭️ レビューAI: 無効")
            
            # === パート3: タスク実行の実行 ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === パート4: 完了メッセージの表示 ===
            print("\n" + "="*60)
            print("🎉 タスク実行完了")
            print("="*60)
            
        except Exception as e:
            logger.error("タスク実行エラー")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "タスク実行")
            else:
                ErrorHandler.log_error(e, "タスク実行")
            raise

    async def cleanup(self):
        """リソースのクリーンアップ（強化版）"""
        logger.info("🧹 クリーンアップ開始...")
        
        cleanup_tasks = []
        
        # ブラウザのクリーンアップ
        if self.browser:
            cleanup_tasks.append(self._safe_cleanup_browser())
        
        # WordPressエージェントのクリーンアップ
        if self.wordpress_agent:
            cleanup_tasks.append(self._safe_cleanup_wordpress())
        
        # その他のエージェントのクリーンアップ
        if hasattr(self, 'dev_agent') and self.dev_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.dev_agent, "dev_agent"))
        
        if hasattr(self, 'design_agent') and self.design_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.design_agent, "design_agent"))
        
        # 並行してクリーンアップ実行
        if cleanup_tasks:
            await asyncio.gather(*cleanup_tasks, return_exceptions=True)
        
        logger.info("✅ 全リソースクリーンアップ完了")

    async def _safe_cleanup_browser(self):
        """安全なブラウザクリーンアップ"""
        try:
            if self.browser:
                await self.browser.cleanup()
                logger.info("✅ ブラウザクリーンアップ完了")
        except Exception as e:
            logger.warning(f"⚠️ ブラウザクリーンアップ失敗: {e}")

    async def _safe_cleanup_wordpress(self):
        """安全なWordPressエージェントクリーンアップ"""
        try:
            if self.wordpress_agent and hasattr(self.wordpress_agent, 'cleanup'):
                await self.wordpress_agent.cleanup()
                logger.info("✅ WordPressエージェントクリーンアップ完了")
        except Exception as e:
            logger.warning(f"⚠️ WordPressエージェントクリーンアップ失敗: {e}")

    async def _safe_cleanup_agent(self, agent, agent_name: str):
        """安全なエージェントクリーンアップ"""
        try:
            if agent and hasattr(agent, 'cleanup'):
                await agent.cleanup()
                logger.info(f"✅ {agent_name} クリーンアップ完了")
        except Exception as e:
            logger.warning(f"⚠️ {agent_name} クリーンアップ失敗: {e}")


async def main():
    """メイン実行関数"""
    # === パート1: コマンドライン引数の解析 ===
    parser = argparse.ArgumentParser(description='マルチエージェントシステム')
    parser.add_argument('--goal', type=str, help='プロジェクト目標を直接指定')
    parser.add_argument('--tasks-only', action='store_true', help='既存タスクのみ実行(PM AIスキップ)')
    parser.add_argument('--auto', action='store_true', help='自動実行(確認なし)')
    parser.add_argument('--no-review', action='store_true', help='レビュー機能を無効化')
    parser.add_argument('--max-iterations', type=int, default=3, help='最大反復回数(デフォルト: 3)')
    parser.add_argument('--pc-id', type=int, help='PC_IDを指定')
    
    args = parser.parse_args()
    
    # === パート2: オーケストレーターの初期化 ===
    orchestrator = MultiAgentOrchestrator(
        pc_id=args.pc_id,
        max_iterations=args.max_iterations
    )
    
    try:
        # === パート3: システム初期化 ===
        await orchestrator.initialize()
        
        # === パート4: ワークフローの実行 ===
        if args.tasks_only:
            await orchestrator.run_tasks_only(
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        else:
            await orchestrator.run_full_workflow(
                goal=args.goal,
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        
    except KeyboardInterrupt:
        # === パート5: ユーザー中断の処理 ===
        logger.warning("\n⏸️ ユーザーによる中断")
    except Exception as e:
        # === パート6: エラー処理 ===
        logger.error(f"❌ 致命的エラー: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        # === パート7: クリーンアップ ===
        await orchestrator.cleanup()
        logger.info("\n👋 マルチエージェントシステムを終了しました")


if __name__ == "__main__":
    asyncio.run(main())

#sheets_manager.py
# sheets_manager.py
"""Google Sheets管理クラス(拡張版: Google Drive対応)"""
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from google.auth import default
from google.auth.transport.requests import Request
from pathlib import Path
from typing import List, Dict, Optional
import logging
import re

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class GoogleSheetsManager:
    """Google Sheets管理クラス(拡張版: Google Drive対応)"""
    
    # Google API スコープの定義
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]
    
    def __init__(self, spreadsheet_id: str, service_account_file: Optional[str] = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.gc: Optional[gspread.Client] = None
        self.drive_service = None  # Google Drive API用
        self.setup_client()
    
    def setup_client(self) -> None:
        """Google Sheets クライアントの設定"""
        try:
            # === パート1: サービスアカウント認証の試行 ===
            logger.info("🔐 Google Sheetsクライアント設定中...")
            
            if self.service_account_file and Path(self.service_account_file).exists():
                # サービスアカウント認証
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.service_account_file, self.GOOGLE_SHEETS_SCOPE)
                self.gc = gspread.authorize(creds)
                
                # Google Drive API用のサービスも初期化
                self._setup_drive_service(creds)
                
                logger.info("✅ サービスアカウントで Google Sheets に接続しました")
            else:
                # === パート2: デフォルト認証へのフォールバック ===
                logger.info("🔄 サービスアカウントなし、デフォルト認証を試行...")
                
                try:
                    creds, project = default(scopes=self.GOOGLE_SHEETS_SCOPE)
                    if creds.expired and creds.refresh_token:
                        creds.refresh(Request())
                    self.gc = gspread.authorize(creds)
                    
                    # Google Drive API用
                    self._setup_drive_service(creds)
                    
                    logger.info("✅ デフォルト認証で Google Sheets に接続しました")
                except Exception as e:
                    logger.warning(f"⚠️ デフォルト認証に失敗しました: {e}")
                    logger.warning("サービスアカウントファイルが必要です")
                    self.gc = None
                    
        except Exception as e:
            ErrorHandler.log_error(e, "Google Sheets クライアント設定")
            self.gc = None
    
    def _setup_drive_service(self, creds):
        """Google Drive APIサービスを初期化"""
        try:
            from googleapiclient.discovery import build
            self.drive_service = build('drive', 'v3', credentials=creds)
            logger.info("✅ Google Drive APIサービスを初期化しました")
        except Exception as e:
            logger.warning(f"⚠️ Google Drive APIサービスの初期化に失敗: {e}")
            self.drive_service = None
    
    def _ensure_client(self) -> None:
        """クライアントが初期化されているか確認"""
        if not self.gc:
            raise Exception("Google Sheets クライアントが初期化されていません。サービスアカウントファイルを設定してください。")
    
    async def update_task_status(self, task_id: int, status: str, sheet_name: str = "pm_tasks") -> bool:
        """
        タスクのステータスを更新（ロバスト性向上版 + 超詳細ログ）
        
        Args:
            task_id: タスクID
            status: 新しいステータス
            sheet_name: シート名
            
        Returns:
            bool: 更新成功フラグ
        """
        try:
            logger.info("=" * 70)
            logger.info(f"🔄 ステータス更新処理開始")
            logger.info(f"   タスクID: {task_id}")
            logger.info(f"   新ステータス: {status}")
            logger.info(f"   対象シート: {sheet_name}")
            logger.info("=" * 70)
            
            # === パート1: クライアントとシートの準備 ===
            logger.info("📋 [ステップ1] Google Sheets クライアント確認中...")
            self._ensure_client()
            logger.info("✅ クライアント確認完了")
            
            logger.info(f"📋 [ステップ2] スプレッドシート接続中 (ID: {self.spreadsheet_id[:20]}...)")
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            logger.info("✅ スプレッドシート接続成功")
            
            logger.info(f"📋 [ステップ3] シート '{sheet_name}' を開いています...")
            task_sheet = sheet.worksheet(sheet_name)
            logger.info("✅ シートを開きました")
            
            # 全データを取得
            logger.info("📋 [ステップ4] シートデータ取得中...")
            all_data = task_sheet.get_all_values()
            logger.info(f"✅ データ取得完了: {len(all_data)}行")
            
            if len(all_data) <= 1:
                logger.warning(f"⚠️ タスクシート '{sheet_name}' にデータがありません（ヘッダーのみ）")
                return False
            
            # === パート2: ヘッダー解析と列インデックスの特定 ===
            logger.info("📋 [ステップ5] ヘッダー解析中...")
            headers = all_data[0]
            logger.info(f"   ヘッダー内容: {headers}")
            
            task_id_col = None
            status_col = None
            
            for i, header in enumerate(headers):
                header_lower = header.lower().strip()
                logger.debug(f"   列{i+1}: '{header}' (小文字: '{header_lower}')")
                
                if 'task_id' in header_lower or header_lower == 'id':
                    task_id_col = i
                    logger.info(f"✅ タスクID列を検出: 列{i+1} ('{header}')")
                elif 'status' in header_lower:
                    status_col = i
                    logger.info(f"✅ ステータス列を検出: 列{i+1} ('{header}')")
            
            # タスクID列が見つからない場合のフォールバック
            if task_id_col is None:
                task_id_col = 0
                logger.warning(f"⚠️ タスクID列が見つかりません。デフォルトで列1を使用します")
            
            # ステータス列が見つからない場合は追加
            if status_col is None:
                status_col = len(headers)
                logger.warning(f"⚠️ ステータス列が見つかりません。新規追加します: 列{status_col + 1}")
                try:
                    task_sheet.update_cell(1, status_col + 1, 'status')
                    logger.info(f"✅ ステータス列を追加しました")
                except Exception as e:
                    logger.error(f"❌ ステータス列追加エラー: {e}")
                    return False
            
            # === パート3: 強化版タスク検索 ===
            logger.info(f"📋 [ステップ6] タスクID '{task_id}' を検索中...")
            logger.info(f"   検索対象列: 列{task_id_col + 1}")
            logger.info(f"   検索対象行数: {len(all_data) - 1}行（ヘッダー除く）")
            
            task_id_str = str(task_id).strip()
            task_found = False
            row_index = None
            
            # 詳細な検索実行
            available_ids = []
            for row_idx, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    
                    logger.debug(f"   行{row_idx}: ID='{cell_value}' (比較対象: '{task_id_str}')")
                    
                    if cell_value == task_id_str:
                        row_index = row_idx
                        task_found = True
                        logger.info(f"✅ タスクを発見: 行{row_idx}")
                        break
            
            if not task_found:
                # 詳細なデバッグ情報を出力
                logger.error(f"❌ タスクID '{task_id_str}' が見つかりません")
                logger.error(f"")
                logger.error(f"🔍 検索詳細:")
                logger.error(f"   検索したID: '{task_id_str}' (型: {type(task_id).__name__})")
                logger.error(f"   検索した列: 列{task_id_col + 1}")
                logger.error(f"   総タスク数: {len(all_data) - 1}")
                logger.error(f"")
                logger.error(f"📋 シート内の利用可能なタスクID:")
                for i, aid in enumerate(available_ids[:10], 1):
                    logger.error(f"   {i}. '{aid}'")
                if len(available_ids) > 10:
                    logger.error(f"   ... 他 {len(available_ids) - 10}件")
                logger.error(f"")
                logger.error(f"💡 確認事項:")
                logger.error(f"   1. タスクID '{task_id}' が pm_tasks シートに存在するか？")
                logger.error(f"   2. タスクIDの列が正しいか？（現在: 列{task_id_col + 1}）")
                logger.error(f"   3. タスクIDに余分な空白や特殊文字が含まれていないか？")
                
                return False
            
            # === パート4: ステータス更新 ===
            logger.info(f"📋 [ステップ7] ステータス更新実行中...")
            logger.info(f"   対象セル: 行{row_index}, 列{status_col + 1}")
            logger.info(f"   新しい値: '{status}'")
            
            try:
                # Google Sheets API でセルを更新
                task_sheet.update_cell(row_index, status_col + 1, status)
                logger.info(f"✅ API呼び出し成功")
                
                # 更新後の検証（オプション）
                import time
                time.sleep(0.5)  # API反映待ち
                
                updated_value = task_sheet.cell(row_index, status_col + 1).value
                logger.info(f"🔍 更新後の値: '{updated_value}'")
                
                if updated_value == status:
                    logger.info(f"✅ ステータス更新確認完了")
                    logger.info("=" * 70)
                    logger.info(f"🎉 タスク {task_id} のステータスを '{status}' に更新しました（行 {row_index}）")
                    logger.info("=" * 70)
                    return True
                else:
                    logger.warning(f"⚠️ 更新値が一致しません: 期待='{status}', 実際='{updated_value}'")
                    return False
                    
            except Exception as api_error:
                logger.error(f"❌ Google Sheets API エラー: {api_error}")
                logger.error(f"")
                logger.error(f"💡 考えられる原因:")
                logger.error(f"   1. サービスアカウントの権限不足")
                logger.error(f"   2. スプレッドシートが編集ロックされている")
                logger.error(f"   3. APIクォータ超過")
                logger.error(f"   4. ネットワーク接続の問題")
                import traceback
                logger.error(traceback.format_exc())
                return False
            
        except Exception as e:
            logger.error(f"❌ タスクステータス更新エラー: {e}")
            logger.error(f"")
            logger.error(f"🔧 エラーコンテキスト:")
            logger.error(f"   タスクID: {task_id}")
            logger.error(f"   ステータス: {status}")
            logger.error(f"   シート: {sheet_name}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def find_available_task_id(self) -> Optional[str]:
        """利用可能なタスクIDを検索（ログ削減版）"""
        try:
            # ログレベルを一時的にERRORに
            original_level = logger.level
            logger.setLevel(logging.ERROR)
            
            # タスクID検索
            task_ids = await self._search_task_ids()
            
            # ログレベルを戻す
            logger.setLevel(original_level)
            
            if task_ids:
                logger.info(f"✅ 利用可能タスク: {len(task_ids)}件")
                return task_ids[0]
            else:
                logger.warning("⚠️ 利用可能タスクなし")
                return None
        
        except Exception as e:
            logger.setLevel(original_level)
            logger.error(f"❌ タスクID検索エラー: {e}")
            return None
    
    async def _search_task_ids(self) -> List[str]:
        """内部検索（ログなし）"""
        try:
            # 既存の検索ロジック
            all_values = self.ws.get_all_values()
            
            # フィルタリング
            valid_ids = []
            for row in all_values[1:]:  # ヘッダー除外
                if len(row) >= 11:
                    task_id = row[0]
                    status = row[10]
                    
                    if task_id and task_id not in ['エージェント未登録', 'Review suggested']:
                        if status in ['pending', 'in_progress', '']:
                            valid_ids.append(task_id)
            
            return valid_ids
        
        except Exception as e:
            return []

    async def load_tasks_from_sheet(self, sheet_name: str = "pm_tasks") -> List[Dict]:
        """指定されたシートからタスクを読み込む（エラー修正版）"""
        try:
            # === パート1: シート接続と基本設定 ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            try:
                task_sheet = sheet.worksheet(sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.error(f"❌ シート '{sheet_name}' が見つかりません")
                return []
        
            # === パート2: データ取得方法の試行（複数方式） ===
            logger.info(f"📥 シート '{sheet_name}' からデータ取得中...")
            
            try:
                # 方法1: get_all_records() を試す
                records = task_sheet.get_all_records()
                logger.info(f"✅ get_all_records() でデータ取得成功: {len(records)}行")
            except Exception as e:
                logger.warning(f"⚠️ get_all_records() 失敗: {e}")
                logger.info("🔧 代替方法でデータを取得します...")
                
                # 方法2: 生データを取得して手動で処理
                all_values = task_sheet.get_all_values()
                
                if len(all_values) <= 1:
                    logger.info("📭 データ行がありません")
                    return []
                
                # ヘッダー行を取得
                headers = all_values[0]
                logger.info(f"📋 ヘッダー: {headers}")
                
                # データ行を処理
                records = []
                for i, row in enumerate(all_values[1:], start=2):
                    if not any(row):  # 空行をスキップ
                        continue
                    
                    record = {}
                    for j, header in enumerate(headers):
                        if j < len(row) and header:  # ヘッダーが空でない場合のみ
                            record[header] = row[j]
                        elif j < len(row):
                            record[f'column_{j+1}'] = row[j]  # 空ヘッダーの場合
                    
                    records.append(record)
                
                logger.info(f"✅ 代替方法でデータ取得成功: {len(records)}行")
        
            # === パート3: レコードからタスクオブジェクトへの変換 ===
            tasks = []
            for i, record in enumerate(records, start=2):
                # タスクIDの処理を改善
                task_id = str(record.get('task_id', '')).strip()
                if not task_id and 'task_id' not in record:
                    # 最初の列をタスクIDとして使用
                    first_col = list(record.values())[0] if record else ''
                    task_id = str(first_col).strip()
                
                task = {
                    'task_id': task_id,
                    'description': record.get('task_description', record.get('description', '')),
                    'required_role': record.get('required_role', ''),
                    'status': record.get('status', ''),
                    'priority': record.get('priority', 'medium'),
                    'estimated_time': record.get('estimated_time', ''),
                    'dependencies': record.get('dependencies', ''),
                    'created_at': record.get('created_at', ''),
                    'batch_id': record.get('batch_id', ''),
                    'review_target_task_id': record.get('review_target_task_id', ''),
                    'post_action': record.get('post_action', ''),
                    'language': record.get('language', ''),
                    'polylang_lang': record.get('polylang_lang', '')
                }
                
                # 基本的な検証
                if task['description'] and task['required_role']:
                    tasks.append(task)
        
            logger.info(f"📊 タスク読み込み: {len(tasks)}件（シート: {sheet_name}）")
            
            # === パート4: デバッグ情報と結果返却 ===
            # デバッグ情報
            if tasks:
                logger.info(f"📝 最初のタスク: {tasks[0].get('description', '')[:50]}...")
            else:
                logger.info("📭 読み込まれたタスクは0件です")
                
            return tasks
        
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー（シート: {sheet_name}）: {e}")
            return []

    async def save_task_output(self, output_data: Dict):
        """タスクの出力を保存"""
        try:
            # === パート1: クライアントとシートの準備 ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            # === パート2: 出力シートの存在確認と作成 ===
            # 出力シートが存在するか確認
            try:
                output_sheet = sheet.worksheet("task_outputs")
            except gspread.exceptions.WorksheetNotFound:
                # シートが存在しない場合は作成
                logger.info("'task_outputs' シートを作成します")
                output_sheet = sheet.add_worksheet(title="task_outputs", rows=1000, cols=10)
                # ヘッダーを設定
                headers = ["task_id", "summary", "full_text", "screenshot", "timestamp"]
                output_sheet.append_row(headers)
        
            # === パート3: データの保存 ===
            # データを追加
            row = [
                output_data.get('task_id', ''),
                output_data.get('summary', ''),
                output_data.get('full_text', ''),
                output_data.get('screenshot', ''),
                output_data.get('timestamp', '')
            ]
            output_sheet.append_row(row)
        
            logger.info(f"✅ タスク出力を保存: {output_data.get('task_id', '')}")
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "タスク出力保存")
            return False
    
    def save_result_to_sheet(self, results: List[Dict], mode: str = "text") -> None:
        """
        結果をスプレッドシートに保存
        
        Args:
            results: 結果のリスト
            mode: "text" または "image"
        """
        try:
            # === パート1: クライアントとシート名の準備 ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            # 結果シート名を決定
            result_sheet_name = f"result_{mode}"
            
            # === パート2: シートの存在確認と作成 ===
            # シートが存在しない場合は作成
            try:
                result_sheet = sheet.worksheet(result_sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.info(f"シート '{result_sheet_name}' を作成します")
                result_sheet = sheet.add_worksheet(title=result_sheet_name, rows=1000, cols=10)
                
                # ヘッダーを設定
                headers = ['Index', 'Prompt', 'Status', 'Filename', 'Timestamp', 'Error', 'Mode']
                result_sheet.append_row(headers)
            
            # === パート3: 結果データの保存 ===
            # 結果を追加
            for result in results:
                row = [
                    result.get('index', ''),
                    result.get('prompt', '')[:100],  # プロンプトは最初の100文字
                    result.get('status', ''),
                    result.get('filename', ''),
                    result.get('timestamp', ''),
                    result.get('error', ''),
                    result.get('mode', mode)
                ]
                result_sheet.append_row(row)
            
            logger.info(f"✅ {len(results)}件の結果を '{result_sheet_name}' に保存しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "結果保存")
            logger.warning("結果の保存に失敗しましたが、処理を続行します")
    
    def extract_file_id_from_url(self, url: str) -> Optional[str]:
        """
        Google DriveのURLからファイルIDを抽出
        
        対応形式:
        - https://drive.google.com/file/d/FILE_ID/view
        - https://drive.google.com/open?id=FILE_ID
        - https://docs.google.com/document/d/FILE_ID/edit
        """
        # === パート1: 正規表現パターンの定義 ===
        patterns = [
            r'/file/d/([a-zA-Z0-9_-]+)',
            r'id=([a-zA-Z0-9_-]+)',
            r'/d/([a-zA-Z0-9_-]+)',
        ]
        
        # === パート2: パターンマッチングの実行 ===
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                file_id = match.group(1)
                logger.info(f"✅ ファイルIDを抽出: {file_id}")
                return file_id
        
        logger.warning(f"⚠️ URLからファイルIDを抽出できませんでした: {url}")
        return None
    
    def read_file_from_drive(self, file_id_or_url: str) -> Optional[str]:
        """
        Google Driveからファイルをダウンロードして読み込む（超詳細ログ版）
        
        Args:
            file_id_or_url: ファイルID または Google DriveのURL
            
        Returns:
            ファイルの内容（テキスト）、失敗時はNone
        """
        try:
            logger.info("="*60)
            logger.info("【Google Drive読み込み開始】")
            logger.info("="*60)
            
            # === パート1: Drive APIサービスの確認 ===
            logger.info("【切り分け1】Drive APIサービスを確認")
            if not self.drive_service:
                logger.error("❌ Google Drive APIサービスが初期化されていません")
                logger.error("  → サービスアカウント認証を確認してください")
                return None
            logger.info("✅ Drive APIサービス: 正常")
            
            # === パート2: 入力値の解析とファイルIDの抽出 ===
            logger.info("【切り分け2】入力値を解析")
            logger.info(f"  入力: {file_id_or_url[:100]}")
            
            if file_id_or_url.startswith('http'):
                logger.info("  → URL形式と判定")
                file_id = self.extract_file_id_from_url(file_id_or_url)
                if not file_id:
                    logger.error("❌ URLからファイルIDを抽出できませんでした")
                    return None
                logger.info(f"✅ ファイルID抽出成功: {file_id}")
            else:
                file_id = file_id_or_url
                logger.info(f"  → ファイルID形式: {file_id}")
            
            # === パート3: ファイルメタデータの取得 ===
            logger.info("【切り分け3】ファイルメタデータを取得")
            try:
                from googleapiclient.http import MediaIoBaseDownload
                import io
                
                file_metadata = self.drive_service.files().get(
                    fileId=file_id, 
                    fields='name,mimeType,size,permissions'
                ).execute()
                
                file_name = file_metadata.get('name', 'Unknown')
                mime_type = file_metadata.get('mimeType', '')
                file_size = file_metadata.get('size', '0')
                
                logger.info("✅ ファイルメタデータ取得成功")
                logger.info(f"  ファイル名: {file_name}")
                logger.info(f"  MIME Type: {mime_type}")
                logger.info(f"  サイズ: {file_size} bytes")
                
            except Exception as e:
                logger.error(f"❌ ファイルメタデータ取得エラー: {e}")
                logger.error("  考えられる原因:")
                logger.error("  - ファイルIDが間違っている")
                logger.error("  - サービスアカウントに権限がない")
                logger.error("  - ファイルが削除されている")
                return None
            
            # === パート4: ファイルのダウンロード ===
            logger.info("【切り分け4】ファイルをダウンロード")
            try:
                request = self.drive_service.files().get_media(fileId=file_id)
                
                fh = io.BytesIO()
                downloader = MediaIoBaseDownload(fh, request)
                
                done = False
                chunk_count = 0
                while not done:
                    status, done = downloader.next_chunk()
                    chunk_count += 1
                    if status:
                        progress = int(status.progress() * 100)
                        logger.debug(f"  ⏳ チャンク{chunk_count}: {progress}%")
                
                logger.info(f"✅ ダウンロード完了: {chunk_count}チャンク")
                
            except Exception as e:
                logger.error(f"❌ ダウンロードエラー: {e}")
                return None
            
            # === パート5: バイトデータからテキストへの変換 ===
            logger.info("【切り分け5】バイトデータをテキストに変換")
            try:
                content = fh.getvalue().decode('utf-8')
                logger.info(f"✅ 変換成功: {len(content)}文字")
                logger.info(f"  先頭100文字: {content[:100]}...")
                
                # 内容の検証
                if len(content) < 10:
                    logger.warning(f"⚠️ 内容が短すぎます: {len(content)}文字")
                
                return content
                
            except UnicodeDecodeError as e:
                logger.error(f"❌ UTF-8デコードエラー: {e}")
                logger.error("  → ファイルがテキスト形式ではない可能性")
                return None
            except Exception as e:
                logger.error(f"❌ 変換エラー: {e}")
                return None
            
        except Exception as e:
            logger.error(f"❌ Google Driveファイル読み込みエラー: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def get_current_pc_id(self) -> int:
        """スプレッドシートのB12セルからPC_IDを読み取る"""
        try:
            # === パート1: シート接続とセル読み取り ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
            
            pc_id_value = setting_sheet.cell(12, 2).value
            
            # === パート2: 値の検証と変換 ===
            if pc_id_value:
                try:
                    pc_id = int(pc_id_value)
                    logger.info(f"✅ スプレッドシートからPC_ID={pc_id}を読み取りました(セルB12)")
                    return pc_id
                except ValueError:
                    logger.warning(f"⚠️ B12セルの値 '{pc_id_value}' を整数に変換できません。デフォルト値1を使用します")
                    return 1
            else:
                logger.warning("⚠️ B12セルが空です。デフォルト値1を使用します")
                return 1
                
        except Exception as e:
            ErrorHandler.log_error(e, "PC_ID読み取り")
            logger.warning("⚠️ PC_IDの読み取りに失敗しました。デフォルト値1を使用します")
            return 1
    
    def load_pc_settings(self, pc_id: int = 1) -> Dict[str, str]:
        """PC固有の設定をsettingシートから読み込み"""
        try:
            # === パート1: シート接続と基本設定 ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
        
            col_index = 1 + pc_id
        
            # === パート2: 各設定値の読み込み ===
            settings = {
                'google_id': self._get_cell_value(setting_sheet, 2, col_index),
                'google_pass': self._get_cell_value(setting_sheet, 3, col_index),
                'service_mail': self._get_cell_value(setting_sheet, 4, col_index),
                'download_image_folder': self._get_cell_value(setting_sheet, 5, col_index),
                'download_text_folder': self._get_cell_value(setting_sheet, 6, col_index),
                'browser_data_dir': self._get_cell_value(setting_sheet, 7, col_index),
                'service_account_file': self._get_cell_value(setting_sheet, 8, col_index),
                'cookies_file': self._get_cell_value(setting_sheet, 9, col_index),
                'generation_mode': self._get_cell_value(setting_sheet, 10, col_index),
                'text_format': self._get_cell_value(setting_sheet, 11, col_index),
                'service_type': self._get_cell_value(setting_sheet, 13, col_index),
                'agent_output_folder': self._get_cell_value(setting_sheet, 14, col_index),
                'max_iterations': self._get_cell_value(setting_sheet, 15, col_index),
                'wp_url': self._get_cell_value(setting_sheet, 16, col_index),
                'wp_user': self._get_cell_value(setting_sheet, 17, col_index),
                'wp_pass': self._get_cell_value(setting_sheet, 18, col_index),
            }
        
            # === パート3: 設定値の検証と正規化 ===
            # generation_modeの検証
            mode = settings.get('generation_mode', '').strip().lower()
            if mode not in ['text', 'image']:
                logger.warning(f"⚠️ 不正なgeneration_mode値: '{mode}' → デフォルト 'image' を使用")
                settings['generation_mode'] = 'image'
            else:
                settings['generation_mode'] = mode
        
            # max_iterationsの検証
            try:
                max_iter = int(settings.get('max_iterations', '3'))
                if max_iter < 1 or max_iter > 10:
                    logger.warning(f"⚠️ 不正なmax_iterations値: {max_iter} → デフォルト 3 を使用")
                    settings['max_iterations'] = 3
                else:
                    settings['max_iterations'] = max_iter
            except (ValueError, TypeError):
                logger.warning(f"⚠️ max_iterationsの変換エラー → デフォルト 3 を使用")
                settings['max_iterations'] = 3
        
            logger.info(f"✅ PC_ID={pc_id} の設定を読み込みました")
            return settings
        
        except Exception as e:
            ErrorHandler.log_error(e, f"PC_ID={pc_id} の設定読み込み")
            raise

    def _get_cell_value(self, sheet, row: int, col: int) -> str:
        """セルの値を安全に取得"""
        try:
            value = sheet.cell(row, col).value
            return value if value is not None else ""
        except Exception:
            return ""
    
    def _get_column_letter(self, col_index: int) -> str:
        """列インデックスを列文字に変換(1→A, 2→B, ...)"""
        result = ""
        while col_index > 0:
            col_index -= 1
            result = chr(col_index % 26 + ord('A')) + result
            col_index //= 26
        return result
    
    def load_credentials_from_sheet(self, pc_id: int = 1) -> Dict[str, str]:
        """認証情報を読み込み(PC_ID対応版)"""
        try:
            # === パート1: 設定読み込み ===
            settings = self.load_pc_settings(pc_id)
            
            # === パート2: 認証情報の抽出 ===
            credentials = {
                'email': settings['google_id'],
                'password': settings['google_pass'],
                'service_mail': settings.get('service_mail')
            }
            
            return credentials
            
        except Exception as e:
            ErrorHandler.log_error(e, "認証情報読み込み")
            raise
    
    # sheets_manager.py に以下のメソッドを追加

    async def verify_task_exists(self, task_id: int, sheet_name: str = "pm_tasks") -> bool:
        """タスクがシートに存在するか検証（追加）"""
        try:
            self._ensure_client()
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            task_sheet = sheet.worksheet(sheet_name)
        
            # 全データを取得
            all_data = task_sheet.get_all_values()
        
            if len(all_data) <= 1:
                logger.warning(f"タスクシートにデータがありません")
                return False
        
            # ヘッダー解析
            headers = all_data[0]
            task_id_col = None
        
            for i, header in enumerate(headers):
                header_lower = header.lower()
                if 'task_id' in header_lower or 'id' in header_lower:
                    task_id_col = i
                    break
        
            if task_id_col is None:
                task_id_col = 0
        
            # タスクID検索（型の不一致を考慮）
            task_id_str = str(task_id)
            for row in all_data[1:]:
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    if cell_value == task_id_str:
                        logger.info(f"✅ タスク {task_id} の存在を確認")
                        return True
        
            logger.warning(f"❌ タスク {task_id} はシートに存在しません")
            return False
        
        except Exception as e:
            logger.error(f"タスク存在確認エラー: {e}")
            return False

    def _enhanced_task_search(self, task_sheet, task_id: int, task_id_col: int) -> tuple:
        """強化版タスク検索（修正）"""
        try:
            all_data = task_sheet.get_all_values()
            task_id_str = str(task_id)
        
            # デバッグ情報の収集
            available_ids = []
            for i, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col and row[task_id_col]:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    if cell_value == task_id_str:
                        return (i, True)  # (行番号, 見つかったか)
        
            logger.warning(f"🔍 検索対象ID: '{task_id_str}'")
            logger.warning(f"🔍 利用可能なタスクID: {available_ids}")
            return (None, False)
        
        except Exception as e:
            logger.error(f"タスク検索エラー: {e}")
            return (None, False)
    
    def validate_sheet_structure(self) -> bool:
        """シート構造の妥当性をチェック"""
        try:
            # === パート1: クライアントとシート一覧の取得 ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            required_sheets = ["setting"]
            existing_sheets = [ws.title for ws in sheet.worksheets()]
            
            # === パート2: 必須シートの存在確認 ===
            for required_sheet in required_sheets:
                if required_sheet not in existing_sheets:
                    logger.error(f"❌ 必要なシート '{required_sheet}' が見つかりません")
                    return False
            
            # === パート3: プロンプトシートの存在確認 ===
            if "prompt_text" not in existing_sheets and "prompt" not in existing_sheets:
                logger.error("❌ プロンプトシート ('prompt_text' または 'prompt') が見つかりません")
                return False
            
            logger.info("✅ シート構造の妥当性チェック完了")
            return True
            
        except Exception as e:
            ErrorHandler.log_error(e, "シート構造チェック")
            return False

#system_cli_executor.py
"""
system_cli_executor.py - システムCLIタスク専門実行モジュール
WP-CLI、ACF、ファイル操作などのシステムタスクを担当
"""

import asyncio
import subprocess
import logging
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime

# 設定
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

# コマンド監視エージェント
try:
    from agents.command_monitor_agent import CommandMonitorAgent
    HAS_COMMAND_MONITOR = True
except ImportError:
    HAS_COMMAND_MONITOR = False
    CommandMonitorAgent = None

logger = logging.getLogger(__name__)


class SystemCLIExecutor:
    """
    システムCLIタスクの専門実行モジュール
    
    WP-CLI、ACFインポート、ファイル操作、
    インフラコマンド実行を統合管理
    """
    
    def __init__(self, sheets_manager: GoogleSheetsManager):
        """
        初期化
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
        """
        self.sheets_manager = sheets_manager
        
        # コマンド監視エージェント初期化
        if HAS_COMMAND_MONITOR and CommandMonitorAgent:
            try:
                self.command_monitor = CommandMonitorAgent()
                logger.info("✅ CommandMonitorAgent 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ CommandMonitorAgent 初期化失敗: {e}")
                self.command_monitor = None
        else:
            logger.info("ℹ️ CommandMonitorAgent は利用できません")
            self.command_monitor = None
        
        # タイムアウト設定
        self.default_timeout = 60.0
        self.long_timeout = 300.0
        
        # WP-CLI設定
        self.wp_cli_path = self._detect_wp_cli_path()
        
        logger.info("✅ SystemCLIExecutor 初期化完了")
    
    def _detect_wp_cli_path(self) -> str:
        """WP-CLIパスを検出"""
        candidates = [
            'wp',  # PATH内
            '/usr/local/bin/wp',
            '/usr/bin/wp',
            './wp-cli.phar'
        ]
        
        for candidate in candidates:
            try:
                result = subprocess.run(
                    [candidate, '--version'],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    logger.info(f"✅ WP-CLI検出: {candidate}")
                    return candidate
            except:
                continue
        
        logger.warning("⚠️ WP-CLI未検出 - 'wp'をデフォルト使用")
        return 'wp'
    
    async def execute_cli_task(self, task: Dict) -> Dict:
        """
        CLIタスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("=" * 60)
            logger.info(f"⚙️ CLIタスク実行開始: {task_id}")
            logger.info("=" * 60)
            
            # タスクタイプ判定
            cli_type = self._determine_cli_type(task)
            logger.info(f"CLIタイプ: {cli_type}")
            
            # タイプ別実行
            if cli_type == 'wp-cli':
                result = await self._execute_wp_cli_task(task)
            elif cli_type == 'acf':
                result = await self._execute_acf_task(task)
            elif cli_type == 'file':
                result = await self._execute_file_operation_task(task)
            elif cli_type == 'generic':
                result = await self._execute_generic_command_task(task)
            else:
                logger.warning(f"⚠️ 未知のCLIタイプ: {cli_type}")
                result = await self._execute_generic_command_task(task)
            
            if result.get('success'):
                logger.info(f"✅ CLIタスク {task_id} 完了")
            else:
                logger.error(f"❌ CLIタスク {task_id} 失敗")
            
            return result
        
        except Exception as e:
            logger.error(f"❌ CLIタスク {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"SystemCLIExecutor.execute_cli_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_cli_type(self, task: Dict) -> str:
        """
        CLIタスクのタイプを判定
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: タスクタイプ ('wp-cli', 'acf', 'file', 'generic')
        """
        description = task.get('description', '').lower()
        command = task.get('command', '').lower()
        
        # WP-CLIキーワード
        if any(kw in description or kw in command for kw in ['wp ', 'wp-cli', 'wordpress cli']):
            return 'wp-cli'
        
        # ACFキーワード
        if any(kw in description or kw in command for kw in ['acf', 'advanced custom fields', 'acf-json']):
            return 'acf'
        
        # ファイル操作キーワード
        if any(kw in description for kw in ['ファイル', 'コピー', '移動', '削除', 'mkdir', 'cp', 'mv', 'rm']):
            return 'file'
        
        return 'generic'
    
    async def _execute_wp_cli_task(self, task: Dict) -> Dict:
        """
        WP-CLIコマンドを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🌐 WP-CLIコマンド実行")
            
            # コマンド構築
            command = task.get('command', '')
            if not command:
                # タスク説明からコマンド抽出を試行
                description = task.get('description', '')
                if 'wp ' in description:
                    command = description[description.find('wp '):]
                else:
                    return {
                        'success': False,
                        'error': 'WP-CLIコマンドが指定されていません'
                    }
            
            # WP-CLIパス付加
            if not command.startswith(self.wp_cli_path):
                command = f"{self.wp_cli_path} {command}"
            
            # 作業ディレクトリ
            wp_path = task.get('wp_path', config.WP_PATH if hasattr(config, 'WP_PATH') else None)
            
            # コマンド監視エージェント使用
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            else:
                # 直接実行（フォールバック）
                result = await self._direct_command_execution(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"❌ WP-CLI実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_acf_task(self, task: Dict) -> Dict:
        """
        ACF関連タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📦 ACFタスク実行")
            
            # ACF操作タイプ判定
            description = task.get('description', '').lower()
            
            if 'インポート' in description or 'import' in description:
                # ACFインポート
                acf_file = task.get('acf_file', task.get('file_path', ''))
                
                if not acf_file:
                    return {
                        'success': False,
                        'error': 'ACFファイルパスが指定されていません'
                    }
                
                if self.command_monitor and hasattr(self.command_monitor, 'monitor_acf_import_process'):
                    result = await self.command_monitor.monitor_acf_import_process(acf_file)
                else:
                    # WP-CLI経由でインポート
                    command = f"{self.wp_cli_path} acf import {acf_file}"
                    result = await self._direct_command_execution(
                        command,
                        timeout=self.long_timeout
                    )
                
                return result
            
            elif 'エクスポート' in description or 'export' in description:
                # ACFエクスポート
                output_path = task.get('output_path', './acf-export.json')
                command = f"{self.wp_cli_path} acf export --path={output_path}"
                
                result = await self._direct_command_execution(
                    command,
                    timeout=self.default_timeout
                )
                
                return result
            
            else:
                return {
                    'success': False,
                    'error': 'ACF操作タイプが不明です'
                }
        
        except Exception as e:
            logger.error(f"❌ ACFタスク実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_file_operation_task(self, task: Dict) -> Dict:
        """
        ファイル操作タスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("📁 ファイル操作タスク実行")
            
            description = task.get('description', '').lower()
            
            # 操作タイプ判定
            if 'コピー' in description or 'copy' in description:
                return await self._file_copy(task)
            elif '移動' in description or 'move' in description:
                return await self._file_move(task)
            elif '削除' in description or 'delete' in description:
                return await self._file_delete(task)
            elif 'ディレクトリ作成' in description or 'mkdir' in description:
                return await self._directory_create(task)
            else:
                return {
                    'success': False,
                    'error': 'ファイル操作タイプが不明です'
                }
        
        except Exception as e:
            logger.error(f"❌ ファイル操作エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _file_copy(self, task: Dict) -> Dict:
        """ファイルコピー"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': 'コピー元またはコピー先が指定されていません'}
        
        try:
            shutil.copy2(source, dest)
            logger.info(f"✅ ファイルコピー成功: {source} -> {dest}")
            return {'success': True, 'message': f'コピー完了: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'コピー失敗: {e}'}
    
    async def _file_move(self, task: Dict) -> Dict:
        """ファイル移動"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': '移動元または移動先が指定されていません'}
        
        try:
            shutil.move(source, dest)
            logger.info(f"✅ ファイル移動成功: {source} -> {dest}")
            return {'success': True, 'message': f'移動完了: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'移動失敗: {e}'}
    
    async def _file_delete(self, task: Dict) -> Dict:
        """ファイル削除"""
        target = task.get('target', task.get('file_path', ''))
        
        if not target:
            return {'success': False, 'error': '削除対象が指定されていません'}
        
        try:
            path = Path(target)
            if path.is_file():
                path.unlink()
            elif path.is_dir():
                import shutil
                shutil.rmtree(path)
            else:
                return {'success': False, 'error': f'ファイルまたはディレクトリが見つかりません: {target}'}
            
            logger.info(f"✅ 削除成功: {target}")
            return {'success': True, 'message': f'削除完了: {target}'}
        except Exception as e:
            return {'success': False, 'error': f'削除失敗: {e}'}
    
    async def _directory_create(self, task: Dict) -> Dict:
        """ディレクトリ作成"""
        dir_path = task.get('directory', task.get('path', ''))
        
        if not dir_path:
            return {'success': False, 'error': 'ディレクトリパスが指定されていません'}
        
        try:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
            logger.info(f"✅ ディレクトリ作成成功: {dir_path}")
            return {'success': True, 'message': f'作成完了: {dir_path}'}
        except Exception as e:
            return {'success': False, 'error': f'作成失敗: {e}'}
    
    async def _execute_generic_command_task(self, task: Dict) -> Dict:
        """
        汎用コマンドタスクを実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info("🔧 汎用コマンド実行")
            
            command = task.get('command', '')
            if not command:
                return {
                    'success': False,
                    'error': 'コマンドが指定されていません'
                }
            
            timeout = task.get('timeout', self.default_timeout)
            cwd = task.get('cwd', None)
            
            # コマンド監視エージェント使用
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            else:
                result = await self._direct_command_execution(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"❌ 汎用コマンド実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _direct_command_execution(
        self,
        command: str,
        cwd: Optional[str] = None,
        timeout: float = 60.0
    ) -> Dict:
        """
        コマンドを直接実行（フォールバック）
        
        Args:
            command: 実行するコマンド
            cwd: 作業ディレクトリ
            timeout: タイムアウト時間（秒）
            
        Returns:
            Dict: 実行結果
        """
        try:
            logger.info(f"🔧 コマンド直接実行: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                return {
                    'success': False,
                    'error': f'タイムアウト ({timeout}秒)'
                }
            
            returncode = process.returncode
            stdout_text = stdout.decode('utf-8') if stdout else ''
            stderr_text = stderr.decode('utf-8') if stderr else ''
            
            if returncode == 0:
                logger.info(f"✅ コマンド実行成功")
                return {
                    'success': True,
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
            else:
                logger.error(f"❌ コマンド実行失敗 (コード: {returncode})")
                return {
                    'success': False,
                    'error': f'コマンド失敗 (コード: {returncode})',
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
        
        except Exception as e:
            logger.error(f"❌ コマンド直接実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#system_integration_agent.py
# system_integration_agent.py
"""
システム統合エージェント
既存のMATaskExecutorとハイブリッド修正システムを統合
"""

import asyncio
import logging
import inspect
import traceback
from typing import Dict, Any, Optional, Callable
from functools import wraps
from datetime import datetime

from data_models import ErrorContextModel, BugFixTask, create_bug_fix_task_from_exception

logger = logging.getLogger(__name__)


class SystemIntegrationAgent:
    """
    システム統合エージェント
    
    機能:
    - 既存システムへのエラーフック設置
    - エラー自動検出とルーティング
    - 修正後のタスク再実行
    - システム間の状態同期
    """
    
    def __init__(
        self,
        ma_task_executor=None,
        hybrid_fix_system=None,
        auto_fix_enabled: bool = True,
        auto_retry_enabled: bool = True,
        max_retry_attempts: int = 3
    ):
        """
        初期化
        
        Args:
            ma_task_executor: MATaskExecutor（既存システム）
            hybrid_fix_system: HybridFixSystem（新システム）
            auto_fix_enabled: 自動修正有効フラグ
            auto_retry_enabled: 自動リトライ有効フラグ
            max_retry_attempts: 最大リトライ回数
        """
        self.ma_executor = ma_task_executor
        self.hybrid_system = hybrid_fix_system
        self.auto_fix_enabled = auto_fix_enabled
        self.auto_retry_enabled = auto_retry_enabled
        self.max_retry_attempts = max_retry_attempts
        
        # エラーフックのレジストリ
        self.error_hooks = {}
        
        # 統計情報
        self.stats = {
            "total_errors_caught": 0,
            "auto_fixed_errors": 0,
            "retry_successes": 0,
            "integration_failures": 0
        }
        
        # エラー発生履歴
        self.error_history = []
        
        logger.info("✅ SystemIntegrationAgent 初期化完了")
    
    async def integrate_with_ma_executor(self):
        """MATaskExecutorと統合"""
        try:
            logger.info("🔗 MATaskExecutorとの統合開始")
            
            if not self.ma_executor:
                logger.warning("⚠️ MATaskExecutorが設定されていません")
                return False
            
            # 1. エラーハンドラーを注入
            self._inject_error_handlers()
            
            # 2. タスク実行メソッドをラップ
            self._wrap_task_execution_methods()
            
            # 3. コンポーネントのエラーハンドラーを設置
            self._setup_component_error_handlers()
            
            logger.info("✅ MATaskExecutorとの統合完了")
            return True
            
        except Exception as e:
            logger.error(f"❌ 統合エラー: {e}", exc_info=True)
            return False
    
    def _inject_error_handlers(self):
        """エラーハンドラーを注入"""
        try:
            # MATaskExecutorのメソッドをラップ
            if hasattr(self.ma_executor, 'execute_task'):
                original_execute = self.ma_executor.execute_task
                self.ma_executor.execute_task = self._wrap_with_error_handler(
                    original_execute,
                    "execute_task"
                )
                logger.info("✅ execute_taskメソッドをラップしました")
            
            # 他の重要なメソッドも同様にラップ
            methods_to_wrap = [
                'process_task',
                'run_single_task',
                '_execute_with_retry'
            ]
            
            for method_name in methods_to_wrap:
                if hasattr(self.ma_executor, method_name):
                    original_method = getattr(self.ma_executor, method_name)
                    wrapped_method = self._wrap_with_error_handler(
                        original_method,
                        method_name
                    )
                    setattr(self.ma_executor, method_name, wrapped_method)
                    logger.info(f"✅ {method_name}メソッドをラップしました")
            
        except Exception as e:
            logger.error(f"❌ エラーハンドラー注入失敗: {e}")
    
    def _wrap_with_error_handler(
        self,
        original_method: Callable,
        method_name: str
    ) -> Callable:
        """メソッドをエラーハンドラーでラップ"""
        
        @wraps(original_method)
        async def wrapper(*args, **kwargs):
            retry_count = 0
            last_error = None
            
            while retry_count <= self.max_retry_attempts:
                try:
                    # 元のメソッドを実行
                    if inspect.iscoroutinefunction(original_method):
                        result = await original_method(*args, **kwargs)
                    else:
                        result = original_method(*args, **kwargs)
                    
                    # 成功したらリトライカウントをリセット
                    if retry_count > 0:
                        self.stats["retry_successes"] += 1
                        logger.info(f"✅ リトライ成功: {method_name} (試行{retry_count + 1}回目)")
                    
                    return result
                
                except Exception as e:
                    last_error = e
                    self.stats["total_errors_caught"] += 1
                    
                    logger.error(
                        f"❌ エラー捕捉: {method_name} "
                        f"(試行{retry_count + 1}/{self.max_retry_attempts + 1})"
                    )
                    logger.error(f"   エラー: {type(e).__name__}: {str(e)}")
                    
                    # タスク情報を取得
                    task_id = self._extract_task_id(args, kwargs)
                    file_path = self._extract_file_path(e)
                    
                    # エラー履歴に記録
                    self.error_history.append({
                        "timestamp": datetime.now().isoformat(),
                        "method": method_name,
                        "error_type": type(e).__name__,
                        "error_message": str(e),
                        "task_id": task_id,
                        "retry_count": retry_count
                    })
                    
                    # 自動修正を試行
                    if self.auto_fix_enabled and self.hybrid_system:
                        fix_result = await self._attempt_auto_fix(
                            error=e,
                            task_id=task_id,
                            method_name=method_name,
                            file_path=file_path
                        )
                        
                        if fix_result and fix_result.get("success"):
                            self.stats["auto_fixed_errors"] += 1
                            logger.info(f"✅ 自動修正成功: {task_id}")
                            
                            # 自動リトライが有効な場合、修正後に再実行
                            if self.auto_retry_enabled:
                                retry_count += 1
                                logger.info(f"🔄 タスク再実行: {task_id} (試行{retry_count + 1}回目)")
                                await asyncio.sleep(2)  # 少し待機
                                continue
                    
                    # リトライ判定
                    if retry_count < self.max_retry_attempts and self.auto_retry_enabled:
                        retry_count += 1
                        logger.warning(f"🔄 リトライ: {method_name} (試行{retry_count + 1}回目)")
                        await asyncio.sleep(5)  # リトライ前に待機
                    else:
                        # リトライ上限到達
                        logger.error(f"❌ リトライ上限到達: {method_name}")
                        raise
            
            # すべてのリトライが失敗
            if last_error:
                raise last_error
        
        return wrapper
    
    async def _attempt_auto_fix(
        self,
        error: Exception,
        task_id: str,
        method_name: str,
        file_path: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """自動修正を試行"""
        try:
            logger.info(f"🔧 自動修正を試行: {task_id}")
            
            if not self.hybrid_system:
                logger.warning("⚠️ HybridFixSystemが設定されていません")
                return None
            
            # ファイルパスの推定
            if not file_path:
                file_path = self._infer_file_path(method_name)
            
            # コンテキスト情報を収集
            context = {
                "method_name": method_name,
                "task_id": task_id,
                "auto_fix_attempt": True
            }
            
            # HybridFixSystemのhandle_errorを呼び出し
            fix_result = await self.hybrid_system.handle_error(
                error=error,
                task_id=task_id,
                file_path=file_path,
                context=context
            )
            
            return fix_result
            
        except Exception as e:
            logger.error(f"❌ 自動修正試行エラー: {e}")
            self.stats["integration_failures"] += 1
            return None
    
    def _wrap_task_execution_methods(self):
        """タスク実行メソッドをラップ"""
        try:
            # WordPressAgent, PluginAgent等のエージェントメソッドもラップ
            agents_to_wrap = [
                'wp_agent',
                'plugin_agent',
                'content_writer',
                'acf_agent',
                'cpt_agent'
            ]
            
            for agent_name in agents_to_wrap:
                if hasattr(self.ma_executor, agent_name):
                    agent = getattr(self.ma_executor, agent_name)
                    if agent:
                        self._wrap_agent_methods(agent, agent_name)
            
        except Exception as e:
            logger.error(f"❌ タスク実行メソッドラップエラー: {e}")
    
    def _wrap_agent_methods(self, agent, agent_name: str):
        """エージェントのメソッドをラップ"""
        try:
            # 主要なメソッドを特定
            method_names = [
                name for name in dir(agent)
                if not name.startswith('_') and callable(getattr(agent, name))
            ]
            
            for method_name in method_names[:5]:  # 最初の5つのみ（例）
                try:
                    original_method = getattr(agent, method_name)
                    wrapped_method = self._wrap_with_error_handler(
                        original_method,
                        f"{agent_name}.{method_name}"
                    )
                    setattr(agent, method_name, wrapped_method)
                except:
                    pass  # ラップできないメソッドはスキップ
            
            logger.info(f"✅ {agent_name}のメソッドをラップしました")
            
        except Exception as e:
            logger.warning(f"⚠️ {agent_name}のラップ失敗: {e}")
    
    def _setup_component_error_handlers(self):
        """コンポーネントのエラーハンドラーを設置"""
        try:
            # CommandMonitorAgentのエラーハンドラー
            if hasattr(self.ma_executor, 'cmd_monitor'):
                cmd_monitor = self.ma_executor.cmd_monitor
                if cmd_monitor and hasattr(cmd_monitor, 'execute_command'):
                    original_execute = cmd_monitor.execute_command
                    cmd_monitor.execute_command = self._wrap_with_error_handler(
                        original_execute,
                        "cmd_monitor.execute_command"
                    )
                    logger.info("✅ CommandMonitorAgentのエラーハンドラーを設置")
            
        except Exception as e:
            logger.warning(f"⚠️ コンポーネントエラーハンドラー設置失敗: {e}")
    
    # ========================================
    # ユーティリティ
    # ========================================
    
    def _extract_task_id(self, args: tuple, kwargs: dict) -> str:
        """引数からタスクIDを抽出"""
        # argsから抽出を試みる
        for arg in args:
            if isinstance(arg, dict) and 'task_id' in arg:
                return arg['task_id']
            if isinstance(arg, str) and arg.startswith('Task'):
                return arg
        
        # kwargsから抽出を試みる
        if 'task_id' in kwargs:
            return kwargs['task_id']
        if 'task' in kwargs and isinstance(kwargs['task'], dict):
            return kwargs['task'].get('task_id', 'Unknown')
        
        return f"Unknown-{datetime.now().strftime('%H%M%S')}"
    
    def _extract_file_path(self, error: Exception) -> Optional[str]:
        """エラーからファイルパスを抽出"""
        try:
            tb = traceback.extract_tb(error.__traceback__)
            if tb:
                # 最後のフレームからファイルパスを取得
                return tb[-1].filename
        except:
            pass
        
        return None
    
    def _infer_file_path(self, method_name: str) -> str:
        """メソッド名からファイルパスを推定"""
        # メソッド名からファイル名を推定
        if 'wp_agent' in method_name:
            return 'wordpress/wp_agent.py'
        elif 'plugin' in method_name:
            return 'wordpress/wp_plugin_manager.py'
        elif 'content' in method_name:
            return 'content_writers/base_writer.py'
        elif 'acf' in method_name:
            return 'wordpress/wp_dev/wp_acf_agent.py'
        elif 'cpt' in method_name:
            return 'wordpress/wp_dev/wp_cpt_agent.py'
        else:
            return 'task_executor/task_executor_ma.py'
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        auto_fix_rate = 0.0
        if self.stats["total_errors_caught"] > 0:
            auto_fix_rate = (
                self.stats["auto_fixed_errors"] / 
                self.stats["total_errors_caught"]
            )
        
        return {
            **self.stats,
            "auto_fix_rate": auto_fix_rate,
            "recent_errors": self.error_history[-10:]  # 直近10件
        }
    
    def print_stats(self):
        """統計情報を表示"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("📊 システム統合エージェント 統計情報")
        print("=" * 80)
        print(f"捕捉エラー総数: {stats['total_errors_caught']}")
        print(f"自動修正成功: {stats['auto_fixed_errors']}")
        print(f"自動修正率: {stats['auto_fix_rate']:.1%}")
        print(f"リトライ成功: {stats['retry_successes']}")
        print(f"統合失敗: {stats['integration_failures']}")
        
        if stats['recent_errors']:
            print("\n最近のエラー:")
            for err in stats['recent_errors'][-5:]:
                print(f"  - {err['timestamp']}: {err['error_type']} in {err['method']}")
        
        print("=" * 80 + "\n")

#task_coordinator.py
"""
task_coordinator.py - タスク実行の統合調整レイヤー
既存のTaskExecutorを補完し、タスクの振り分けと結果集約を担当
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# 設定とユーティリティ
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

# 既存のTaskExecutor
from task_executor import TaskExecutor

# 専門実行モジュール（新規）
try:
    from content_task_executor import ContentTaskExecutor
    HAS_CONTENT_EXECUTOR = True
except ImportError:
    HAS_CONTENT_EXECUTOR = False
    ContentTaskExecutor = None

try:
    from system_cli_executor import SystemCLIExecutor
    HAS_CLI_EXECUTOR = True
except ImportError:
    HAS_CLI_EXECUTOR = False
    SystemCLIExecutor = None

try:
    from workflow_executor import WorkflowExecutor
    HAS_WORKFLOW_EXECUTOR = True
except ImportError:
    HAS_WORKFLOW_EXECUTOR = False
    WorkflowExecutor = None

logger = logging.getLogger(__name__)


class TaskCoordinator:
    """
    タスク実行の統合調整レイヤー
    
    既存のTaskExecutorを拡張し、専門実行モジュールへの
    タスク振り分けと結果集約を行う
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        初期化
        
        Args:
            task_executor: 既存のTaskExecutorインスタンス
            sheets_manager: GoogleSheetsManagerインスタンス
            browser_controller: BrowserControllerインスタンス(オプション)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # 統計情報
        self.stats = {
            'total_executed': 0,
            'content_tasks': 0,
            'cli_tasks': 0,
            'workflow_tasks': 0,
            'fallback_tasks': 0,
            'success': 0,
            'failed': 0
        }
        
        logger.info("=" * 60)
        logger.info("🎯 TaskCoordinator 初期化中...")
        logger.info("=" * 60)
        
        # 専門実行モジュールの初期化
        self._initialize_specialized_executors()
        
        logger.info("=" * 60)
        logger.info("✅ TaskCoordinator 初期化完了")
        logger.info("=" * 60)
    
    def _initialize_specialized_executors(self):
        """専門実行モジュールを初期化"""
        
        # コンテンツタスク実行モジュール
        if HAS_CONTENT_EXECUTOR and ContentTaskExecutor:
            try:
                self.content_executor = ContentTaskExecutor(
                    browser_controller=self.browser,
                    sheets_manager=self.sheets_manager
                )
                logger.info("✅ ContentTaskExecutor 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ ContentTaskExecutor 初期化失敗: {e}")
                self.content_executor = None
        else:
            logger.info("ℹ️ ContentTaskExecutor は利用できません（既存実装を使用）")
            self.content_executor = None
        
        # CLIタスク実行モジュール
        if HAS_CLI_EXECUTOR and SystemCLIExecutor:
            try:
                self.cli_executor = SystemCLIExecutor(
                    sheets_manager=self.sheets_manager
                )
                logger.info("✅ SystemCLIExecutor 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ SystemCLIExecutor 初期化失敗: {e}")
                self.cli_executor = None
        else:
            logger.info("ℹ️ SystemCLIExecutor は利用できません")
            self.cli_executor = None
        
        # ワークフロー実行モジュール
        if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
            try:
                self.workflow_executor = WorkflowExecutor(
                    task_executor=self.task_executor,
                    sheets_manager=self.sheets_manager,
                    browser_controller=self.browser
                )
                logger.info("✅ WorkflowExecutor 初期化完了")
            except Exception as e:
                logger.warning(f"⚠️ WorkflowExecutor 初期化失敗: {e}")
                self.workflow_executor = None
        else:
            logger.info("ℹ️ WorkflowExecutor は利用できません")
            self.workflow_executor = None
            
    def determine_executor_type(self, task: Dict) -> str:
        """
        タスクに最適な実行モジュールを判定
            
        Args:
            task: タスク情報辞書
                
        Returns:
            str: 実行モジュールタイプ ('content', 'cli', 'workflow', 'review', 'fallback')
        """
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
            
        # ========================================
        # 🔍 レビュータスク判定（最優先 - 新規追加）
        # ========================================
        if role == 'review' or 'レビュー' in description or 'review' in description:
            return 'review'
        # ========================================
            
        # ワークフローキーワードチェック（最優先）
        workflow_keywords = [
            '多言語', 'マルチステップ', 'レビュー→修正',
            'シーケンス', 'パイプライン', 'チェーン'
        ]
        if any(kw in description for kw in workflow_keywords):
            return 'workflow'
            
        # コンテンツ生成キーワードチェック
        content_keywords = [
            '記事', '生成', '執筆', 'ライティング', 
            'コンテンツ', 'ai', 'gemini', 'deepseek',
            'プロンプト', '抽出'
        ]
        if any(kw in description for kw in content_keywords):
            return 'content'
            
        # CLIコマンドキーワードチェック
        cli_keywords = [
            'wp-cli', 'acf', 'コマンド実行', 'インポート',
            'ファイル操作', 'システム', 'インフラ'
        ]
        if any(kw in description for kw in cli_keywords):
            return 'cli'
            
        # ロールベース判定
        if role in ['content', 'writer', 'seo']:
            return 'content'
        elif role in ['dev', 'system', 'admin']:
            return 'cli'
            
        # デフォルトは既存実装にフォールバック
        return 'fallback'
    
    async def execute_task_coordinated(self, task: Dict) -> Dict:
        """
        タスクを適切な実行モジュールに振り分けて実行
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        self.stats['total_executed'] += 1
        
        try:
            # 実行モジュールタイプを判定
            executor_type = self.determine_executor_type(task)
            
            logger.info("=" * 60)
            logger.info(f"📋 タスク振り分け: {task_id}")
            logger.info(f"実行タイプ: {executor_type.upper()}")
            logger.info("=" * 60)
            
            result = None
            
            # ========================================
            # 🔍 レビュータスク実行（新規追加）
            # ========================================
            if executor_type == 'review':
                logger.info("🔍 ReviewAgent で実行")
                
                # TaskExecutor経由でreview_agentを実行
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'review',
                    'message': 'レビュー実行完了' if success else 'レビュー実行失敗'
                }
            # ========================================
            
            # ワークフロー実行
            elif executor_type == 'workflow' and self.workflow_executor:
                logger.info("🔄 WorkflowExecutor で実行")
                self.stats['workflow_tasks'] += 1
                result = await self.workflow_executor.execute_workflow_task(task)
            
            # コンテンツ生成実行
            elif executor_type == 'content' and self.content_executor:
                logger.info("✍️ ContentTaskExecutor で実行")
                self.stats['content_tasks'] += 1
                result = await self.content_executor.execute_content_task(task)
            
            # CLIタスク実行
            elif executor_type == 'cli' and self.cli_executor:
                logger.info("⚙️ SystemCLIExecutor で実行")
                self.stats['cli_tasks'] += 1
                result = await self.cli_executor.execute_cli_task(task)
            
            # 既存実装へフォールバック
            else:
                logger.info("🔙 既存 TaskExecutor で実行（フォールバック）")
                self.stats['fallback_tasks'] += 1
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'fallback',
                    'message': '既存実装で実行完了'
                }
            
            # 統計更新
            if result and result.get('success'):
                self.stats['success'] += 1
            else:
                self.stats['failed'] += 1
            
            # 実行情報を結果に追加
            if result:
                result['executor_type'] = executor_type
                result['coordinated_execution'] = True
            
            return result
            
        except Exception as e:
            logger.error(f"❌ タスク調整エラー: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
            
        except Exception as e:
            logger.error(f"❌ タスク調整エラー: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
    
    async def run_all_tasks_coordinated(
        self,
        auto_continue: bool = False,
        enable_review: bool = True
    ):
        """
        全タスクを調整レイヤー経由で実行
        
        Args:
            auto_continue: 自動継続フラグ
            enable_review: レビュー有効化フラグ
        """
        logger.info("\n" + "=" * 60)
        logger.info("🚀 タスク調整実行開始")
        logger.info("=" * 60)
        
        try:
            iteration = 0
            max_iterations = self.task_executor.max_iterations
            
            while iteration < max_iterations:
                iteration += 1
                
                logger.info(f"\n{'=' * 60}")
                logger.info(f"反復 {iteration}/{max_iterations}")
                logger.info(f"{'=' * 60}")
                
                # 保留中タスクの読み込み
                pending_tasks = await self.task_executor.load_pending_tasks()
                
                if not pending_tasks:
                    logger.info("✅ 全タスク完了または保留タスクなし")
                    break
                
                logger.info(f"📋 実行予定タスク: {len(pending_tasks)}件")
                
                # タスク実行ループ
                for task in pending_tasks:
                    task_id = task.get('task_id', 'UNKNOWN')
                    
                    try:
                        logger.info(f"\n{'─' * 60}")
                        logger.info(f"タスク実行: {task_id}")
                        logger.info(f"{'─' * 60}")
                        
                        # 調整レイヤー経由で実行
                        result = await self.execute_task_coordinated(task)
                        
                        if result and result.get('success'):
                            logger.info(f"✅ タスク {task_id} 成功")
                        else:
                            logger.error(f"❌ タスク {task_id} 失敗")
                        
                        # ユーザー確認（自動継続でない場合）
                        if not auto_continue:
                            continue_task = input(
                                f"\n次のタスクに進みますか? "
                                f"(y/n/a=以降全て実行): "
                            ).lower()
                            
                            if continue_task == 'n':
                                logger.info("ユーザーによる中断")
                                return
                            elif continue_task == 'a':
                                auto_continue = True
                                logger.info("自動実行モードに切り替え")
                        
                        await asyncio.sleep(2)
                        
                    except KeyboardInterrupt:
                        logger.warning("⏸️ ユーザーによる中断")
                        raise
                    
                    except Exception as e:
                        logger.error(f"❌ タスク {task_id} で予期しないエラー")
                        ErrorHandler.log_error(e, f"タスク {task_id} 実行中")
                        
                        if not auto_continue:
                            cont = input(
                                f"\n⚠️ エラーが発生しました。続行しますか? (y/n): "
                            ).lower()
                            if cont != 'y':
                                logger.info("ユーザーによる中断")
                                break
            
            # 最終統計レポート
            self._print_coordination_report()
            
        except KeyboardInterrupt:
            logger.warning("\n⏸️ ユーザーによる中断")
            self._print_coordination_report()
            raise
        
        except Exception as e:
            logger.error("❌ タスク調整実行全体で重大エラー")
            ErrorHandler.log_error(e, "TaskCoordinator.run_all_tasks_coordinated")
            self._print_coordination_report()
            raise
    
    def _print_coordination_report(self):
        """タスク調整の統計レポートを出力"""
        logger.info("\n" + "=" * 60)
        logger.info("📊 タスク調整実行レポート")
        logger.info("=" * 60)
        logger.info(f"総実行数: {self.stats['total_executed']}")
        logger.info(f"  - コンテンツタスク: {self.stats['content_tasks']}")
        logger.info(f"  - CLIタスク: {self.stats['cli_tasks']}")
        logger.info(f"  - ワークフロータスク: {self.stats['workflow_tasks']}")
        logger.info(f"  - フォールバック: {self.stats['fallback_tasks']}")
        logger.info(f"成功: {self.stats['success']}")
        logger.info(f"失敗: {self.stats['failed']}")
        logger.info("=" * 60)
        
        # コンソール出力
        print("\n" + "=" * 60)
        print("📊 タスク調整実行レポート")
        print("=" * 60)
        print(f"総実行数: {self.stats['total_executed']}")
        print(f"  - コンテンツタスク: {self.stats['content_tasks']}")
        print(f"  - CLIタスク: {self.stats['cli_tasks']}")
        print(f"  - ワークフロータスク: {self.stats['workflow_tasks']}")
        print(f"  - フォールバック: {self.stats['fallback_tasks']}")
        print(f"成功: {self.stats['success']}")
        print(f"失敗: {self.stats['failed']}")
        print("=" * 60 + "\n")
    
    def get_stats(self) -> Dict:
        """統計情報を取得"""
        return self.stats.copy()

#task_executor.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== 設定とユーティリティ =====
from config_utils import ErrorHandler, config

# ===== データ管理 =====
from sheets_manager import GoogleSheetsManager

# ===== エラーハンドラー（オプション） =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced未検出（標準エラーハンドラー使用）")

# ===== 分離モジュール =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPress連携（オプション） =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """タスク実行コントローラー(エラーハンドリング強化版)"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        初期化
        
        Args:
            sheets_manager: GoogleSheetsManager インスタンス
            browser_controller: BrowserController インスタンス(オプション)
            max_iterations: 最大反復回数
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: 最大反復回数 = {self.max_iterations}")
        
        # エージェントを自動初期化
        self._initialize_agents()
        
        # === 分離モジュール初期化 ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # 記事生成専用エグゼキュータ
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("✅ ContentTaskExecutor 初期化完了")
                
                # M&A専用エグゼキュータ
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("✅ MATaskExecutor 初期化完了")
                
                logger.info("="*60)
                logger.info("分離モジュール初期化完了")
                logger.info("  - ContentTaskExecutor (記事生成専用)")
                logger.info("  - MATaskExecutor (M&A/企業検索専用)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"⚠️ 分離モジュール初期化失敗: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("⚠️ 分離モジュールが利用できません")
            self.content_executor = None
            self.ma_executor = None
        
        # === WordPress開発専用エージェント初期化 ===
        logger.info("\n" + "="*60)
        logger.info("🔧 WordPress開発エージェント初期化中...")
        logger.info("="*60)
        
        # WordPress開発エージェント (wp_dev) の初期化
        self.wp_dev_agent = None
        try:
            from wordpress.wp_dev import WordPressDevAgent
            
            if self.browser:
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_dev'] = self.wp_dev_agent
                logger.info("✅ WordPressDevAgent (wp_dev) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラー未初期化のため wp_dev スキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ wordpress/wp_dev.py のインポート失敗: {e}")
            logger.info("💡 WordPress開発タスクは標準 dev エージェントで処理されます")
        except Exception as e:
            logger.warning(f"⚠️ wp_dev エージェント初期化エラー: {e}")
        
        # WordPress設計エージェント (wp_design) の初期化
        self.wp_design_agent = None
        try:
            from wordpress.wp_design import WordPressDesignAgent
            
            if self.browser:
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_design'] = self.wp_design_agent
                logger.info("✅ WordPressDesignAgent (wp_design) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラー未初期化のため wp_design スキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ wordpress/wp_design.py のインポート失敗: {e}")
            logger.info("💡 WordPress設計タスクは標準 design エージェントで処理されます")
        except Exception as e:
            logger.warning(f"⚠️ wp_design エージェント初期化エラー: {e}")
        
        logger.info("="*60)
        logger.info("WordPress専用エージェント初期化完了")
        if self.wp_dev_agent:
            logger.info("  - WordPressDevAgent (カスタム開発)")
        if self.wp_design_agent:
            logger.info("  - WordPressDesignAgent (テーマ/CSS)")
        logger.info("="*60)
        

        # ========================================
        # 🔍 レビューエージェント初期化（新規追加）
        # ========================================
        
        logger.info("\n" + "="*60)
        logger.info("🔍 レビューエージェント初期化中...")
        logger.info("="*60)
        
        # レビューエージェント (review) の初期化
        self.review_agent_instance = None
        try:
            from review_agent import ReviewAgent
            
            if self.browser:
                self.review_agent_instance = ReviewAgent(self.browser)
                if hasattr(self.review_agent_instance, 'sheets_manager'):
                    self.review_agent_instance.sheets_manager = self.sheets_manager
                
                self.agents['review'] = self.review_agent_instance
                logger.info("✅ ReviewAgent (review) 登録完了")
            else:
                logger.warning("⚠️ ブラウザコントローラ未初期化のため review エージェントスキップ")
                
        except ImportError as e:
            logger.warning(f"⚠️ review_agent.py のインポート失敗: {e}")
            logger.info("💡 レビュータスクは標準処理でスキップされます")
        except Exception as e:
            logger.warning(f"⚠️ review エージェント初期化エラー: {e}")
        
        logger.info("="*60)
        if self.review_agent_instance:
            logger.info("レビューエージェント初期化完了")
            logger.info("  - ReviewAgent (品質チェック・仕様確認)")
        else:
            logger.info("レビューエージェントは利用できません")
        logger.info("="*60)

        # ========================================
        # 📦 新規モジュール統合（__init__メソッド内に追加）
        # ========================================

        logger.info("\n" + "="*60)
        logger.info("📦 拡張モジュール統合チェック")
        logger.info("="*60)

        # task_executor.tas__init__ から新規モジュールをインポート
        try:
            from task_executor.tas__init__ import (
                TaskCoordinator,
                ContentTaskExecutor as NewContentExecutor,
                SystemCLIExecutor,
                WorkflowExecutor,
                HAS_COORDINATOR,
                HAS_CONTENT_EXECUTOR,
                HAS_CLI_EXECUTOR,
                HAS_WORKFLOW_EXECUTOR,
                print_module_status
            )
            
            # TaskCoordinator の初期化（オプション）
            if HAS_COORDINATOR:
                try:
                    logger.info("✅ TaskCoordinator 利用可能")
                    self._has_coordinator = True
                except Exception as e:
                    logger.warning(f"⚠️ TaskCoordinator 初期化スキップ: {e}")
                    self._has_coordinator = False
            else:
                logger.info("ℹ️ TaskCoordinator は配置されていません（オプション）")
                self._has_coordinator = False
            
            # 新規 ContentTaskExecutor の初期化（オプション）
            if HAS_CONTENT_EXECUTOR and NewContentExecutor:
                try:
                    self.new_content_executor = NewContentExecutor(
                        browser_controller=self.browser,
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("✅ 新規 ContentTaskExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ 新規 ContentTaskExecutor 初期化失敗: {e}")
                    self.new_content_executor = None
            else:
                logger.info("ℹ️ 新規 ContentTaskExecutor は配置されていません")
                self.new_content_executor = None
            
            # SystemCLIExecutor の初期化（オプション）
            if HAS_CLI_EXECUTOR and SystemCLIExecutor:
                try:
                    self.cli_executor = SystemCLIExecutor(
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("✅ SystemCLIExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ SystemCLIExecutor 初期化失敗: {e}")
                    self.cli_executor = None
            else:
                logger.info("ℹ️ SystemCLIExecutor は配置されていません")
                self.cli_executor = None
            
            # WorkflowExecutor の初期化（オプション）
            if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
                try:
                    self.workflow_executor = WorkflowExecutor(
                        task_executor=self,
                        sheets_manager=self.sheets_manager,
                        browser_controller=self.browser
                    )
                    logger.info("✅ WorkflowExecutor 初期化完了")
                except Exception as e:
                    logger.warning(f"⚠️ WorkflowExecutor 初期化失敗: {e}")
                    self.workflow_executor = None
            else:
                logger.info("ℹ️ WorkflowExecutor は配置されていません")
                self.workflow_executor = None
            
            logger.info("="*60)
            logger.info("拡張モジュール統合完了")
            logger.info("="*60)

        except ImportError as e:
            logger.info("="*60)
            logger.info("ℹ️ 拡張モジュール未配置（既存機能のみ使用）")
            logger.info(f"詳細: {e}")
            logger.info("="*60)
            self._has_coordinator = False
            self.new_content_executor = None
            self.cli_executor = None
            self.workflow_executor = None

    def _initialize_agents(self):
        """エージェントの自動初期化"""
        logger.info("エージェントを初期化中...")
        # エージェントは外部から register_agent() で登録される
        logger.info("エージェント初期化完了")

    def register_agent(self, role: str, agent):
        """エージェントを登録"""
        self.agents[role] = agent
        logger.info(f"エージェント '{role}' を登録しました")

    def register_review_agent(self, review_agent):
        """レビューエージェントを登録"""
        self.review_agent = review_agent
        logger.info("レビューエージェントを登録しました")

    async def execute_task_with_extensions(self, task: Dict) -> bool:
        """
        拡張モジュールを考慮したタスク実行
        
        新規モジュールが利用可能な場合は優先的に使用し、
        そうでなければ既存実装にフォールバック
        
        Args:
            task: タスク情報辞書
            
        Returns:
            bool: 実行成功フラグ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            # CLIタスク判定
            if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'コマンド実行']):
                logger.info(f"🔧 SystemCLIExecutor でタスク {task_id} を実行")
                result = await self.cli_executor.execute_cli_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # ワークフロータスク判定
            if self.workflow_executor and any(kw in description for kw in ['多言語', 'レビュー→修正', 'マルチステップ']):
                logger.info(f"🔄 WorkflowExecutor でタスク {task_id} を実行")
                result = await self.workflow_executor.execute_workflow_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # 既存実装にフォールバック
            logger.info(f"🔙 既存実装でタスク {task_id} を実行")
            return await self.execute_task(task)
        
        except Exception as e:
            logger.error(f"❌ 拡張実行エラー: {e}")
            ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
            # エラー時も既存実装にフォールバック
            return await self.execute_task(task)

    async def load_pending_tasks(self) -> List[Dict]:
        """保留中のタスクを読み込む（エラーハンドリング強化版）"""
        try:
            logger.info("📋 保留中のタスクを読み込み中...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("📭 pm_tasksシートにタスクがありません")
                return []
            
            # statusが'pending'のタスクのみをフィルタ
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"📊 保留中のタスク: {len(pending_tasks)}件")
            
            # デバッグ情報
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... 他 {len(pending_tasks)-3}件")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー: {e}")
            return []

    async def update_task_status(self, task: Dict, status: str, **kwargs):
        """
        タスクステータス更新（引数統一版）
        
        Args:
            task: タスク辞書
            status: ステータス ('completed', 'failed', など)
            **kwargs: その他の引数（errorなど）
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # エラーメッセージの取得
            error_msg = kwargs.get('error', '')
            
            logger.info(f"💬 タスク {task_id} ステータス更新: {status}")
            if error_msg:
                logger.info(f"   エラー: {error_msg}")
            
            # シートマネージャーがある場合のみ更新
            if self.sheets_manager:
                try:
                    # ステータス列に書き込み
                    row = task.get('_row_index')
                    if row:
                        self.sheets_manager.ws.update_cell(row, 11, status)
                        
                        # エラーがある場合はメモ列に書き込み
                        if error_msg and status == 'failed':
                            self.sheets_manager.ws.update_cell(row, 12, f"エラー: {error_msg}")
                except Exception as e:
                    logger.warning(f"⚠️ シート更新失敗: {e}")
            
        except Exception as e:
            logger.warning(f"⚠️ ステータス更新エラー: {e}")
    
    async def execute_task(self, task: Dict) -> bool:
        """タスク実行（完全修正版）"""
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            print(f"\n{'='*70}")
            print(f"🎯 タスク: {task_id}")
            print(f"説明: {task.get('description', 'N/A')[:50]}...")
            print(f"{'='*70}\n")
            
            # ステータス更新
            await self.update_task_status(task, 'in_progress')
            
            role = task['required_role'].lower()
            
            # タイムアウト設定
            task_timeout = 180.0
            
            # エージェント取得
            agent = self.agents.get(role)
            
            if not agent:
                logger.error(f"❌ エージェント '{role}' が登録されていません")
                await self.update_task_status(task, 'failed', error=f'エージェント未登録: {role}')
                return False
            
            # タスク実行（execute または process_task）
            result = None
            
            try:
                if hasattr(agent, 'execute'):
                    logger.info(f"実行: {role}.execute()")
                    result = await asyncio.wait_for(
                        agent.execute(task),
                        timeout=task_timeout
                    )
                elif hasattr(agent, 'process_task'):
                    logger.info(f"実行: {role}.process_task()")
                    result = await asyncio.wait_for(
                        agent.process_task(task),
                        timeout=task_timeout
                    )
                else:
                    logger.error(f"❌ エージェント '{role}' にexecute/process_taskメソッドがありません")
                    await self.update_task_status(task, 'failed', error='メソッド不在')
                    return False
                
            except asyncio.TimeoutError:
                logger.error(f"⏱️ タイムアウト: {task_id}")
                await self.update_task_status(task, 'failed', error='タイムアウト')
                return False
            
            # 結果判定
            if result and result.get('success'):
                logger.info(f"✅ タスク完了: {task_id}")
                await self.update_task_status(task, 'completed')
                
                # 結果保存
                try:
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"⚠️ 結果保存失敗: {e}")
                
                
                # ========================================
                # 🔍 レビュータスク自動生成（新規追加）
                # ========================================
                try:
                    await self._generate_review_task_if_needed(task, result)
                except Exception as e:
                    logger.warning(f"⚠️ レビュータスク生成エラー: {e}")
                # ========================================
                                
                return True
            else:
                error = result.get('error', '不明') if result else '結果なし'
                logger.error(f"❌ タスク失敗: {error}")
                await self.update_task_status(task, 'failed', error=error)
                return False
        
        except Exception as e:
            logger.error(f"❌ タスク実行エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            try:
                await self.update_task_status(task, 'failed', error=str(e))
            except:
                pass
            
            return False
    
    def _determine_task_type_safe(self, task: Dict) -> str:
        """タスクタイプ判定（セーフ版）"""
        try:
            if HAS_TASK_ROUTER and task_router:
                return task_router.determine_task_type(task)
        except:
            pass
        
        # フォールバック判定
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
        
        if any(kw in description for kw in ['要件定義', 'requirements', 'wordpress']):
            return 'requirements'
        elif role in ['ma', 'content', 'review']:
            return role
        else:
            return 'default'
    
    async def _fallback_generic_task(self, task: Dict) -> Dict:
        """汎用フォールバック処理"""
        logger.warning(f"⚠️ エージェント不在 - 汎用処理")
        
        return {
            'success': True,
            'message': 'フォールバック処理完了',
            'summary': f'タスク {task.get("task_id")} を汎用処理で完了'
        }

    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """全タスクを一括実行"""
        logger.info("\n" + "="*80)
        logger.info("🚀 全タスク実行を開始します")
        logger.info("="*80 + "\n")
            
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
            
        try:
            logger.info("📋 ペンディングタスクを読み込み中...")
            pending_tasks = await self.load_pending_tasks()
                
            if not pending_tasks:
                logger.info("📭 実行すべきタスクがありません")
                summary['end_time'] = datetime.now()
                return summary
                
            summary['total'] = len(pending_tasks)
            logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            logger.info(f"👥 登録済みエージェント: {list(self.agents.keys())}\n")
                
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                    
                self.current_iteration += 1
                if self.current_iteration > self.max_iterations:
                    logger.warning(f"⚠️ 最大反復回数 ({self.max_iterations}) に到達")
                    summary['skipped'] = summary['total'] - index + 1
                    break
                    
                logger.info(f"\n{'─'*80}")
                logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                logger.info(f"{'─'*80}")
                    
                try:
                    success = await self.execute_task(task)
                        
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                        
                    if success:
                        summary['success'] += 1
                        logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                        
                    await asyncio.sleep(1)
                        
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"❌ タスク {task_id} エラー: {e}")
                
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
                
            logger.info("\n" + "="*80)
            logger.info("📊 全タスク実行完了")
            logger.info("="*80)
            logger.info(f"  総タスク数:   {summary['total']:>3}件")
            logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
            logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
            logger.info(f"  ⏭️  スキップ:  {summary['skipped']:>3}件")
            logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
            logger.info("="*80 + "\n")
                
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"📈 成功率: {success_rate:.1f}%")
                
            return summary
                
        except Exception as e:
            logger.error(f"❌ 全タスク実行エラー: {e}")
            ErrorHandler.log_error(e, "run_all_tasks")
            summary['end_time'] = datetime.now()
            return summary
            
        finally:
            logger.info("\n🧹 クリーンアップ...")
            self.current_iteration = 0
            logger.info("✅ 完了\n")
    
    async def _generate_review_task_if_needed(self, completed_task: Dict, result: Dict):
        """
        完了タスクに対してレビューが必要な場合、自動的にレビュータスクを生成
                
        Args:
            completed_task: 完了したタスク情報
            result: タスク実行結果
        """
        task_id = completed_task.get('task_id', 'UNKNOWN')
        role = completed_task.get('required_role', '').lower()
        description = completed_task.get('description', '').lower()
                
        # レビューが必要なタスクのキーワード
        review_trigger_keywords = [
            '要件定義', '詳細設計', 'カスタム投稿タイプ', 'acf設計',
            'テンプレート作成', 'テーマカスタマイズ', 'プラグイン開発',
            'requirements', 'design', 'template', 'custom post type'
        ]
                
        # レビューが必要なロール
        review_trigger_roles = ['dev', 'wp_dev', 'design', 'wp_design']
                
        # レビュータスク生成条件チェック
        should_create_review = False
                
        # キーワードベースのチェック
        if any(keyword in description for keyword in review_trigger_keywords):
            should_create_review = True
            logger.info(f"📋 タスク {task_id} はレビュー対象キーワードを含んでいます")
                
        # ロールベースのチェック
        if role in review_trigger_roles:
            should_create_review = True
            logger.info(f"📋 タスク {task_id} のロール '{role}' はレビュー対象です")
                
        # タスク結果に重要なアウトプットがある場合
        if result.get('output_path') or result.get('created_files'):
            should_create_review = True
            logger.info(f"📋 タスク {task_id} は成果物を生成しました")
                
        if not should_create_review:
            logger.debug(f"タスク {task_id} はレビュー不要と判断")
            return
                
        # レビュータスクの生成
        try:
            logger.info(f"🔍 タスク {task_id} のレビュータスクを生成中...")
                    
            # レビュータスクの説明文生成
            review_description = f"【レビュー】ID:{task_id} ({completed_task.get('description', '')[:30]}...) の成果物レビュー"
                    
            # 新しいタスクIDの生成
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            review_task_id = f"REVIEW_{task_id}_{timestamp}"
                    
            # レビュータスクデータ
            review_task_data = {
                'task_id': review_task_id,
                'description': review_description,
                'required_role': 'review',  # ← 重要: レビューエージェントを指定
                'status': 'pending',
                'priority': 'high',
                'parent_task_id': task_id,  # 元タスクへの参照
                'target_output': result.get('output_path', ''),
                'created_at': timestamp
            }
                    
            # Google Sheetsに追加
            if self.sheets_manager:
                try:
                    # pm_tasksシートに新規行を追加
                    new_row = [
                        review_task_id,
                        review_description,
                        'review',  # required_role
                        'high',    # priority
                        'pending', # status
                        '',        # assigned_to
                        '',        # started_at
                        '',        # completed_at
                        task_id,   # parent_task_id
                        result.get('output_path', ''),  # target_output
                        '',        # result
                        f'元タスク: {task_id}'  # memo
                    ]
                            
                    # シートに追加
                    ws = self.sheets_manager.ws
                    ws.append_row(new_row)
                            
                    logger.info(f"✅ レビュータスク {review_task_id} を生成しました")
                    logger.info(f"   対象: {task_id}")
                    logger.info(f"   説明: {review_description}")
                            
                except Exception as e:
                    logger.error(f"❌ レビュータスクのシート追加エラー: {e}")
            else:
                logger.warning("⚠️ sheets_manager が利用できません")
                        
        except Exception as e:
            logger.error(f"❌ レビュータスク生成エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
    
    

#task_executor_content.py
"""
task_executor_content.py
記事生成専用のタスク実行モジュール
task_executor.pyから分離
"""
import logging
from typing import Dict, List
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """記事生成タスク専用の実行クラス"""
    
    def __init__(self, agents: Dict):
        self.agents = agents
    
    async def execute_writer_task(self, task: Dict, role: str) -> Dict:
        """言語別ライタータスクを実行"""
        # === パート1: タスク情報の抽出 ===
        task_language = task.get('language')
        polylang_lang = task.get('polylang_lang')
        
        # === パート2: 実行開始ヘッダー ===
        logger.info("┌" + "─"*58 + "┐")
        logger.info(f"│ ✏️ ライターAIエージェント実行中 ({role})")
        logger.info("├" + "─"*58 + "┤")
        logger.info(f"│ 言語: {task_language}")
        logger.info(f"│ Polylang: {polylang_lang}")
        logger.info("└" + "─"*58 + "┘")
        
        # === パート3: エージェントの選択と実行 ===
        if role == 'writer' or role == 'content':
            # === パート3-1: 汎用ライターの処理 ===
            logger.info("📝 汎用ライターを使用(後方互換性モード)")
            agent = self.agents.get('writer')
            if not agent:
                logger.error("❌ writerエージェントが登録されていません")
                return {
                    'success': False,
                    'error': 'writer エージェントが登録されていません'
                }
            result = await agent.process_task(task)
        else:
            # === パート3-2: 言語別ライターの処理 ===
            agent = self.agents.get(role)
            if not agent:
                logger.error(f"❌ {role}エージェントが登録されていません")
                return {
                    'success': False,
                    'error': f'未対応の言語ライター: {role}'
                }
            
            # === パート3-3: 言語確認 ===
            if task_language and hasattr(agent, 'get_language_code'):
                if agent.get_language_code() != task_language:
                    logger.warning(f"⚠️ 言語不一致: タスク={task_language}, ライター={agent.get_language_code()}")
            
            result = await agent.process_task(task)
        
        # === パート4: 結果の処理 ===
        if result.get('success'):
            logger.info(f"✅ ライターAI ({role}): タスク完了")
            # 言語情報を追加
            if hasattr(agent, 'get_language_code'):
                result['language'] = agent.get_language_code()
                result['polylang_lang'] = polylang_lang or agent.get_language_code()
        else:
            logger.error(f"❌ ライターAI ({role}): 失敗 - {result.get('error', '不明')}")
        
        return result
    
    def display_suggested_tasks(self, suggested_tasks: List[Dict]):
        """提案タスクの詳細を表示"""
        # === パート1: ヘッダー表示 ===
        print("\n" + "="*60)
        print("提案タスク詳細")
        print("="*60)

        # === パート2: 各タスクの詳細表示 ===
        for i, task in enumerate(suggested_tasks, 1):
            # === パート2-1: 優先度マークの設定 ===
            priority_mark = {
                'high': '🔴[高]',
                'medium': '🟡[中]', 
                'low': '🟢[低]'
            }.get(task.get('priority', 'medium'), '⚪[中]')
        
            # === パート2-2: 役割ラベルの設定 ===
            role_label = {
                'design': '📐[設計]',
                'dev': '💻[開発]',
                'ui': '🎨[UI]',
                'review': '✅[レビュー]',
                'wordpress': '🌐[WordPress]',
                'writer': '✏️[ライター]',
                'writer_ja': '🇯🇵[日本語]',
                'writer_en': '🇬🇧[英語]',
                'writer_ru': '🇷🇺[ロシア語]',
                'content': '📄[コンテンツ]'
            }.get(task.get('required_role', 'dev'), '📋[タスク]')
        
            # === パート2-3: タスク情報の表示 ===
            print(f"\n{i}. {priority_mark} {role_label} {task.get('description', 'N/A')}")
            print(f"   理由: {task.get('reasoning', 'N/A')}")
            print(f"   担当: {task.get('required_role', 'dev')}")
            print(f"   優先度: {task.get('priority', 'medium')}")

        # === パート3: フッター表示 ===
        print("="*60)
    
    async def edit_suggested_tasks(self, suggested_tasks: List[Dict]) -> List[Dict]:
        """提案タスクを編集"""
        try:
            # === パート1: 変数初期化 ===
            edited_tasks = []
        
            # === パート2: 各タスクの編集ループ ===
            for i, task in enumerate(suggested_tasks, 1):
                # === パート2-1: 現在のタスク情報表示 ===
                print(f"\n--- タスク {i}/{len(suggested_tasks)} の編集 ---")
                print(f"現在の内容:")
                print(f"  説明: {task.get('description', '')}")
                print(f"  担当: {task.get('required_role', 'dev')}")
                print(f"  優先度: {task.get('priority', 'medium')}")
                print(f"  理由: {task.get('reasoning', '')}")
            
                # === パート2-2: 編集オプション表示 ===
                print(f"\n編集オプション:")
                print("  (d)説明を変更 / (r)担当を変更 / (p)優先度を変更 / (e)理由を変更")
                print("  (s)このタスクをスキップ / (k)このタスクを保持 / (q)編集を終了")
            
                # === パート2-3: ユーザー入力の取得 ===
                edit_choice = input("選択: ").lower()
            
                # === パート2-4: 各選択肢の処理 ===
                if edit_choice == 'd':
                    # 説明変更
                    new_desc = input("新しい説明: ").strip()
                    if new_desc:
                        task['description'] = new_desc
                    edited_tasks.append(task)
                
                elif edit_choice == 'r':
                    # 担当変更
                    print("利用可能な担当:")
                    print("  design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                    new_role = input("新しい担当: ").strip()
                    valid_roles = ['design', 'dev', 'ui', 'review', 'wordpress', 'writer', 
                                'writer_ja', 'writer_en', 'writer_ru', 'writer_uz', 
                                'writer_zh', 'writer_ko', 'writer_tr', 'plugin', 'content']
                    if new_role in valid_roles:
                        task['required_role'] = new_role
                    else:
                        print("無効な担当です。変更しません。")
                    edited_tasks.append(task)
                
                elif edit_choice == 'p':
                    # 優先度変更
                    print("優先度: high, medium, low")
                    new_priority = input("新しい優先度: ").strip()
                    if new_priority in ['high', 'medium', 'low']:
                        task['priority'] = new_priority
                    else:
                        print("無効な優先度です。変更しません。")
                    edited_tasks.append(task)
                
                elif edit_choice == 'e':
                    # 理由変更
                    new_reason = input("新しい理由: ").strip()
                    if new_reason:
                        task['reasoning'] = new_reason
                    edited_tasks.append(task)
                
                elif edit_choice == 's':
                    # スキップ
                    print(f"タスク {i} をスキップしました")
                    continue
                
                elif edit_choice == 'k':
                    # 保持
                    edited_tasks.append(task)
                    print(f"タスク {i} をそのまま保持しました")
                
                elif edit_choice == 'q':
                    # 編集終了
                    print("編集を終了します")
                    break
                
                else:
                    # 不正な入力
                    print("不正な入力です。タスクをそのまま保持します。")
                    edited_tasks.append(task)
        
            # === パート3: 編集結果の表示 ===
            if edited_tasks:
                print(f"\n編集後のタスク ({len(edited_tasks)}件):")
                self.display_suggested_tasks(edited_tasks)
            
            return edited_tasks
        
        except Exception as e:
            # === パート4: 例外処理 ===
            ErrorHandler.log_error(e, "タスク編集")
            return suggested_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """手動でタスクを作成"""
        try:
            # === パート1: 変数初期化 ===
            manual_tasks = []
            
            # === パート2: 作成開始ヘッダー ===
            print("\n" + "="*60)
            print("手動タスク作成")
            print("="*60)
            print("新しいタスクを手動で作成します。")
            print("空の説明で終了します。")
            
            # === パート3: タスク作成ループ ===
            while True:
                # === パート3-1: タスクヘッダー表示 ===
                print(f"\n--- タスク {len(manual_tasks) + 1} ---")
                
                # === パート3-2: タスク説明の入力 ===
                description = input("タスク説明: ").strip()
                if not description:
                    break
                    
                # === パート3-3: 担当の入力 ===
                print("利用可能な担当: design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                role = input("担当 (デフォルト: dev): ").strip() or "dev"
                
                # === パート3-4: 優先度の入力 ===
                print("優先度: high, medium, low")
                priority = input("優先度 (デフォルト: medium): ").strip() or "medium"
                
                # === パート3-5: 理由の入力 ===
                reasoning = input("理由: ").strip()
                
                # === パート3-6: タスクオブジェクトの作成 ===
                task = {
                    'description': description,
                    'required_role': role,
                    'priority': priority,
                    'reasoning': reasoning
                }
                
                # === パート3-7: タスクリストへの追加 ===
                manual_tasks.append(task)
                print(f"タスクを追加しました (合計: {len(manual_tasks)}件)")
                
                # === パート3-8: 継続確認 ===
                more = input("さらにタスクを追加しますか? (y/n): ").lower()
                if more != 'y':
                    break
            
            # === パート4: 作成結果の表示 ===
            if manual_tasks:
                print(f"\n作成したタスク ({len(manual_tasks)}件):")
                self.display_suggested_tasks(manual_tasks)
                
            return manual_tasks
            
        except Exception as e:
            # === パート5: 例外処理 ===
            ErrorHandler.log_error(e, "手動タスク作成")
            return []

#task_executor_ma.py
# task_executor_ma.py
# M&A/企業検索専用のタスク実行モジュール（完全版）

import asyncio
import logging
from typing import Dict, Optional, Any, List
from datetime import datetime
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class MATaskExecutor:
    """M&A/企業検索タスク専用の実行クラス（依存関係注入対応版）"""

    def __init__(self, sheets_manager, browser, max_iterations: int = 30, 
                 wp_agent=None, plugin_agent=None):
        """
        MATaskExecutorの初期化（緩和版 - 必須チェックを削除）
    
        Args:
            sheets_manager: Google Sheetsマネージャー
            browser: ブラウザコントローラー
            max_iterations: 最大イテレーション数
            wp_agent: WordPressエージェント（後で設定可能）
            plugin_agent: プラグインエージェント（後で設定可能）
        """
        # === パート1: 基本プロパティの設定 ===
        self.sheets_manager = sheets_manager
        self.browser = browser
        self.max_iterations = max_iterations
        self.agents = {}  # エージェント辞書を空で初期化
        self.review_agent = None
    
        # === パート2: エージェントの設定（必須チェックを削除）===
        self.wp_agent = wp_agent
        self.plugin_agent = plugin_agent
    
        # === パート3: 遅延初期化フラグ ===
        self._initialized = False
    
        logger.info(f"✅ MATaskExecutor 基本初期化完了 (max_iterations={max_iterations})")
        logger.info(f"   - wp_agent: {'✅ 設定済み' if wp_agent else '⚠️ 未設定（後で設定可能）'}")
        logger.info(f"   - plugin_agent: {'✅ 設定済み' if plugin_agent else '⚠️ 未設定（後で設定可能）'}")

    def set_wordpress_agent(self, wp_agent):
        """WordPressエージェントを後から設定"""
        if not wp_agent:
            logger.error("❌ 設定するWordPressエージェントがNoneです")
            return False
    
        self.wp_agent = wp_agent
        self.agents['wordpress'] = wp_agent
        logger.info("✅ WordPressエージェントを後から設定しました")
    
        # プラグインマネージャーも自動登録
        if hasattr(wp_agent, 'plugin_manager') and wp_agent.plugin_manager:
            self.plugin_agent = wp_agent.plugin_manager
            self.agents['plugin'] = wp_agent.plugin_manager
            logger.info("✅ プラグインマネージャーを自動登録しました")
    
        self._initialized = True
        return True

    def set_plugin_agent(self, plugin_agent):
        """プラグインエージェントを後から設定"""
        if not plugin_agent:
            logger.error("❌ 設定するプラグインエージェントがNoneです")
            return False
    
        self.plugin_agent = plugin_agent
        self.agents['plugin'] = plugin_agent
        logger.info("✅ プラグインエージェントを後から設定しました")
        return True

    def ensure_agents_ready(self):
        """エージェントが準備できているか確認"""
        if not self.wp_agent:
            logger.error("❌ WordPressエージェントがまだ設定されていません")
            return False
        return True
    
    def _register_core_agents(self):
        """コアエージェントを自動登録"""
        # WordPressエージェント登録
        self.agents['wordpress'] = self.wp_agent
        logger.info("✅ WordPressエージェントを登録しました")
        
        # プラグインエージェント登録（存在する場合）
        if self.plugin_agent:
            self.agents['plugin'] = self.plugin_agent
            logger.info("✅ プラグインエージェントを登録しました")
        elif hasattr(self.wp_agent, 'plugin_manager') and self.wp_agent.plugin_manager:
            self.agents['plugin'] = self.wp_agent.plugin_manager
            logger.info("✅ WordPressエージェントからプラグインマネージャーを登録しました")
        else:
            logger.warning("⚠️ プラグインエージェントが見つかりませんでした")
            
    # === 追加メソッド: エージェント登録機能 ===
    def register_agent(self, agent_name: str, agent):
        """エージェントを登録"""
        self.agents[agent_name] = agent
        logger.info(f"✅ エージェント '{agent_name}' を登録しました")
    
    def register_review_agent(self, review_agent):
        """レビューエージェントを登録"""
        self.review_agent = review_agent
        self.agents['review'] = review_agent
        logger.info("✅ レビューエージェントを登録しました")
    
    # ========================================
    # ✅ ここに追加: タスク読み込みメソッド（互換性のため）
    # ========================================
    async def load_pending_tasks(self):
        """
        保留中のタスクを読み込む
        
        Returns:
            List[Dict]: pendingステータスのタスクリスト
        """
        try:
            logger.info("📋 保留中のタスクを読み込み中...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("🔭 pm_tasksシートにタスクがありません")
                return []
            
            # statusが'pending'のタスクのみをフィルタ
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"📊 保留中のタスク: {len(pending_tasks)}件")
            return pending_tasks
            
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー: {e}")
            return []
    
    # ========================================
    # ✅ ここに追加: タスク実行メソッド（互換性のため）
    # ========================================
    async def execute_task(self, task: Dict) -> bool:
        """
        タスクを実行（基本的な実装）
        
        Args:
            task: タスク情報辞書
            
        Returns:
            bool: 実行成功フラグ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info(f"🎯 タスク実行開始: {task_id}")
            
            # M&Aタスクとして実行
            result = await self.execute_ma_task(task)
            
            if result and result.get('success'):
                logger.info(f"✅ タスク完了: {task_id}")
                return True
            else:
                error = result.get('error', '不明') if result else '結果なし'
                logger.error(f"❌ タスク失敗: {error}")
                return False
                
        except Exception as e:
            logger.error(f"❌ タスク実行エラー: {e}")
            return False
    
    # ========================================
    # ✅ ここに追加: 全タスク実行メソッド（互換性のため）
    # ========================================
    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """
        全タスクを一括実行
        
        Args:
            auto_continue: 自動継続フラグ
            enable_review: レビュー有効化フラグ
            
        Returns:
            Dict: 実行結果サマリー
        """
        from datetime import datetime
        
        logger.info("\n" + "="*80)
        logger.info("🚀 全タスク実行を開始します")
        logger.info("="*80 + "\n")
        
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
        
        try:
            # 保留中のタスクを読み込み
            pending_tasks = await self.load_pending_tasks()
            
            if not pending_tasks:
                logger.info("🔭 実行すべきタスクがありません")
                summary['end_time'] = datetime.now()
                return summary
            
            summary['total'] = len(pending_tasks)
            logger.info(f"📊 実行対象タスク: {summary['total']}件\n")
            
            # タスクを順番に実行
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                
                logger.info(f"\n{'─'*80}")
                logger.info(f"📌 タスク {index}/{summary['total']}: {task_id}")
                logger.info(f"{'─'*80}")
                
                try:
                    success = await self.execute_task(task)
                    
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                    
                    if success:
                        summary['success'] += 1
                        logger.info(f"✅ タスク {task_id} 成功 ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"⚠️ タスク {task_id} 失敗 ({index}/{summary['total']})")
                    
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"❌ タスク {task_id} エラー: {e}")
            
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
            logger.info("\n" + "="*80)
            logger.info("📊 全タスク実行完了")
            logger.info("="*80)
            logger.info(f"  総タスク数:   {summary['total']:>3}件")
            logger.info(f"  ✅ 成功:      {summary['success']:>3}件")
            logger.info(f"  ❌ 失敗:      {summary['failed']:>3}件")
            logger.info(f"  ⏱️  実行時間:  {elapsed_time:.2f}秒")
            logger.info("="*80 + "\n")
            
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"📈 成功率: {success_rate:.1f}%")
            
            return summary
            
        except Exception as e:
            logger.error(f"❌ 全タスク実行エラー: {e}")
            summary['end_time'] = datetime.now()
            return summary

    async def execute_ma_task(self, task: Dict) -> Dict:
        """
        M&A関連タスクを実行
    
        タスクの内容を解析して、適切なメソッドに振り分ける
        """
        try:
            # === パート1: 実行開始ヘッダー ===
            logger.info("="*60)
            logger.info("📊 M&A案件処理タスク実行")
            logger.info("="*60)
        
            # === パート2: タスク内容の解析 ===
            description = task.get('description', '').lower()
            parameters = task.get('parameters', {})
        
            # === パート3: パラメータベースの判定（最も確実）===
            if 'cpt_slug' in parameters or 'cpt_labels' in parameters:
                logger.info("→ Custom Post Type作成タスクと判定")
                return await self._execute_cpt_creation(task)
        
            elif 'acf_field_group_name' in parameters or 'acf_fields' in parameters:
                logger.info("→ ACF設定タスクと判定")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy_slug' in parameters or 'taxonomy_labels' in parameters:
                logger.info("→ タクソノミー作成タスクと判定")
                return await self._execute_taxonomy_creation(task)
        
            elif 'facets' in parameters or 'facetwp' in description:
                logger.info("→ 検索機能設定タスクと判定")
                return await self._execute_search_setup(task)
        
            elif 'role_slug' in parameters or 'role_name' in parameters:
                logger.info("→ ユーザーロール設定タスクと判定")
                return await self._execute_user_role_setup(task)
        
            # === パート4: キーワードベースの判定 ===
            elif 'custom post type' in description or 'カスタム投稿タイプ' in description:
                logger.info("→ Custom Post Type作成タスクと判定（キーワード）")
                return await self._execute_cpt_creation(task)
        
            elif 'acf' in description or 'カスタムフィールド' in description:
                logger.info("→ ACF設定タスクと判定（キーワード）")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy' in description or 'タクソノミー' in description:
                logger.info("→ タクソノミー作成タスクと判定（キーワード）")
                return await self._execute_taxonomy_creation(task)
        
            elif 'm&a案件' in description or 'ma_case' in description:
                logger.info("→ M&A案件投稿タスクと判定")
                return await self._execute_ma_case_post(task)
        
            elif '検索' in description or 'search' in description:
                logger.info("→ 検索機能設定タスクと判定")
                return await self._execute_search_setup(task)
        
            elif 'user role' in description or 'ユーザーロール' in description:
                logger.info("→ ユーザーロール設定タスクと判定")
                return await self._execute_user_role_setup(task)
        
            else:
                # === パート5: デフォルト処理 ===
                logger.info("→ 汎用WordPressタスクとして処理")
                wp_agent = self.agents.get('wordpress')
                if wp_agent:
                    return await wp_agent.process_task(task)
                else:
                    return {
                        'success': False,
                        'error': 'WordPressエージェントが登録されていません'
                    }
    
        except Exception as e:
            # === パート6: 例外処理 ===
            ErrorHandler.log_error(e, "M&Aタスク実行")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_cpt_creation(self, task: Dict) -> Dict:
        """Custom Post Type作成タスクを実行"""
        logger.info("【Custom Post Type作成】")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'cpt_slug': parameters.get('cpt_slug', 'ma_case'),
            'cpt_labels': parameters.get('cpt_labels', {
                'singular': 'M&A案件',
                'plural': 'M&A案件一覧'
            }),
            'cpt_supports': parameters.get('cpt_supports', ['title', 'editor', 'thumbnail', 'custom-fields']),
            'cpt_settings': parameters.get('cpt_settings', {
                'public': True,
                'has_archive': True,
                'show_in_rest': True,
                'menu_icon': 'dashicons-portfolio'
            })
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'configure_custom_post_type'):
            result = await wp_agent.configure_custom_post_type(task_params)
        else:
            logger.warning("configure_custom_post_type メソッドが見つかりません")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_acf_setup(self, task: Dict) -> Dict:
        """ACFフィールド設定タスクを実行"""
        logger.info("【ACFフィールド設定】")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'acf_field_group_name': parameters.get('acf_field_group_name', 'M&A案件基本情報'),
            'acf_fields': parameters.get('acf_fields', [
                {'name': 'case_id', 'type': 'text', 'label': '案件ID'},
                {'name': 'ma_scheme', 'type': 'select', 'label': 'M&Aスキーム'},
                {'name': 'desired_price', 'type': 'number', 'label': '希望価格'},
                {'name': 'industry_category', 'type': 'taxonomy', 'label': '業種'},
                {'name': 'region', 'type': 'taxonomy', 'label': '地域'},
                {'name': 'established_year', 'type': 'number', 'label': '設立年'},
                {'name': 'employees', 'type': 'number', 'label': '従業員数'},
            ]),
            'acf_location_rules': parameters.get('acf_location_rules', {
                'post_type': 'ma_case'
            })
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'configure_acf_fields'):
            result = await wp_agent.configure_acf_fields(task_params)
        else:
            logger.warning("configure_acf_fields メソッドが見つかりません")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_taxonomy_creation(self, task: Dict) -> Dict:
        """カスタムタクソノミー作成タスクを実行"""
        logger.info("【カスタムタクソノミー作成】")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません'
            }
        
        parameters = task.get('parameters', {})
        
        # タスクパラメータを構築
        task_params = {
            'taxonomy_slug': parameters.get('taxonomy_slug', 'industry_category'),
            'taxonomy_labels': parameters.get('taxonomy_labels', {
                'singular': '業種',
                'plural': '業種一覧'
            }),
            'taxonomy_post_types': parameters.get('taxonomy_post_types', ['ma_case']),
            'taxonomy_hierarchical': parameters.get('taxonomy_hierarchical', True)
        }
        
        # WordPressエージェントで実行
        if hasattr(wp_agent, 'configure_custom_taxonomy'):
            result = await wp_agent.configure_custom_taxonomy(task_params)
        else:
            logger.warning("configure_custom_taxonomy メソッドが見つかりません")
            result = await wp_agent.process_task(task)
        
        return result
    
    # === 修正: M&A案件投稿メソッド ===
    async def _execute_ma_case_post(self, task: Dict) -> Dict:
        """M&A案件投稿タスクを実行（完全修正版）"""
        logger.info("【M&A案件投稿】")

        # === パート1: 複数の方法でWordPressエージェントを取得 ===
        wp_agent = None
        
        # 方法1: 直接属性から取得
        if hasattr(self, 'wp_agent') and self.wp_agent:
            wp_agent = self.wp_agent
            logger.info("✅ wp_agent 属性から取得")
        
        # 方法2: agents辞書から取得
        elif 'wordpress' in self.agents and self.agents['wordpress']:
            wp_agent = self.agents['wordpress']
            logger.info("✅ agents辞書から取得")
        
        # 方法3: フォールバック - 登録済みエージェントから検索
        else:
            logger.error("❌ WordPressエージェントが見つかりません。登録状況:")
            for agent_name, agent_instance in self.agents.items():
                logger.error(f"  - {agent_name}: {agent_instance}")
            
            return {
                'success': False,
                'error': 'WordPressエージェントが登録されていません。以下のエージェントのみ登録されています: ' + 
                        ', '.join(self.agents.keys())
            }

        if not wp_agent:
            logger.error("❌ WordPressエージェントの取得に失敗")
            return {
                'success': False,
                'error': 'WordPressエージェントの取得に失敗しました'
            }

        # === パート2: タスクパラメータの構築 ===
        parameters = task.get('parameters', {})
        
        task_params = {
            'post_type': 'ma_case',
            'post_title': parameters.get('post_title', '新規M&A案件'),
            'post_content': parameters.get('post_content', ''),
            'acf_fields': parameters.get('acf_fields', {}),
            'polylang_lang': parameters.get('polylang_lang', 'ja'),
            'post_status': parameters.get('post_status', 'draft')
        }
        
        # === パート3: WordPressエージェントで実行 ===
        try:
            logger.info(f"📝 WordPressエージェントでタスク実行: {task_params['post_title']}")
            
            if hasattr(wp_agent, 'create_ma_case_post'):
                result = await wp_agent.create_ma_case_post(task_params)
            else:
                logger.warning("⚠️ create_ma_case_post メソッドが見つからないため、process_task を使用")
                modified_task = task.copy()
                modified_task['parameters'] = task_params
                result = await wp_agent.process_task(modified_task)
            
            return result
            
        except Exception as e:
            logger.error(f"❌ M&A案件投稿実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_search_setup(self, task: Dict) -> Dict:
        """検索機能設定タスクを実行（完全修正版）"""
        logger.info("【検索機能設定】")

        # === パート1: 複数の方法でプラグインエージェントを取得 ===
        plugin_agent = None
        
        # 方法1: 直接属性から取得
        if hasattr(self, 'plugin_agent') and self.plugin_agent:
            plugin_agent = self.plugin_agent
            logger.info("✅ plugin_agent 属性から取得")
        
        # 方法2: agents辞書から取得
        elif 'plugin' in self.agents and self.agents['plugin']:
            plugin_agent = self.agents['plugin']
            logger.info("✅ agents辞書から取得")
        
        # 方法3: WordPressエージェントから取得
        elif hasattr(self, 'wp_agent') and self.wp_agent and hasattr(self.wp_agent, 'plugin_manager'):
            plugin_agent = self.wp_agent.plugin_manager
            logger.info("✅ WordPressエージェントからplugin_managerを取得")
        
        # 方法4: フォールバック
        else:
            logger.error("❌ プラグインエージェントが見つかりません。代替方法を試行...")
            
            # WordPressエージェントで直接処理を試みる
            if hasattr(self, 'wp_agent') and self.wp_agent:
                logger.info("🔧 WordPressエージェントで直接処理")
                return await self.wp_agent.process_task(task)
            else:
                logger.error("❌ 代替方法も失敗")
                return {
                    'success': False,
                    'error': 'プラグインエージェントが見つかりません。WordPressエージェントも利用できません。'
                }

        if not plugin_agent:
            logger.error("❌ プラグインエージェントの取得に失敗")
            return {
                'success': False,
                'error': 'プラグインエージェントの取得に失敗しました'
            }

        # === パート2: タスク実行 ===
        parameters = task.get('parameters', {})
        
        task_params = {
            'plugin_name': 'facetwp',
            'action': 'configure',
            'facets': parameters.get('facets', [
                {
                    'name': '業種フィルター',
                    'type': 'checkboxes',
                    'source': 'tax/industry_category'
                },
                {
                    'name': '価格帯フィルター', 
                    'type': 'slider',
                    'source': 'cf/desired_price'
                }
            ])
        }
        
        try:
            logger.info("🔧 プラグインエージェントで設定実行")
            
            if hasattr(plugin_agent, 'configure_facetwp'):
                result = await plugin_agent.configure_facetwp(task_params)
            else:
                logger.warning("⚠️ configure_facetwp メソッドが見つからないため、change_plugin_settings を使用")
                result = await plugin_agent.change_plugin_settings(None, task)
            
            return result
            
        except Exception as e:
            logger.error(f"❌ 検索機能設定実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_user_role_setup(self, task: Dict) -> Dict:
        """ユーザーロール設定タスクを実行"""
        logger.info("【ユーザーロール設定】")
    
        # === パート1: プラグインエージェント取得（フォールバック付き） ===
        plugin_agent = self.agents.get('plugin')
    
        # プラグインエージェントがない場合、WordPressエージェントから取得を試みる
        if not plugin_agent:
            logger.warning("⚠️ plugin エージェントが直接登録されていません")
        
            wp_agent = self.agents.get('wordpress')
            if wp_agent and hasattr(wp_agent, 'plugin_manager'):
                plugin_agent = wp_agent.plugin_manager
                logger.info("✅ WordPressエージェントからplugin_managerを取得しました")
            else:
                logger.error("❌ プラグインエージェントが見つかりません")
                return {
                    'success': False,
                    'error': 'プラグインエージェントが登録されていません。WordPressエージェントを確認してください。'
                }
        
        parameters = task.get('parameters', {})
        
        # User Role Editor設定タスクとして実行
        task_params = {
            'plugin_name': 'user-role-editor',
            'action': 'configure',
            'role_slug': parameters.get('role_slug', 'ma_partner'),
            'role_name': parameters.get('role_name', '提携パートナー'),
            'capabilities': parameters.get('capabilities', {
                'read': True,
                'edit_posts': True,
                'delete_posts': True,
                'edit_published_posts': True,
                'publish_posts': False
            })
        }
        
        # プラグインエージェントで実行
        if hasattr(plugin_agent, 'configure_user_roles'):
            result = await plugin_agent.configure_user_roles(None, task_params)
        else:
            logger.warning("configure_user_roles メソッドが見つかりません")
            result = await plugin_agent.change_plugin_settings(None, task)
        
        return result
    
def validate_ma_task(self, task: Dict) -> tuple[bool, Optional[str]]:
    """
    M&Aタスクのパラメータを検証
        
    Returns:
        (valid: bool, error_message: Optional[str])
    """
    try:
        parameters = task.get('parameters', {})
            
        # === パート1: Custom Post Type作成の検証 ===
        if 'cpt_slug' in parameters:
            if not parameters['cpt_slug']:
                return False, "cpt_slugが空です"
            if not parameters['cpt_slug'].replace('_', '').isalnum():
                return False, "cpt_slugは英数字とアンダースコアのみ使用可能です"
            
        # === パート2: ACF設定の検証 ===
        if 'acf_field_group_name' in parameters:
            if not parameters['acf_field_group_name']:
                return False, "acf_field_group_nameが空です"
                
            acf_fields = parameters.get('acf_fields', [])
            if not isinstance(acf_fields, list):
                return False, "acf_fieldsはリスト形式である必要があります"
                
            for field in acf_fields:
                if 'name' not in field or 'type' not in field:
                    return False, "ACFフィールドにはnameとtypeが必要です"
            
        # === パート3: タクソノミー作成の検証 ===
        if 'taxonomy_slug' in parameters:
            if not parameters['taxonomy_slug']:
                return False, "taxonomy_slugが空です"
            if not parameters['taxonomy_slug'].replace('_', '').isalnum():
                return False, "taxonomy_slugは英数字とアンダースコアのみ使用可能です"
            
        # === パート4: 検証成功 ===
        return True, None
            
    except Exception as e:
        # === パート5: 検証中の例外処理 ===
        return False, f"検証エラー: {str(e)}"

#test_tasks.py
"""
test_tasks.py - 既存タスクのテスト実行用スクリプト（エラー診断強化版）
"""

import logging
import asyncio
import argparse
import inspect
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

# 基本インポート
from config_utils import config, ErrorHandler, PathManager
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

# ロガー設定
logger = logging.getLogger(__name__)


class ClassInspector:
    """クラス診断ツール - 引数不一致エラーの根本原因を特定"""
    
    @staticmethod
    def diagnose_class_initialization(class_obj, provided_args: Dict, class_name: str) -> Dict:
        """
        クラス初期化の診断レポートを生成
        
        Args:
            class_obj: 診断対象のクラス
            provided_args: 渡そうとしている引数
            class_name: クラス名（ログ用）
        
        Returns:
            診断レポート
        """
        try:
            # クラスの__init__メソッドのシグネチャを取得
            init_signature = inspect.signature(class_obj.__init__)
            expected_params = list(init_signature.parameters.keys())
            
            # 提供されている引数
            provided_params = list(provided_args.keys())
            
            # 診断レポート
            report = {
                'class_name': class_name,
                'expected_parameters': expected_params,
                'provided_parameters': provided_params,
                'missing_parameters': [],
                'extra_parameters': [],
                'parameter_match': False,
                'diagnosis': '',
                'recommendation': ''
            }
            
            # 期待されるパラメータをチェック
            for expected in expected_params[1:]:  # selfを除外
                if expected not in provided_params:
                    report['missing_parameters'].append(expected)
            
            # 余分なパラメータをチェック
            for provided in provided_params:
                if provided not in expected_params[1:]:  # selfを除外
                    report['extra_parameters'].append(provided)
            
            # 診断結果
            report['parameter_match'] = (len(report['missing_parameters']) == 0 and 
                                       len(report['extra_parameters']) == 0)
            
            # 診断メッセージを構築
            if report['parameter_match']:
                report['diagnosis'] = "✅ パラメータ完全一致"
            else:
                diagnosis_parts = []
                if report['missing_parameters']:
                    diagnosis_parts.append(f"不足パラメータ: {report['missing_parameters']}")
                if report['extra_parameters']:
                    diagnosis_parts.append(f"余分パラメータ: {report['extra_parameters']}")
                report['diagnosis'] = "❌ " + ", ".join(diagnosis_parts)
            
            # 推奨事項
            if not report['parameter_match']:
                report['recommendation'] = (
                    f"修正が必要: {class_name}.__init__() を確認し、"
                    f"期待されるパラメータ: {expected_params[1:]} に合わせて修正してください"
                )
            
            return report
            
        except Exception as e:
            return {
                'class_name': class_name,
                'error': f"診断エラー: {str(e)}",
                'diagnosis': '❌ 診断失敗',
                'recommendation': 'クラス定義を確認してください'
            }


class ArgumentResolver:
    """引数解決クラス - 各エージェントの引数要件に合わせて動的に解決"""
    
    def __init__(self, browser_controller, sheets_manager):
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        self.argument_profiles = self._build_argument_profiles()
    
    def _build_argument_profiles(self) -> Dict:
        """各エージェントの引数プロファイルを構築"""
        return {
            'DesignAgent': {
                'browser': self.browser,
                'browser_controller': self.browser,
                'output_folder': None
            },
            'DevAgent': {
                'browser': self.browser,
                'browser_controller': self.browser,
                'output_folder': None
            },
            'ContentWriterAgent': {
                'browser': self.browser,
                'browser_controller': self.browser,
                'output_folder': None
            },
            'ReviewAgent': {
                # レビューエージェントは引数なし
            },
            'WordPressAgent': {
                'browser_controller': self.browser,
                'wp_credentials': {}
            },
            'WordPressDevAgent': {
                'browser_controller': self.browser
            },
            'WordPressDesignAgent': {
                'browser_controller': self.browser
            }
        }
    
    def resolve_arguments(self, class_obj, class_name: str) -> Dict:
        """
        クラスの引数要件に基づいて適切な引数を解決
        
        Returns:
            解決された引数の辞書
        """
        try:
            # クラスのシグネチャを取得
            init_signature = inspect.signature(class_obj.__init__)
            expected_params = list(init_signature.parameters.keys())[1:]  # selfを除外
            
            # 引数プロファイルから解決
            resolved_args = {}
            profile = self.argument_profiles.get(class_name, {})
            
            for param in expected_params:
                if param in profile:
                    resolved_args[param] = profile[param]
                else:
                    # デフォルト値の取得を試みる
                    param_obj = init_signature.parameters[param]
                    if param_obj.default != inspect.Parameter.empty:
                        resolved_args[param] = param_obj.default
                    else:
                        logger.warning(f"⚠️ パラメータ '{param}' の解決方法が不明です")
            
            return resolved_args
            
        except Exception as e:
            logger.error(f"❌ 引数解決エラー ({class_name}): {e}")
            return {}


class TaskExecutorResolver:
    """TaskExecutorの動的解決クラス"""
    
    @staticmethod
    def resolve_executor():
        """利用可能なTaskExecutorを解決"""
        executor_candidates = [
            ('task_executor.task_executor_ma', 'MATaskExecutor', 'M&A'),
            ('task_executor.content_task_executor', 'ContentTaskExecutor', 'コンテンツ'),
            ('task_executor.task_coordinator', 'TaskCoordinator', 'コーディネーター'),
        ]
        
        for module_path, class_name, executor_type in executor_candidates:
            try:
                module = __import__(module_path, fromlist=[class_name])
                executor_class = getattr(module, class_name)
                logger.info(f"🏁 main ✅ INFO {executor_type} Executor をインポート: {class_name}")
                return executor_class
            except (ImportError, AttributeError) as e:
                logger.debug(f"🏁 main 🐛 DEBUG ⚠️ {module_path}.{class_name} インポート失敗: {e}")
        
        logger.error("🏁 main ❌ ERROR 利用可能なTaskExecutorクラスが見つかりません")
        return None


class AgentInitializer:
    """エージェント初期化専用クラス（診断機能強化版）"""
    
    def __init__(self, browser_controller: BrowserController, sheets_manager: GoogleSheetsManager):
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        self.agents = {}
        self.argument_resolver = ArgumentResolver(browser_controller, sheets_manager)
        self.diagnostic_reports = {}
    
    async def initialize_all_agents(self, settings: Dict) -> Dict[str, any]:
        """
        全エージェントを初期化（診断機能付き）
        """
        logger.info("=" * 60)
        logger.info("🤖 エージェント初期化開始（診断モード）")
        logger.info("=" * 60)
        
        # 診断レポート用
        initialization_summary = {
            'total_agents': 0,
            'successful': 0,
            'failed': 0,
            'diagnostic_details': []
        }
        
        # 各エージェントを順次初期化
        agents_to_initialize = [
            ('design', self._init_design_agent),
            ('dev', self._init_dev_agent),
            ('review', self._init_review_agent),
            ('content_writer', self._init_content_writer_agent),
            ('wordpress', lambda: self._init_wordpress_agent(settings)),
            ('wp_dev', self._init_wp_dev_agent),
            ('wp_design', self._init_wp_design_agent),
        ]
        
        for agent_name, init_func in agents_to_initialize:
            initialization_summary['total_agents'] += 1
            success = await init_func()
            if success:
                initialization_summary['successful'] += 1
            else:
                initialization_summary['failed'] += 1
        
        # 診断サマリーを表示
        self._display_diagnostic_summary(initialization_summary)
        
        logger.info("=" * 60)
        logger.info(f"✅ エージェント初期化完了: {len(self.agents)}個")
        logger.info("=" * 60)
        
        return self.agents
    
    def _display_diagnostic_summary(self, summary: Dict):
        """診断サマリーを表示"""
        logger.info("\n" + "=" * 60)
        logger.info("🔍 エージェント初期化診断サマリー")
        logger.info("=" * 60)
        logger.info(f"総エージェント数: {summary['total_agents']}")
        logger.info(f"✅ 成功: {summary['successful']}")
        logger.info(f"❌ 失敗: {summary['failed']}")
        logger.info(f"📊 成功率: {summary['successful']/summary['total_agents']*100:.1f}%")
        
        # 診断詳細を表示
        if hasattr(self, 'diagnostic_reports') and self.diagnostic_reports:
            logger.info("\n📋 詳細診断レポート:")
            for agent_name, report in self.diagnostic_reports.items():
                status = "✅" if report.get('success', False) else "❌"
                logger.info(f"  {status} {agent_name}: {report.get('diagnosis', 'N/A')}")
        
        logger.info("=" * 60)
    
    async def _init_design_agent(self) -> bool:
        """設計エージェント初期化（診断付き）"""
        return await self._initialize_agent_with_diagnosis(
            'design', 'DesignAgent', 'design_agent'
        )
    
    async def _init_dev_agent(self) -> bool:
        """開発エージェント初期化（診断付き）"""
        return await self._initialize_agent_with_diagnosis(
            'dev', 'DevAgent', 'dev_agent'
        )
    
    async def _init_review_agent(self) -> bool:
        """レビューエージェント初期化（診断付き）"""
        return await self._initialize_agent_with_diagnosis(
            'review', 'ReviewAgent', 'review_agent'
        )
    
    async def _init_content_writer_agent(self) -> bool:
        """コンテンツライターエージェント初期化（診断付き）"""
        return await self._initialize_agent_with_diagnosis(
            'content_writer', 'ContentWriterAgent', 'content_writer_agent'
        )
    
    async def _init_wordpress_agent(self, settings: Dict) -> bool:
        """WordPressエージェント初期化（診断付き）"""
        try:
            from wordpress.wp_agent import WordPressAgent
            
            # WordPress認証情報を構築
            wp_credentials = {
                'wp_url': settings.get('wp_url', '').strip(),
                'wp_user': settings.get('wp_user', '').strip(),
                'wp_pass': settings.get('wp_pass', '').strip()
            }
            
            # 引数を解決
            resolved_args = self.argument_resolver.resolve_arguments(WordPressAgent, 'WordPressAgent')
            resolved_args['wp_credentials'] = wp_credentials
            
            # 診断レポート
            diagnostic_report = ClassInspector.diagnose_class_initialization(
                WordPressAgent, resolved_args, 'WordPressAgent'
            )
            
            logger.info(f"🔍 WordPressAgent 診断: {diagnostic_report['diagnosis']}")
            
            if not diagnostic_report['parameter_match']:
                logger.warning(f"⚠️ パラメータ不一致: {diagnostic_report['recommendation']}")
            
            # エージェント初期化
            agent = WordPressAgent(**resolved_args)
            agent.sheets_manager = self.sheets_manager
            
            # WordPressセッション初期化
            if all([wp_credentials['wp_url'], wp_credentials['wp_user'], wp_credentials['wp_pass']]):
                try:
                    await agent.initialize_wp_session()
                    logger.info("🌐 wp-agent ✅ INFO WordPressセッション初期化完了")
                except Exception as session_error:
                    logger.warning(f"🌐 wp-agent ⚠️ WARN セッション初期化失敗: {session_error}")
            
            self.agents['wordpress'] = agent
            
            # 診断レポートを保存
            self.diagnostic_reports['wordpress'] = {
                'success': True,
                'diagnosis': diagnostic_report['diagnosis'],
                'details': diagnostic_report
            }
            
            logger.info("🌐 wp-agent ✅ INFO WordPressAgent初期化完了")
            return True
            
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR 初期化エラー: {e}")
            self.diagnostic_reports['wordpress'] = {
                'success': False,
                'error': str(e),
                'diagnosis': '❌ 初期化失敗'
            }
            return False
    
    async def _init_wp_dev_agent(self) -> bool:
        """WordPress開発エージェント初期化（診断付き）"""
        return await self._initialize_agent_with_diagnosis(
            'wp_dev', 'WordPressDevAgent', 'wordpress.wp_dev'
        )
    
    async def _init_wp_design_agent(self) -> bool:
        """WordPress設計エージェント初期化（診断付き）"""
        return await self._initialize_agent_with_diagnosis(
            'wp_design', 'WordPressDesignAgent', 'wordpress.wp_design'
        )
    
    async def _initialize_agent_with_diagnosis(self, agent_key: str, class_name: str, module_path: str) -> bool:
        """
        エージェント初期化の統一メソッド（診断機能付き）
        """
        try:
            # モジュールの動的インポート
            module = __import__(module_path, fromlist=[class_name])
            agent_class = getattr(module, class_name)
            
            # 引数の解決
            resolved_args = self.argument_resolver.resolve_arguments(agent_class, class_name)
            
            # 診断レポートの生成
            diagnostic_report = ClassInspector.diagnose_class_initialization(
                agent_class, resolved_args, class_name
            )
            
            logger.info(f"🔍 {class_name} 診断: {diagnostic_report['diagnosis']}")
            
            # パラメータ不一致の警告
            if not diagnostic_report['parameter_match']:
                logger.warning(f"⚠️ {class_name} パラメータ不一致:")
                logger.warning(f"   期待: {diagnostic_report['expected_parameters']}")
                logger.warning(f"   提供: {diagnostic_report['provided_parameters']}")
                logger.warning(f"   推奨: {diagnostic_report['recommendation']}")
            
            # エージェントの初期化
            agent = agent_class(**resolved_args)
            
            # sheets_managerの設定（可能な場合）
            if hasattr(agent, 'sheets_manager'):
                agent.sheets_manager = self.sheets_manager
            
            self.agents[agent_key] = agent
            
            # 診断レポートを保存
            self.diagnostic_reports[agent_key] = {
                'success': True,
                'diagnosis': diagnostic_report['diagnosis'],
                'details': diagnostic_report
            }
            
            logger.info(f"✅ {agent_key} ✅ INFO {class_name}初期化完了")
            return True
            
        except ImportError as e:
            logger.warning(f"⚠️ {agent_key} ⚠️ WARN インポート失敗: {e}")
            self.diagnostic_reports[agent_key] = {
                'success': False,
                'error': f"インポート失敗: {str(e)}",
                'diagnosis': '❌ モジュール未見つかり'
            }
            return False
        except Exception as e:
            logger.error(f"❌ {agent_key} ❌ ERROR 初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            self.diagnostic_reports[agent_key] = {
                'success': False,
                'error': str(e),
                'diagnosis': '❌ 初期化失敗',
                'traceback': traceback.format_exc()
            }
            return False


class TaskTester:
    """既存タスクのテスト実行用クラス（診断機能強化版）"""
    
    def __init__(self, spreadsheet_id: str, service_account_file: str = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.sheets_manager = None
        self.browser = None
        self.task_executor = None
        self.agent_initializer = None
    
    async def initialize(self):
        """システム初期化（診断モード）"""
        try:
            logger.info("=" * 60)
            logger.info("🚀 タスクテスター初期化中（診断モード）...")
            logger.info("=" * 60)
            
            # 1. Google Sheets接続
            await self._initialize_sheets()
            
            # 2. 設定読み込み
            settings = await self._load_settings()
            
            # 3. ブラウザ初期化
            await self._initialize_browser(settings)
            
            # 4. エージェント初期化（診断機能付き）
            await self._initialize_agents(settings)
            
            # 5. TaskExecutor初期化
            await self._initialize_task_executor()
            
            # 6. エージェント登録
            await self._register_agents_to_executor()
            
            logger.info("=" * 60)
            logger.info("✅ システム初期化完了")
            logger.info("=" * 60)
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "🏁 main システム初期化")
            return False
    
    async def _initialize_sheets(self):
        """Google Sheets初期化"""
        logger.info("📊 Google Sheets接続中...")
        self.sheets_manager = GoogleSheetsManager(
            self.spreadsheet_id,
            self.service_account_file
        )
    
    async def _load_settings(self):
        """設定読み込み"""
        pc_id = self.sheets_manager.get_current_pc_id()
        settings = self.sheets_manager.load_pc_settings(pc_id)
        
        logger.info(f"⚙️ config ✅ INFO PC設定読み込み完了: {pc_id}")
        return settings
    
    async def _initialize_browser(self, settings: Dict):
        """ブラウザ初期化"""
        logger.info("🌐 browser ✅ INFO ブラウザ初期化中...")
        
        # 出力フォルダ設定
        download_folder = self._setup_download_folder(settings)
        
        # ブラウザ設定
        config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
        config.COOKIES_FILE = settings.get('cookies_file')
        config.GENERATION_MODE = 'text'
        config.SERVICE_TYPE = 'google'
        
        # ブラウザ起動
        self.browser = BrowserController(
            download_folder,
            mode='text',
            service='google'
        )
        await self.browser.setup_browser()
        await self.browser.navigate_to_gemini()
        
        logger.info("🌐 browser ✅ INFO ブラウザ初期化完了")
    
    def _setup_download_folder(self, settings: Dict) -> Path:
        """ダウンロードフォルダ設定"""
        agent_output = settings.get('agent_output_folder')
        
        if not agent_output or agent_output.startswith('http'):
            download_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
            download_folder.mkdir(exist_ok=True, parents=True)
            return download_folder
        else:
            return PathManager.get_safe_path(agent_output)
    
    async def _initialize_agents(self, settings: Dict):
        """エージェント初期化（診断機能付き）"""
        logger.info("🤖 エージェント初期化開始（診断モード）...")
        
        # AgentInitializerを使用して診断付きで初期化
        self.agent_initializer = AgentInitializer(self.browser, self.sheets_manager)
        agents = await self.agent_initializer.initialize_all_agents(settings)
        
        logger.info(f"✅ エージェント初期化完了: {len(agents)}個")
    
    async def _initialize_task_executor(self):
        """TaskExecutor初期化"""
        logger.info("⚙️ config ✅ INFO タスク実行エンジン初期化中...")
        
        executor_class = TaskExecutorResolver.resolve_executor()
        if not executor_class:
            raise ImportError("利用可能なTaskExecutorが見つかりません")
        
        logger.info(f"🏁 main ✅ INFO 使用するExecutor: {executor_class.__name__}")
        
        # Executorの種別判定
        is_ma_executor = 'MATaskExecutor' in executor_class.__name__
        
        # 基本パラメータ
        init_params = {
            'sheets_manager': self.sheets_manager,
            'browser': self.browser,
            'max_iterations': 30
        }
        
        # MATaskExecutor用の追加パラメータ
        if is_ma_executor:
            wp_agent = self.agent_initializer.agents.get('wordpress')
            init_params.update({
                'wp_agent': wp_agent,
                'plugin_agent': None
            })
        
        self.task_executor = executor_class(**init_params)
        logger.info(f"⚙️ config ✅ INFO {executor_class.__name__} 初期化完了")
    
    async def _register_agents_to_executor(self):
        """エージェント登録"""
        if not self.task_executor or not self.agent_initializer:
            return
        
        registration_map = {
            'design': ['design'],
            'dev': ['dev'],
            'review': ['review'],
            'content_writer': ['writer', 'content'],
            'wordpress': ['wordpress'],
            'wp_dev': ['wp_dev'],
            'wp_design': ['wp_design'],
        }
        
        for agent_name, executor_keys in registration_map.items():
            agent_instance = self.agent_initializer.agents.get(agent_name)
            if not agent_instance:
                continue
            
            for key in executor_keys:
                try:
                    self.task_executor.register_agent(key, agent_instance)
                    logger.info(f"✅ {key} エージェント登録完了")
                except Exception as e:
                    logger.error(f"❌ {key} エージェント登録失敗: {e}")
        
        # レビューエージェントの特別登録
        review_agent = self.agent_initializer.agents.get('review')
        if review_agent and hasattr(self.task_executor, 'register_review_agent'):
            self.task_executor.register_review_agent(review_agent)
            logger.info("✅ レビューエージェントを特別登録")

    # 既存のテストメソッドは変更なし
    async def test_tasks_by_role(self, role: str, auto: bool = False):
        """特定の役割のタスクをテスト実行"""
        # 実装は変更なし...

    async def test_all_pending_tasks(self, auto: bool = False):
        """全てのpendingタスクをテスト実行"""
        # 実装は変更なし...

    async def cleanup(self):
        """クリーンアップ"""
        if self.browser:
            await self.browser.cleanup()


async def main():
    """メイン関数"""
    # 実装は変更なし...
    pass


if __name__ == "__main__":
    asyncio.run(main())

#workflow_executor.py
"""
workflow_executor.py - 複雑なワークフロー実行モジュール
マルチステップ・マルチエージェント連携タスクを統合管理
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# 設定
from config_utils import ErrorHandler, config

# データ管理
from sheets_manager import GoogleSheetsManager

# 既存のTaskExecutor
from task_executor import TaskExecutor

logger = logging.getLogger(__name__)


class WorkflowExecutor:
    """
    複雑なワークフロー実行モジュール
    
    複数ステップ、マルチエージェント連携、
    レビュー→修正サイクル、多言語展開などを統合管理
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        初期化
        
        Args:
            task_executor: 既存のTaskExecutorインスタンス
            sheets_manager: GoogleSheetsManagerインスタンス
            browser_controller: BrowserControllerインスタンス(オプション)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # ワークフロー統計
        self.workflow_stats = {
            'total_workflows': 0,
            'completed': 0,
            'failed': 0,
            'partial_success': 0
        }
        
        logger.info("✅ WorkflowExecutor 初期化完了")
    
    async def execute_workflow_task(self, task: Dict) -> Dict:
        """
        ワークフローのメインエントリポイント
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        workflow_type = self._determine_workflow_type(task)
        
        self.workflow_stats['total_workflows'] += 1
        
        try:
            logger.info("=" * 60)
            logger.info(f"🔄 ワークフロー実行開始: {task_id}")
            logger.info(f"ワークフロータイプ: {workflow_type}")
            logger.info("=" * 60)
            
            result = None
            
            # ワークフロータイプ別実行
            if workflow_type == 'multilingual':
                result = await self._execute_multilingual_workflow(task)
            elif workflow_type == 'review_cycle':
                result = await self._execute_review_cycle_workflow(task)
            elif workflow_type == 'sequential':
                result = await self._execute_sequential_workflow(task)
            elif workflow_type == 'parallel':
                result = await self._execute_parallel_workflow(task)
            elif workflow_type == 'conditional':
                result = await self._execute_conditional_workflow(task)
            else:
                # デフォルトシーケンシャル実行
                result = await self._execute_sequential_workflow(task)
            
            # 統計更新
            if result and result.get('success'):
                self.workflow_stats['completed'] += 1
            elif result and result.get('partial_success'):
                self.workflow_stats['partial_success'] += 1
            else:
                self.workflow_stats['failed'] += 1
            
            return result
        
        except Exception as e:
            logger.error(f"❌ ワークフロー {task_id} 実行エラー")
            ErrorHandler.log_error(e, f"WorkflowExecutor.execute_workflow_task({task_id})")
            self.workflow_stats['failed'] += 1
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_workflow_type(self, task: Dict) -> str:
        """
        ワークフロータイプを判定
        
        Args:
            task: タスク情報辞書
            
        Returns:
            str: ワークフロータイプ
        """
        description = task.get('description', '').lower()
        
        # 多言語ワークフロー
        if any(kw in description for kw in ['多言語', '翻訳', 'multilingual', 'translation']):
            return 'multilingual'
        
        # レビューサイクルワークフロー
        if any(kw in description for kw in ['レビュー→修正', 'review cycle', 'iterative review']):
            return 'review_cycle'
        
        # 並列ワークフロー
        if any(kw in description for kw in ['並列', '同時', 'parallel', 'concurrent']):
            return 'parallel'
        
        # 条件分岐ワークフロー
        if any(kw in description for kw in ['条件', '分岐', 'conditional', 'if-then']):
            return 'conditional'
        
        # デフォルトはシーケンシャル
        return 'sequential'
    
    async def _execute_multilingual_workflow(self, task: Dict) -> Dict:
        """
        多言語コンテンツ生成ワークフロー（Polylang連携強化版）
            
        1. 日本語記事生成
        2. 英語翻訳
        3. その他言語翻訳（オプション）
        4. WordPress多言語投稿（Polylang連携）
            
        Args:
            task: タスク情報辞書
                
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("🌍 多言語ワークフロー実行（Polylang連携版）")
                
            # ターゲット言語リスト
            target_languages = task.get('target_languages', ['ja', 'en'])
            base_language = task.get('base_language', 'ja')
                
            # Polylang言語コードマッピング
            polylang_lang_codes = {
                'ja': 'ja',
                'en': 'en',
                'uz': 'uz_UZ',  # ウズベク語
                'ru': 'ru_RU',  # ロシア語
                'tr': 'tr_TR',  # トルコ語
                'zh': 'zh_CN',  # 中国語
                'ko': 'ko_KR'   # 韓国語
            }
                
            results = {}
            contents = {}
            post_ids = {}  # 投稿IDを保存（Polylang連携用）
                
            # ========================================
            # ステップ1: 基本言語でコンテンツ生成
            # ========================================
            logger.info(f"--- ステップ1: {base_language} コンテンツ生成 ---")
                
            base_task = {
                **task,
                'task_id': f"{task_id}_base_{base_language}",
                'language': base_language,
                'required_role': 'content'
            }
                
            base_result = await self.task_executor.execute_task(base_task)
                
            if not base_result:
                return {
                    'success': False,
                    'error': f'{base_language} コンテンツ生成失敗'
                }
                
            results[base_language] = base_result
                
            # 基本コンテンツ取得
            base_content = ""
            if hasattr(base_result, 'get'):
                base_content = base_result.get('full_text', base_result.get('content', ''))
                
            contents[base_language] = base_content
                
            # ========================================
            # ステップ2: 他言語への翻訳
            # ========================================
            for lang in target_languages:
                if lang == base_language:
                    continue
                    
                logger.info(f"--- ステップ2-{lang}: {lang} 翻訳 ---")
                    
                translation_task = {
                    'task_id': f"{task_id}_translate_{lang}",
                    'description': f'{base_language}から{lang}に翻訳',
                    'prompt': f'以下のコンテンツを{lang}に翻訳してください:\n\n{base_content}',
                    'required_role': 'content',
                    'language': lang,
                    'source_language': base_language,
                    'target_language': lang,
                    'source_text': base_content
                }
                    
                translate_result = await self.task_executor.execute_task(translation_task)
                    
                results[lang] = translate_result
                    
                if translate_result and hasattr(translate_result, 'get'):
                    translated_content = translate_result.get('full_text', translate_result.get('content', ''))
                    contents[lang] = translated_content
                else:
                    logger.warning(f"⚠️ {lang} 翻訳失敗")
                    
                await asyncio.sleep(2)
                
            # ========================================
            # ステップ3: WordPress多言語投稿（Polylang連携強化版）
            # ========================================
            if task.get('auto_publish', False):
                logger.info("--- ステップ3: WordPress多言語投稿（Polylang連携） ---")
                    
                # 3-1: 基本言語の投稿を作成
                base_lang_code = polylang_lang_codes.get(base_language, base_language)
                base_wp_task = {
                    'task_id': f"{task_id}_publish_{base_language}",
                    'description': f'{base_language} コンテンツをWordPressに投稿',
                    'required_role': 'wordpress',
                    'language': base_language,
                    'polylang_lang': base_lang_code,
                    'post_action': 'create',
                    'post_title': task.get('post_title', f'記事_{base_language}'),
                    'post_content': contents.get(base_language, ''),
                    'post_status': 'draft'  # 下書きで作成
                }
                    
                base_publish_result = await self.task_executor.execute_task(base_wp_task)
                results[f'{base_language}_publish'] = base_publish_result
                    
                # 投稿IDを取得
                if base_publish_result and hasattr(base_publish_result, 'get'):
                    base_post_id = base_publish_result.get('post_id')
                    if base_post_id:
                        post_ids[base_language] = base_post_id
                        logger.info(f"✅ {base_language} 投稿ID: {base_post_id}")
                    
                await asyncio.sleep(2)
                    
                # 3-2: 翻訳投稿を作成し、Polylangで連携
                for lang, content in contents.items():
                    if lang == base_language or not content:
                        continue
                        
                    lang_code = polylang_lang_codes.get(lang, lang)
                        
                    wp_task = {
                        'task_id': f"{task_id}_publish_{lang}",
                        'description': f'{lang} コンテンツをWordPressに投稿（Polylang連携）',
                        'required_role': 'wordpress',
                        'language': lang,
                        'polylang_lang': lang_code,
                        'post_action': 'create',
                        'post_title': task.get('post_title', f'記事_{lang}'),
                        'post_content': content,
                        'post_status': 'draft',
                        # ========================================
                        # 🆕 Polylang連携パラメータ（新規追加）
                        # ========================================
                        'polylang_link_to': post_ids.get(base_language),  # 基本言語の投稿IDとリンク
                        'polylang_translation_group': task_id  # 翻訳グループID
                    }
                        
                    publish_result = await self.task_executor.execute_task(wp_task)
                    results[f'{lang}_publish'] = publish_result
                        
                    # 投稿IDを取得
                    if publish_result and hasattr(publish_result, 'get'):
                        post_id = publish_result.get('post_id')
                        if post_id:
                            post_ids[lang] = post_id
                            logger.info(f"✅ {lang} 投稿ID: {post_id}")
                        
                    await asyncio.sleep(2)
                    
                # ========================================
                # 🆕 ステップ3-3: Polylang翻訳リンクの設定（新規追加）
                # ========================================
                if len(post_ids) > 1:
                    logger.info("--- ステップ3-3: Polylang翻訳リンク設定 ---")
                        
                    polylang_link_task = {
                        'task_id': f"{task_id}_polylang_link",
                        'description': 'Polylang翻訳リンクを設定',
                        'required_role': 'wordpress',
                        'action': 'polylang_link_translations',
                        'post_ids': post_ids,  # {'ja': 123, 'en': 124, ...}
                        'translation_group': task_id
                    }
                        
                    link_result = await self.task_executor.execute_task(polylang_link_task)
                    results['polylang_link'] = link_result
                        
                    if link_result and hasattr(link_result, 'get') and link_result.get('success'):
                        logger.info("✅ Polylang翻訳リンク設定完了")
                    else:
                        logger.warning("⚠️ Polylang翻訳リンク設定失敗（手動で設定が必要）")
                
            # ========================================
            # 結果集約
            # ========================================
            success_count = sum(1 for r in results.values() if r and (r is True or (hasattr(r, 'get') and r.get('success'))))
            total_count = len(results)
                
            logger.info(f"✅ 多言語ワークフロー完了: {success_count}/{total_count} 成功")
                
            return {
                'success': success_count == total_count,
                'partial_success': success_count > 0 and success_count < total_count,
                'results': results,
                'contents': contents,
                'post_ids': post_ids,  # 投稿ID情報を追加
                'summary': f'{success_count}/{total_count} 言語で成功（投稿数: {len(post_ids)}）',
                'full_text': '\n\n---\n\n'.join([f'[{lang}]\n{content}' for lang, content in contents.items()])
            }
            
        except Exception as e:
            logger.error(f"❌ 多言語ワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_multilingual_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_review_cycle_workflow(self, task: Dict) -> Dict:
        """
        レビュー→修正サイクルワークフロー
        
        1. コンテンツ生成
        2. レビュー実行
        3. 修正指示に基づいて再生成
        4. 最終承認まで繰り返し
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        max_iterations = task.get('max_review_iterations', 3)
        
        try:
            logger.info("🔄 レビューサイクルワークフロー実行")
            
            iteration = 0
            current_content = None
            review_history = []
            
            while iteration < max_iterations:
                iteration += 1
                logger.info(f"--- レビューサイクル {iteration}/{max_iterations} ---")
                
                # ステップ1: コンテンツ生成（初回）または修正（2回目以降）
                if iteration == 1:
                    logger.info("初回コンテンツ生成")
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'required_role': 'content'
                    }
                else:
                    logger.info("レビューフィードバックに基づく修正")
                    last_review = review_history[-1]
                    feedback = last_review.get('feedback', '')
                    
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'prompt': f'{task.get("prompt", "")}\n\n前回のレビューフィードバック:\n{feedback}\n\n上記フィードバックを反映して修正してください。',
                        'required_role': 'content'
                    }
                
                content_result = await self.task_executor.execute_task(content_task)
                
                if not content_result:
                    logger.error("コンテンツ生成失敗")
                    break
                
                if hasattr(content_result, 'get'):
                    current_content = content_result.get('full_text', content_result.get('content', ''))
                else:
                    current_content = str(content_result)
                
                # ステップ2: レビュー実行
                logger.info("レビュー実行")
                review_task = {
                    'task_id': f"{task_id}_review_v{iteration}",
                    'description': 'コンテンツレビュー',
                    'required_role': 'review',
                    'review_target_task_id': f"{task_id}_content_v{iteration}",
                    'content_to_review': current_content
                }
                
                review_result = await self.task_executor.execute_task(review_task)
                
                if not review_result or not hasattr(review_result, 'get'):
                    logger.warning("レビュー実行失敗 - サイクル終了")
                    break
                
                review_history.append(review_result)
                
                # ステップ3: 承認判定
                approved = review_result.get('approved', False)
                
                if approved:
                    logger.info(f"✅ レビュー承認 (反復{iteration}回)")
                    return {
                        'success': True,
                        'content': current_content,
                        'iterations': iteration,
                        'review_history': review_history,
                        'full_text': current_content,
                        'summary': f'{iteration}回の反復で承認'
                    }
                else:
                    logger.info(f"🔄 修正が必要 - 次の反復へ")
                    await asyncio.sleep(2)
            
            # 最大反復回数到達
            logger.warning(f"⚠️ 最大反復回数({max_iterations})到達 - 最終版を返却")
            
            return {
                'success': False,
                'partial_success': True,
                'content': current_content,
                'iterations': iteration,
                'review_history': review_history,
                'full_text': current_content,
                'summary': f'{iteration}回反復したが承認されず',
                'error': '最大反復回数到達'
            }
        
        except Exception as e:
            logger.error(f"❌ レビューサイクルワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_review_cycle_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_sequential_workflow(self, task: Dict) -> Dict:
        """
        シーケンシャルワークフロー（順次実行）
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("ステップ定義なし - 単一タスクとして実行")
            result = await self.task_executor.execute_task(task)
            return {'success': bool(result), 'result': result}
        
        try:
            logger.info(f"📋 シーケンシャルワークフロー実行 ({len(steps)}ステップ)")
            
            results = []
            accumulated_output = {}
            
            for i, step in enumerate(steps, 1):
                logger.info(f"--- ステップ {i}/{len(steps)}: {step.get('description', 'N/A')} ---")
                
                # ステップタスク構築
                step_task = {
                    **task,
                    **step,  # ステップ設定で上書き
                    'task_id': f"{task_id}_step{i}",
                }
                
                # 前ステップの出力を参照
                if step.get('use_previous_output') and accumulated_output:
                    prev_output = accumulated_output.get(f'step{i-1}', '')
                    if 'prompt' in step_task:
                        step_task['prompt'] = step_task['prompt'].replace(
                            '{previous_output}',
                            str(prev_output)
                        )
                
                # ステップ実行
                step_result = await self.task_executor.execute_task(step_task)
                
                results.append(step_result)
                accumulated_output[f'step{i}'] = step_result
                
                # 失敗時の処理
                if not step_result or (hasattr(step_result, 'get') and not step_result.get('success')):
                    if step.get('continue_on_failure', False):
                        logger.warning(f"⚠️ ステップ {i} 失敗したが継続")
                    else:
                        logger.error(f"❌ ステップ {i} 失敗 - ワークフロー中断")
                        return {
                            'success': False,
                            'error': f'ステップ {i} 失敗',
                            'completed_steps': i - 1,
                            'results': results
                        }
                
                logger.info(f"✅ ステップ {i} 完了")
                await asyncio.sleep(1)
            
            logger.info(f"✅ 全 {len(steps)} ステップ完了")
            
            return {
                'success': True,
                'steps_completed': len(steps),
                'results': results,
                'accumulated_output': accumulated_output,
                'full_text': str(accumulated_output)
            }
        
        except Exception as e:
            logger.error(f"❌ シーケンシャルワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_sequential_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_parallel_workflow(self, task: Dict) -> Dict:
        """
        並列ワークフロー（複数タスク同時実行）
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        parallel_tasks = task.get('parallel_tasks', [])
        
        if not parallel_tasks:
            logger.warning("並列タスク定義なし")
            return {'success': False, 'error': '並列タスクが定義されていません'}
        
        try:
            logger.info(f"⚡ 並列ワークフロー実行 ({len(parallel_tasks)}タスク)")
            
            # 並列タスクリスト構築
            coroutines = []
            for i, parallel_task in enumerate(parallel_tasks, 1):
                parallel_task_config = {
                    **task,
                    **parallel_task,
                    'task_id': f"{task_id}_parallel{i}"
                }
                coroutines.append(
                    self.task_executor.execute_task(parallel_task_config)
                )
            
            # 並列実行
            results = await asyncio.gather(*coroutines, return_exceptions=True)
            
            # 結果分析
            success_count = sum(
                1 for r in results 
                if r and not isinstance(r, Exception) and (r is True or (hasattr(r, 'get') and r.get('success')))
            )
            
            logger.info(f"✅ 並列ワークフロー完了: {success_count}/{len(results)} 成功")
            
            return {
                'success': success_count == len(results),
                'partial_success': success_count > 0 and success_count < len(results),
                'results': results,
                'summary': f'{success_count}/{len(results)} タスク成功'
            }
        
        except Exception as e:
            logger.error(f"❌ 並列ワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_parallel_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_conditional_workflow(self, task: Dict) -> Dict:
        """
        条件分岐ワークフロー
        
        Args:
            task: タスク情報辞書
            
        Returns:
            Dict: 実行結果
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("🔀 条件分岐ワークフロー実行")
            
            # 条件評価タスク実行
            condition_task = task.get('condition_task')
            if not condition_task:
                return {'success': False, 'error': '条件タスクが定義されていません'}
            
            condition_result = await self.task_executor.execute_task(condition_task)
            
            # 条件評価
            condition_met = self._evaluate_condition(condition_result, task.get('condition'))
            
            # 分岐実行
            if condition_met:
                logger.info("✅ 条件成立 - then分岐実行")
                then_task = task.get('then_task')
                if then_task:
                    result = await self.task_executor.execute_task(then_task)
                    return {'success': True, 'branch': 'then', 'result': result}
            else:
                logger.info("❌ 条件不成立 - else分岐実行")
                else_task = task.get('else_task')
                if else_task:
                    result = await self.task_executor.execute_task(else_task)
                    return {'success': True, 'branch': 'else', 'result': result}
            
            return {'success': True, 'branch': 'none'}
        
        except Exception as e:
            logger.error(f"❌ 条件分岐ワークフローエラー: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_conditional_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _evaluate_condition(self, result: Any, condition: Dict) -> bool:
        """
        条件を評価
        
        Args:
            result: 評価対象の結果
            condition: 条件定義辞書
            
        Returns:
            bool: 条件成立フラグ
        """
        if not condition:
            return True
        
        condition_type = condition.get('type', 'success')
        
        if condition_type == 'success':
            return result and (result is True or (hasattr(result, 'get') and result.get('success')))
        elif condition_type == 'contains':
            target_text = condition.get('text', '')
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return target_text.lower() in content.lower()
        elif condition_type == 'length':
            min_length = condition.get('min_length', 0)
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return len(content) >= min_length
        
        return False
    
    def get_workflow_stats(self) -> Dict:
        """ワークフロー統計情報を取得"""
        return self.workflow_stats.copy()

#wp_acf_agent.py
"""
WordPress ACF設計・設定エージェント
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressACFAgent:
    """ACF設計・設定専門エージェント"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """ACFタスクを実行"""
        # 実装（wp_cpt_agent.py と同様のパターン）
        return {
            'success': True,
            'message': 'ACF設定完了（実装中）',
            'task_id': task.get('task_id')
        }
        
"""
専門エージェントの修正パターン例
（wp_acf_agent.py, wp_cpt_agent.py などに適用）

❌ エラーが発生するパターン（修正前）
✅ 安全なパターン（修正後）
"""

# ========================================
# ❌ エラーパターン1: 条件分岐外での変数参照
# ========================================

# --- 修正前（エラーが発生） ---
async def save_generated_code_BAD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """❌ このパターンはエラーが発生します"""
    
    # 条件分岐内でのみ変数を定義
    if output_type == 'php':
        php_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        json_filename = f"acf_{task_id}.json"
    
    # ここで変数を参照すると、条件に合致しなかった場合にエラー！
    # UnboundLocalError: cannot access local variable 'php_filename' where it is not associated with a value
    await self.browser.save_text_to_file(content, php_filename)  # ❌ エラー発生箇所


# --- 修正後（安全） ---
async def save_generated_code_GOOD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """✅ このパターンは安全です"""
    
    # === 方法1: 最初に変数を初期化 ===
    final_filename = None  # 最初に初期化（重要！）
    
    if output_type == 'php':
        final_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        final_filename = f"acf_{task_id}.json"
    else:
        # デフォルト値を設定（どの条件にも合致しない場合）
        final_filename = f"output_{task_id}.txt"
    
    # 安全に参照可能
    if final_filename:
        await self.browser.save_text_to_file(content, final_filename)
    else:
        logger.error("❌ ファイル名が決定できませんでした")


# ========================================
# ❌ エラーパターン2: 複雑な条件分岐
# ========================================

# --- 修正前（エラーリスク高） ---
async def process_and_save_BAD(self, task: dict, generated_content: str):
    """❌ 複雑な条件でエラーリスクが高い"""
    
    task_type = task.get('type')
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = 'ma_case_template.php'
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = 'acf_fields.json'
    
    # 上記の条件に合致しない場合、output_filenameが未定義！
    save_result = await self._save_file(output_filename, generated_content)  # ❌ エラー


# --- 修正後（安全） ---
async def process_and_save_GOOD(self, task: dict, generated_content: str):
    """✅ デフォルト値で安全に処理"""
    
    task_type = task.get('type')
    task_id = task.get('task_id', 'unknown')
    
    # === デフォルト値を最初に設定 ===
    output_filename = f"output_{task_id}.txt"  # デフォルト
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = f"ma_case_template_{task_id}.php"
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = f"acf_fields_{task_id}.json"
    
    # 常にoutput_filenameが定義されているので安全
    save_result = await self._save_file(output_filename, generated_content)  # ✅ 安全


# ========================================
# ✅ 推奨パターン: 親クラスのヘルパーメソッド使用
# ========================================

class WordPressACFAgent:
    """ACF設計エージェント（修正例）"""
    
    def __init__(self, browser, output_folder, parent_agent=None):
        self.browser = browser
        self.output_folder = output_folder
        self.parent_agent = parent_agent  # 親のWordPressDevAgentへの参照
    
    async def execute(self, task: dict):
        """タスク実行"""
        task_id = task.get('task_id', 'unknown')
        
        try:
            # AIでコンテンツ生成
            generated_content = await self._generate_acf_fields(task)
            
            # === 推奨: 親エージェントの安全なヘルパーを使用 ===
            if self.parent_agent and hasattr(self.parent_agent, 'safe_save_code_file'):
                save_result = await self.parent_agent.safe_save_code_file(
                    content=generated_content,
                    task_id=task_id,
                    file_type='json',  # or 'php'
                    custom_filename=None  # 自動生成
                )
                
                if save_result['success']:
                    logger.info(f"✅ 保存成功: {save_result['filepath']}")
                    return {
                        'success': True,
                        'output_file': save_result['filepath']
                    }
                else:
                    logger.error(f"❌ 保存失敗: {save_result['error']}")
                    return {
                        'success': False,
                        'error': save_result['error']
                    }
            else:
                # === フォールバック: 自前で安全に処理 ===
                return await self._safe_save_fallback(task_id, generated_content)
        
        except Exception as e:
            logger.error(f"❌ 実行エラー: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _safe_save_fallback(self, task_id: str, content: str):
        """安全なフォールバック保存"""
        # 変数を最初に初期化
        filename = None
        saved_path = None
        
        try:
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # ファイル名決定
            filename = f"acf_output_{task_id}_{timestamp}.json"
            output_path = self.output_folder / filename
            
            # 保存実行
            if hasattr(self.browser, 'save_text_to_file'):
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
            else:
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                saved_path = str(output_path)
            
            return {
                'success': True,
                'output_file': saved_path
            }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"保存エラー: {e}"
            }


# ========================================
# 🔧 実際の修正手順（各専門エージェントファイルで実行）
# ========================================

"""
1. wordpress/wp_dev/__init__.py を確認し、親エージェントの参照を渡す:

   from .wp_acf_agent import WordPressACFAgent
   
   # 初期化時に親エージェントを渡す
   def create_agents(browser, output_folder, parent):
       acf_agent = WordPressACFAgent(
           browser, 
           output_folder,
           parent_agent=parent  # 追加
       )
       return acf_agent

2. 各専門エージェント（wp_acf_agent.py など）内のファイル保存ロジックを探す:
   
   検索キーワード:
   - "filename" + "if" または "elif"
   - "save" + "file"
   - ".php" または ".json"

3. 上記のパターンに従って修正:
   
   修正前:
   ```python
   if condition:
       php_filename = "something.php"
   
   await save(php_filename)  # ❌ エラー
   ```
   
   修正後:
   ```python
   php_filename = None  # 最初に初期化
   
   if condition:
       php_filename = "something.php"
   else:
       php_filename = "default.txt"  # デフォルト値
   
   if php_filename:
       await save(php_filename)  # ✅ 安全
   ```

4. または、親のヘルパーメソッドを使用:
   
   ```python
   result = await self.parent_agent.safe_save_code_file(
       content=generated_code,
       task_id=task_id,
       file_type='php'
   )
   ```
"""

#wp_agent - コピー.py
""" wp_agent.py WordPressエージェント - メインオーケストレーター"""
import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path
from playwright.async_api import Page

from config_utils import ErrorHandler
from browser_controller import BrowserController
from datetime import datetime  
from .wp_auth import WordPressAuth
from .wp_post_editor import WordPressPostEditor
from .wp_post_creator import WordPressPostCreator
from .wp_plugin_manager import WordPressPluginManager
from .wp_settings_manager import WordPressSettingsManager
from .wp_tester import WordPressTester
from .wp_utils import TaskTypeAnalyzer

logger = logging.getLogger(__name__)


    # === 修正開始: WordPressAgentクラスに自動ログイン機能を追加 ===

class WordPressAgent:
    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        初期化
        
        Args:
            browser_controller: BrowserController インスタンス
            wp_credentials: WordPress 認証情報
                - wp_url: サイトURL
                - wp_user: ユーザー名
                - wp_pass: パスワード
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.is_logged_in = False
        
        # WordPress 専用ページ（新しいタブ）
        self.wp_page = None
        
        # 認証情報の取得
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        self.wp_user = self.wp_credentials.get('wp_user', '')
        self.wp_pass = self.wp_credentials.get('wp_pass', '')
        
        # WordPress 認証モジュール
        if self.wp_url and self.wp_user and self.wp_pass:
            self.auth = WordPressAuth(
                browser_controller=self.browser,
                wp_url=self.wp_url,
                wp_user=self.wp_user,
                wp_pass=self.wp_pass
            )
        else:
            logger.warning("⚠️ WordPress 認証情報が不完全です")
            self.auth = None
        
        # ========================================
        # ✅ ここに追加：サブエージェントの初期化
        # ========================================
        
        # シートマネージャー（後で外部から設定される）
        self.sheets_manager = None
        
        # 投稿編集エージェント
        self.post_editor = WordPressPostEditor(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressPostEditor 初期化完了")
        
        # 投稿作成エージェント
        self.post_creator = WordPressPostCreator(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressPostCreator 初期化完了")
        
        # プラグインマネージャー
        self.plugin_manager = WordPressPluginManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressPluginManager 初期化完了")
        
        # 設定マネージャー
        self.settings_manager = WordPressSettingsManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressSettingsManager 初期化完了")
        
        # テスター
        self.tester = WordPressTester(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("✅ WordPressTester 初期化完了")
        
        logger.info("="*60)
        logger.info("WordPressAgent 全サブエージェント初期化完了")
        logger.info("="*60)
    
    async def initialize_wp_session(self) -> bool:
        """
        WordPress セッション初期化（完全修正版 - クッキー強制ナビゲーション対応）
            
        改善点:
        1. 新しいタブ作成（Gemini セッションとは完全独立）
        2. クッキー適用 + 管理画面への強制ナビゲーション
        3. ログイン状態の厳格な検証
        4. 失敗時の手動ログインフォールバック
            
        Returns:
            bool: 初期化成功時 True
        """
        try:
            logger.info("="*60)
            logger.info("🔐 WordPress セッション初期化中...")
            logger.info("="*60)
                
            # ✅ Phase 1: 新しいタブを作成
            if not self.browser.context:
                logger.error("❌ ブラウザコンテキストが初期化されていません")
                return False
                
            self.wp_page = await self.browser.context.new_page()
            logger.info("✅ WordPress 専用タブを作成しました")
                
            # ✅ Phase 2: 認証情報の検証
            if not self.auth:
                logger.error("❌ WordPress 認証モジュールが初期化されていません")
                return False
                
            # ✅ Phase 3: ログイン実行（クッキー優先 + 強制ナビゲーション）
            logger.info("🔄 WordPress認証を実行中...")
            login_success = await self.auth.login(self.wp_page)
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("✅ WordPress セッション初期化完了")
                logger.info("  認証方法: クッキー or 手動ログイン")
                logger.info("  ページURL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("❌ WordPress ログイン失敗")
                logger.error("  原因: 認証情報またはネットワークの問題")
                logger.error("  対策: 認証情報を確認してください")
                logger.error("="*60)
                    
                # デバッグ用: 失敗時のスクリーンショット
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("📸 デバッグ用スクリーンショット: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"❌ WordPress セッション初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def ensure_logged_in(self) -> bool:
        """
        ログイン状態を保証
    
        Returns:
            bool: ログイン済みまたはログイン成功時 True
        """
        if self.is_logged_in and self.wp_page:
            # 定期的にログイン状態を確認
            if await self.auth._verify_login_status(self.wp_page):
                return True
    
        # ログインしていない場合は再初期化
        logger.info("🔄 WordPress 再ログインを試行します")
        return await self.initialize_wp_session()
    
    async def _try_cookie_login(self, wp_url: str) -> bool:
        """クッキーを使用したログイン試行"""
        try:
            if not wp_url:
                logger.warning("⚠️ WordPress URLが設定されていません")
                return False
        
            # WordPressクッキーをロード
            cookie_loaded = await self.browser.load_wordpress_cookies(wp_url)
            if not cookie_loaded:
                return False
        
            # 管理画面にアクセスしてログイン状態を確認
            admin_url = f"{wp_url.rstrip('/')}/wp-admin/"
            await self.browser.page.goto(admin_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ログイン状態を詳細チェック
            return await self._verify_wordpress_login_status()
        
        except Exception as e:
            logger.warning(f"⚠️ クッキーログイン試行エラー: {e}")
            return False

    async def _verify_wordpress_login_status(self) -> bool:
        """WordPressログイン状態を詳細検証"""
        try:
            page = self.browser.page
        
            # 複数の方法でログイン状態を確認
            checks = []
        
            # 1. 管理バーの存在チェック
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('管理バー', bool(admin_bar)))
        
            # 2. ダッシュボード要素チェック
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ダッシュボード', bool(dashboard)))
        
            # 3. ログインフォームの不在チェック
            login_form = await page.query_selector('#loginform')
            checks.append(('ログインフォーム不在', not bool(login_form)))
        
            # 4. URLチェック（リダイレクトされていないか）
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('管理ページURL', is_admin_page))
        
            # 結果の集計
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
        
            logger.info(f"🔍 ログイン状態検証: {total_passed}/4 合格")
            if total_passed >= 3:  # 4つのうち3つ以上合格ならログイン成功
                logger.info(f"  合格項目: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  不合格項目が多すぎます")
                return False
            
        except Exception as e:
            logger.warning(f"⚠️ ログイン状態検証エラー: {e}")
            return False

    async def _manual_wordpress_login(self) -> bool:
        """手動WordPressログイン"""
        try:
            wp_url = self.wp_credentials.get('wp_url', '')
            wp_user = self.wp_credentials.get('wp_user', '')
            wp_pass = self.wp_credentials.get('wp_pass', '')
        
            if not all([wp_url, wp_user, wp_pass]):
                logger.error("❌ WordPress認証情報が不足しています")
                return False
        
            # ログインページに移動
            login_url = f"{wp_url.rstrip('/')}/wp-login.php"
            await self.browser.page.goto(login_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ユーザー名入力
            user_field = await self.browser.page.query_selector('#user_login')
            if user_field:
                await user_field.fill(wp_user)
                logger.info("✅ ユーザー名入力完了")
            else:
                logger.error("❌ ユーザー名入力フィールドが見つかりません")
                return False
        
            # パスワード入力
            pass_field = await self.browser.page.query_selector('#user_pass')
            if pass_field:
                await pass_field.fill(wp_pass)
                logger.info("✅ パスワード入力完了")
            else:
                logger.error("❌ パスワード入力フィールドが見つかりません")
                return False
        
            # ログインボタンクリック
            login_button = await self.browser.page.query_selector('#wp-submit')
            if login_button:
                await login_button.click()
                logger.info("✅ ログインボタンクリック")
            else:
                logger.error("❌ ログインボタンが見つかりません")
                return False
        
            # ログイン完了待機
            await self.browser.page.wait_for_load_state('networkidle')
            await asyncio.sleep(3)
        
            # ログイン成功確認
            if await self._verify_wordpress_login_status():
                logger.info("✅ 手動ログイン成功")
                return True
            else:
                logger.error("❌ 手動ログイン失敗 - 認証情報またはネットワークの問題")
                return False
            
        except Exception as e:
            logger.error(f"❌ 手動ログインエラー: {e}")
            return False

    async def ensure_logged_in(self) -> bool:
        """ログイン状態を保証"""
        if self.is_logged_in:
            return True
    
        # 定期的にログイン状態を確認
        if await self._verify_wordpress_login_status():
            self.is_logged_in = True
            return True
    
        # ログインしていない場合は再初期化
        return await self.initialize_wp_session()
       
    async def process_task(self, task: Dict) -> Dict:
        """WordPressタスクを処理"""
        try:
            # ログイン状態を確認
            if not await self.ensure_logged_in():
                return {
                    'success': False,
                    'error': 'WordPress にログインできませんでした'
                }
            # === パート1: タスク実行開始 ===
            logger.info("="*60)
            logger.info("WordPressエージェント: タスク実行開始")
            logger.info(f"タスク: {task['description']}")
            logger.info("="*60)
            
            # === パート2: シートマネージャー設定 ===
            self.post_editor.sheets_manager = self.sheets_manager
            self.post_creator.sheets_manager = self.sheets_manager
            
            # === パート3: タスクタイプ解析 ===
            task_type = TaskTypeAnalyzer.analyze(task['description'])
            logger.info(f"解析されたタスクタイプ: {task_type}")
            
            # === パート4: タスクタイプに応じた処理実行 ===
            result = await self._execute_task_by_type(task, task_type)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressタスク処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_task_by_type(self, task: Dict, task_type: str) -> Dict:
        """タスクタイプに応じて適切なモジュールに処理を委譲"""
        try:
            # === パート1: プラグイン関連タスク ===
            if task_type == 'plugin_install':
                result = await self.plugin_manager.install_plugin(self.wp_page, task)
            elif task_type == 'plugin_settings':
                result = await self.plugin_manager.change_plugin_settings(self.wp_page, task)
            
            # === パート2: 投稿関連タスク ===
            elif task_type == 'edit_post':
                result = await self.post_editor.edit_post(self.wp_page, task)
            elif task_type == 'content_create':
                result = await self.post_creator.create_post(self.wp_page, task)
            
            # === パート3: 設定関連タスク ===
            elif task_type == 'theme_change':
                result = await self.settings_manager.change_theme(self.wp_page, task)
            elif task_type == 'setting_change':
                result = await self.settings_manager.change_settings(self.wp_page, task)
            
            # === パート4: テストタスク ===
            elif task_type == 'test_functionality':
                result = await self.tester.test_functionality(self.wp_page, task)
            
            # === パート5: その他のタスク ===
            else:
                result = await self._generic_execution(task)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "タスクタイプ別実行")
            return {
                'success': False,
                'error': str(e)
            }
            
    def get_plugin_manager(self):
        """プラグインマネージャーを安全に取得"""
        if hasattr(self, 'plugin_manager') and self.plugin_manager:
            return self.plugin_manager
        else:
            logger.error("❌ plugin_manager が利用できません")
            return None

    async def execute_plugin_task(self, task: Dict) -> Dict:
        """プラグイン関連タスクを実行（安全なラッパー）"""
        try:
            if not self.plugin_manager:
                return {
                    'success': False,
                    'error': 'プラグインマネージャーが初期化されていません'
                }
        
            # タスクタイプに応じて適切なメソッドを呼び出す
            task_type = task.get('type', '')
        
            if task_type == 'facetwp_configure':
                return await self.plugin_manager.configure_facetwp(task.get('parameters', {}))
            elif task_type == 'user_role_configure':
                return await self.plugin_manager.configure_user_roles(task.get('parameters', {}))
            else:
                return await self.plugin_manager.change_plugin_settings(None, task)
            
        except Exception as e:
            logger.error(f"❌ プラグインタスク実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def create_post(self, page: Page, task: Dict) -> Dict:
        """新規投稿を作成（post_status対応版）"""
        try:
            # === パート1: タスクパラメータ取得 ===
            post_status = task.get('post_status', 'draft')
            post_action = task.get('post_action', 'create')
        
            logger.info(f"WordPress投稿作成:")
            logger.info(f"  アクション: {post_action}")
            logger.info(f"  ステータス: {post_status}")
        
            # === パート2: 記事コンテンツ設定 ===
            # （既存の記事取得・タイトル・本文設定処理）
            article_title = "デフォルトタイトル"  # 実際の実装では適切な値を設定
            polylang_lang = "ja"
            language = "日本語"
            article_body = ""
            screenshot_path = None
        
            # === パート3: 投稿ステータスに応じた処理 ===
            status_result = await self._handle_post_status(page, post_status, post_action)
            
            # === パート4: 結果サマリー構築 ===
            summary = self._build_create_summary(
                article_title, polylang_lang, language, 
                len(article_body), post_status, status_result['message']
            )
        
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'action': post_action,
                'screenshot': screenshot_path
            }
        
        except Exception as e:
            logger.error(f"❌ WordPress投稿作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _handle_post_status(self, page: Page, post_status: str, post_action: str) -> Dict:
        """投稿ステータスに応じた保存/公開処理"""
        try:
            # === パート1: 下書き保存の場合 ===
            if post_status == 'draft' or post_action == 'create':
                logger.info("\n【下書き保存中...】")
                saved = await self._save_draft(page)
            
                if saved:
                    logger.info("✅ 下書き保存完了")
                    return {'success': True, 'message': '下書き保存'}
                else:
                    logger.warning("⚠️ 下書き保存ボタンが見つかりませんでした")
                    return {'success': False, 'message': '保存確認推奨'}
        
            # === パート2: 公開の場合 ===
            elif post_status == 'publish' or post_action == 'publish':
                logger.info("\n【記事を公開中...】")
                published = await self._publish_post(page)
            
                if published:
                    logger.info("✅ 記事公開完了")
                    return {'success': True, 'message': '公開完了'}
                else:
                    logger.warning("⚠️ 公開ボタンが見つかりませんでした")
                    return {'success': False, 'message': '公開確認推奨'}
        
            # === パート3: その他のステータスの場合 ===
            else:
                logger.info(f"\n【カスタムステータス: {post_status}】")
                saved = await self._save_draft(page)
                return {
                    'success': saved, 
                    'message': f'保存完了（ステータス: {post_status}）'
                }
        
        except Exception as e:
            logger.error(f"投稿ステータス処理エラー: {e}")
            return {'success': False, 'message': f'エラー: {str(e)}'}


    async def _publish_post(self, page: Page) -> bool:
        """投稿を公開"""
        # === パート1: 公開ボタンセレクタ定義 ===
        publish_selectors = [
            'button:has-text("公開")',
            'button[aria-label="公開"]',
            '.editor-post-publish-button',
            'button.editor-post-publish-button__button'
        ]
    
        logger.debug("公開ボタンを探索中...")
    
        # === パート2: 公開ボタン探索ループ ===
        for i, selector in enumerate(publish_selectors, 1):
            logger.debug(f"  試行 {i}/{len(publish_selectors)}: {selector}")
            try:
                publish_button = await page.query_selector(selector)
                if not publish_button:
                    continue
                    
                # === パート3: ボタン状態チェック ===
                is_visible = await publish_button.is_visible()
                is_disabled = await publish_button.is_disabled() if is_visible else True
            
                logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === パート4: 公開ボタンクリック ===
                    await publish_button.click()
                    await page.wait_for_timeout(2000)
                
                    # === パート5: 確認ダイアログ処理 ===
                    try:
                        confirm_button = await page.query_selector('button:has-text("公開")')
                        if confirm_button and await confirm_button.is_visible():
                            await confirm_button.click()
                            await page.wait_for_timeout(3000)
                    except:
                        pass
                
                    logger.info("✅ 公開ボタンクリック成功")
                    return True
                    
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
    
        logger.warning("❌ 公開ボタンが見つかりませんでした")
        return False


    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        # === パート1: 保存ボタンセレクタ定義 ===
        save_selectors = [
            'button:has-text("下書き保存")',
            'button[aria-label="下書き保存"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
    
        logger.debug("下書き保存ボタンを探索中...")
    
        # === パート2: 保存ボタン探索ループ ===
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  試行 {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if not save_button:
                    continue
                    
                # === パート3: ボタン状態チェック ===
                is_visible = await save_button.is_visible()
                is_disabled = await save_button.is_disabled() if is_visible else True
            
                logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === パート4: 保存ボタンクリック ===
                    await save_button.click()
                    await page.wait_for_timeout(4000)
                    logger.info("✅ 下書き保存ボタンクリック成功")
                    return True
                    
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
    
        logger.warning("❌ 下書き保存ボタンが見つかりませんでした")
        return False


    def _build_create_summary(self, title: str, polylang_lang: str, 
                             language: str, content_length: int, 
                             post_status: str, status_message: str) -> str:
        """新規投稿作成のサマリーを構築"""
        # === パート1: サマリー行の構築 ===
        summary_lines = []
        summary_lines.append("【WordPress投稿完了】")
        summary_lines.append(f"タイトル: {title}")
        summary_lines.append(f"言語: {language}")
        summary_lines.append(f"Polylang設定: {polylang_lang}")
        summary_lines.append(f"本文: {content_length}文字（HTML形式）")
        summary_lines.append(f"投稿ステータス: {post_status}")
        summary_lines.append(f"✅ {status_message}")
    
        # === パート2: サマリー文字列の結合 ===
        return '\n'.join(summary_lines)
    
    
    async def _generic_execution(self, task: Dict) -> Dict:
        """汎用的なタスク実行(Geminiに確認しながら実行)"""
        try:
            # === パート1: 実行開始 ===
            logger.info("汎用タスクを実行中...")
            
            # === パート2: Geminiプロンプト作成 ===
            gemini_prompt = self._build_gemini_prompt(task)
            
            # === パート3: Geminiに送信 ===
            await self.browser.send_prompt(gemini_prompt)
            await self.browser.wait_for_text_generation(max_wait=120)
            response = await self.browser.extract_latest_text_response()
            
            logger.info("Geminiから実行手順を取得しました")
            logger.info(f"手順:\n{response[:500]}...")
            
            # === パート4: 結果返却 ===
            return self._build_generic_result(task, response)
            
        except Exception as e:
            ErrorHandler.log_error(e, "汎用タスク実行")
            return {
                'success': False,
                'error': str(e)
            }

    def _build_gemini_prompt(self, task: Dict) -> str:
        """Gemini用プロンプトを構築"""
        return f"""
        WordPressで以下のタスクを実行したいです:

        【タスク】
        {task['description']}

        【WordPress情報】
        - URL: {self.wp_url}
        - 管理画面にログイン済み

        【質問】
        このタスクを実行するための具体的な手順を、WordPress管理画面の操作として教えてください。

        以下の形式で回答してください:
        1. 移動するページのURL(相対パス)
        2. クリックまたは入力する要素のセレクタ
        3. 入力する値
        4. 確認すべきポイント

        セレクタはできるだけ具体的に(id, class, name属性など)。
        """

    def _build_generic_result(self, task: Dict, response: str) -> Dict:
        """汎用実行の結果を構築"""
        logger.info("⚠️ 実際の実行は手動で確認してください")
        
        return {
            'success': True,
            'summary': 'Geminiから実行手順を取得しました。手順を確認して実行してください。',
            'full_text': f'【タスク】\n{task["description"]}\n\n【実行手順】\n{response}'
        }
    
    async def cleanup(self):
        """WordPressセッションをクリーンアップ"""
        # === パート1: ページクローズ ===
        if self.wp_page:
            await self.wp_page.close()
            logger.info("WordPressセッションを終了しました")


# === 追加機能メソッド（分割済み） ===

    async def configure_acf_fields(self, task_params: Dict) -> Dict:
        """Advanced Custom Fieldsのフィールドグループを設定"""
        try:
            # === パート1: パラメータ取得 ===
            field_group_name = task_params.get('acf_field_group_name')
            fields = task_params.get('acf_fields', [])
            location_rules = task_params.get('acf_location_rules', {})
            
            logger.info(f"ACFフィールドグループ '{field_group_name}' を設定中...")
            
            # === パート2: ACF画面移動 ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/edit.php?post_type=acf-field-group")
            await self.wp_page.wait_for_timeout(2000)
            
            # === パート3: 新規フィールドグループ追加 ===
            await self._click_acf_add_new_button()
            
            # === パート4: フィールドグループ名入力 ===
            await self._input_acf_field_group_name(field_group_name)
            
            # === パート5: スクリーンショットと結果返却 ===
            return await self._build_acf_result(field_group_name, fields, location_rules)
            
        except Exception as e:
            logger.error(f"ACF設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _click_acf_add_new_button(self):
        """ACF新規追加ボタンをクリック"""
        add_button_selectors = [
            'a.page-title-action:has-text("新規追加")',
            'a:has-text("Add New")',
            '.page-title-action'
        ]
        
        for selector in add_button_selectors:
            try:
                add_button = await self.wp_page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await self.wp_page.wait_for_timeout(3000)
                    break
            except:
                continue

    async def _input_acf_field_group_name(self, field_group_name: str):
        """ACFフィールドグループ名を入力"""
        title_input = await self.wp_page.query_selector('#title')
        if title_input:
            await title_input.fill(field_group_name)
            logger.info(f"フィールドグループ名を入力: {field_group_name}")

    async def _build_acf_result(self, field_group_name: str, fields: list, location_rules: dict) -> Dict:
        """ACF設定結果を構築"""
        # スクリーンショット
        screenshot_path = f"acf_setup_{datetime.now().strftime('%H%M%S')}.png"  # ✅ datetime が利用可能
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("⚠️ ACFフィールドの詳細設定は手動で確認してください")
        
        return {
            'success': True,
            'summary': f'ACFフィールドグループ "{field_group_name}" の設定画面を開きました。',
            'field_group_name': field_group_name,
            'fields_count': len(fields),
            'screenshot': screenshot_path,
            'full_text': f'ACFフィールドグループ設定\n名前: {field_group_name}\nフィールド数: {len(fields)}\n※フィールド追加は手動で実施してください'
        }

    # （他の追加機能メソッドも同様に分割。以下は一部のみ表示）

    async def configure_custom_post_type(self, task_params: Dict) -> Dict:
        """Custom Post Type UIでカスタム投稿タイプを作成"""
        try:
            # === パート1: パラメータ取得 ===
            cpt_slug = task_params.get('cpt_slug')
            cpt_labels = task_params.get('cpt_labels', {})
            cpt_supports = task_params.get('cpt_supports', [])
            cpt_settings = task_params.get('cpt_settings', {})
            
            logger.info(f"カスタム投稿タイプ '{cpt_slug}' を作成中...")
            
            # === パート2: CPT UI画面移動 ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_post_types")
            await self.wp_page.wait_for_timeout(3000)
            
            # === パート3: 基本情報入力 ===
            await self._input_cpt_basic_info(cpt_slug, cpt_labels)
            
            # === パート4: 結果構築 ===
            return await self._build_cpt_result(cpt_slug, cpt_labels)
            
        except Exception as e:
            logger.error(f"Custom Post Type作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _input_cpt_basic_info(self, cpt_slug: str, cpt_labels: dict):
        """CPT基本情報を入力"""
        # Post Type Slug入力
        slug_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[name]"]')
        if slug_input:
            await slug_input.fill(cpt_slug)
            logger.info(f"スラッグを入力: {cpt_slug}")
        
        # Plural Label入力
        plural_label = cpt_labels.get('plural', cpt_slug)
        plural_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[label]"]')
        if plural_input:
            await plural_input.fill(plural_label)
            logger.info(f"複数形ラベルを入力: {plural_label}")
        
        # Singular Label入力
        singular_label = cpt_labels.get('singular', cpt_slug)
        singular_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[singular_label]"]')
        if singular_input:
            await singular_input.fill(singular_label)
            logger.info(f"単数形ラベルを入力: {singular_label}")

    async def _build_cpt_result(self, cpt_slug: str, cpt_labels: dict) -> Dict:
        """CPT作成結果を構築"""
        screenshot_path = f"cpt_creation_{cpt_slug}_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("⚠️ 詳細設定とSupports設定は手動で確認してください")
        
        return {
            'success': True,
            'summary': f'カスタム投稿タイプ "{cpt_slug}" の設定画面を開きました。',
            'cpt_slug': cpt_slug,
            'cpt_labels': cpt_labels,
            'screenshot': screenshot_path,
            'full_text': f'Custom Post Type作成\nスラッグ: {cpt_slug}\nラベル: {cpt_labels}\n※Supports設定等は手動で実施してください'
        }


    # === 3. カスタムタクソノミー作成機能 ===
    async def configure_custom_taxonomy(self, task_params: Dict) -> Dict:
        """
        Custom Post Type UIでカスタムタクソノミーを作成
        
        Parameters:
            taxonomy_slug: str - タクソノミースラッグ
            taxonomy_labels: dict - ラベル設定
            taxonomy_post_types: list - 紐づける投稿タイプ
            taxonomy_hierarchical: bool - 階層構造の有無
        """
        try:
            taxonomy_slug = task_params.get('taxonomy_slug')
            taxonomy_labels = task_params.get('taxonomy_labels', {})
            taxonomy_post_types = task_params.get('taxonomy_post_types', [])
            taxonomy_hierarchical = task_params.get('taxonomy_hierarchical', True)
            
            logger.info(f"カスタムタクソノミー '{taxonomy_slug}' を作成中...")
            
            # 1 Custom Post Type UI - Taxonomies画面に移動
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_taxonomies")
            await self.wp_page.wait_for_timeout(3000)
            
            # 2 Taxonomy Slug入力
            slug_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[name]"]')
            if slug_input:
                await slug_input.fill(taxonomy_slug)
                logger.info(f"タクソノミースラッグを入力: {taxonomy_slug}")
            
            # 3 Plural Label入力
            plural_label = taxonomy_labels.get('plural', taxonomy_slug)
            plural_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[label]"]')
            if plural_input:
                await plural_input.fill(plural_label)
                logger.info(f"複数形ラベルを入力: {plural_label}")
            
            # 4 Singular Label入力
            singular_label = taxonomy_labels.get('singular', taxonomy_slug)
            singular_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[singular_label]"]')
            if singular_input:
                await singular_input.fill(singular_label)
                logger.info(f"単数形ラベルを入力: {singular_label}")
            
            # 5 スクリーンショット
            screenshot_path = f"taxonomy_creation_{taxonomy_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("⚠️ Attach to Post Typesと階層設定は手動で確認してください")
            
            return {
                'success': True,
                'summary': f'カスタムタクソノミー "{taxonomy_slug}" の設定画面を開きました。',
                'taxonomy_slug': taxonomy_slug,
                'taxonomy_labels': taxonomy_labels,
                'screenshot': screenshot_path,
                'full_text': f'Custom Taxonomy作成\nスラッグ: {taxonomy_slug}\nラベル: {taxonomy_labels}\n※投稿タイプ紐付けは手動で実施してください'
            }
            
        except Exception as e:
            logger.error(f"カスタムタクソノミー作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 4. M&A案件投稿機能（ACFフィールド付き） ===
    async def create_ma_case_post(self, task_params: Dict) -> Dict:
        """
        M&A案件をACFカスタムフィールド付きで投稿
        
        Parameters:
            post_title: str - 投稿タイトル
            post_content: str - 本文
            acf_fields: dict - ACFカスタムフィールドの値
            polylang_lang: str - 言語設定
            post_status: str - 投稿ステータス
        """
        try:
            post_title = task_params.get('post_title')
            post_content = task_params.get('post_content', '')
            acf_fields = task_params.get('acf_fields', {})
            polylang_lang = task_params.get('polylang_lang', 'ja')
            post_status = task_params.get('post_status', 'draft')
            
            logger.info(f"M&A案件投稿: {post_title}")
            
            # 1 新規投稿画面に移動（ma_case投稿タイプ）
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post-new.php?post_type=ma_case")
            await self.wp_page.wait_for_timeout(5000)
            
            # 2 タイトル入力
            await self._input_title(self.wp_page, post_title)
            
            # 3 本文入力（ある場合）
            if post_content:
                await self._input_content(self.wp_page, post_content)
            
            # 4 ACFフィールドに値を入力
            logger.info("ACFフィールドに値を入力中...")
            for field_name, field_value in acf_fields.items():
                try:
                    # フィールド名からセレクタを推測
                    field_selector = f'input[name="acf[{field_name}]"]'
                    field_input = await self.wp_page.query_selector(field_selector)
                    
                    if field_input:
                        await field_input.fill(str(field_value))
                        logger.info(f"  {field_name}: {field_value}")
                    else:
                        logger.warning(f"  フィールド '{field_name}' が見つかりません")
                except Exception as e:
                    logger.warning(f"  フィールド '{field_name}' 入力エラー: {e}")
            
            # 5 Polylang言語設定
            await self._set_polylang_language(self.wp_page, polylang_lang)
            
            # 6 スクリーンショット
            screenshot_path = f"ma_case_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            # 7 保存または公開
            if post_status == 'draft':
                saved = await self._save_draft(self.wp_page)
                status_message = "下書き保存完了" if saved else "保存確認推奨"
            elif post_status == 'publish':
                published = await self._publish_post(self.wp_page)
                status_message = "公開完了" if published else "公開確認推奨"
            else:
                saved = await self._save_draft(self.wp_page)
                status_message = f"保存完了（ステータス: {post_status}）"
            
            summary = f"""【M&A案件投稿完了】
    タイトル: {post_title}
    言語: {polylang_lang}
    ACFフィールド: {len(acf_fields)}件
    投稿ステータス: {post_status}
    ✅ {status_message}"""
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'acf_fields_count': len(acf_fields),
                'screenshot': screenshot_path,
                'full_text': summary
            }
            
        except Exception as e:
            logger.error(f"M&A案件投稿エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 5. Polylang翻訳連携機能 ===
    async def link_polylang_translations(self, original_post_id: int, translated_post_id: int, lang_code: str) -> Dict:
        """
        Polylangで投稿同士を翻訳関係として連携
        
        Parameters:
            original_post_id: int - 元の投稿ID
            translated_post_id: int - 翻訳先の投稿ID
            lang_code: str - 翻訳先の言語コード
        """
        try:
            logger.info(f"Polylang翻訳連携: {original_post_id} → {translated_post_id} ({lang_code})")
            
            # 元の投稿の編集画面を開く
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post.php?post={original_post_id}&action=edit")
            await self.wp_page.wait_for_timeout(3000)
            
            # Polylang言語メタボックスで+ボタンをクリック
            logger.info("Polylang言語設定メタボックスを操作中...")
            
            # スクリーンショット
            screenshot_path = f"polylang_link_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("⚠️ Polylang翻訳連携は手動で確認してください")
            
            return {
                'success': True,
                'summary': f'投稿ID {original_post_id} の編集画面を開きました。Polylang設定で投稿ID {translated_post_id} を連携してください。',
                'original_post_id': original_post_id,
                'translated_post_id': translated_post_id,
                'lang_code': lang_code,
                'screenshot': screenshot_path,
                'full_text': f'Polylang翻訳連携\n元投稿ID: {original_post_id}\n翻訳先ID: {translated_post_id}\n言語: {lang_code}\n※手動で連携を完了してください'
            }
            
        except Exception as e:
            logger.error(f"Polylang翻訳連携エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _calculate_dynamic_timeout(self, text_content: str) -> int:
        """動的タイムアウト計算 - WP処理対応"""
        base_timeout = 120
            
        # 既存のキーワード
        long_task_keywords = [
            '要件定義', '設計書', 'コード生成', '実装'
        ]
            
        # === 新規追加: WordPress専用キーワード ===
        wp_long_task_keywords = [
            'FacetWP', 'Relevanssi', 'インデックス再構築',
            'WP-CLI', 'データベース移行', 'プラグイン一括',
            'ACF Pro ライセンス', 'カスタムフィールド同期'
        ]
            
        # 通常の長時間タスク
        if any(kw in text_content for kw in long_task_keywords):
            base_timeout = 300
            
        # === WP特化の超長時間タスク ===
        if any(kw in text_content for kw in wp_long_task_keywords):
            base_timeout = 600  # 10分
            logger.info(f"⏱️ config WP長時間処理を検出 - タイムアウト: {base_timeout}秒")
        
        async def cleanup(self):
            """WordPress セッションをクリーンアップ"""
            if self.wp_page:
                try:
                    await self.wp_page.close()
                    logger.info("WordPress セッションを終了しました")
                except Exception as e:
                    logger.warning(f"⚠️ WordPress ページクローズエラー: {e}")
            
        return base_timeout
            

#wp_agent.py
"""
wp_agent.py - WordPressエージェント（完全版・全機能保持）

エラー対策:
1. __init__の引数名を browser_controller に統一
2. wp_credentials を辞書型で受け取る設計
3. サブエージェントへの引数渡しを統一
4. 初期化エラーの詳細ログ出力
5. 元のコードの全機能を保持
"""

import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path
from playwright.async_api import Page
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController

# WordPressサブモジュール
from .wp_auth import WordPressAuth
from .wp_post_editor import WordPressPostEditor
from .wp_post_creator import WordPressPostCreator
from .wp_plugin_manager import WordPressPluginManager
from .wp_settings_manager import WordPressSettingsManager
from .wp_tester import WordPressTester
from .wp_utils import TaskTypeAnalyzer

logger = logging.getLogger(__name__)


class WordPressAgent:
    """
    WordPressエージェント - メインオーケストレーター（全機能版）
    
    重要: 初期化引数は browser_controller と wp_credentials の2つのみ
    """
    
    def __init__(self, browser_controller: BrowserController, wp_credentials: Dict = None):
        """
        初期化（エラー対策版）
        
        Args:
            browser_controller: BrowserControllerインスタンス（必須）
            wp_credentials: WordPress認証情報の辞書（オプション）
                - wp_url: サイトURL
                - wp_user: ユーザー名
                - wp_pass: パスワード
        """
        logger.info("=" * 60)
        logger.info("🌐 wp-agent ✅ INFO WordPressAgent初期化開始")
        logger.info("=" * 60)
        
        # ✅ 基本プロパティ設定
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.is_logged_in = False
        self.wp_page = None  # WordPress専用ページ
        self.sheets_manager = None  # 後で外部から設定される
        
        # ✅ 認証情報の取得
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        self.wp_user = self.wp_credentials.get('wp_user', '')
        self.wp_pass = self.wp_credentials.get('wp_pass', '')
        
        # ✅ 認証情報の検証とログ出力
        self._validate_credentials()
        
        # ✅ 認証モジュール初期化
        self._initialize_auth_module()
        
        # ✅ サブエージェント初期化
        self._initialize_sub_agents()
        
        logger.info("=" * 60)
        logger.info("🌐 wp-agent ✅ INFO WordPressAgent初期化完了")
        logger.info("=" * 60)
    
    def _validate_credentials(self):
        """認証情報の検証"""
        missing = []
        
        if not self.wp_url:
            missing.append('wp_url')
        if not self.wp_user:
            missing.append('wp_user')
        if not self.wp_pass:
            missing.append('wp_pass')
        
        if missing:
            logger.warning(f"🌐 wp-agent ⚠️ WARN ⚠️ WordPress認証情報が不完全です: {', '.join(missing)}")
            logger.warning("🌐 wp-agent ⚠️ WARN 記事作成機能のみ利用可能（投稿機能は制限されます）")
        else:
            logger.info("🌐 wp-agent ✅ INFO WordPress認証情報の確認完了")
    
    def _initialize_auth_module(self):
        """認証モジュール初期化"""
        if self.wp_url and self.wp_user and self.wp_pass:
            try:
                self.auth = WordPressAuth(
                    browser_controller=self.browser,
                    wp_url=self.wp_url,
                    wp_user=self.wp_user,
                    wp_pass=self.wp_pass
                )
                logger.info("🌐 wp-agent ✅ INFO WordPressAuth初期化完了")
            except Exception as e:
                logger.error(f"🌐 wp-agent ❌ ERROR WordPressAuth初期化失敗: {e}")
                self.auth = None
        else:
            logger.warning("🌐 wp-agent ⚠️ WARN WordPressAuth初期化スキップ（認証情報不足）")
            self.auth = None
    
    def _initialize_sub_agents(self):
        """
        サブエージェント初期化（引数統一版）
        
        重要: 全てのサブエージェントに browser_controller と wp_credentials を渡す
        """
        try:
            # ✅ 投稿編集エージェント
            self.post_editor = WordPressPostEditor(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("🌐 wp-agent ✅ INFO WordPressPostEditor初期化完了")
            
            # ✅ 投稿作成エージェント
            self.post_creator = WordPressPostCreator(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("🌐 wp-agent ✅ INFO WordPressPostCreator初期化完了")
            
            # ✅ プラグインマネージャー
            self.plugin_manager = WordPressPluginManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("🌐 wp-agent ✅ INFO WordPressPluginManager初期化完了")
            
            # ✅ 設定マネージャー
            self.settings_manager = WordPressSettingsManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("🌐 wp-agent ✅ INFO WordPressSettingsManager初期化完了")
            
            # ✅ テスター
            self.tester = WordPressTester(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("🌐 wp-agent ✅ INFO WordPressTester初期化完了")
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR サブエージェント初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            raise
    
    async def initialize_wp_session(self) -> bool:
        """
        WordPressセッション初期化（完全修正版 - クッキー強制ナビゲーション対応）
        
        改善点:
        1. 新しいタブ作成（Geminiセッションと完全独立）
        2. クッキー適用 + 管理画面への強制ナビゲーション
        3. ログイン状態の厳格な検証
        4. 失敗時の手動ログインフォールバック
        
        Returns:
            bool: 初期化成功時 True
        """
        try:
            logger.info("=" * 60)
            logger.info("🌐 wp-agent ✅ INFO WordPressセッション初期化中...")
            logger.info("=" * 60)
            
            # ✅ Phase 1: 新しいタブを作成
            if not self.browser.context:
                logger.error("🌐 wp-agent ❌ ERROR ブラウザコンテキストが初期化されていません")
                return False
            
            self.wp_page = await self.browser.context.new_page()
            logger.info("🌐 wp-agent ✅ INFO WordPress専用タブを作成しました")
            
            # ✅ Phase 2: 認証情報の検証
            if not self.auth:
                logger.error("🌐 wp-agent ❌ ERROR WordPress認証モジュールが初期化されていません")
                return False
            
            # ✅ Phase 3: ログイン実行（クッキー優先 + 強制ナビゲーション）
            logger.info("🌐 wp-agent ✅ INFO WordPress認証を実行中...")
            login_success = await self.auth.login(self.wp_page)
            
            if login_success:
                self.is_logged_in = True
                logger.info("=" * 60)
                logger.info("🌐 wp-agent ✅ INFO WordPressセッション初期化完了")
                logger.info(f"  認証方法: クッキー or 手動ログイン")
                logger.info(f"  ページURL: {self.wp_page.url}")
                logger.info("=" * 60)
                return True
            else:
                logger.error("=" * 60)
                logger.error("🌐 wp-agent ❌ ERROR WordPressログイン失敗")
                logger.error("  原因: 認証情報またはネットワークの問題")
                logger.error("  対策: 認証情報を確認してください")
                logger.error("=" * 60)
                
                # デバッグ用: 失敗時のスクリーンショット
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("🌐 wp-agent 📸 INFO デバッグ用スクリーンショット: wp_session_init_failed.png")
                except:
                    pass
                
                return False
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR WordPressセッション初期化エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def ensure_logged_in(self) -> bool:
        """
        ログイン状態を保証
        
        Returns:
            bool: ログイン済みまたはログイン成功時 True
        """
        if self.is_logged_in and self.wp_page:
            # 定期的にログイン状態を確認
            if await self.auth._verify_login_status(self.wp_page):
                return True
        
        # ログインしていない場合は再初期化
        logger.info("🌐 wp-agent ✅ INFO WordPress再ログインを試行します")
        return await self.initialize_wp_session()
    
    async def _try_cookie_login(self, wp_url: str) -> bool:
        """クッキーを使用したログイン試行"""
        try:
            if not wp_url:
                logger.warning("🌐 wp-agent ⚠️ WARN WordPress URLが設定されていません")
                return False
            
            # WordPressクッキーをロード
            cookie_loaded = await self.browser.load_wordpress_cookies(wp_url)
            if not cookie_loaded:
                return False
            
            # 管理画面にアクセスしてログイン状態を確認
            admin_url = f"{wp_url.rstrip('/')}/wp-admin/"
            await self.browser.page.goto(admin_url, wait_until='networkidle')
            await asyncio.sleep(2)
            
            # ログイン状態を詳細チェック
            return await self._verify_wordpress_login_status()
        
        except Exception as e:
            logger.warning(f"🌐 wp-agent ⚠️ WARN クッキーログイン試行エラー: {e}")
            return False
    
    async def _verify_wordpress_login_status(self) -> bool:
        """WordPressログイン状態を詳細検証"""
        try:
            page = self.browser.page
            
            # 複数の方法でログイン状態を確認
            checks = []
            
            # 1. 管理バーの存在チェック
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('管理バー', bool(admin_bar)))
            
            # 2. ダッシュボード要素チェック
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ダッシュボード', bool(dashboard)))
            
            # 3. ログインフォームの不在チェック
            login_form = await page.query_selector('#loginform')
            checks.append(('ログインフォーム不在', not bool(login_form)))
            
            # 4. URLチェック（リダイレクトされていないか）
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('管理ページURL', is_admin_page))
            
            # 結果の集計
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
            
            logger.info(f"🌐 wp-agent ✅ INFO ログイン状態検証: {total_passed}/4 合格")
            if total_passed >= 3:  # 4つのうち3つ以上合格ならログイン成功
                logger.info(f"  合格項目: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"🌐 wp-agent ⚠️ WARN 不合格項目が多すぎます")
                return False
        
        except Exception as e:
            logger.warning(f"🌐 wp-agent ⚠️ WARN ログイン状態検証エラー: {e}")
            return False
    
    async def _manual_wordpress_login(self) -> bool:
        """手動WordPressログイン"""
        try:
            wp_url = self.wp_credentials.get('wp_url', '')
            wp_user = self.wp_credentials.get('wp_user', '')
            wp_pass = self.wp_credentials.get('wp_pass', '')
            
            if not all([wp_url, wp_user, wp_pass]):
                logger.error("🌐 wp-agent ❌ ERROR WordPress認証情報が不足しています")
                return False
            
            # ログインページに移動
            login_url = f"{wp_url.rstrip('/')}/wp-login.php"
            await self.browser.page.goto(login_url, wait_until='networkidle')
            await asyncio.sleep(2)
            
            # ユーザー名入力
            user_field = await self.browser.page.query_selector('#user_login')
            if user_field:
                await user_field.fill(wp_user)
                logger.info("🌐 wp-agent ✅ INFO ユーザー名入力完了")
            else:
                logger.error("🌐 wp-agent ❌ ERROR ユーザー名入力フィールドが見つかりません")
                return False
            
            # パスワード入力
            pass_field = await self.browser.page.query_selector('#user_pass')
            if pass_field:
                await pass_field.fill(wp_pass)
                logger.info("🌐 wp-agent ✅ INFO パスワード入力完了")
            else:
                logger.error("🌐 wp-agent ❌ ERROR パスワード入力フィールドが見つかりません")
                return False
            
            # ログインボタンクリック
            login_button = await self.browser.page.query_selector('#wp-submit')
            if login_button:
                await login_button.click()
                logger.info("🌐 wp-agent ✅ INFO ログインボタンクリック")
            else:
                logger.error("🌐 wp-agent ❌ ERROR ログインボタンが見つかりません")
                return False
            
            # ログイン完了待機
            await self.browser.page.wait_for_load_state('networkidle')
            await asyncio.sleep(3)
            
            # ログイン成功確認
            if await self._verify_wordpress_login_status():
                logger.info("🌐 wp-agent ✅ INFO 手動ログイン成功")
                return True
            else:
                logger.error("🌐 wp-agent ❌ ERROR 手動ログイン失敗 - 認証情報またはネットワークの問題")
                return False
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR 手動ログインエラー: {e}")
            return False
    
    async def process_task(self, task: Dict) -> Dict:
        """
        WordPressタスクを処理
        
        Args:
            task: タスク情報（description, task_id等）
        
        Returns:
            処理結果の辞書
        """
        try:
            # ログイン状態を確認
            if not await self.ensure_logged_in():
                return {
                    'success': False,
                    'error': 'WordPressにログインできませんでした'
                }
            
            logger.info("=" * 60)
            logger.info("🌐 wp-agent ✅ INFO WordPressタスク実行開始")
            logger.info(f"タスク: {task['description']}")
            logger.info("=" * 60)
            
            # シートマネージャー設定
            self.post_editor.sheets_manager = self.sheets_manager
            self.post_creator.sheets_manager = self.sheets_manager
            
            # タスクタイプ解析
            task_type = TaskTypeAnalyzer.analyze(task['description'])
            logger.info(f"🌐 wp-agent ✅ INFO 解析されたタスクタイプ: {task_type}")
            
            # タスクタイプに応じた処理実行
            result = await self._execute_task_by_type(task, task_type)
            
            return result
        
        except Exception as e:
            ErrorHandler.log_error(e, "🌐 wp-agent WordPressタスク処理")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_task_by_type(self, task: Dict, task_type: str) -> Dict:
        """タスクタイプに応じて適切なモジュールに処理を委譲"""
        try:
            # プラグイン関連タスク
            if task_type == 'plugin_install':
                result = await self.plugin_manager.install_plugin(self.wp_page, task)
            elif task_type == 'plugin_settings':
                result = await self.plugin_manager.change_plugin_settings(self.wp_page, task)
            
            # 投稿関連タスク
            elif task_type == 'edit_post':
                result = await self.post_editor.edit_post(self.wp_page, task)
            elif task_type == 'content_create':
                result = await self.post_creator.create_post(self.wp_page, task)
            
            # 設定関連タスク
            elif task_type == 'theme_change':
                result = await self.settings_manager.change_theme(self.wp_page, task)
            elif task_type == 'setting_change':
                result = await self.settings_manager.change_settings(self.wp_page, task)
            
            # テストタスク
            elif task_type == 'test_functionality':
                result = await self.tester.test_functionality(self.wp_page, task)
            
            # その他のタスク
            else:
                result = await self._generic_execution(task)
            
            return result
        
        except Exception as e:
            ErrorHandler.log_error(e, "🌐 wp-agent タスクタイプ別実行")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _generic_execution(self, task: Dict) -> Dict:
        """汎用的なタスク実行（Geminiに確認しながら実行）"""
        try:
            logger.info("🌐 wp-agent ✅ INFO 汎用タスクを実行中...")
            
            # Geminiプロンプト作成
            gemini_prompt = self._build_gemini_prompt(task)
            
            # Geminiに送信
            await self.browser.send_prompt(gemini_prompt)
            await self.browser.wait_for_text_generation(max_wait=120)
            response = await self.browser.extract_latest_text_response()
            
            logger.info(f"🌐 wp-agent ✅ INFO Geminiから実行手順を取得しました")
            logger.info(f"手順:\n{response[:500]}...")
            
            return self._build_generic_result(task, response)
        
        except Exception as e:
            ErrorHandler.log_error(e, "🌐 wp-agent 汎用タスク実行")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _build_gemini_prompt(self, task: Dict) -> str:
        """Gemini用プロンプトを構築"""
        return f"""
WordPressで以下のタスクを実行したいです:

【タスク】
{task['description']}

【WordPress情報】
- URL: {self.wp_url}
- 管理画面にログイン済み

【質問】
このタスクを実行するための具体的な手順を、WordPress管理画面の操作として教えてください。

以下の形式で回答してください:
1. 移動するページのURL（相対パス）
2. クリックまたは入力する要素のセレクタ
3. 入力する値
4. 確認すべきポイント

セレクタはできるだけ具体的に（id, class, name属性など）。
"""
    
    def _build_generic_result(self, task: Dict, response: str) -> Dict:
        """汎用実行の結果を構築"""
        logger.info("🌐 wp-agent ⚠️ WARN 実際の実行は手動で確認してください")
        
        return {
            'success': True,
            'summary': 'Geminiから実行手順を取得しました。手順を確認して実行してください。',
            'full_text': f'【タスク】\n{task["description"]}\n\n【実行手順】\n{response}'
        }
    
    def get_plugin_manager(self):
        """プラグインマネージャーを安全に取得"""
        if hasattr(self, 'plugin_manager') and self.plugin_manager:
            return self.plugin_manager
        else:
            logger.error("🌐 wp-agent ❌ ERROR plugin_manager が利用できません")
            return None
    
    async def execute_plugin_task(self, task: Dict) -> Dict:
        """プラグイン関連タスクを実行（安全なラッパー）"""
        try:
            if not self.plugin_manager:
                return {
                    'success': False,
                    'error': 'プラグインマネージャーが初期化されていません'
                }
            
            task_type = task.get('type', '')
            
            if task_type == 'facetwp_configure':
                return await self.plugin_manager.configure_facetwp(task.get('parameters', {}))
            elif task_type == 'user_role_configure':
                return await self.plugin_manager.configure_user_roles(task.get('parameters', {}))
            else:
                return await self.plugin_manager.change_plugin_settings(None, task)
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR プラグインタスク実行エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    # ========================================
    # ✅ 元のコードの全機能を以下に保持
    # ========================================
    
    async def create_post(self, page: Page, task: Dict) -> Dict:
        """新規投稿を作成（post_status対応版）"""
        try:
            post_status = task.get('post_status', 'draft')
            post_action = task.get('post_action', 'create')
            
            logger.info(f"🌐 wp-agent ✅ INFO WordPress投稿作成:")
            logger.info(f"  アクション: {post_action}")
            logger.info(f"  ステータス: {post_status}")
            
            # 記事コンテンツ設定
            article_title = "デフォルトタイトル"
            polylang_lang = "ja"
            language = "日本語"
            article_body = ""
            screenshot_path = None
            
            # 投稿ステータスに応じた処理
            status_result = await self._handle_post_status(page, post_status, post_action)
            
            # 結果サマリー構築
            summary = self._build_create_summary(
                article_title, polylang_lang, language,
                len(article_body), post_status, status_result['message']
            )
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'action': post_action,
                'screenshot': screenshot_path
            }
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR WordPress投稿作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _handle_post_status(self, page: Page, post_status: str, post_action: str) -> Dict:
        """投稿ステータスに応じた保存/公開処理"""
        try:
            # 下書き保存の場合
            if post_status == 'draft' or post_action == 'create':
                logger.info("🌐 wp-agent ✅ INFO 【下書き保存中...】")
                saved = await self._save_draft(page)
                
                if saved:
                    logger.info("🌐 wp-agent ✅ INFO 下書き保存完了")
                    return {'success': True, 'message': '下書き保存'}
                else:
                    logger.warning("🌐 wp-agent ⚠️ WARN 下書き保存ボタンが見つかりませんでした")
                    return {'success': False, 'message': '保存確認推奨'}
            
            # 公開の場合
            elif post_status == 'publish' or post_action == 'publish':
                logger.info("🌐 wp-agent ✅ INFO 【記事を公開中...】")
                published = await self._publish_post(page)
                
                if published:
                    logger.info("🌐 wp-agent ✅ INFO 記事公開完了")
                    return {'success': True, 'message': '公開完了'}
                else:
                    logger.warning("🌐 wp-agent ⚠️ WARN 公開ボタンが見つかりませんでした")
                    return {'success': False, 'message': '公開確認推奨'}
            
            # その他のステータスの場合
            else:
                logger.info(f"🌐 wp-agent ✅ INFO 【カスタムステータス: {post_status}】")
                saved = await self._save_draft(page)
                return {
                    'success': saved,
                    'message': f'保存完了（ステータス: {post_status}）'
                }
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR 投稿ステータス処理エラー: {e}")
            return {'success': False, 'message': f'エラー: {str(e)}'}
    
    async def _publish_post(self, page: Page) -> bool:
        """投稿を公開"""
        publish_selectors = [
            'button:has-text("公開")',
            'button[aria-label="公開"]',
            '.editor-post-publish-button',
            'button.editor-post-publish-button__button'
        ]
        
        logger.debug("🌐 wp-agent 🐛 DEBUG 公開ボタンを探索中...")
        
        for i, selector in enumerate(publish_selectors, 1):
            logger.debug(f"  試行 {i}/{len(publish_selectors)}: {selector}")
            try:
                publish_button = await page.query_selector(selector)
                if not publish_button:
                    continue
                
                is_visible = await publish_button.is_visible()
                is_disabled = await publish_button.is_disabled() if is_visible else True
                
                logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
                
                if is_visible and not is_disabled:
                    await publish_button.click()
                    await page.wait_for_timeout(2000)
                    
                    # 確認ダイアログ処理
                    try:
                        confirm_button = await page.query_selector('button:has-text("公開")')
                        if confirm_button and await confirm_button.is_visible():
                            await confirm_button.click()
                            await page.wait_for_timeout(3000)
                    except:
                        pass
                    
                    logger.info("🌐 wp-agent ✅ INFO 公開ボタンクリック成功")
                    return True
            
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("🌐 wp-agent ⚠️ WARN 公開ボタンが見つかりませんでした")
        return False
    
    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        save_selectors = [
            'button:has-text("下書き保存")',
            'button[aria-label="下書き保存"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
        
        logger.debug("🌐 wp-agent 🐛 DEBUG 下書き保存ボタンを探索中...")
        
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  試行 {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if not save_button:
                    continue
                
                is_visible = await save_button.is_visible()
                is_disabled = await save_button.is_disabled() if is_visible else True
                
                logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
                
                if is_visible and not is_disabled:
                    await save_button.click()
                    await page.wait_for_timeout(4000)
                    logger.info("🌐 wp-agent ✅ INFO 下書き保存ボタンクリック成功")
                    return True
            
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("🌐 wp-agent ⚠️ WARN 下書き保存ボタンが見つかりませんでした")
        return False
    
    def _build_create_summary(self, title: str, polylang_lang: str,
                             language: str, content_length: int,
                             post_status: str, status_message: str) -> str:
        """新規投稿作成のサマリーを構築"""
        summary_lines = []
        summary_lines.append("【WordPress投稿完了】")
        summary_lines.append(f"タイトル: {title}")
        summary_lines.append(f"言語: {language}")
        summary_lines.append(f"Polylang設定: {polylang_lang}")
        summary_lines.append(f"本文: {content_length}文字（HTML形式）")
        summary_lines.append(f"投稿ステータス: {post_status}")
        summary_lines.append(f"✅ {status_message}")
        
        return '\n'.join(summary_lines)
    
    # ========================================
    # ✅ ACFフィールド設定機能
    # ========================================
    
    async def configure_acf_fields(self, task_params: Dict) -> Dict:
        """Advanced Custom Fieldsのフィールドグループを設定"""
        try:
            field_group_name = task_params.get('acf_field_group_name')
            fields = task_params.get('acf_fields', [])
            location_rules = task_params.get('acf_location_rules', {})
            
            logger.info(f"🌐 wp-agent ✅ INFO ACFフィールドグループ '{field_group_name}' を設定中...")
            
            # ACF画面移動
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/edit.php?post_type=acf-field-group")
            await self.wp_page.wait_for_timeout(2000)
            
            # 新規フィールドグループ追加
            await self._click_acf_add_new_button()
            
            # フィールドグループ名入力
            await self._input_acf_field_group_name(field_group_name)
            
            # スクリーンショットと結果返却
            return await self._build_acf_result(field_group_name, fields, location_rules)
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR ACF設定エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _click_acf_add_new_button(self):
        """ACF新規追加ボタンをクリック"""
        add_button_selectors = [
            'a.page-title-action:has-text("新規追加")',
            'a:has-text("Add New")',
            '.page-title-action'
        ]
        
        for selector in add_button_selectors:
            try:
                add_button = await self.wp_page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await self.wp_page.wait_for_timeout(3000)
                    break
            except:
                continue
    
    async def _input_acf_field_group_name(self, field_group_name: str):
        """ACFフィールドグループ名を入力"""
        title_input = await self.wp_page.query_selector('#title')
        if title_input:
            await title_input.fill(field_group_name)
            logger.info(f"🌐 wp-agent ✅ INFO フィールドグループ名を入力: {field_group_name}")
    
    async def _build_acf_result(self, field_group_name: str, fields: list, location_rules: dict) -> Dict:
        """ACF設定結果を構築"""
        screenshot_path = f"acf_setup_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("🌐 wp-agent ⚠️ WARN ACFフィールドの詳細設定は手動で確認してください")
        
        return {
            'success': True,
            'summary': f'ACFフィールドグループ "{field_group_name}" の設定画面を開きました。',
            'field_group_name': field_group_name,
            'fields_count': len(fields),
            'screenshot': screenshot_path,
            'full_text': f'ACFフィールドグループ設定\n名前: {field_group_name}\nフィールド数: {len(fields)}\n※フィールド追加は手動で実施してください'
        }
    
    # ========================================
    # ✅ カスタム投稿タイプ作成機能
    # ========================================
    
    async def configure_custom_post_type(self, task_params: Dict) -> Dict:
        """Custom Post Type UIでカスタム投稿タイプを作成"""
        try:
            cpt_slug = task_params.get('cpt_slug')
            cpt_labels = task_params.get('cpt_labels', {})
            cpt_supports = task_params.get('cpt_supports', [])
            cpt_settings = task_params.get('cpt_settings', {})
            
            logger.info(f"🌐 wp-agent ✅ INFO カスタム投稿タイプ '{cpt_slug}' を作成中...")
            
            # CPT UI画面移動
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_post_types")
            await self.wp_page.wait_for_timeout(3000)
            
            # 基本情報入力
            await self._input_cpt_basic_info(cpt_slug, cpt_labels)
            
            # 結果構築
            return await self._build_cpt_result(cpt_slug, cpt_labels)
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR Custom Post Type作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _input_cpt_basic_info(self, cpt_slug: str, cpt_labels: dict):
        """CPT基本情報を入力"""
        # Post Type Slug入力
        slug_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[name]"]')
        if slug_input:
            await slug_input.fill(cpt_slug)
            logger.info(f"🌐 wp-agent ✅ INFO スラッグを入力: {cpt_slug}")
        
        # Plural Label入力
        plural_label = cpt_labels.get('plural', cpt_slug)
        plural_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[label]"]')
        if plural_input:
            await plural_input.fill(plural_label)
            logger.info(f"🌐 wp-agent ✅ INFO 複数形ラベルを入力: {plural_label}")
        
        # Singular Label入力
        singular_label = cpt_labels.get('singular', cpt_slug)
        singular_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[singular_label]"]')
        if singular_input:
            await singular_input.fill(singular_label)
            logger.info(f"🌐 wp-agent ✅ INFO 単数形ラベルを入力: {singular_label}")
    
    async def _build_cpt_result(self, cpt_slug: str, cpt_labels: dict) -> Dict:
        """CPT作成結果を構築"""
        screenshot_path = f"cpt_creation_{cpt_slug}_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("🌐 wp-agent ⚠️ WARN 詳細設定とSupports設定は手動で確認してください")
        
        return {
            'success': True,
            'summary': f'カスタム投稿タイプ "{cpt_slug}" の設定画面を開きました。',
            'cpt_slug': cpt_slug,
            'cpt_labels': cpt_labels,
            'screenshot': screenshot_path,
            'full_text': f'Custom Post Type作成\nスラッグ: {cpt_slug}\nラベル: {cpt_labels}\n※Supports設定等は手動で実施してください'
        }
    
    # ========================================
    # ✅ カスタムタクソノミー作成機能
    # ========================================
    
    async def configure_custom_taxonomy(self, task_params: Dict) -> Dict:
        """Custom Post Type UIでカスタムタクソノミーを作成"""
        try:
            taxonomy_slug = task_params.get('taxonomy_slug')
            taxonomy_labels = task_params.get('taxonomy_labels', {})
            taxonomy_post_types = task_params.get('taxonomy_post_types', [])
            taxonomy_hierarchical = task_params.get('taxonomy_hierarchical', True)
            
            logger.info(f"🌐 wp-agent ✅ INFO カスタムタクソノミー '{taxonomy_slug}' を作成中...")
            
            # Custom Post Type UI - Taxonomies画面に移動
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_taxonomies")
            await self.wp_page.wait_for_timeout(3000)
            
            # Taxonomy Slug入力
            slug_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[name]"]')
            if slug_input:
                await slug_input.fill(taxonomy_slug)
                logger.info(f"🌐 wp-agent ✅ INFO タクソノミースラッグを入力: {taxonomy_slug}")
            
            # Plural Label入力
            plural_label = taxonomy_labels.get('plural', taxonomy_slug)
            plural_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[label]"]')
            if plural_input:
                await plural_input.fill(plural_label)
                logger.info(f"🌐 wp-agent ✅ INFO 複数形ラベルを入力: {plural_label}")
            
            # Singular Label入力
            singular_label = taxonomy_labels.get('singular', taxonomy_slug)
            singular_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[singular_label]"]')
            if singular_input:
                await singular_input.fill(singular_label)
                logger.info(f"🌐 wp-agent ✅ INFO 単数形ラベルを入力: {singular_label}")
            
            # スクリーンショット
            screenshot_path = f"taxonomy_creation_{taxonomy_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("🌐 wp-agent ⚠️ WARN Attach to Post Typesと階層設定は手動で確認してください")
            
            return {
                'success': True,
                'summary': f'カスタムタクソノミー "{taxonomy_slug}" の設定画面を開きました。',
                'taxonomy_slug': taxonomy_slug,
                'taxonomy_labels': taxonomy_labels,
                'screenshot': screenshot_path,
                'full_text': f'Custom Taxonomy作成\nスラッグ: {taxonomy_slug}\nラベル: {taxonomy_labels}\n※投稿タイプ紐付けは手動で実施してください'
            }
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR カスタムタクソノミー作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    # ========================================
    # ✅ M&A案件投稿機能（ACFフィールド付き）
    # ========================================
    
    async def create_ma_case_post(self, task_params: Dict) -> Dict:
        """M&A案件をACFカスタムフィールド付きで投稿"""
        try:
            post_title = task_params.get('post_title')
            post_content = task_params.get('post_content', '')
            acf_fields = task_params.get('acf_fields', {})
            polylang_lang = task_params.get('polylang_lang', 'ja')
            post_status = task_params.get('post_status', 'draft')
            
            logger.info(f"🌐 wp-agent ✅ INFO M&A案件投稿: {post_title}")
            
            # 新規投稿画面に移動（ma_case投稿タイプ）
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post-new.php?post_type=ma_case")
            await self.wp_page.wait_for_timeout(5000)
            
            # タイトル入力
            await self._input_title(self.wp_page, post_title)
            
            # 本文入力（ある場合）
            if post_content:
                await self._input_content(self.wp_page, post_content)
            
            # ACFフィールドに値を入力
            logger.info("🌐 wp-agent ✅ INFO ACFフィールドに値を入力中...")
            for field_name, field_value in acf_fields.items():
                try:
                    field_selector = f'input[name="acf[{field_name}]"]'
                    field_input = await self.wp_page.query_selector(field_selector)
                    
                    if field_input:
                        await field_input.fill(str(field_value))
                        logger.info(f"  {field_name}: {field_value}")
                    else:
                        logger.warning(f"  フィールド '{field_name}' が見つかりません")
                except Exception as e:
                    logger.warning(f"  フィールド '{field_name}' 入力エラー: {e}")
            
            # Polylang言語設定
            await self._set_polylang_language(self.wp_page, polylang_lang)
            
            # スクリーンショット
            screenshot_path = f"ma_case_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            # 保存または公開
            if post_status == 'draft':
                saved = await self._save_draft(self.wp_page)
                status_message = "下書き保存完了" if saved else "保存確認推奨"
            elif post_status == 'publish':
                published = await self._publish_post(self.wp_page)
                status_message = "公開完了" if published else "公開確認推奨"
            else:
                saved = await self._save_draft(self.wp_page)
                status_message = f"保存完了（ステータス: {post_status}）"
            
            summary = f"""【M&A案件投稿完了】
タイトル: {post_title}
言語: {polylang_lang}
ACFフィールド: {len(acf_fields)}件
投稿ステータス: {post_status}
✅ {status_message}"""
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'acf_fields_count': len(acf_fields),
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR M&A案件投稿エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _input_title(self, page: Page, title: str):
        """タイトル入力"""
        title_input = await page.query_selector('#title, .editor-post-title__input')
        if title_input:
            await title_input.fill(title)
            logger.info(f"🌐 wp-agent ✅ INFO タイトル入力: {title}")
    
    async def _input_content(self, page: Page, content: str):
        """本文入力"""
        # ブロックエディタの場合
        content_block = await page.query_selector('.block-editor-writing-flow')
        if content_block:
            await content_block.click()
            await page.keyboard.type(content)
            logger.info(f"🌐 wp-agent ✅ INFO 本文入力完了（{len(content)}文字）")
    
    async def _set_polylang_language(self, page: Page, lang_code: str):
        """Polylang言語設定"""
        try:
            lang_selector = f'select#post_lang_choice option[value="{lang_code}"]'
            lang_option = await page.query_selector(lang_selector)
            if lang_option:
                await lang_option.click()
                logger.info(f"🌐 wp-agent ✅ INFO Polylang言語設定: {lang_code}")
        except Exception as e:
            logger.warning(f"🌐 wp-agent ⚠️ WARN Polylang言語設定エラー: {e}")
    
    # ========================================
    # ✅ Polylang翻訳連携機能
    # ========================================
    
    async def link_polylang_translations(self, original_post_id: int, translated_post_id: int, lang_code: str) -> Dict:
        """Polylangで投稿同士を翻訳関係として連携"""
        try:
            logger.info(f"🌐 wp-agent ✅ INFO Polylang翻訳連携: {original_post_id} → {translated_post_id} ({lang_code})")
            
            # 元の投稿の編集画面を開く
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post.php?post={original_post_id}&action=edit")
            await self.wp_page.wait_for_timeout(3000)
            
            # Polylang言語メタボックスで+ボタンをクリック
            logger.info("🌐 wp-agent ✅ INFO Polylang言語設定メタボックスを操作中...")
            
            # スクリーンショット
            screenshot_path = f"polylang_link_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("🌐 wp-agent ⚠️ WARN Polylang翻訳連携は手動で確認してください")
            
            return {
                'success': True,
                'summary': f'投稿ID {original_post_id} の編集画面を開きました。Polylang設定で投稿ID {translated_post_id} を連携してください。',
                'original_post_id': original_post_id,
                'translated_post_id': translated_post_id,
                'lang_code': lang_code,
                'screenshot': screenshot_path,
                'full_text': f'Polylang翻訳連携\n元投稿ID: {original_post_id}\n翻訳先ID: {translated_post_id}\n言語: {lang_code}\n※手動で連携を完了してください'
            }
        
        except Exception as e:
            logger.error(f"🌐 wp-agent ❌ ERROR Polylang翻訳連携エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    # ========================================
    # ✅ 動的タイムアウト計算
    # ========================================
    
    def _calculate_dynamic_timeout(self, text_content: str) -> int:
        """動的タイムアウト計算 - WP処理対応"""
        base_timeout = 120
        
        # 既存のキーワード
        long_task_keywords = [
            '要件定義', '設計書', 'コード生成', '実装'
        ]
        
        # WordPress専用キーワード
        wp_long_task_keywords = [
            'FacetWP', 'Relevanssi', 'インデックス再構築',
            'WP-CLI', 'データベース移行', 'プラグイン一括',
            'ACF Pro ライセンス', 'カスタムフィールド同期'
        ]
        
        # 通常の長時間タスク
        if any(kw in text_content for kw in long_task_keywords):
            base_timeout = 300
        
        # WP特化の超長時間タスク
        if any(kw in text_content for kw in wp_long_task_keywords):
            base_timeout = 600  # 10分
            logger.info(f"🌐 wp-agent ⏱️ INFO WP長時間処理を検出 - タイムアウト: {base_timeout}秒")
        
        return base_timeout
    
    async def cleanup(self):
        """WordPressセッションをクリーンアップ"""
        if self.wp_page:
            try:
                await self.wp_page.close()
                logger.info("🌐 wp-agent ✅ INFO WordPressセッションを終了しました")
            except Exception as e:
                logger.warning(f"🌐 wp-agent ⚠️ WARN WordPressページクローズエラー: {e}")

#wp_auth.py
"""WordPress認証・ログイン管理（完全修正版 - クッキー強制ナビゲーション対応）"""
import asyncio
import logging
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressAuth:
    """WordPress認証管理（BrowserController統合版 + クッキー強制ナビゲーション対応）"""
    
    def __init__(self, browser_controller, wp_url: str, wp_user: str, wp_pass: str):
        """
        初期化
        
        Args:
            browser_controller: BrowserController インスタンス
            wp_url: WordPress サイトURL
            wp_user: ユーザー名
            wp_pass: パスワード
        """
        self.browser = browser_controller
        self.wp_url = wp_url.rstrip('/')
        self.wp_user = wp_user
        self.wp_pass = wp_pass
    
    async def login(self, page: Page) -> bool:
        """
        WordPressにログイン（クッキー優先 + 強制ナビゲーション版）
        
        改善点:
        1. クッキー適用後に必ず管理画面URLへナビゲーション
        2. ログイン状態検証の厳格化
        3. 失敗時のフォールバック強化
        
        Args:
            page: Playwright Page オブジェクト
            
        Returns:
            bool: ログイン成功時 True
        """
        try:
            logger.info("="*60)
            logger.info("WordPress: ログイン開始（クッキー優先 + 強制ナビゲーション）")
            logger.info(f"URL: {self.wp_url}")
            logger.info("="*60)
            
            # ✅ Phase 1: クッキーでのログインを試行
            cookies_loaded = await self.browser.load_wordpress_cookies(self.wp_url)
            
            if cookies_loaded:
                logger.info("✅ WordPress クッキーを読み込みました")
                
                # ✅ 重要: クッキー適用後に管理画面に強制ナビゲーション
                admin_url = f"{self.wp_url}/wp-admin/"
                logger.info(f"🔄 管理画面にナビゲーション中: {admin_url}")
                
                try:
                    await page.goto(admin_url, timeout=30000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)  # セッション確立を待機
                    
                    # ✅ Phase 2: ログイン状態を厳格に検証
                    if await self._verify_login_status(page):
                        logger.info("✅ クッキー認証成功 - 既にログイン済み")
                        
                        # スクリーンショット保存
                        screenshot_path = f"wp_cookie_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                        await page.screenshot(path=screenshot_path)
                        logger.info(f"📸 クッキーログイン成功: {screenshot_path}")
                        
                        return True
                    else:
                        logger.warning("⚠️ クッキー認証失敗 - 手動ログインを実行します")
                        
                except Exception as nav_error:
                    logger.warning(f"⚠️ 管理画面ナビゲーションエラー: {nav_error}")
            
            # ✅ Phase 3: クッキー認証が失敗した場合は手動ログイン
            return await self.manual_login(page)
                
        except Exception as e:
            logger.error(f"❌ ログインエラー: {e}")
            # フォールバック: 手動ログイン
            return await self.manual_login(page)
    
    async def manual_login(self, page: Page) -> bool:
        """
        手動ログイン（ユーザー名/パスワード方式）
        
        Args:
            page: Playwright Page オブジェクト
            
        Returns:
            bool: ログイン成功時 True
        """
        try:
            logger.info("🔐 手動ログインを実行します")
            
            # ログインページに移動
            login_url = f"{self.wp_url}/wp-login.php"
            await page.goto(login_url, timeout=30000, wait_until="domcontentloaded")
            await asyncio.sleep(2)
            
            # ユーザー名入力
            user_field = await page.query_selector('#user_login')
            if not user_field:
                logger.error("❌ ユーザー名入力フィールドが見つかりません")
                return False
            
            await user_field.fill(self.wp_user)
            await asyncio.sleep(0.5)
            logger.info("✅ ユーザー名入力完了")
            
            # パスワード入力
            pass_field = await page.query_selector('#user_pass')
            if not pass_field:
                logger.error("❌ パスワード入力フィールドが見つかりません")
                return False
            
            await pass_field.fill(self.wp_pass)
            await asyncio.sleep(0.5)
            logger.info("✅ パスワード入力完了")
            
            # ログインボタンをクリック
            login_button = await page.query_selector('#wp-submit')
            if not login_button:
                logger.error("❌ ログインボタンが見つかりません")
                return False
            
            await login_button.click()
            await asyncio.sleep(5)
            logger.info("✅ ログインボタンをクリックしました")
            
            # ログイン成功確認
            if await self._verify_login_status(page):
                logger.info("✅ WordPress手動ログイン成功")
                
                # ✅ ログイン成功時にクッキーを保存
                await self.browser.save_wordpress_cookies(self.wp_url)
                
                # スクリーンショット保存
                screenshot_path = f"wp_manual_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                logger.info(f"📸 手動ログイン成功: {screenshot_path}")
                
                return True
            else:
                logger.error("❌ WordPressログイン失敗")
                
                # 失敗時のスクリーンショット
                await page.screenshot(path="wp_login_failed.png")
                
                # エラーメッセージの確認
                error_element = await page.query_selector('#login_error')
                if error_element:
                    error_text = await error_element.text_content()
                    logger.error(f"ログインエラーメッセージ: {error_text}")
                
                return False
                
        except Exception as e:
            logger.error(f"❌ 手動ログインエラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _verify_login_status(self, page: Page) -> bool:
        """
        WordPressログイン状態を詳細検証（厳格版）
        
        改善点:
        1. URL確認を最優先
        2. 4つのチェックのうち3つ以上で合格判定
        3. 各チェック結果を詳細にログ出力
        
        Args:
            page: Playwright Page オブジェクト
            
        Returns:
            bool: ログイン済みの場合 True
        """
        try:
            checks = []
            
            # ✅ 1. URL確認（最優先）
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('管理ページURL', is_admin_page))
            
            # ✅ 2. 管理バーの存在チェック
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('管理バー', bool(admin_bar)))
            
            # ✅ 3. ダッシュボード要素チェック
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ダッシュボード', bool(dashboard)))
            
            # ✅ 4. ログインフォームの不在チェック
            login_form = await page.query_selector('#loginform')
            checks.append(('ログインフォーム不在', not bool(login_form)))
            
            # 結果の集計
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
            
            logger.info(f"🔍 ログイン状態検証: {total_passed}/4 合格")
            
            # ✅ 詳細ログ出力
            for name, passed in checks:
                status = "✅" if passed else "❌"
                logger.info(f"  {status} {name}")
            
            if total_passed >= 3:  # 4つのうち3つ以上合格ならログイン成功
                logger.info(f"  ✅ 合格項目: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  ❌ 不合格が多すぎます（合格: {total_passed}/4）")
                logger.warning(f"  現在URL: {current_url}")
                return False
                
        except Exception as e:
            logger.warning(f"⚠️ ログイン状態検証エラー: {e}")
            return False

#wp_cpt_agent.py
"""
WordPressカスタム投稿タイプ作成エージェント
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """カスタム投稿タイプ作成専門エージェント"""
    
    PROMPT_TEMPLATE = """あなたはWordPress開発の専門家です。

【タスク】
以下の仕様でカスタム投稿タイプを作成するPHPコードを生成してください：

{cpt_spec}

【出力要件】
1. 完全に動作するPHPコード
2. register_post_type() を使用
3. 多言語対応（Polylang互換）
4. エラーハンドリング付き
5. コメント付き

【出力形式】
```php
<?php
/**
 * カスタム投稿タイプ: {cpt_name}
 * 作成日: {date}
 */

function register_cpt_{cpt_slug}() {{
    // コード実装
}}
add_action('init', 'register_cpt_{cpt_slug}', 0);
完全なPHPコードを出力してください。
"""
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder

    async def execute(self, task: Dict) -> Dict:
        """CPT作成タスクを実行"""
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '')
        
        try:
            logger.info("🔧 カスタム投稿タイプ作成開始")
            
            # CPT仕様を抽出
            cpt_spec = self._extract_cpt_spec(description)
            
            # プロンプト構築
            prompt = self.PROMPT_TEMPLATE.format(
                cpt_spec=cpt_spec,
                cpt_name=cpt_spec.get('name', 'N/A'),
                cpt_slug=cpt_spec.get('slug', 'custom_post'),
                date=datetime.now().strftime('%Y-%m-%d')
            )
            
            # プロンプト送信
            await self.browser.send_prompt(prompt)
            
            # 応答待機
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                return {'success': False, 'error': 'タイムアウト'}
            
            # 応答取得
            response_text = await self.browser.extract_latest_text_response()
            
            # PHP保存
            output_file = await self._save_php_code(response_text, cpt_spec['slug'], task_id)
            
            return {
                'success': True,
                'message': f'CPT作成完了: {cpt_spec["slug"]}',
                'output_file': str(output_file),
                'cpt_slug': cpt_spec['slug'],
                'task_id': task_id
            }
            
        except Exception as e:
            logger.error(f"❌ CPT作成エラー: {e}")
            return {'success': False, 'error': str(e), 'task_id': task_id}

    def _extract_cpt_spec(self, description: str) -> Dict:
        """説明からCPT仕様を抽出"""
        # M&A案件の場合
        if 'ma_case' in description.lower() or 'm&a案件' in description:
            return {
                'slug': 'ma_case',
                'name': 'M&A案件',
                'singular': 'M&A案件',
                'plural': 'M&A案件一覧'
            }
        
        # デフォルト
        return {
            'slug': 'custom_post',
            'name': 'カスタム投稿',
            'singular': 'カスタム投稿',
            'plural': 'カスタム投稿一覧'
        }

    async def _save_php_code(self, code: str, slug: str, task_id: str) -> Path:
        """PHPコードを保存"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"cpt_{slug}_{task_id}_{timestamp}.php"
        output_path = self.output_folder / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        logger.info(f"✅ PHP保存: {filename}")
        return output_path

#### 3-3. `wordpress/wp_dev/wp_taxonomy_agent.py`
"""
WordPressタクソノミー作成エージェント
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressTaxonomyAgent:
    """タクソノミー作成専門エージェント"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """タクソノミー作成タスクを実行"""
        # 実装（wp_cpt_agent.py と同様のパターン）
        return {
            'success': True,
            'message': 'タクソノミー作成完了（実装中）',
            'task_id': task.get('task_id')
        }

#wp_design.py
# wp_design.py
"""
WordPress設計・開発タスク実行モジュール
task_executor.py の WordPress 専用メソッドを提供
"""

import asyncio
import logging
from typing import Dict, Any, Optional

# ロガーの設定
logger = logging.getLogger(__name__)

# グローバルフラグ（実際の実装では適切に設定されるべき）
HAS_TASK_ROUTER = False
HAS_ENHANCED_HANDLER = False

# ダミークラス定義（実際の実装では適切なクラスをインポート）
class EnhancedErrorHandler:
    @staticmethod
    async def timeout_wrapper(coro, timeout, context):
        return await asyncio.wait_for(coro, timeout=timeout)
    
    @staticmethod
    def log_error_with_context(e, context):
        logger.error(f"{context}: {e}")

class ErrorHandler:
    @staticmethod
    def log_error(e, context):
        logger.error(f"{context}: {e}")

class TaskRouter:
    @staticmethod
    def determine_task_type(task):
        return task.get('task_type', 'default')

# グローバルインスタンス
task_router = TaskRouter() if HAS_TASK_ROUTER else None


class WordPressTaskExecutor:
    """
    WordPress専用タスク実行クラス
    """
    
    def __init__(self, agents=None, ma_executor=None, content_executor=None, review_agent=None):
        """初期化"""
        self.agents = agents or {}
        self.ma_executor = ma_executor
        self.content_executor = content_executor
        self.review_agent = review_agent
        
        logger.info("✅ WordPressTaskExecutor 初期化完了")
    
    async def execute_task(self, task: Dict) -> bool:
        """単一タスクを実行（WordPress専用エージェント対応版）"""
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # ============================================================
            # === パート1: タスク開始ヘッダー表示 ===
            # ============================================================
            print("\n" + "📷"*40)
            print("=" * 80)
            print(f"🎯 タスク開始: {task_id}")
            print("=" * 80)
            print(f"📝 内容: {task['description'][:70]}...")
            print(f"👤 担当エージェント: {task['required_role'].upper()}")
            
            print("=" * 80)
            print("📷"*40 + "\n")
            
            logger.info(f"タスク {task_id} 実行開始")
            
            # タスクのステータスを'in_progress'に更新
            try:
                await self.update_task_status(task, 'in_progress')
            except Exception as e:
                logger.warning(f"⚠️ ステータス更新失敗（続行）: {e}")
            
            # ============================================================
            # === パート2: タスクタイプ判定とタイムアウト設定 ===
            # ============================================================
            role = task['required_role'].lower()
            
            # タイムアウトマップ
            timeout_map = {
                'ma': 300.0,
                'content': 240.0,
                'review': 180.0,
                'wordpress': 300.0,
                'wp_design': 300.0,  # WordPress設計
                'wp_dev': 300.0,     # WordPress開発
                'default': 180.0
            }
            
            # タスクタイプを取得
            task_type = 'default'
            if HAS_TASK_ROUTER and task_router:
                try:
                    task_type = task_router.determine_task_type(task)
                    logger.info(f"📊 タスクタイプ判定: {task_type}")
                except Exception as e:
                    logger.warning(f"⚠️ タスクタイプ判定失敗、デフォルト処理: {e}")
            
            task_timeout = timeout_map.get(task_type, timeout_map.get(role, 180.0))
            
            # ============================================================
            # === パート3: タスク実行（エージェント振り分け） ===
            # ============================================================
            result = None
            
            try:
                # --- 3-1: WordPress専用エージェント判定（最優先） ---
                if role == 'wp_design':
                    logger.info("="*60)
                    logger.info("🎨 WordPress設計AIエージェント実行中")
                    logger.info("="*60)
                    task_coro = self._execute_wp_design_task(task)
                
                elif role == 'wp_dev':
                    logger.info("="*60)
                    logger.info("💻 WordPress開発AIエージェント実行中")
                    logger.info("="*60)
                    task_coro = self._execute_wp_dev_task(task)
                
                # --- 3-2: タスクタイプベースの分岐 ---
                elif task_type == 'ma' and self.ma_executor:
                    logger.info("="*60)
                    logger.info("📊 M&A/企業検索タスクとして処理")
                    logger.info("="*60)
                    task_coro = self.ma_executor.execute_ma_task(task)
                
                elif task_type == 'content' and self.content_executor:
                    logger.info("="*60)
                    logger.info("✏️ 記事生成タスクとして処理")
                    logger.info("="*60)
                    task_coro = self.content_executor.execute_writer_task(task, role)
                
                elif task_type == 'review':
                    logger.info("="*60)
                    logger.info("✅ レビュータスクとして処理")
                    logger.info("="*60)
                    task_coro = self._execute_review_task(task)
                
                # --- 3-3: デフォルトのロール分岐 ---
                else:
                    logger.info("="*60)
                    logger.info(f"📋 デフォルトタスク ({role}) として処理")
                    logger.info("="*60)
                    
                    if role == 'design':
                        task_coro = self._execute_design_task(task)
                    elif role == 'dev':
                        task_coro = self._execute_dev_task(task)
                    elif role == 'ui':
                        task_coro = self._execute_ui_task(task)
                    elif role == 'wordpress':
                        task_coro = self._execute_wordpress_task(task)
                    elif role == 'plugin':
                        task_coro = self._execute_plugin_task(task)
                    else:
                        # 未登録エージェント
                        agent = self.agents.get(role)
                        if not agent:
                            logger.warning(f"担当エージェント '{role}' が見つかりません - スキップします")
                            await self.update_task_status(task, 'skipped', error=f"エージェント未登録")
                            return False
                        task_coro = agent.process_task(task)
                
                # --- 3-4: タイムアウト付きで実行 ---
                if HAS_ENHANCED_HANDLER:
                    result = await EnhancedErrorHandler.timeout_wrapper(
                        task_coro,
                        timeout=task_timeout,
                        context=f"タスク {task_id} 実行"
                    )
                else:
                    result = await asyncio.wait_for(task_coro, timeout=task_timeout)
            
            # ============================================================
            # === パート4: タイムアウトエラーハンドリング ===
            # ============================================================
            except asyncio.TimeoutError:
                logger.error("="*60)
                logger.error(f"⏱️ タスク {task_id} タイムアウト（{task_timeout}秒）")
                logger.error("="*60)
                
                await self.update_task_status(
                    task, 
                    'failed', 
                    error=f'タイムアウト（{task_timeout}秒）'
                )
                
                print("\n" + "📷"*40)
                print("=" * 80)
                print(f"⏱️ タスクタイムアウト: {task_id}")
                print(f"制限時間: {task_timeout}秒")
                print("=" * 80)
                print("📷"*40 + "\n")
                
                return False
            
            # ============================================================
            # === パート5: 一般的な例外ハンドリング ===
            # ============================================================
            except Exception as e:
                logger.error("="*60)
                logger.error(f"❌ タスク {task_id} 実行中に例外発生")
                logger.error(f"エラー: {str(e)}")
                logger.error("="*60)
                
                if HAS_ENHANCED_HANDLER:
                    EnhancedErrorHandler.log_error_with_context(
                        e, 
                        f"タスク {task_id} 実行"
                    )
                
                await self.update_task_status(task, 'failed', error=str(e))
                
                print("\n" + "📷"*40)
                print("=" * 80)
                print(f"💥 タスク例外: {task_id}")
                print(f"例外: {str(e)}")
                print("=" * 80)
                print("📷"*40 + "\n")
                
                return False
            
            # ============================================================
            # === パート6: 実行結果の処理（成功時） ===
            # ============================================================
            if result and result.get('success'):
                logger.info("="*60)
                logger.info(f"✅ タスク {task_id} 実行成功")
                logger.info("="*60)
                
                # --- 6-1: 結果保存 ---
                try:
                    await self.update_task_status(task, 'completed')
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"⚠️ 結果保存失敗（タスク自体は成功）: {e}")
                
                # --- 6-2: レビューAIでチェック ---
                if self.review_agent and role != 'review' and task_type != 'review':
                    try:
                        logger.info("="*60)
                        logger.info("✅ レビューAIでチェックを開始")
                        logger.info("="*60)
                        
                        if HAS_ENHANCED_HANDLER:
                            await EnhancedErrorHandler.timeout_wrapper(
                                self.perform_review_and_add_tasks(task, result),
                                timeout=120.0,
                                context=f"レビュー（タスク {task_id}）"
                            )
                        else:
                            await asyncio.wait_for(
                                self.perform_review_and_add_tasks(task, result),
                                timeout=120.0
                            )
                    except Exception as e:
                        logger.warning(f"⚠️ レビュー失敗（無視）: {e}")
                
                # --- 6-3: 成功メッセージ表示 ---
                print("\n" + "📷"*40)
                print("=" * 80)
                print(f"✅ タスク完了: {task_id}")
                print(f"タイプ: {task_type.upper()}")
                print(f"ステータス: 成功")
                print("=" * 80)
                print("📷"*40 + "\n")
                
                return True
            
            # ============================================================
            # === パート7: 実行結果の処理（失敗時） ===
            # ============================================================
            else:
                error_msg = result.get('error', '不明') if result else '結果なし'
                logger.error("="*60)
                logger.error(f"❌ タスク {task_id} 実行失敗")
                logger.error(f"エラー: {error_msg}")
                logger.error("="*60)
                
                await self.update_task_status(task, 'failed', error=error_msg)
                
                print("\n" + "📷"*40)
                print("=" * 80)
                print(f"❌ タスク失敗: {task_id}")
                print(f"タイプ: {task_type.upper()}")
                print(f"エラー: {error_msg}")
                print("=" * 80)
                print("📷"*40 + "\n")
                
                return False
        
        # ============================================================
        # === パート8: 最外層の例外ハンドリング ===
        # ============================================================
        except Exception as e:
            logger.error(f"❌ タスク {task_id} 処理全体で予期しないエラー")
            
            if HAS_ENHANCED_HANDLER:
                EnhancedErrorHandler.log_error_with_context(
                    e, 
                    f"タスク {task_id} 全体処理"
                )
            else:
                ErrorHandler.log_error(e, f"タスク {task_id} 実行")
            
            try:
                await self.update_task_status(task, 'failed', error=str(e))
            except:
                pass
            
            print("\n" + "📷"*40)
            print("=" * 80)
            print(f"💥 タスク重大エラー: {task_id}")
            print(f"例外: {str(e)}")
            print("=" * 80)
            print("📷"*40 + "\n")
            
            return False

    async def _execute_wp_design_task(self, task: Dict) -> Dict:
        """WordPress設計タスクを実行"""
        logger.info("┌" + "─"*58 + "┐")
        logger.info("│ 🎨 WordPress設計AIエージェント実行中")
        logger.info("├" + "─"*58 + "┤")
        logger.info(f"│ タスク: {task.get('description', 'N/A')[:50]}")
        logger.info("└" + "─"*58 + "┘")
        
        try:
            # === パート1: エージェント取得 ===
            agent = self.agents.get('wp_design')
            if not agent:
                logger.error("❌ WordPress設計AIエージェントが登録されていません")
                return {
                    'success': False,
                    'error': 'wp_design エージェントが登録されていません'
                }

            # === パート2: タスク実行 ===
            result = await agent.process_task(task)
            
            # === パート3: 結果ログ出力 ===
            if result.get('success'):
                logger.info("✅ WordPress設計AI: タスク完了")
            else:
                logger.error(f"❌ WordPress設計AI: 失敗 - {result.get('error', '不明')}")
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPress設計タスク実行")
            logger.error(f"❌ WordPress設計AIエージェント: 例外発生 - {str(e)}")
            return {
                'success': False,
                'error': f'WordPress設計タスク実行エラー: {str(e)}'
            }

    async def _execute_wp_dev_task(self, task: Dict) -> Dict:
        """WordPress開発タスクを実行"""
        logger.info("┌" + "─"*58 + "┐")
        logger.info("│ 💻 WordPress開発AIエージェント実行中")
        logger.info("├" + "─"*58 + "┤")
        logger.info(f"│ タスク: {task.get('description', 'N/A')[:50]}")
        logger.info("└" + "─"*58 + "┘")
        
        try:
            # === パート1: エージェント取得 ===
            agent = self.agents.get('wp_dev')
            if not agent:
                logger.error("❌ WordPress開発AIエージェントが登録されていません")
                return {
                    'success': False,
                    'error': 'wp_dev エージェントが登録されていません'
                }
            
            # === パート2: タスク実行 ===
            result = await agent.process_task(task)
            
            # === パート3: 結果ログ出力 ===
            if result.get('success'):
                logger.info("✅ WordPress開発AI: タスク完了")
            else:
                logger.error(f"❌ WordPress開発AI: 失敗 - {result.get('error', '不明')}")
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPress開発タスク実行")
            logger.error(f"❌ WordPress開発AIエージェント: 例外発生 - {str(e)}")
            return {
                'success': False,
                'error': f'WordPress開発タスク実行エラー: {str(e)}'
            }

    # スタブメソッド（実際の実装では適切に定義）
    async def update_task_status(self, task: Dict, status: str, error: Optional[str] = None):
        """タスクステータスを更新"""
        logger.info(f"タスク {task.get('task_id')} ステータスを {status} に更新")
        if error:
            logger.info(f"エラー: {error}")

    async def save_task_output(self, task: Dict, result: Dict):
        """タスク出力を保存"""
        logger.info(f"タスク {task.get('task_id')} の結果を保存")

    async def perform_review_and_add_tasks(self, task: Dict, result: Dict):
        """レビューを実行してタスクを追加"""
        logger.info(f"タスク {task.get('task_id')} のレビューを実行")

    async def _execute_review_task(self, task: Dict) -> Dict:
        """レビュータスクを実行"""
        return {'success': True}

    async def _execute_design_task(self, task: Dict) -> Dict:
        """デザインタスクを実行"""
        return {'success': True}

    async def _execute_dev_task(self, task: Dict) -> Dict:
        """開発タスクを実行"""
        return {'success': True}

    async def _execute_ui_task(self, task: Dict) -> Dict:
        """UIタスクを実行"""
        return {'success': True}

    async def _execute_wordpress_task(self, task: Dict) -> Dict:
        """WordPressタスクを実行"""
        return {'success': True}

    async def _execute_plugin_task(self, task: Dict) -> Dict:
        """プラグインタスクを実行"""
        return {'success': True}


# 使用例
async def main():
    """テスト用のメイン関数"""
    executor = WordPressTaskExecutor()
    
    # テストタスク
    test_task = {
        'task_id': 'TEST_001',
        'description': 'WordPressサイトのデザイン作成',
        'required_role': 'wp_design'
    }
    
    result = await executor.execute_task(test_task)
    print(f"タスク実行結果: {result}")


if __name__ == "__main__":
    # テスト実行
    asyncio.run(main())

#wp_dev.py
"""
WordPress開発タスクルーター（完全動作版）
"""

import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class WordPressDevAgent:
    """WordPress開発タスクルーター（完全動作版）"""
    
    def __init__(self, browser, output_folder: Path = None):
        self.browser = browser
        self.output_folder = output_folder or Path('./outputs/wordpress')
        self.output_folder.mkdir(parents=True, exist_ok=True)
        
        # 専門エージェントの初期化
        self._init_specialized_agents()
        
        logger.info("✅ WordPressDevAgent 初期化完了")
    
    def _init_specialized_agents(self):
        """専門エージェントを初期化"""
        try:
            from wordpress.wp_dev import (
                WordPressRequirementsAgent,
                WordPressCPTAgent,
                WordPressTaxonomyAgent,
                WordPressACFAgent
            )
            
            self.requirements_agent = WordPressRequirementsAgent(
                self.browser, 
                self.output_folder
            )
            self.cpt_agent = WordPressCPTAgent(self.browser, self.output_folder)
            self.taxonomy_agent = WordPressTaxonomyAgent(self.browser, self.output_folder)
            self.acf_agent = WordPressACFAgent(self.browser, self.output_folder)
            
            logger.info("✅ 専門エージェント初期化完了")
            
        except ImportError as e:
            logger.warning(f"⚠️ インポートエラー: {e}")
            self.requirements_agent = None
            self.cpt_agent = None
            self.taxonomy_agent = None
            self.acf_agent = None
    
    async def execute(self, task: Dict) -> Dict:
        """
        execute メソッド（必須）
        他のエージェントとの互換性のため
        """
        return await self.process_task(task)
    
    async def process_task(self, task: Dict) -> Dict:
        """
        process_task メソッド（必須）
        実際のタスク処理
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            logger.info(f"🔧 WordPress開発タスク: {task_id}")
            
            # タスクタイプを判定
            task_type = self._determine_task_type(description)
            logger.info(f"📊 タスクタイプ: {task_type}")
            
            # エージェントに振り分け
            if task_type == 'requirements':
                if self.requirements_agent:
                    return await self.requirements_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'cpt':
                if self.cpt_agent:
                    return await self.cpt_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'taxonomy':
                if self.taxonomy_agent:
                    return await self.taxonomy_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'acf':
                if self.acf_agent:
                    return await self.acf_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            else:
                # フォールバック
                return await self._fallback_execution(task)
        
        except Exception as e:
            logger.error(f"❌ エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return {
                'success': False,
                'error': str(e),
                'task_id': task_id
            }
    
    def _determine_task_type(self, description: str) -> str:
        """タスクタイプ判定（柔軟版）"""
        # 要件定義（デフォルト）
        requirements_patterns = [
            '要件定義', 'requirements', '仕様書', '設計書',
            'ポータル', 'cocoon', 'polylang', '多言語',
            'm&a', 'ウズベキスタン', 'wordpress'
        ]
        
        if any(kw in description for kw in requirements_patterns):
            return 'requirements'
        
        # CPT
        if any(kw in description for kw in ['cpt', 'custom post type', 'カスタム投稿', 'ma_case']):
            return 'cpt'
        
        # タクソノミー
        if any(kw in description for kw in ['taxonomy', 'タクソノミー', 'カテゴリ', 'industry']):
            return 'taxonomy'
        
        # ACF
        if any(kw in description for kw in ['acf', 'advanced custom fields', 'カスタムフィールド']):
            return 'acf'
        
        # デフォルト
        return 'requirements'
    
    async def _fallback_execution(self, task: Dict) -> Dict:
        """フォールバック実行"""
        logger.warning("⚠️ エージェント不在 - Geminiで直接実行")
        
        try:
            prompt = f"""WordPressタスクを実行してください：

{task.get('description', '')}

簡潔に実装方法を説明してください。"""
            
            await self.browser.send_prompt(prompt)
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if success:
                response = await self.browser.extract_latest_text_response()
                return {
                    'success': True,
                    'message': 'フォールバック実行完了',
                    'summary': response[:300] if response else 'N/A',
                    'full_text': response or ''
                }
            else:
                return {
                    'success': False,
                    'error': 'タイムアウト'
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

#wp_plugin_manager.py
"""wp_plugin_manager.py - WordPressプラグイン管理"""
import logging
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

logger = logging.getLogger(__name__)


class PluginNameExtractor:
    """プラグイン名抽出ユーティリティ"""
    
    @staticmethod
    def extract(description: str) -> str:
        """タスク説明からプラグイン名を抽出"""
        # シンプルな抽出ロジック - 実際の要件に応じて拡張
        import re
        patterns = [
            r'プラグイン[「"](.+?)[」"]',
            r'plugin[「"](.+?)[」"]',
            r'install[\s\w]+\s(.+?)\s',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                return match.group(1).strip()
        
        # 見つからない場合は説明文の最初の数単語を使用
        return description.split()[0] if description else "unknown_plugin"


class WordPressPluginManager:
    """WordPressプラグイン管理機能（最適化版）"""

    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        初期化
        
        Args:
            browser_controller: BrowserController インスタンス
            wp_credentials: WordPress 認証情報
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        
        logger.info(f"WordPressPluginManager 初期化: {self.wp_url}")

    async def install_plugin(self, page: Page, task: Dict) -> Dict:
        """プラグインをインストールして有効化"""
        try:
            plugin_name = PluginNameExtractor.extract(task['description'])
            logger.info(f"プラグインインストール開始: {plugin_name}")
            
            # プラグインページに移動
            await page.goto(f"{self.wp_url}/wp-admin/plugin-install.php")
            await page.wait_for_timeout(2000)
            
            # プラグイン検索とインストール実行
            search_success = await self._search_plugin(page, plugin_name)
            if not search_success:
                return {
                    'success': False,
                    'error': 'プラグイン検索に失敗しました'
                }
            
            # インストールと有効化
            installed, status = await self._install_and_activate(page)
            
            # 結果記録
            screenshot_path = f"wp_plugin_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            if installed:
                return self._build_success_result(plugin_name, status, screenshot_path)
            else:
                return self._build_manual_result(plugin_name, screenshot_path)
                
        except Exception as e:
            logger.error(f"プラグインインストールエラー: {e}")
            return self._build_error_result(str(e))

    async def _search_plugin(self, page: Page, plugin_name: str) -> bool:
        """プラグインを検索"""
        search_box = await page.query_selector('#search-plugins')
        if not search_box:
            return False
            
        await search_box.fill(plugin_name)
        await page.keyboard.press('Enter')
        await page.wait_for_timeout(4000)
        
        logger.info(f"プラグイン検索完了: {plugin_name}")
        return True

    async def _install_and_activate(self, page: Page) -> tuple[bool, str]:
        """プラグインをインストール・有効化"""
        install_selectors = [
            'a.install-now:has-text("今すぐインストール")',
            '.plugin-card-top a.install-now',
            'a[data-slug]:has-text("今すぐインストール")',
        ]
        
        for selector in install_selectors:
            try:
                install_button = await page.query_selector(selector)
                if install_button and await install_button.is_visible():
                    logger.info(f"インストールボタンをクリック: {selector}")
                    await install_button.click()
                    await page.wait_for_timeout(5000)
                    
                    # 有効化処理
                    return await self._activate_plugin(page)
            except Exception as e:
                logger.warning(f"インストール試行エラー ({selector}): {e}")
                continue
        
        return False, "インストール失敗"

    async def _activate_plugin(self, page: Page) -> tuple[bool, str]:
        """プラグインを有効化"""
        activate_button = await page.query_selector('a:has-text("有効化")')
        if activate_button:
            logger.info("有効化ボタンをクリック")
            await activate_button.click()
            await page.wait_for_timeout(3000)
            logger.info("✅ プラグインのインストールと有効化が完了しました")
            return True, "インストール・有効化完了"
        else:
            logger.info("✅ プラグインのインストールが完了しました(有効化は手動)")
            return True, "インストール完了(有効化は手動で実施してください)"

    async def change_plugin_settings(self, page: Page, task: Dict) -> Dict:
        """プラグイン設定を変更"""
        try:
            plugin_name = PluginNameExtractor.extract(task['description'])
            logger.info(f"プラグイン設定変更: {plugin_name}")
            
            await page.goto(f"{self.wp_url}/wp-admin/plugins.php")
            await page.wait_for_timeout(3000)
            
            settings_found = await self._navigate_to_settings(page, plugin_name)
            screenshot_path = f"wp_plugin_settings_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            if settings_found:
                return self._build_settings_success_result(plugin_name, screenshot_path)
            else:
                return self._build_settings_error_result(plugin_name, screenshot_path)
                
        except Exception as e:
            logger.error(f"プラグイン設定変更エラー: {e}")
            return self._build_error_result(str(e))

    async def _navigate_to_settings(self, page: Page, plugin_name: str) -> bool:
        """プラグイン設定画面へ移動"""
        settings_selectors = [
            f'tr:has-text("{plugin_name}") .settings a',
            f'a:has-text("{plugin_name}設定")',
            '.plugin-action-buttons a:has-text("設定")'
        ]
        
        for selector in settings_selectors:
            try:
                settings_link = await page.query_selector(selector)
                if settings_link and await settings_link.is_visible():
                    await settings_link.click()
                    await page.wait_for_timeout(3000)
                    logger.info(f"✅ {plugin_name}の設定画面を開きました")
                    return True
            except Exception:
                continue
        
        return False

    # === 主要プラグイン設定機能 ===

    async def configure_facetwp(self, page: Page, task_params: Dict) -> Dict:
        """FacetWP 絞り込み検索の設定"""
        try:
            facets = task_params.get('facets', [])
            logger.info(f"FacetWP設定開始: {len(facets)}件のファセット")
            
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=facetwp-settings")
            await page.wait_for_timeout(3000)
            
            created_facets = await self._create_facets(page, facets)
            screenshot_path = f"facetwp_setup_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_facetwp_result(created_facets, facets, screenshot_path)
            
        except Exception as e:
            logger.error(f"FacetWP設定エラー: {e}")
            return self._build_error_result(str(e))

    async def _create_facets(self, page: Page, facets: List[Dict]) -> List[str]:
        """ファセットを作成"""
        created_facets = []
        
        for i, facet in enumerate(facets, 1):
            try:
                logger.info(f"ファセット {i}/{len(facets)}: {facet.get('name')}")
                
                # 新規ファセット追加
                if await self._click_add_new_facet(page):
                    # ファセット設定
                    if await self._configure_facet_fields(page, facet):
                        # 保存
                        if await self._save_facet(page):
                            created_facets.append(facet.get('name'))
                            logger.info(f"✅ ファセット '{facet.get('name')}' を保存")
                            
                await page.wait_for_timeout(1000)
                
            except Exception as e:
                logger.warning(f"⚠️ ファセット {i} 作成エラー: {e}")
                continue
                
        return created_facets

    async def _click_add_new_facet(self, page: Page) -> bool:
        """新規ファセット追加ボタンをクリック"""
        add_new_selectors = [
            'a.facetwp-add:has-text("Add New")',
            'button:has-text("Add New")',
            '.facetwp-add-facet'
        ]
        
        for selector in add_new_selectors:
            try:
                add_button = await page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await page.wait_for_timeout(1500)
                    return True
            except Exception:
                continue
        return False

    async def _configure_facet_fields(self, page: Page, facet: Dict) -> bool:
        """ファセットフィールドを設定"""
        try:
            # ファセット名
            name_input = await page.query_selector('input[name="facet_label"]')
            if name_input:
                await name_input.fill(facet.get('name', ''))
            
            # ファセットタイプ
            type_select = await page.query_selector('select[name="facet_type"]')
            if type_select:
                await type_select.select_option(facet.get('type', 'checkboxes'))
            
            # データソース
            source = facet.get('source', '')
            if source.startswith('tax/'):
                return await self._configure_taxonomy_source(page, source)
            elif source.startswith('cf/'):
                return await self._configure_custom_field_source(page, source)
            
            return True
        except Exception as e:
            logger.warning(f"ファセット設定エラー: {e}")
            return False

    async def _configure_taxonomy_source(self, page: Page, source: str) -> bool:
        """タクソノミーソースを設定"""
        try:
            taxonomy_name = source.replace('tax/', '')
            source_select = await page.query_selector('select[name="facet_source"]')
            if source_select:
                await source_select.select_option('tax')
                await page.wait_for_timeout(500)
            
            taxonomy_select = await page.query_selector('select[name="facet_source_taxonomy"]')
            if taxonomy_select:
                await taxonomy_select.select_option(taxonomy_name)
                logger.info(f"  ソース: Taxonomy - {taxonomy_name}")
                return True
        except Exception as e:
            logger.warning(f"タクソノミーソース設定エラー: {e}")
        return False

    async def _configure_custom_field_source(self, page: Page, source: str) -> bool:
        """カスタムフィールドソースを設定"""
        try:
            field_name = source.replace('cf/', '')
            source_select = await page.query_selector('select[name="facet_source"]')
            if source_select:
                await source_select.select_option('cf')
                await page.wait_for_timeout(500)
            
            field_input = await page.query_selector('input[name="facet_source_custom_field"]')
            if field_input:
                await field_input.fill(field_name)
                logger.info(f"  ソース: Custom Field - {field_name}")
                return True
        except Exception as e:
            logger.warning(f"カスタムフィールドソース設定エラー: {e}")
        return False

    async def _save_facet(self, page: Page) -> bool:
        """ファセットを保存"""
        save_selectors = [
            'button.facetwp-save:has-text("Save")',
            'button:has-text("Save Changes")',
            'input[type="submit"][value="Save"]'
        ]
        
        for selector in save_selectors:
            try:
                save_button = await page.query_selector(selector)
                if save_button and await save_button.is_visible():
                    await save_button.click()
                    await page.wait_for_timeout(2000)
                    return True
            except Exception:
                continue
        return False

    async def configure_user_roles(self, page: Page, task_params: Dict) -> Dict:
        """User Role Editorでカスタムロールを作成"""
        try:
            role_slug = task_params.get('role_slug')
            role_name = task_params.get('role_name')
            
            logger.info(f"ユーザーロール作成: {role_name}")
            
            await page.goto(f"{self.wp_url}/wp-admin/users.php?page=users-user-role-editor-php")
            await page.wait_for_timeout(3000)
            
            # ロール作成画面を開く
            if await self._open_add_role_dialog(page):
                # ロール情報入力
                await self._fill_role_info(page, role_slug, role_name)
                
                screenshot_path = f"user_role_{role_slug}_{datetime.now().strftime('%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                
                return self._build_user_role_result(role_name, role_slug, screenshot_path)
            else:
                return self._build_error_result("ロール追加ダイアログを開けませんでした")
                
        except Exception as e:
            logger.error(f"ユーザーロール作成エラー: {e}")
            return self._build_error_result(str(e))

    async def _open_add_role_dialog(self, page: Page) -> bool:
        """ロール追加ダイアログを開く"""
        add_role_selectors = [
            'button:has-text("Add Role")',
            'input[value="Add Role"]',
            '#ure_add_role_button'
        ]
        
        for selector in add_role_selectors:
            try:
                add_button = await page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await page.wait_for_timeout(2000)
                    return True
            except Exception:
                continue
        return False

    async def _fill_role_info(self, page: Page, role_slug: str, role_name: str):
        """ロール情報を入力"""
        slug_input = await page.query_selector('#user_role_id')
        if slug_input:
            await slug_input.fill(role_slug)
            logger.info(f"ロールスラッグを入力: {role_slug}")
        
        name_input = await page.query_selector('#user_role_name')
        if name_input:
            await name_input.fill(role_name)
            logger.info(f"ロール名を入力: {role_name}")

    async def configure_wordfence(self, page: Page, task_params: Dict) -> Dict:
        """Wordfence Security の基本設定"""
        try:
            logger.info("Wordfence Security設定開始")
            
            await page.goto(f"{self.wp_url}/wp-admin/admin.php?page=Wordfence")
            await page.wait_for_timeout(3000)
            
            screenshot_path = f"wordfence_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_wordfence_result(task_params, screenshot_path)
            
        except Exception as e:
            logger.error(f"Wordfence設定エラー: {e}")
            return self._build_error_result(str(e))

    async def configure_wp_rocket(self, page: Page, task_params: Dict) -> Dict:
        """WP Rocket キャッシュプラグインの設定"""
        try:
            logger.info("WP Rocket設定開始")
            
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=wprocket")
            await page.wait_for_timeout(3000)
            
            screenshot_path = f"wp_rocket_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_wp_rocket_result(screenshot_path)
            
        except Exception as e:
            logger.error(f"WP Rocket設定エラー: {e}")
            return self._build_error_result(str(e))

    async def configure_relevanssi(self, page: Page, task_params: Dict) -> Dict:
        """Relevanssi 高度な検索プラグインの設定"""
        try:
            logger.info("Relevanssi設定開始")
            
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=relevanssi/relevanssi.php")
            await page.wait_for_timeout(3000)
            
            screenshot_path = f"relevanssi_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_relevanssi_result(task_params, screenshot_path)
            
        except Exception as e:
            logger.error(f"Relevanssi設定エラー: {e}")
            return self._build_error_result(str(e))

    async def bulk_configure_plugins(self, page: Page, plugin_configs: List[Dict]) -> Dict:
        """複数のプラグインを一括で設定"""
        try:
            results = []
            
            for i, config in enumerate(plugin_configs, 1):
                plugin_name = config.get('plugin_name')
                logger.info(f"プラグイン設定 {i}/{len(plugin_configs)}: {plugin_name}")
                
                # プラグイン種別に応じて設定を実行
                result = await self._configure_single_plugin(page, config)
                results.append({'plugin': plugin_name, 'result': result})
            
            successful = sum(1 for r in results if r['result'].get('success'))
            
            return {
                'success': successful > 0,
                'summary': f'{successful}/{len(plugin_configs)}件のプラグイン設定を完了',
                'results': results
            }
            
        except Exception as e:
            logger.error(f"プラグイン一括設定エラー: {e}")
            return self._build_error_result(str(e))

    async def _configure_single_plugin(self, page: Page, config: Dict) -> Dict:
        """単一プラグインを設定"""
        plugin_name = config.get('plugin_name')
        
        plugin_handlers = {
            'facetwp': self.configure_facetwp,
            'user-role-editor': self.configure_user_roles,
            'wordfence': self.configure_wordfence,
            'wp-rocket': self.configure_wp_rocket,
            'relevanssi': self.configure_relevanssi,
        }
        
        handler = plugin_handlers.get(plugin_name)
        if handler:
            return await handler(page, config)
        else:
            return {'success': False, 'error': f'未対応のプラグイン: {plugin_name}'}

    # === 結果ビルダーメソッド ===

    def _build_success_result(self, plugin_name: str, status: str, screenshot_path: str) -> Dict:
        """成功結果を作成"""
        return {
            'success': True,
            'summary': f'プラグイン "{plugin_name}" を{status}',
            'screenshot': screenshot_path,
            'full_text': f'プラグイン処理完了\n名前: {plugin_name}\nステータス: {status}\nスクリーンショット: {screenshot_path}'
        }

    def _build_manual_result(self, plugin_name: str, screenshot_path: str) -> Dict:
        """手動確認が必要な結果を作成"""
        return {
            'success': True,
            'summary': f'プラグイン "{plugin_name}" を検索しました。手動でインストールを確認してください。',
            'screenshot': screenshot_path,
            'full_text': f'プラグイン検索: {plugin_name}\nスクリーンショット: {screenshot_path}\n※インストールボタンが見つからなかったため手動で実施してください'
        }

    def _build_error_result(self, error_message: str) -> Dict:
        """エラー結果を作成"""
        return {
            'success': False,
            'error': error_message
        }

    def _build_settings_success_result(self, plugin_name: str, screenshot_path: str) -> Dict:
        """設定成功結果を作成"""
        return {
            'success': True,
            'summary': f'プラグイン「{plugin_name}」の設定画面を開きました。手動で設定を確認してください。',
            'screenshot': screenshot_path,
            'full_text': f'プラグイン設定画面表示\nプラグイン: {plugin_name}\nスクリーンショット: {screenshot_path}\n※設定変更は手動で実施してください'
        }

    def _build_settings_error_result(self, plugin_name: str, screenshot_path: str) -> Dict:
        """設定エラー結果を作成"""
        return {
            'success': False,
            'error': f'プラグイン「{plugin_name}」の設定画面が見つかりませんでした',
            'screenshot': screenshot_path
        }

    def _build_facetwp_result(self, created_facets: List[str], facets: List[Dict], screenshot_path: str) -> Dict:
        """FacetWP設定結果を作成"""
        summary_lines = ["【FacetWP設定完了】"]
        summary_lines.append(f"作成成功: {len(created_facets)}/{len(facets)}件")
        for name in created_facets:
            summary_lines.append(f"  ✓ {name}")
            
        if len(created_facets) < len(facets):
            summary_lines.append("\n⚠️ 一部のファセットは手動で確認が必要です")
            
        summary = '\n'.join(summary_lines)
        
        return {
            'success': len(created_facets) > 0,
            'summary': summary,
            'facets_created': created_facets,
            'facets_count': len(facets),
            'screenshot': screenshot_path,
            'full_text': f'{summary}\nスクリーンショット: {screenshot_path}'
        }

    def _build_user_role_result(self, role_name: str, role_slug: str, screenshot_path: str) -> Dict:
        """ユーザーロール作成結果を作成"""
        return {
            'success': True,
            'summary': f'ユーザーロール "{role_name}" の作成画面を開きました。',
            'role_slug': role_slug,
            'role_name': role_name,
            'screenshot': screenshot_path,
            'full_text': f'User Role作成\nスラッグ: {role_slug}\n表示名: {role_name}\n※権限設定は手動で実施してください'
        }

    def _build_wordfence_result(self, task_params: Dict, screenshot_path: str) -> Dict:
        """Wordfence設定結果を作成"""
        firewall_mode = task_params.get('firewall_mode', 'enabled')
        scan_schedule = task_params.get('scan_schedule', 'daily')
        two_factor_auth = task_params.get('two_factor_auth', True)
        
        summary = f"""【Wordfence Security設定】
ファイアウォールモード: {firewall_mode}
スキャンスケジュール: {scan_schedule}
2FA: {'有効' if two_factor_auth else '無効'}
※手動で設定を完了してください"""
        
        return {
            'success': True,
            'summary': 'Wordfence設定画面を開きました。',
            'screenshot': screenshot_path,
            'full_text': summary
        }

    def _build_wp_rocket_result(self, screenshot_path: str) -> Dict:
        """WP Rocket設定結果を作成"""
        summary = """【WP Rocket設定】
推奨設定:
- Mobile Cache: 有効
- User Cache: 有効
- Minify CSS/JS: 有効
- Combine CSS/JS: 有効
※手動で設定を完了してください"""
        
        return {
            'success': True,
            'summary': 'WP Rocket設定画面を開きました。',
            'screenshot': screenshot_path,
            'full_text': summary
        }

    def _build_relevanssi_result(self, task_params: Dict, screenshot_path: str) -> Dict:
        """Relevanssi設定結果を作成"""
        index_fields = task_params.get('index_fields', [])
        
        summary = f"""【Relevanssi設定】
インデックス対象フィールド: {len(index_fields)}件
推奨設定:
- Custom fields: ACFフィールド名を追加
- Build Index: インデックス構築実行
- Weight設定: Title=高, Content=中, Custom fields=中
※手動で設定を完了してください"""
        
        return {
            'success': True,
            'summary': 'Relevanssi設定画面を開きました。',
            'screenshot': screenshot_path,
            'full_text': summary
        }

#wp_post_creator.py
"""WordPress投稿作成"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostCreator:
    """WordPress投稿作成機能"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
    
    async def create_post(self, page: Page, task: Dict) -> Dict:
        """コンテンツ(投稿/ページ)を作成"""
        try:
            logger.info("コンテンツ作成を実行中...")
            
            # task_idを抽出
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            post_content = None
            post_title = f"AI投稿_{datetime.now().strftime('%Y%m%d_%H%M')}"
            
            if target_task_id:
                logger.info(f"task_id {target_task_id} の記事内容を使用")
                post_content = await TaskContentFetcher.get_task_content(
                    self.sheets_manager, target_task_id
                )
                
                if post_content:
                    # タイトルを抽出(最初の行をタイトルとする)
                    lines = post_content.split('\n')
                    if lines:
                        post_title = lines[0].strip()[:100]
                        # 本文は2行目以降
                        post_content = '\n'.join(lines[1:]).strip()
            
            if not post_content:
                # タスクからタイトルと本文を直接抽出
                title_match = re.search(r'タイトル[　\s]*(.+?)[\n本文]', task['description'])
                content_match = re.search(r'本文[　\s]*(.+?)[\n」]', task['description'])
                
                post_title = title_match.group(1).strip() if title_match else post_title
                post_content = content_match.group(1).strip() if content_match else "自動生成されたコンテンツ"
            
            logger.info(f"投稿内容: タイトル='{post_title}', 本文='{post_content[:50]}...'")
            
            # 新規投稿ページに移動
            await page.goto(f"{self.wp_url}/wp-admin/post-new.php")
            await page.wait_for_timeout(4000)
            
            # タイトル入力
            title_filled = await self._fill_title(page, post_title)
            
            # 本文入力
            content_filled = await self._fill_content(page, post_content)
            
            # Polylangの言語を日本語に設定
            await self._set_polylang_language(page)
            
            # 下書き保存
            saved = await self._save_draft(page)
            
            # スクリーンショット
            screenshot_path = f"wp_post_saved_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            
            if saved:
                return {
                    'success': True,
                    'summary': f'投稿を下書き保存しました。タイトル: {post_title}',
                    'screenshot': screenshot_path,
                    'full_text': f'投稿作成完了\nタイトル: {post_title}\n本文: {post_content[:200]}...\nスクリーンショット: {screenshot_path}'
                }
            else:
                return {
                    'success': True,
                    'summary': f'投稿を作成しました(保存ボタンが見つからなかったため手動確認が必要)',
                    'screenshot': screenshot_path,
                    'full_text': f'投稿作成\nタイトル: {post_title}\n本文: {post_content[:200]}...\nスクリーンショット: {screenshot_path}'
                }
                
        except Exception as e:
            logger.error(f"コンテンツ作成エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _fill_title(self, page: Page, title: str) -> bool:
        """タイトル入力"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="タイトルを追加"]',
            'textarea[placeholder*="タイトル"]',
            '#post-title-0'
        ]
        
        for selector in title_selectors:
            try:
                title_input = await page.query_selector(selector)
                if title_input and await title_input.is_visible():
                    await title_input.click()
                    await page.wait_for_timeout(500)
                    await title_input.fill(title)
                    await page.wait_for_timeout(1000)
                    logger.info(f"✅ タイトル入力完了: {title}")
                    return True
            except:
                continue
        
        logger.warning("タイトル入力欄が見つかりません")
        return False
    
    # wp_post_creator.py に追加するメソッド
    async def _fill_html_content(self, page: Page, html_content: str) -> bool:
        """HTMLコンテンツをGutenbergエディタに挿入"""
        try:
            logger.info("HTMLコンテンツを挿入中...")
        
            # カスタムHTMLブロックを追加
            await page.keyboard.press('/')
            await page.wait_for_timeout(1000)
            await page.keyboard.type('html')
            await page.wait_for_timeout(1000)
            await page.keyboard.press('Enter')
            await page.wait_for_timeout(2000)
        
            # HTML入力エリアを見つける
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]'
            ]
        
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input and await html_input.is_visible():
                        await html_input.click()
                        await page.wait_for_timeout(500)
                        await html_input.fill(html_content)
                        await page.wait_for_timeout(1000)
                        logger.info("✅ HTMLコンテンツ挿入完了")
                        return True
                except Exception as e:
                    logger.debug(f"HTML入力試行エラー ({selector}): {e}")
                    continue
        
            return False
        
        except Exception as e:
            logger.error(f"HTMLコンテンツ挿入エラー: {e}")
            return False
    
    async def _fill_content(self, page: Page, content: str) -> bool:
        """本文入力"""
        # Tabキーで本文エリアに移動
        await page.keyboard.press('Tab')
        await page.wait_for_timeout(500)
        
        content_selectors = [
            'p[data-title="段落"]',
            '.block-editor-default-block-appender__content',
            '[aria-label="ブロックを追加"]',
            '.wp-block-paragraph'
        ]
        
        for selector in content_selectors:
            try:
                content_area = await page.query_selector(selector)
                if content_area:
                    await content_area.click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content)
                    await page.wait_for_timeout(1000)
                    logger.info("✅ 本文入力完了")
                    return True
            except:
                continue
        
        # フォールバック: 単純にTabキー後に入力
        await page.keyboard.type(content)
        await page.wait_for_timeout(1000)
        logger.info("✅ 本文入力完了(フォールバック)")
        return True
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangの言語を日本語に設定（wp_post_editor.pyと同じロジック）"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylang言語設定セレクタを探索中...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  試行 {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        # 日本語オプションを探す
                        options = await lang_select.inner_text()
                        logger.debug(f"  → 利用可能な言語: {options[:100]}")
                        
                        # 複数の日本語表記を試す
                        japanese_labels = ['日本語', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"✅ Polylang言語設定成功: {label}")
                                
                                # 確認ダイアログ処理
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ Polylang言語設定要素が見つかりませんでした")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """確認ダイアログを処理（wp_post_editor.pyと同じ）"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("はい")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("✅ 確認ダイアログでOKをクリック")
                        return
            except:
                continue
    
    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        save_selectors = [
            'button[aria-label="下書き保存"]',
            'button:has-text("下書き保存")',
            '.editor-post-save-draft'
        ]
        
        for selector in save_selectors:
            try:
                save_button = await page.query_selector(selector)
                if save_button and await save_button.is_visible():
                    is_disabled = await save_button.is_disabled()
                    if not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(3000)
                        logger.info("✅ 下書き保存完了")
                        return True
            except:
                continue
        
        return False

#wp_post_editor.py
"""WordPress投稿編集（超堅牢版・詳細ログ付き）"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostEditor:
    """WordPress投稿編集機能（超堅牢版）"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
        self.debug_screenshots = []  # デバッグ用スクリーンショット一覧
    
    async def edit_post(self, page: Page, task: Dict) -> Dict:
        """既存の投稿を編集（タイトル抽出改善版）"""
        try:
            logger.info("="*80)
            logger.info("【ステップ1/10】投稿編集タスク開始")
            logger.info("="*80)
            
            # ステップ1: タスク内容の解析 - 改善版
            logger.info("\n【ステップ2/10】タスク内容を解析中...")
            
            # 複数のパターンでタイトルを抽出
            search_title = ""
            description = task['description']
            
            # パターン1: 「」で囲まれたタイトル
            title_patterns = [
                r'[「『](.+?)[」』].*の下書き保存',
                r'タイトル[　\s]*[「『](.+?)[」』]',
                r'投稿[　\s]*[「『](.+?)[」』]',
                r'[「『](AI投稿)[」』]'  # 明示的に「AI投稿」を探す
            ]
            
            for pattern in title_patterns:
                match = re.search(pattern, description)
                if match:
                    search_title = match.group(1)
                    logger.info(f"✅ タイトル抽出成功（パターン: {pattern}）: {search_title}")
                    break
            
            # パターン2: 特定のキーワードから判断
            if not search_title:
                if 'AI投稿' in description:
                    search_title = 'AI投稿'
                    logger.info(f"✅ キーワードからタイトル推測: {search_title}")
            
            if not search_title:
                logger.warning("⚠️ タイトルが見つかりませんでした。デフォルトを使用します。")
                search_title = "AI投稿"
            
            logger.info(f"🔍 検索タイトル: {search_title}")
            
            # ステップ2: task_idの抽出
            logger.info("\n【ステップ3/10】書き換え元記事のtask_idを抽出中...")
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            
            if target_task_id:
                logger.info(f"✅ task_id抽出成功: {target_task_id}")
            else:
                logger.error("❌ task_idが見つかりません")
                return {
                    'success': False,
                    'error': 'task_idが見つかりません。タスク説明にtask_idを含めてください。'
                }
            
            # ステップ3: 記事内容の取得
            logger.info("\n【ステップ4/10】Google Drive/スプレッドシートから記事内容を取得中...")
            logger.info(f"対象: task_id={target_task_id}")
            
            replacement_content = await TaskContentFetcher.get_task_content(
                self.sheets_manager, target_task_id
            )
            
            if not replacement_content:
                logger.error(f"❌ task_id {target_task_id} の記事内容が取得できませんでした")
                return {
                    'success': False,
                    'error': f'task_id {target_task_id} の記事内容が見つかりません'
                }
            
            logger.info(f"✅ 記事内容取得成功: {len(replacement_content)}文字")
            logger.info(f"先頭200文字:\n{replacement_content[:200]}...")
            
            # ステップ3.5: タイトルと本文を分離
            logger.info("\n【ステップ4.5/10】記事からタイトルと本文を分離中...")
            article_title, article_body = self._extract_title_and_body(replacement_content)
            
            logger.info(f"✅ タイトル: {article_title}")
            logger.info(f"✅ 本文: {len(article_body)}文字")
            
            # ステップ4: 投稿一覧ページへ移動
            logger.info("\n【ステップ5/10】WordPress投稿一覧ページへ移動中...")
            await page.goto(f"{self.wp_url}/wp-admin/edit.php", timeout=30000)
            await page.wait_for_timeout(3000)
            
            screenshot_path = await self._save_screenshot(page, "01_post_list")
            logger.info(f"✅ 投稿一覧ページ到達: {screenshot_path}")
            
            # ステップ5: タイトル検索
            if search_title:
                logger.info(f"\n【ステップ6/10】タイトル '{search_title}' で検索中...")
                search_success = await self._search_post(page, search_title)
                
                if search_success:
                    logger.info("✅ 検索実行成功")
                    screenshot_path = await self._save_screenshot(page, "02_search_result")
                else:
                    logger.warning("⚠️ 検索ボックスが見つかりませんでした")
            
            # ステップ6: 投稿編集ページへ移動
            logger.info(f"\n【ステップ7/10】投稿 '{search_title}' の編集ページへ移動中...")
            post_found, post_id = await self._navigate_to_edit_page(page, search_title)
            
            if not post_found:
                logger.error(f"❌ 投稿が見つかりませんでした: {search_title}")
                screenshot_path = await self._save_screenshot(page, "03_post_not_found")
                return {
                    'success': False,
                    'error': f'タイトル「{search_title}」の投稿が見つかりませんでした',
                    'screenshot': screenshot_path,
                    'debug_screenshots': self.debug_screenshots
                }
            
            logger.info(f"✅ 投稿編集ページ到達: 投稿ID={post_id}")
            screenshot_path = await self._save_screenshot(page, "04_edit_page")
            
            # ステップ7.5: タイトルを変更
            if article_title != search_title:
                logger.info(f"\n【ステップ7.5/10】投稿タイトルを '{article_title}' に変更中...")
                title_changed = await self._change_title(page, article_title)
                
                if title_changed:
                    logger.info("✅ タイトル変更完了")
                else:
                    logger.warning("⚠️ タイトル変更に失敗しました")
                
                screenshot_path = await self._save_screenshot(page, "04b_after_title_change")
            
            # ステップ7: Polylang言語設定
            logger.info("\n【ステップ8/10】Polylangの言語を日本語に変更中...")
            language_changed = await self._set_polylang_language(page)
            
            if language_changed:
                logger.info("✅ Polylang言語設定完了: 日本語")
            else:
                logger.warning("⚠️ Polylang設定が見つかりませんでした")
            
            screenshot_path = await self._save_screenshot(page, "05_after_language")
            
            # ステップ8: 記事内容の書き換え
            logger.info(f"\n【ステップ9/10】記事内容を書き換え中... ({len(article_body)}文字)")
            
            # マークダウンをHTMLに変換
            article_html = self._convert_markdown_to_html(article_body)
            logger.info(f"  マークダウン→HTML変換: {len(article_html)}文字")
            
            content_replaced = await self._replace_content(page, article_html)
            
            if content_replaced:
                logger.info("✅ 記事内容の書き換え完了")
            else:
                logger.error("❌ 記事内容の書き換えに失敗しました")
            
            screenshot_path = await self._save_screenshot(page, "06_after_content")
            
            # ステップ9: 下書き保存
            logger.info("\n【ステップ10/10】下書き保存中...")
            saved = await self._save_draft(page)
            
            if saved:
                logger.info("✅ 下書き保存完了")
            else:
                logger.warning("⚠️ 下書き保存ボタンが見つかりませんでした")
            
            # 最終スクリーンショット
            screenshot_path = await self._save_screenshot(page, "07_final")
            
            # 結果サマリー
            logger.info("\n" + "="*80)
            logger.info("【完了】投稿編集タスク終了")
            logger.info("="*80)
            
            result_summary = self._build_summary(
                search_title, post_id, article_title, language_changed, 
                len(article_body), saved
            )
            summary_text = '\n'.join(result_summary)
            
            logger.info("\n【最終結果】")
            logger.info(summary_text)
            
            return {
                'success': True,
                'summary': summary_text,
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots,
                'full_text': f'{summary_text}\n\n【デバッグ情報】\n' + '\n'.join([f'- {s}' for s in self.debug_screenshots])
            }
                
        except Exception as e:
            logger.error(f"❌ 投稿編集エラー: {e}")
            import traceback
            traceback.print_exc()
            
            screenshot_path = await self._save_screenshot(page, "ERROR")
            
            return {
                'success': False,
                'error': str(e),
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots
            }
    
    async def _save_screenshot(self, page: Page, name: str) -> str:
        """デバッグ用スクリーンショット保存"""
        try:
            timestamp = datetime.now().strftime('%H%M%S')
            screenshot_path = f"wp_debug_{name}_{timestamp}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            self.debug_screenshots.append(screenshot_path)
            logger.debug(f"📸 スクリーンショット保存: {screenshot_path}")
            return screenshot_path
        except Exception as e:
            logger.warning(f"スクリーンショット保存失敗: {e}")
            return ""
    
    async def _search_post(self, page: Page, search_title: str) -> bool:
        """投稿を検索"""
        search_box_selectors = [
            '#post-search-input',
            'input[name="s"]',
            'input[type="search"]',
            '.search-box input'
        ]
        
        for i, selector in enumerate(search_box_selectors, 1):
            try:
                logger.debug(f"検索ボックス試行 {i}/{len(search_box_selectors)}: {selector}")
                search_box = await page.query_selector(selector)
                
                if search_box:
                    is_visible = await search_box.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        await search_box.fill(search_title)
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Enter')
                        await page.wait_for_timeout(3000)
                        logger.info(f"✅ 検索実行成功: セレクタ={selector}")
                        return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
    
    # wp_post_editor.py の _extract_title_and_body メソッドを修正

    def _extract_title_and_body(self, content: str) -> tuple[str, str]:
        """
        記事からタイトルと本文を抽出（HTML対応強化版）
        """
        try:
            logger.info(f"【記事内容解析開始】文字数: {len(content)}")
                
            # HTML形式の場合はHTMLCleanerを使用
            if '<h1' in content or '<div' in content or '<p>' in content:
                logger.info("✅ HTML形式の記事を検出 - HTMLCleanerを使用")
                    
                # HTMLCleanerでタイトルと本文を抽出
                from .wp_utils import HTMLCleaner
                title, body = HTMLCleaner.prepare_html_for_wordpress(content)
                    
                logger.info(f"✅ HTML処理完了: タイトル='{title}', 本文={len(body)}文字")
                return title, body
                
            # Markdown形式の処理（既存のロジック）
            lines = content.split('\n')
            title = ""
            body_lines = []
                
            for i, line in enumerate(lines):
                line_stripped = line.strip()
                    
                # 最初の # で始まる行をタイトルとする
                if line_stripped.startswith('# ') and not title:
                    title = line_stripped[2:].strip()
                    logger.info(f"✅ Markdownタイトル抽出: {title}")
                    continue
                    
                # タイトルが見つかった後の行を本文とする
                if title:
                    body_lines.append(line)
                # タイトルが見つかる前の非空行をタイトル候補とする
                elif line_stripped and not title:
                    title = line_stripped[:100]
                    logger.info(f"✅ 最初の行をタイトルとして使用: {title}")

            if title:
                body = '\n'.join(body_lines).strip() if body_lines else content
                logger.info(f"✅ タイトル・本文分離完了: タイトル={title[:30]}..., 本文={len(body)}文字")
                return title, body

            # フォールバック
            logger.warning("❌ タイトルを抽出できませんでした")
            return "AI投稿_自動生成", content

        except Exception as e:
            logger.error(f"❌ タイトル抽出エラー: {e}")
            import traceback
            traceback.print_exc()
            return "AI投稿_エラー", content
    
    async def _change_title(self, page: Page, new_title: str) -> bool:
        """投稿のタイトルを変更"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="タイトルを追加"]',
            'textarea[placeholder*="タイトル"]',
            '#post-title-0',
            '.wp-block-post-title'
        ]
        
        logger.debug("タイトル入力欄を探索中...")
        
        for i, selector in enumerate(title_selectors, 1):
            logger.debug(f"  試行 {i}/{len(title_selectors)}: {selector}")
            try:
                title_input = await page.query_selector(selector)
                if title_input:
                    is_visible = await title_input.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        # 既存のタイトルをクリア
                        await title_input.click()
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Control+A')
                        await page.wait_for_timeout(300)
                        
                        # 新しいタイトルを入力
                        await page.keyboard.type(new_title)
                        await page.wait_for_timeout(1000)
                        
                        logger.info(f"✅ タイトル変更成功: {new_title}")
                        return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ タイトル入力欄が見つかりませんでした")
        return False
    
    def _convert_markdown_to_html(self, markdown_text: str) -> str:
        """
        マークダウンをHTMLに変換
        
        対応：
        - ## 見出し → <h2>見出し</h2>
        - ### 見出し → <h3>見出し</h3>
        - **太字** → <strong>太字</strong>
        - *斜体* → <em>斜体</em>
        """
        try:
            import re
            
            html_lines = []
            lines = markdown_text.split('\n')
            
            for line in lines:
                # 見出しの変換
                if line.strip().startswith('### '):
                    # H3
                    text = line.strip()[4:]
                    html_lines.append(f'<h3>{text}</h3>')
                elif line.strip().startswith('## '):
                    # H2
                    text = line.strip()[3:]
                    html_lines.append(f'<h2>{text}</h2>')
                elif line.strip().startswith('# '):
                    # H1（通常はタイトルなのでスキップ）
                    text = line.strip()[2:]
                    html_lines.append(f'<h1>{text}</h1>')
                else:
                    # 本文の変換
                    converted_line = line
                    
                    # **太字** → <strong>太字</strong>
                    converted_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', converted_line)
                    
                    # *斜体* → <em>斜体</em>
                    converted_line = re.sub(r'\*(.+?)\*', r'<em>\1</em>', converted_line)
                    
                    # 段落タグで囲む（空行でない場合）
                    if converted_line.strip():
                        html_lines.append(f'<p>{converted_line}</p>')
                    else:
                        html_lines.append('')
            
            html_content = '\n'.join(html_lines)
            
            logger.info(f"【マークダウン→HTML変換完了】")
            logger.info(f"  元: {len(markdown_text)}文字")
            logger.info(f"  変換後: {len(html_content)}文字")
            
            return html_content
            
        except Exception as e:
            logger.warning(f"マークダウン変換エラー: {e}")
            return markdown_text
    
    async def _replace_content(self, page: Page, content: str, is_html: bool = False) -> bool:
        """記事内容を置換（Gutenbergブロック対応版）"""
        logger.info("記事エディタを探索中...")
        
        if is_html:
            logger.info("HTML形式のため、Gutenbergブロックとして挿入します")
            return await self._insert_as_gutenberg_blocks(page, content)
        
        # 通常のテキストの場合
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  試行 {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  → {len(content_blocks)}個の要素発見")
                    
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"✅ 記事内容書き換え成功: {len(content)}文字")
                    return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.error("❌ すべてのエディタセレクタで失敗")
        return False
    
    async def _insert_as_gutenberg_blocks(self, page: Page, html_content: str) -> bool:
        """HTMLをカスタムHTMLブロックとして挿入（簡易版）"""
        try:
            logger.info("【カスタムHTMLブロック挿入開始】")
            
            # 既存のコンテンツを削除
            logger.info("  ステップ1: 既存コンテンツを削除")
            await self._clear_all_blocks_simple(page)
            
            # カスタムHTMLブロックを追加
            logger.info("  ステップ2: カスタムHTMLブロックを追加")
            
            # 方法1: /html で検索
            try:
                await page.keyboard.press('/')
                await page.wait_for_timeout(500)
                await page.keyboard.type('html')
                await page.wait_for_timeout(1000)
                await page.keyboard.press('Enter')
                await page.wait_for_timeout(1000)
                logger.info("  → /html で検索成功")
            except Exception as e:
                logger.debug(f"  方法1失敗: {e}")
                
                # 方法2: ブロック追加ボタンから
                try:
                    await page.click('button[aria-label="ブロックを追加"]', timeout=3000)
                    await page.wait_for_timeout(500)
                    await page.type('input[placeholder*="検索"]', 'html')
                    await page.wait_for_timeout(1000)
                    await page.click('button:has-text("カスタムHTML")', timeout=3000)
                    await page.wait_for_timeout(1000)
                    logger.info("  → ブロック追加ボタンから成功")
                except Exception as e2:
                    logger.debug(f"  方法2失敗: {e2}")
            
            # HTMLコードエリアを見つけて貼り付け
            logger.info("  ステップ3: HTMLコードを貼り付け")
            
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]',
                'textarea.components-textarea-control__input'
            ]
            
            pasted = False
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input:
                        is_visible = await html_input.is_visible()
                        if is_visible:
                            await html_input.click()
                            await page.wait_for_timeout(500)
                            
                            # HTMLを貼り付け
                            await html_input.fill(html_content)
                            await page.wait_for_timeout(1000)
                            
                            logger.info(f"  ✅ HTML貼り付け成功: {len(html_content)}文字")
                            pasted = True
                            break
                except Exception as e:
                    logger.debug(f"  {selector} エラー: {e}")
                    continue
            
            if not pasted:
                logger.warning("  ⚠️ HTML入力欄が見つかりませんでした")
                return False
            
            # プレビューモードに切り替え（見た目を確認）
            logger.info("  ステップ4: プレビューモードに切り替え")
            try:
                # 「プレビュー」ボタンを探す
                preview_button = await page.query_selector('button:has-text("プレビュー")')
                if preview_button:
                    await preview_button.click()
                    await page.wait_for_timeout(1000)
                    logger.info("  ✅ プレビューモード表示")
            except Exception as e:
                logger.debug(f"  プレビュー切り替えエラー: {e}")
            
            logger.info(f"✅ カスタムHTMLブロック挿入完了")
            return True
            
        except Exception as e:
            logger.error(f"❌ カスタムHTMLブロック挿入エラー: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def _clear_all_blocks_simple(self, page: Page) -> bool:
        """既存のブロックを簡易的に削除"""
        try:
            # Ctrl+A で全選択 → Backspace で削除
            await page.keyboard.press('Control+A')
            await page.wait_for_timeout(500)
            await page.keyboard.press('Backspace')
            await page.wait_for_timeout(1000)
            
            logger.info("  ✅ 既存コンテンツ削除完了")
            return True
            
        except Exception as e:
            logger.debug(f"  既存コンテンツ削除エラー: {e}")
            return False
        
        logger.warning("❌ すべての検索ボックスセレクタで失敗")
        return False
    
    async def _navigate_to_edit_page(self, page: Page, search_title: str) -> tuple[bool, Optional[str]]:
        """投稿編集ページへ移動"""
        logger.info("投稿リンクを探索中...")
        
        # 方法1: タイトルリンクから直接編集URL
        logger.debug("【方法1】タイトルリンクから編集URLを取得")
        try:
            # 複数のセレクタを試行
            title_selectors = [
                f'a.row-title:has-text("{search_title}")',
                f'td.title a:has-text("{search_title}")',
                f'.row-title:has-text("{search_title}")'
            ]
            
            for i, selector in enumerate(title_selectors, 1):
                logger.debug(f"  試行 {i}/{len(title_selectors)}: {selector}")
                try:
                    title_link = await page.query_selector(selector)
                    if title_link:
                        href = await title_link.get_attribute('href')
                        if href:
                            post_id_match = re.search(r'post=(\d+)', href)
                            if post_id_match:
                                post_id = post_id_match.group(1)
                                edit_url = f"{self.wp_url}/wp-admin/post.php?post={post_id}&action=edit"
                                logger.info(f"✅ 編集URL構築成功: 投稿ID={post_id}")
                                
                                await page.goto(edit_url, timeout=30000)
                                await page.wait_for_timeout(4000)
                                
                                return True, post_id
                except Exception as e:
                    logger.debug(f"  → エラー: {e}")
                    continue
        except Exception as e:
            logger.debug(f"方法1失敗: {e}")
        
        # 方法2: 編集リンクをクリック
        logger.debug("【方法2】編集リンクをクリック")
        edit_link_selectors = [
            f'tr:has-text("{search_title}") .row-actions .edit a',
            f'a.row-title:has-text("{search_title}")',
            '.row-actions .edit a',
            f'tr:has(a:has-text("{search_title}")) .edit a'
        ]
        
        for i, selector in enumerate(edit_link_selectors, 1):
            logger.debug(f"  試行 {i}/{len(edit_link_selectors)}: {selector}")
            try:
                edit_link = await page.query_selector(selector)
                if edit_link:
                    is_visible = await edit_link.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        await edit_link.click()
                        await page.wait_for_timeout(5000)
                        
                        # URLから投稿IDを取得
                        current_url = page.url
                        post_id_match = re.search(r'post=(\d+)', current_url)
                        post_id = post_id_match.group(1) if post_id_match else "不明"
                        
                        logger.info(f"✅ 編集リンククリック成功: 投稿ID={post_id}")
                        return True, post_id
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        # 方法3: 最初の投稿を開く（フォールバック）
        logger.debug("【方法3】最初の投稿を開く（フォールバック）")
        try:
            first_edit_link = await page.query_selector('.row-actions .edit a')
            if first_edit_link:
                await first_edit_link.click()
                await page.wait_for_timeout(4000)
                logger.warning("⚠️ 最初の投稿を開きました（フォールバック）")
                return True, "不明"
        except Exception as e:
            logger.debug(f"方法3失敗: {e}")
        
        logger.error("❌ すべての方法で投稿編集ページへの移動に失敗")
        return False, None
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangの言語を日本語に設定"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylang言語設定セレクタを探索中...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  試行 {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  → 要素発見: 表示={is_visible}")
                    
                    if is_visible:
                        # 日本語オプションを探す
                        options = await lang_select.inner_text()
                        logger.debug(f"  → 利用可能な言語: {options[:100]}")
                        
                        # 複数の日本語表記を試す
                        japanese_labels = ['日本語', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"✅ Polylang言語設定成功: {label}")
                                
                                # 確認ダイアログ処理
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ Polylang言語設定要素が見つかりませんでした")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """確認ダイアログを処理"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("はい")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("✅ 確認ダイアログでOKをクリック")
                        return
            except:
                continue
    
    async def _replace_content(self, page: Page, content: str) -> bool:
        """記事内容を置換"""
        logger.info("記事エディタを探索中...")
        
        # Gutenbergエディタのセレクタ
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
            '.editor-post-text-editor',
            'textarea.editor-post-text-editor',
            '#content'  # クラシックエディタ
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  試行 {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  → {len(content_blocks)}個の要素発見")
                    
                    # 最初のブロックをクリック
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    logger.debug("  → クリック完了")
                    
                    # 全選択して削除
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    logger.debug("  → 既存内容削除完了")
                    
                    # 新しい内容を入力
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"✅ 記事内容書き換え成功: {len(content)}文字")
                    return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.error("❌ すべてのエディタセレクタで失敗")
        return False
    
    async def _save_draft(self, page: Page) -> bool:
        """下書き保存"""
        save_selectors = [
            'button:has-text("下書き保存")',
            'button[aria-label="下書き保存"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
        
        logger.debug("下書き保存ボタンを探索中...")
        
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  試行 {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if save_button:
                    is_visible = await save_button.is_visible()
                    is_disabled = await save_button.is_disabled() if is_visible else True
                    
                    logger.debug(f"  → 要素発見: 表示={is_visible}, 無効={is_disabled}")
                    
                    if is_visible and not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(4000)
                        logger.info("✅ 下書き保存ボタンクリック成功")
                        return True
            except Exception as e:
                logger.debug(f"  → エラー: {e}")
                continue
        
        logger.warning("❌ 下書き保存ボタンが見つかりませんでした")
        return False
    
    def _build_summary(self, old_title: str, post_id: str, new_title: str, 
                      lang_changed: bool, content_length: int, saved: bool) -> list:
        """結果サマリーを構築"""
        result_summary = []
        result_summary.append(f"【投稿編集完了】")
        result_summary.append(f"元のタイトル: {old_title}")
        
        if new_title != old_title:
            result_summary.append(f"新しいタイトル: {new_title}")
        
        result_summary.append(f"投稿ID: {post_id}")
        result_summary.append("")
        
        if lang_changed:
            result_summary.append("✅ Polylang言語設定: 日本語")
        else:
            result_summary.append("⚠️ Polylang言語設定: スキップ")
        
        result_summary.append(f"✅ 記事内容書き換え: {content_length}文字（HTML変換済み）")
        
        if saved:
            result_summary.append("✅ 下書き保存: 完了")
        else:
            result_summary.append("⚠️ 下書き保存: スキップ（手動確認推奨）")
        
        return result_summary

#wp_requirements_agent.py
"""
WordPress要件定義書作成エージェント（完全版）
エラー処理・検証・フォールバック完備
"""

import asyncio
import logging
from typing import Dict, Optional, List
from pathlib import Path
from datetime import datetime
import json
import re

logger = logging.getLogger(__name__)


class WordPressRequirementsAgent:
    """WordPress要件定義書作成専門エージェント（完全版）"""
    
    # プロンプトは長いので簡潔版に変更
    PROMPT_TEMPLATE = """あなたはWordPress開発の専門家で、要件定義のプロフェッショナルです。

【あなたの役割】
ウズベキスタンのM&Aポータルサイトの完全な要件定義書を作成してください。

【プロジェクト情報】
- **サイト名**: ウズベキスタンM&Aポータル
- **WordPressテーマ**: Cocoon（日本製高機能テーマ）
- **多言語**: Polylang（日英露ウズ中韓トルコ語の7言語）
- **主要プラグイン**: ACF PRO, FacetWP, Relevanssi, Wordfence, WP Rocket

【要件定義書の構成】
以下の構造で**詳細な要件定義書**を出力してください：

# 1.0 プロジェクト概要
## 1.1 プロジェクト名
## 1.2 目的・背景
## 1.3 対象ユーザー
## 1.4 成功指標（KPI）

# 2.0 システム構成
## 2.1 技術スタック
- WordPress 6.4+、Cocoon、Polylang Pro、ACF PRO、FacetWP、Relevanssi
## 2.2 サーバー要件
- PHP 8.0+、MySQL 8.0+、メモリ 512MB+
## 2.3 開発・本番環境

# 3.0 機能要件
## 3.1 カスタム投稿タイプ
### 3.1.1 M&A案件（ma_case）
- supports: title, editor, thumbnail, custom-fields, excerpt
- taxonomies: industry_category, region, deal_type
### 3.1.2 企業情報（company）
### 3.1.3 ニュース（news）

## 3.2 カスタムタクソノミー
### 3.2.1 業種分類（industry_category） - 階層型
### 3.2.2 地域（region） - 階層型
### 3.2.3 案件タイプ（deal_type） - 非階層型

## 3.3 ACFカスタムフィールド
### M&A案件用フィールド（20個定義）
1. case_id（案件ID） - テキスト、必須
2. ma_scheme（M&Aスキーム） - セレクト、必須
3. desired_price（希望価格） - 数値
4. established_year（設立年） - 数値
5. employees（従業員数） - 数値
6. annual_revenue（年商） - 数値
7. reason_for_sale（売却理由） - テキストエリア
8. confidential_level（機密レベル） - セレクト
9-20. その他フィールド（具体的に記載）

## 3.4 検索・フィルター（FacetWP）
- 業種別検索（チェックボックス）
- 地域別検索（ドロップダウン）
- 価格帯検索（スライダー）
- 案件タイプ検索（チェックボックス）
- キーワード検索（Relevanssi）

## 3.5 多言語機能（Polylang）
### 言語設定
- デフォルト: 日本語（ja）
- 翻訳言語: en, ru, uz, zh, ko, tr
### URLマッピング
日本語: https://example.com/ma-cases/
英語: https://example.com/en/ma-cases/
ロシア語: https://example.com/ru/ma-cases/

## 3.6 ユーザー管理
### カスタムロール: ma_partner
- 自身の作成した ma_case のみ編集可能
- 他ユーザーの案件は閲覧・編集不可

## 3.7 問い合わせ機能
- Contact Form 7
- 多言語対応フォーム

## 3.8 SEO対策（Cocoon活用）
- 構造化データ自動生成
- OGPタグ設定
- パンくずリスト

## 3.9 セキュリティ（Wordfence）
- ファイアウォール: enabled
- スキャン: 週1回

## 3.10 パフォーマンス（WP Rocket + Cocoon）
- モバイルキャッシュ: 有効
- CSS/JS縮小化: 有効

# 4.0 非機能要件
## 4.1 パフォーマンス
- ページ読み込み: 3秒以内
- PageSpeed Insights: 80点以上
## 4.2 可用性
- サーバー稼働率: 99.9%以上
## 4.3 Pydanticモデル移行計画

# 5.0 画面設計
## 5.1 トップページ
## 5.2 M&A案件一覧
## 5.3 M&A案件詳細

# 6.0 データ構造
## 6.1 カスタム投稿タイプ定義（JSON）
```json
{
  "ma_case": {
    "labels": {
      "ja": "M&A案件",
      "en": "M&A Cases"
    },
    "supports": ["title", "editor", "thumbnail"],
    "taxonomies": ["industry_category", "region"],
    "has_archive": true
  }
}
6.2 ACFフィールドグループ定義（JSON）
json{
  "ma_case_fields": {
    "title": "M&A案件基本情報",
    "fields": [
      {
        "name": "case_id",
        "type": "text",
        "required": true
      }
    ]
  }
}
7.0 実装計画
フェーズ1: 基本構築（1-2週間）
フェーズ2: 機能実装（2-3週間）
フェーズ3: コンテンツ登録（1週間）
フェーズ4: テスト・調整（1週間）
フェーズ5: 本番公開（1週間）
8.0 運用保守
定期作業

WordPress/プラグイン更新（月1回）
バックアップ確認（週1回）

9.0 コスト見積もり
初期費用
月額費用
10.0 リスクと対策
技術的リスク
対策

【出力要件】

すべての章立て（1.0～10.0）を完全に記載
JSONコードブロックは必ず閉じる（```で終了）
具体的な数値・名称を記載
Cocoon、Polylangの機能を明記
15,000文字以上を目標

それでは、完全な要件定義書を出力してください。
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # 統計情報
    self.stats = {
        'total_attempts': 0,
        'successful': 0,
        'failed': 0
    }
    
    logger.info("✅ WordPressRequirementsAgent 初期化完了")
    logger.info(f"📁 出力フォルダ: {self.output_folder}")

async def execute(self, task: Dict) -> Dict:
    """要件定義書作成タスクを実行（完全版）"""
    task_id = task.get('task_id', 'UNKNOWN')
    self.stats['total_attempts'] += 1
    
    try:
        logger.info("\n" + "="*70)
        logger.info("📋 WordPress要件定義書作成開始")
        logger.info(f"タスクID: {task_id}")
        logger.info("="*70 + "\n")
        
        # ステップ1: ブラウザ確認
        if not self._verify_browser():
            return self._create_error_result(task_id, 'ブラウザが利用できません')
        
        # ステップ2: プロンプト送信
        logger.info("📤 ステップ1: Geminiにプロンプト送信")
        if not await self._send_prompt():
            return self._create_error_result(task_id, 'プロンプト送信失敗')
        
        # ステップ3: 応答待機
        logger.info("⏱️ ステップ2: 応答待機（最大300秒）")
        if not await self._wait_for_response():
            return self._create_error_result(task_id, 'タイムアウト（300秒）')
        
        # ステップ4: 応答取得
        logger.info("📥 ステップ3: 応答取得")
        response_text = await self._extract_response()
        
        if not response_text:
            return self._create_error_result(task_id, '応答取得失敗')
        
        # ステップ5: 品質検証
        logger.info("🔍 ステップ4: 品質検証")
        validation_result = self._validate_response(response_text)
        
        if not validation_result['valid']:
            logger.warning(f"⚠️ 品質警告: {validation_result['warnings']}")
        
        # ステップ6: ファイル保存
        logger.info("💾 ステップ5: ファイル保存")
        output_files = await self._save_requirements(response_text, task_id)
        
        # ステップ7: 成功結果の作成
        self.stats['successful'] += 1
        
        logger.info("\n" + "="*70)
        logger.info("✅ WordPress要件定義書作成完了")
        logger.info(f"📄 文字数: {len(response_text):,}文字")
        logger.info(f"📁 保存ファイル: {len(output_files)}件")
        logger.info("="*70 + "\n")
        
        return {
            'success': True,
            'message': '要件定義書作成完了',
            'task_id': task_id,
            'content_length': len(response_text),
            'output_files': [str(f['path']) for f in output_files],
            'validation': validation_result,
            'summary': f'要件定義書作成完了（{len(response_text):,}文字、{len(output_files)}ファイル）',
            'full_text': response_text[:1000] + '...' if len(response_text) > 1000 else response_text
        }
        
    except Exception as e:
        self.stats['failed'] += 1
        logger.error(f"❌ 要件定義書作成エラー: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return self._create_error_result(task_id, str(e))

def _verify_browser(self) -> bool:
    """ブラウザの状態を確認"""
    if not self.browser:
        logger.error("❌ ブラウザコントローラーが初期化されていません")
        return False
    
    if not hasattr(self.browser, 'send_prompt'):
        logger.error("❌ ブラウザに send_prompt メソッドがありません")
        return False
    
    logger.info("✅ ブラウザ確認: OK")
    return True

async def _send_prompt(self) -> bool:
    """プロンプトを送信"""
    try:
        await self.browser.send_prompt(self.PROMPT_TEMPLATE)
        logger.info("✅ プロンプト送信完了")
        return True
    except Exception as e:
        logger.error(f"❌ プロンプト送信エラー: {e}")
        return False

async def _wait_for_response(self, max_wait: int = 300) -> bool:
    """応答を待機"""
    try:
        success = await self.browser.wait_for_text_generation(max_wait=max_wait)
        if success:
            logger.info(f"✅ 応答待機完了（{max_wait}秒以内）")
        else:
            logger.error(f"❌ タイムアウト（{max_wait}秒）")
        return success
    except Exception as e:
        logger.error(f"❌ 応答待機エラー: {e}")
        return False

async def _extract_response(self) -> Optional[str]:
    """応答テキストを抽出"""
    try:
        response_text = await self.browser.extract_latest_text_response()
        
        if response_text:
            logger.info(f"✅ 応答取得: {len(response_text):,}文字")
        else:
            logger.error("❌ 応答が空です")
        
        return response_text
    except Exception as e:
        logger.error(f"❌ 応答抽出エラー: {e}")
        return None

def _validate_response(self, text: str) -> Dict:
    """応答の品質を検証"""
    warnings = []
    
    # 長さチェック
    if len(text) < 10000:
        warnings.append(f'文字数が少ない（{len(text):,}文字）')
    
    # 章立てチェック
    required_sections = [
        '1.0 プロジェクト概要',
        '2.0 システム構成',
        '3.0 機能要件',
        '4.0 非機能要件',
        '5.0 画面設計',
        '6.0 データ構造',
        '7.0 実装計画',
        '8.0 運用保守',
        '9.0 コスト見積もり',
        '10.0 リスクと対策'
    ]
    
    missing_sections = [s for s in required_sections if s not in text]
    if missing_sections:
        warnings.append(f'欠落セクション: {", ".join(missing_sections)}')
    
    # JSONブロックチェック
    json_blocks = re.findall(r'```json', text)
    if len(json_blocks) < 2:
        warnings.append(f'JSONブロックが少ない（{len(json_blocks)}個）')
    
    # Cocoonキーワードチェック
    if 'Cocoon' not in text and 'cocoon' not in text:
        warnings.append('Cocoonテーマの記述が見つかりません')
    
    # Polylangキーワードチェック
    if 'Polylang' not in text and 'polylang' not in text:
        warnings.append('Polylangプラグインの記述が見つかりません')
    
    valid = len(warnings) == 0
    
    if valid:
        logger.info("✅ 品質検証: 合格")
    else:
        logger.warning(f"⚠️ 品質検証: 警告あり（{len(warnings)}件）")
        for w in warnings:
            logger.warning(f"  - {w}")
    
    return {
        'valid': valid,
        'warnings': warnings,
        'length': len(text),
        'sections_found': len(required_sections) - len(missing_sections),
        'sections_total': len(required_sections)
    }

async def _save_requirements(self, text: str, task_id: str) -> List[Dict]:
    """要件定義書を保存"""
    output_files = []
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    try:
        # 1. メイン要件定義書（Markdown）
        doc_filename = f"requirements_wordpress_{task_id}_{timestamp}.md"
        doc_path = self.output_folder / doc_filename
        
        with open(doc_path, 'w', encoding='utf-8') as f:
            f.write(f"# WordPress要件定義書 - ウズベキスタンM&Aポータル\n\n")
            f.write(f"**作成日時**: {datetime.now().strftime('%Y年%m月%d日 %H:%M:%S')}\n")
            f.write(f"**タスクID**: {task_id}\n")
            f.write(f"**文字数**: {len(text):,}文字\n\n")
            f.write("---\n\n")
            f.write(text)
        
        output_files.append({
            'type': '要件定義書（Markdown）',
            'path': doc_path,
            'size': len(text)
        })
        logger.info(f"✅ 保存: {doc_filename} ({len(text):,}文字)")
        
        # 2. JSON構造（もし抽出できれば）
        json_data = self._extract_json_structures(text)
        if json_data:
            json_filename = f"data_structures_{task_id}_{timestamp}.json"
            json_path = self.output_folder / json_filename
            
            with open(json_path, 'w', encoding='utf-8') as f:
                json.dump(json_data, f, ensure_ascii=False, indent=2)
            
            output_files.append({
                'type': 'データ構造（JSON）',
                'path': json_path,
                'size': json_path.stat().st_size
            })
            logger.info(f"✅ 保存: {json_filename}")
        
        # 3. 実装チェックリスト
        checklist_filename = f"checklist_{task_id}_{timestamp}.md"
        checklist_path = self.output_folder / checklist_filename
        
        checklist_content = self._generate_checklist()
        with open(checklist_path, 'w', encoding='utf-8') as f:
            f.write(checklist_content)
        
        output_files.append({
            'type': '実装チェックリスト',
            'path': checklist_path,
            'size': len(checklist_content)
        })
        logger.info(f"✅ 保存: {checklist_filename}")
        
        logger.info(f"✅ 合計 {len(output_files)} ファイル保存完了")
        return output_files
        
    except Exception as e:
        logger.error(f"❌ ファイル保存エラー: {e}")
        return output_files

def _extract_json_structures(self, text: str) -> Optional[Dict]:
    """JSONブロックを抽出"""
    try:
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        
        if not json_blocks:
            return None
        
        combined_data = {}
        for i, json_str in enumerate(json_blocks, 1):
            try:
                data = json.loads(json_str)
                combined_data[f"block_{i}"] = data
            except json.JSONDecodeError:
                logger.warning(f"⚠️ JSONブロック {i} のパースに失敗")
                continue
        
        return combined_data if combined_data else None
        
    except Exception as e:
        logger.warning(f"⚠️ JSON抽出エラー: {e}")
        return None

def _generate_checklist(self) -> str:
    """実装チェックリストを生成"""
    return """# WordPress M&Aポータル 実装チェックリスト
フェーズ1: 基本構築 ✅

 WordPress 6.4+ インストール
 Cocoonテーマ インストール・有効化
 Polylang Pro インストール・設定（7言語）
 必須プラグイン インストール

 Advanced Custom Fields PRO
 Custom Post Type UI
 FacetWP
 Relevanssi
 Wordfence Security
 WP Rocket
 Contact Form 7
 User Role Editor



フェーズ2: カスタム投稿タイプ 🔧

 M&A案件（ma_case）作成

 ラベル設定（7言語）
 サポート機能設定
 パーマリンク設定


 企業情報（company）作成
 ニュース（news）作成

フェーズ3: タクソノミー 🏷️

 業種分類（industry_category）作成 - 階層型
 地域（region）作成 - 階層型
 案件タイプ（deal_type）作成 - 非階層型
 Polylang翻訳設定

フェーズ4: ACFフィールド 📝

 M&A案件フィールドグループ作成

 基本情報（case_id, ma_scheme, etc.）
 財務情報（desired_price, revenue, etc.）
 連絡先情報


 企業情報フィールドグループ作成
 Polylang連携設定

フェーズ5: 検索・フィルター 🔍

 FacetWP設定

 業種別ファセット
 地域別ファセット
 価格帯スライダー
 案件タイプファセット


 Relevanssi設定

 インデックス構築
 カスタムフィールド検索設定

フェーズ6: セキュリティ・最適化 🔒

 Wordfence Security設定

 ファイアウォール有効化
 スキャンスケジュール設定


 WP Rocket設定

 モバイルキャッシュ有効化
 CSS/JS縮小化


 Cocoon高速化設定

フェーズ7: ユーザー管理 👥

 カスタムロール（ma_partner）作成
 権限設定
 テストユーザー作成・検証

フェーズ8: コンテンツ登録 📄

 サンプルM&A案件登録（各言語）
 サンプル企業情報登録
 固定ページ作成
 メニュー設定

フェーズ9: テスト 🧪

 多言語表示確認
 検索機能テスト
 フィルター機能テスト
 フォーム送信テスト
 パフォーマンステスト
 セキュリティスキャン

フェーズ10: 本番公開 🚀

 DNS設定
 SSL証明書設定
 本番環境移行
 最終確認


作成日: {datetime}
バージョン: 1.0
""".format(datetime=datetime.now().strftime('%Y-%m-%d %H:%M'))
def _create_error_result(self, task_id: str, error: str) -> Dict:
    """エラー結果を作成"""
    logger.error(f"❌ エラー: {error}")
    
    return {
        'success': False,
        'error': error,
        'task_id': task_id,
        'stats': self.stats.copy()
    }

def get_stats(self) -> Dict:
    """統計情報を取得"""
    return self.stats.copy()



### 3. `wordpress/wp_dev/wp_cpt_agent.py`（完全版）

"""
WordPressカスタム投稿タイプ作成エージェント（完全版）
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """CPT作成専門エージェント（完全版）"""
    
    PROMPT_TEMPLATE = """あなたはWordPress開発の専門家です。

【タスク】
以下のカスタム投稿タイプを作成するPHPコードを生成してください：

**投稿タイプ情報**:
- スラッグ: {cpt_slug}
- 表示名（単数）: {cpt_singular}
- 表示名（複数）: {cpt_plural}
- サポート機能: {supports}
- タクソノミー: {taxonomies}

【要件】
1. `register_post_type()` を使用した完全なPHPコード
2. Polylang多言語対応
3. REST API対応（show_in_rest: true）
4. has_archive: true
5. エラーハンドリング付き
6. 詳細なコメント付き

【出力形式】
```php
<?php
/**
 * カスタム投稿タイプ: {cpt_name}
 * 作成日: {date}
 * Polylang対応
 */

function register_cpt_{cpt_slug_clean}() {{
    $labels = array(
        'name' => __( '{cpt_plural}', 'textdomain' ),
        'singular_name' => __( '{cpt_singular}', 'textdomain' ),
        // ... その他のラベル
    );
    
    $args = array(
        'labels' => $labels,
        'public' => true,
        'has_archive' => true,
        'show_in_rest' => true,
        'supports' => {supports_array},
        'taxonomies' => {taxonomies_array},
        // ... その他の設定
    );
    
    register_post_type( '{cpt_slug}', $args );
}}
add_action( 'init', 'register_cpt_{cpt_slug_clean}', 0 );
?>
完全に動作するPHPコードを出力してください。
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    logger.info("✅ WordPressCPTAgent 初期化")

async def execute(self, task: Dict) -> Dict:
    """CPT作成タスクを実行"""
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '')
    
    try:
        logger.info("=" * 70)
        logger.info("🔧 カスタム投稿タイプ作成開始")
        logger.info("=" * 70)
        
        # CPT仕様を抽出
        cpt_spec = self._extract_cpt_spec(description)
        logger.info(f"📊 CPT仕様: {cpt_spec['slug']}")
        
        # プロンプト構築
        prompt = self._build_prompt(cpt_spec)
        
        # Geminiに送信
        await self.browser.send_prompt(prompt)
        
        # 応答待機
        success = await self.browser.wait_for_text_generation(max_wait=180)
        
        if not success:
            return {'success': False, 'error': 'タイムアウト', 'task_id': task_id}
        
        # 応答取得
        response_text = await self.browser.extract_latest_text_response()
        
        if not response_text:
            return {'success': False, 'error': '応答取得失敗', 'task_id': task_id}
        
        # PHP保存
        output_file = await self._save_php_code(response_text, cpt_spec, task_id)
        
        logger.info("=" * 70)
        logger.info("✅ CPT作成完了")
        logger.info("=" * 70)
        
        return {
            'success': True,
            'message': f'CPT作成完了: {cpt_spec["slug"]}',
            'output_file': str(output_file),
            'cpt_slug': cpt_spec['slug'],
            'task_id': task_id,
            'summary': f'カスタム投稿タイプ {cpt_spec["slug"]} 作成完了'
        }
        
    except Exception as e:
        logger.error(f"❌ CPT作成エラー: {e}")
        return {'success': False, 'error': str(e), 'task_id': task_id}

def _extract_cpt_spec(self, description: str) -> Dict:
    """説明からCPT仕様を抽出"""
    desc_lower = description.lower()
    
    # M&A案件
    if 'ma_case' in desc_lower or 'm&a案件' in desc_lower:
        return {
            'slug': 'ma_case',
            'singular': 'M&A案件',
            'plural': 'M&A案件一覧',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields', 'excerpt'],
            'taxonomies': ['industry_category', 'region', 'deal_type']
        }
    
    # 企業情報
    elif 'company' in desc_lower or '企業情報' in desc_lower:
        return {
            'slug': 'company',
            'singular': '企業情報',
            'plural': '企業情報一覧',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields'],
            'taxonomies': ['industry_category', 'region']
        }
    
    # ニュース
    elif 'news' in desc_lower or 'ニュース' in desc_lower:
        return {
            'slug': 'news',
            'singular': 'ニュース',
            'plural': 'ニュース一覧',
            'supports': ['title', 'editor', 'thumbnail', 'excerpt'],
            'taxonomies': []
        }
    
    # デフォルト
    return {
        'slug': 'custom_post',
        'singular': 'カスタム投稿',
        'plural': 'カスタム投稿一覧',
        'supports': ['title', 'editor', 'thumbnail'],
        'taxonomies': []
    }

def _build_prompt(self, cpt_spec: Dict) -> str:
    """プロンプトを構築"""
    slug_clean = cpt_spec['slug'].replace('-', '_')
    
    return self.PROMPT_TEMPLATE.format(
        cpt_slug=cpt_spec['slug'],
        cpt_singular=cpt_spec['singular'],
        cpt_plural=cpt_spec['plural'],
        cpt_name=cpt_spec['singular'],
        cpt_slug_clean=slug_clean,
        supports=', '.join(cpt_spec['supports']),
        taxonomies=', '.join(cpt_spec['taxonomies']) if cpt_spec['taxonomies'] else 'なし',
        supports_array=str(cpt_spec['supports']).replace("'", '"'),
        taxonomies_array=str(cpt_spec['taxonomies']).replace("'", '"'),
        date=datetime.now().strftime('%Y-%m-%d')
    )

async def _save_php_code(self, code: str, cpt_spec: Dict, task_id: str) -> Path:
    """PHPコードを保存"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"cpt_{cpt_spec['slug']}_{task_id}_{timestamp}.php"
    output_path = self.output_folder / filename
    
    with open(output_path, 'w', encoding='utf-8') as f:
        # ヘッダーコメント追加
        f.write(f"<?php\n")
        f.write(f"/**\n")
        f.write(f" * カスタム投稿タイプ: {cpt_spec['singular']}\n")
        f.write(f" * スラッグ: {cpt_spec['slug']}\n")
        f.write(f" * 作成日: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f" */\n\n")
        
        # コード本体
        if '<?php' in code:
            # 既にPHPタグがある場合はそのまま
            f.write(code)
        else:
            # PHPタグがない場合は追加
            f.write(code)
    
    logger.info(f"✅ PHP保存: {filename}")
    return output_path



#wp_settings_manager.py
"""WordPress設定管理"""
import logging
from datetime import datetime
from typing import Dict
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressSettingsManager:
    """WordPress設定管理機能"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
    
    async def change_settings(self, page: Page, task: Dict) -> Dict:
        """WordPress設定を変更"""
        try:
            logger.info("設定変更を実行中...")
            
            # 設定ページに移動
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php")
            await page.wait_for_timeout(2000)
            
            # 現在の設定をスクリーンショット
            screenshot_path = f"wp_settings_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("✅ 設定画面を確認しました")
            logger.info("⚠️ 実際の設定変更は手動で確認してください")
            
            return {
                'success': True,
                'summary': '設定画面を表示しました。変更内容を確認して手動で適用してください。',
                'screenshot': screenshot_path,
                'full_text': f'設定確認完了\nスクリーンショット: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"設定変更エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def change_theme(self, page: Page, task: Dict) -> Dict:
        """テーマを変更"""
        try:
            logger.info("テーマ変更を実行中...")
            
            # テーマページに移動
            await page.goto(f"{self.wp_url}/wp-admin/themes.php")
            await page.wait_for_timeout(3000)
            
            # 現在のテーマを確認
            screenshot_path = f"wp_themes_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("✅ テーマ画面を表示しました")
            logger.info("⚠️ 実際のテーマ変更は手動で確認してください")
            
            return {
                'success': True,
                'summary': 'テーマ画面を表示しました。変更内容を確認して手動で適用してください。',
                'screenshot': screenshot_path,
                'full_text': f'テーマ確認完了\nスクリーンショット: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"テーマ変更エラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#wp_tester.py
"""WordPressテスト機能（品質管理強化版）"""
import logging
import re
from datetime import datetime
from typing import Dict, List, Tuple
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressTester:
    """WordPressテスト機能（品質管理強化版）"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
        self.test_frameworks = {
            'php': ['PHPUnit', 'Codeception', 'WP_UnitTestCase'],
            'javascript': ['Jest', 'Mocha', 'Chai', 'Cypress'],
            'wordpress': ['WP_UnitTestCase', 'WordPress PHPUnit']
        }
    
    async def test_functionality(self, page: Page, task: Dict) -> Dict:
        """機能をテスト（品質検証強化版）"""
        try:
            logger.info("🔍 機能テストを実行中（品質検証付き）...")
            
            test_results = []
            quality_issues = []
            
            # 1. サイトの表示テスト
            site_test_result = await self._test_site_accessibility(page)
            test_results.extend(site_test_result['results'])
            quality_issues.extend(site_test_result['quality_issues'])
            
            # 2. 管理画面テスト
            admin_test_result = await self._test_admin_access(page)
            test_results.extend(admin_test_result['results'])
            quality_issues.extend(admin_test_result['quality_issues'])
            
            # 3. プラグインステータス確認
            plugin_test_result = await self._test_plugins_status(page)
            test_results.extend(plugin_test_result['results'])
            quality_issues.extend(plugin_test_result['quality_issues'])
            
            # 4. コード品質検証（タスクにテストコードが含まれる場合）
            if self._has_test_code(task):
                code_quality_result = await self._validate_test_code_quality(task)
                test_results.extend(code_quality_result['results'])
                quality_issues.extend(code_quality_result['quality_issues'])
            
            # テスト結果の集計
            summary = self._generate_test_summary(test_results, quality_issues)
            
            logger.info("\n" + "="*60)
            logger.info("📊 テスト結果サマリー")
            logger.info("="*60)
            logger.info(summary)
            
            return {
                'success': len(quality_issues) == 0,
                'summary': summary[:500],
                'full_text': summary,
                'quality_issues': quality_issues,
                'test_results': test_results
            }
            
        except Exception as e:
            logger.error(f"❌ 機能テストエラー: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _test_site_accessibility(self, page: Page) -> Dict:
        """サイトアクセシビリティテスト"""
        results = []
        quality_issues = []
        
        try:
            # サイトにアクセス
            await page.goto(self.wp_url, wait_until='networkidle')
            await page.wait_for_timeout(3000)
            
            # ページタイトル取得
            page_title = await page.title()
            results.append(f"✅ サイト表示OK: {page_title}")
            
            # HTTPステータスチェック
            response = await page.goto(self.wp_url)
            if response and response.status == 200:
                results.append("✅ HTTPステータス: 200 OK")
            else:
                quality_issues.append("❌ HTTPステータスが200ではありません")
                results.append("❌ HTTPステータスエラー")
            
            # スクリーンショット
            timestamp = datetime.now().strftime('%H%M%S')
            site_screenshot = f"wp_site_{timestamp}.png"
            await page.screenshot(path=site_screenshot, full_page=True)
            results.append(f"📸 サイト全体: {site_screenshot}")
            
            # ページ読み込み速度チェック
            load_time = await self._measure_page_load_time(page, self.wp_url)
            if load_time < 5000:  # 5秒以内
                results.append(f"✅ ページ読み込み速度: {load_time}ms")
            else:
                quality_issues.append(f"⚠️ ページ読み込みが遅い: {load_time}ms")
                results.append(f"⚠️ ページ読み込み速度: {load_time}ms")
            
        except Exception as e:
            quality_issues.append(f"❌ サイトアクセステスト失敗: {str(e)}")
            results.append(f"❌ サイトアクセステスト失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_admin_access(self, page: Page) -> Dict:
        """管理画面アクセステスト"""
        results = []
        quality_issues = []
        
        try:
            # 管理画面にアクセス
            admin_url = f"{self.wp_url}/wp-admin/"
            await page.goto(admin_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ログインフォームの存在確認
            login_form = await page.query_selector('#loginform')
            if login_form:
                results.append("✅ 管理画面ログインフォーム確認")
            else:
                # 既にログイン済みかチェック
                admin_bar = await page.query_selector('#wpadminbar')
                if admin_bar:
                    results.append("✅ 管理画面: 既にログイン済み")
                else:
                    quality_issues.append("❌ 管理画面にアクセスできません")
                    results.append("❌ 管理画面アクセス失敗")
            
            # スクリーンショット
            timestamp = datetime.now().strftime('%H%M%S')
            admin_screenshot = f"wp_admin_{timestamp}.png"
            await page.screenshot(path=admin_screenshot)
            results.append(f"📸 管理画面: {admin_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"❌ 管理画面テスト失敗: {str(e)}")
            results.append(f"❌ 管理画面テスト失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_plugins_status(self, page: Page) -> Dict:
        """プラグインステータステスト"""
        results = []
        quality_issues = []
        
        try:
            # プラグインページにアクセス（ログインが必要な場合）
            plugins_url = f"{self.wp_url}/wp-admin/plugins.php"
            await page.goto(plugins_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ページタイトルでプラグインページか確認
            page_title = await page.title()
            if 'プラグイン' in page_title or 'Plugins' in page_title:
                results.append("✅ プラグイン一覧ページ確認")
                
                # アクティブなプラグイン数をチェック
                active_plugins = await page.query_selector_all('.plugins .active')
                if len(active_plugins) > 0:
                    results.append(f"✅ アクティブプラグイン: {len(active_plugins)}個")
                else:
                    quality_issues.append("⚠️ アクティブなプラグインがありません")
                    results.append("⚠️ アクティブプラグイン: 0個")
            else:
                quality_issues.append("❌ プラグインページにアクセスできません")
                results.append("❌ プラグインページアクセス失敗")
            
            # スクリーンショット
            timestamp = datetime.now().strftime('%H%M%S')
            plugins_screenshot = f"wp_plugins_{timestamp}.png"
            await page.screenshot(path=plugins_screenshot)
            results.append(f"📸 プラグイン: {plugins_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"❌ プラグインテスト失敗: {str(e)}")
            results.append(f"❌ プラグインテスト失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _validate_test_code_quality(self, task: Dict) -> Dict:
        """テストコードの品質検証"""
        results = []
        quality_issues = []
        
        try:
            # タスクからテストコードを抽出
            test_code = self._extract_test_code(task)
            
            if not test_code:
                results.append("ℹ️ 検証対象のテストコードなし")
                return {'results': results, 'quality_issues': quality_issues}
            
            # 言語別の品質検証
            if self._is_php_code(test_code):
                php_validation = self._validate_php_test_code(test_code)
                results.extend(php_validation['results'])
                quality_issues.extend(php_validation['quality_issues'])
            
            elif self._is_javascript_code(test_code):
                js_validation = self._validate_javascript_test_code(test_code)
                results.extend(js_validation['results'])
                quality_issues.extend(js_validation['quality_issues'])
            
            else:
                # 一般的なテストコード検証
                general_validation = self._validate_general_test_code(test_code)
                results.extend(general_validation['results'])
                quality_issues.extend(general_validation['quality_issues'])
            
        except Exception as e:
            quality_issues.append(f"❌ テストコード検証エラー: {str(e)}")
            results.append(f"❌ テストコード検証失敗: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_php_test_code(self, code: str) -> Dict:
        """PHPテストコードの検証"""
        results = []
        quality_issues = []
        
        # PHPUnitの基本構造チェック
        if 'class' not in code and 'function' not in code:
            quality_issues.append("❌ PHPテスト: クラスまたは関数が定義されていません")
            results.append("❌ PHPテスト構造: 不完全")
        
        # テストメソッドの存在チェック
        test_method_patterns = [
            r'function\s+test\w+',
            r'public\s+function\s+test\w+',
            r'public\s+function\s+test_\w+'
        ]
        
        has_test_methods = any(re.search(pattern, code) for pattern in test_method_patterns)
        if not has_test_methods:
            quality_issues.append("❌ PHPテスト: テストメソッドが定義されていません")
            results.append("❌ PHPテストメソッド: 未定義")
        else:
            results.append("✅ PHPテストメソッド: 定義済み")
        
        # アサーションの存在チェック
        assertion_patterns = [
            r'\$this->assert',
            r'assertEquals',
            r'assertTrue',
            r'assertFalse',
            r'expectException'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("❌ PHPテスト: アサーションがありません")
            results.append("❌ PHPテストアサーション: 未定義")
        else:
            results.append("✅ PHPテストアサーション: 定義済み")
        
        # PHPUnitのインポートチェック
        if 'PHPUnit' in code or 'use PHPUnit' in code:
            results.append("✅ PHPUnitフレームワーク: 検出")
        else:
            quality_issues.append("⚠️ PHPテスト: PHPUnitフレームワークが明示されていません")
            results.append("⚠️ PHPUnitフレームワーク: 未検出")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_javascript_test_code(self, code: str) -> Dict:
        """JavaScriptテストコードの検証"""
        results = []
        quality_issues = []
        
        # テストフレームワークのチェック
        frameworks = ['describe', 'it', 'test', 'expect']
        has_framework = any(framework in code for framework in frameworks)
        
        if not has_framework:
            quality_issues.append("❌ JSテスト: テストフレームワークが検出されません")
            results.append("❌ JSテストフレームワーク: 未検出")
        else:
            results.append("✅ JSテストフレームワーク: 検出")
        
        # アサーションの存在チェック
        assertion_patterns = [
            'expect',
            'assert',
            'should',
            'toBe',
            'toEqual'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("❌ JSテスト: アサーションがありません")
            results.append("❌ JSテストアサーション: 未定義")
        else:
            results.append("✅ JSテストアサーション: 定義済み")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_general_test_code(self, code: str) -> Dict:
        """一般的なテストコードの検証"""
        results = []
        quality_issues = []
        
        # テスト関連キーワードのチェック
        test_keywords = [
            'test', 'assert', 'expect', 'verify',
            'should', 'check', 'validate'
        ]
        
        has_test_keywords = any(keyword in code.lower() for keyword in test_keywords)
        if not has_test_keywords:
            quality_issues.append("❌ テストコード: テスト関連キーワードが不足しています")
            results.append("❌ テストキーワード: 不足")
        else:
            results.append("✅ テストキーワード: 検出")
        
        # 実行可能なコードかチェック（コメントのみでないか）
        lines = code.split('\n')
        code_lines = [line for line in lines if line.strip() and not line.strip().startswith(('//', '#'))]
        
        if len(code_lines) < 3:
            quality_issues.append("❌ テストコード: 実行可能なコードが不足しています")
            results.append("❌ 実行可能コード: 不足")
        else:
            results.append("✅ 実行可能コード: 十分")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _has_test_code(self, task: Dict) -> bool:
        """タスクにテストコードが含まれているかチェック"""
        description = task.get('description', '').lower()
        if any(keyword in description for keyword in ['test', 'テスト', 'testing']):
            return True
        
        # 出力やパラメータからテストコードを探す
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        test_indicators = ['function test', 'class Test', '@Test', 'describe(', 'it(']
        combined_text = f"{output} {parameters}".lower()
        
        return any(indicator in combined_text for indicator in test_indicators)
    
    def _extract_test_code(self, task: Dict) -> str:
        """タスクからテストコードを抽出"""
        # 出力からコードブロックを抽出
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        # コードブロックを検索
        code_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', output, re.DOTALL)
        if code_blocks:
            return '\n'.join(code_blocks)
        
        # パラメータからコードを抽出
        if '```' in parameters:
            param_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', parameters, re.DOTALL)
            if param_blocks:
                return '\n'.join(param_blocks)
        
        return output  # フォールバック
    
    def _is_php_code(self, code: str) -> bool:
        """PHPコードか判定"""
        php_indicators = ['<?php', 'function', 'class', '$this', '->']
        return any(indicator in code for indicator in php_indicators)
    
    def _is_javascript_code(self, code: str) -> bool:
        """JavaScriptコードか判定"""
        js_indicators = ['function', 'const', 'let', 'var', '=>', 'describe', 'it']
        return any(indicator in code for indicator in js_indicators)
    
    async def _measure_page_load_time(self, page: Page, url: str) -> float:
        """ページ読み込み時間を計測"""
        try:
            start_time = datetime.now()
            await page.goto(url, wait_until='networkidle')
            end_time = datetime.now()
            return (end_time - start_time).total_seconds() * 1000  # ミリ秒
        except:
            return 0
    
    def _generate_test_summary(self, test_results: List[str], quality_issues: List[str]) -> str:
        """テスト結果サマリーを生成"""
        summary = []
        
        summary.append("📊 テスト結果サマリー")
        summary.append("=" * 50)
        
        # テスト結果
        summary.append("\n✅ 成功テスト:")
        success_tests = [r for r in test_results if '✅' in r or 'OK' in r]
        for test in success_tests:
            summary.append(f"  • {test}")
        
        # 品質問題
        if quality_issues:
            summary.append("\n❌ 品質問題:")
            for issue in quality_issues:
                summary.append(f"  • {issue}")
        else:
            summary.append("\n🎉 品質問題: なし")
        
        # 統計
        total_tests = len(test_results)
        success_count = len(success_tests)
        issue_count = len(quality_issues)
        
        summary.append("\n📈 統計:")
        summary.append(f"  総テスト数: {total_tests}")
        summary.append(f"  成功テスト: {success_count}")
        summary.append(f"  品質問題: {issue_count}")
        
        if total_tests > 0:
            success_rate = (success_count / total_tests) * 100
            summary.append(f"  成功率: {success_rate:.1f}%")
        
        return '\n'.join(summary)

#wp_tester_agent.py
# wp_tester_agent.py
"""
WordPress自動テストエージェント
WP-CLIとPytestを使用した自動テスト
"""

import asyncio
import logging
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class WPTesterAgent:
    """
    WordPress自動テストエージェント
    
    機能:
    - WP-CLIコマンドのテスト実行
    - Pytestベースのユニットテスト
    - 統合テスト
    - テスト結果の検証と報告
    """
    
    def __init__(
        self,
        command_monitor,
        wp_path: str = "/var/www/html"
    ):
        """
        初期化
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_path: WordPressのパス
        """
        self.cmd_monitor = command_monitor
        self.wp_path = Path(wp_path)
        
        # テスト結果保存ディレクトリ
        self.test_results_dir = Path("./test_results")
        self.test_results_dir.mkdir(parents=True, exist_ok=True)
        
        # 統計情報
        self.stats = {
            "total_tests": 0,
            "passed_tests": 0,
            "failed_tests": 0,
            "skipped_tests": 0
        }
        
        logger.info(f"✅ WPTesterAgent 初期化完了 (WP_PATH={wp_path})")
    
    async def run_tests(self, task_id: str, test_type: str = "auto") -> Dict[str, Any]:
        """
        テストを実行
        
        Args:
            task_id: タスクID
            test_type: テストタイプ (auto, unit, integration, wp-cli)
            
        Returns:
            Dict: テスト結果
        """
        start_time = datetime.now()
        
        try:
            logger.info("=" * 60)
            logger.info(f"🧪 テスト実行開始: {task_id} (タイプ={test_type})")
            logger.info("=" * 60)
            
            self.stats["total_tests"] += 1
            
            if test_type == "auto":
                # タスクIDから適切なテストを自動選択
                result = await self._run_auto_tests(task_id)
            elif test_type == "unit":
                result = await self._run_unit_tests(task_id)
            elif test_type == "integration":
                result = await self._run_integration_tests(task_id)
            elif test_type == "wp-cli":
                result = await self._run_wp_cli_tests(task_id)
            else:
                result = {
                    "passed": False,
                    "error": f"Unknown test type: {test_type}"
                }
            
            # 統計更新
            if result.get("passed"):
                self.stats["passed_tests"] += 1
            else:
                self.stats["failed_tests"] += 1
            
            execution_time = (datetime.now() - start_time).total_seconds()
            result["execution_time"] = execution_time
            
            # 結果を保存
            await self._save_test_result(task_id, result)
            
            logger.info(
                f"{'✅' if result.get('passed') else '❌'} "
                f"テスト{'成功' if result.get('passed') else '失敗'}: {task_id} "
                f"({execution_time:.2f}秒)"
            )
            
            return result
            
        except Exception as e:
            logger.error(f"💥 テスト実行エラー: {e}", exc_info=True)
            self.stats["failed_tests"] += 1
            
            return {
                "passed": False,
                "error": str(e),
                "execution_time": (datetime.now() - start_time).total_seconds()
            }
    
    async def _run_auto_tests(self, task_id: str) -> Dict[str, Any]:
        """タスクに応じた自動テストを実行"""
        
        # タスクIDから種類を判定
        if "CPT" in task_id or "カスタム投稿タイプ" in task_id:
            return await self._test_custom_post_type(task_id)
        
        elif "ACF" in task_id or "カスタムフィールド" in task_id:
            return await self._test_acf_fields(task_id)
        
        elif "投稿" in task_id or "post" in task_id.lower():
            return await self._test_post_creation(task_id)
        
        elif "プラグイン" in task_id or "plugin" in task_id.lower():
            return await self._test_plugin_activation(task_id)
        
        else:
            # デフォルト: 基本的なWPチェック
            return await self._test_wp_health()
    
    async def _run_unit_tests(self, task_id: str) -> Dict[str, Any]:
        """ユニットテストを実行"""
        try:
            # Pytest実行
            cmd = f"pytest tests/unit/ -v --tb=short --json-report --json-report-file={self.test_results_dir / f'{task_id}_unit.json'}"
            
            result = await self.cmd_monitor.execute_command(cmd)
            
            if result.get("success"):
                # JSONレポートを読み込み
                report_file = self.test_results_dir / f"{task_id}_unit.json"
                if report_file.exists():
                    report = json.loads(report_file.read_text())
                    
                    return {
                        "passed": report.get("summary", {}).get("failed", 0) == 0,
                        "total": report.get("summary", {}).get("total", 0),
                        "passed_count": report.get("summary", {}).get("passed", 0),
                        "failed_count": report.get("summary", {}).get("failed", 0),
                        "report": report
                    }
            
            return {
                "passed": False,
                "error": result.get("stderr", "Unit test execution failed")
            }
            
        except Exception as e:
            logger.error(f"❌ ユニットテストエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _run_integration_tests(self, task_id: str) -> Dict[str, Any]:
        """統合テストを実行"""
        try:
            cmd = f"pytest tests/integration/ -v --tb=short"
            result = await self.cmd_monitor.execute_command(cmd)
            
            return {
                "passed": result.get("success", False),
                "output": result.get("stdout", ""),
                "error": result.get("stderr") if not result.get("success") else None
            }
            
        except Exception as e:
            logger.error(f"❌ 統合テストエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _run_wp_cli_tests(self, task_id: str) -> Dict[str, Any]:
        """WP-CLI基本テストを実行"""
        tests = [
            ("wp core version", "WordPressバージョン確認"),
            ("wp plugin list --status=active", "プラグイン一覧"),
            ("wp theme list --status=active", "アクティブテーマ確認"),
        ]
        
        results = []
        all_passed = True
        
        for cmd, description in tests:
            logger.info(f"🔍 テスト: {description}")
            result = await self.cmd_monitor.execute_command(cmd)
            
            passed = result.get("success", False)
            results.append({
                "test": description,
                "command": cmd,
                "passed": passed,
                "output": result.get("stdout", "")
            })
            
            if not passed:
                all_passed = False
        
        return {
            "passed": all_passed,
            "tests": results
        }
    
    # ========================================
    # 専門テスト関数
    # ========================================
    
    async def _test_custom_post_type(self, task_id: str) -> Dict[str, Any]:
        """カスタム投稿タイプのテスト"""
        try:
            # CPT一覧を取得
            cmd = "wp post-type list --format=json"
            result = await self.cmd_monitor.execute_command(cmd)
            
            if not result.get("success"):
                return {
                    "passed": False,
                    "error": "Failed to list post types"
                }
            
            # タスクIDからCPT名を推定（例: Task 54 → ma_case）
            cpt_name = self._extract_cpt_name_from_task(task_id)
            
            if cpt_name:
                # 特定のCPTをチェック
                post_types = json.loads(result.get("stdout", "[]"))
                cpt_exists = any(pt.get("name") == cpt_name for pt in post_types)
                
                if cpt_exists:
                    logger.info(f"✅ CPT '{cpt_name}' が正常に登録されています")
                    return {"passed": True, "cpt_name": cpt_name}
                else:
                    logger.warning(f"⚠️ CPT '{cpt_name}' が見つかりません")
                    return {
                        "passed": False,
                        "error": f"CPT '{cpt_name}' not found",
                        "cpt_name": cpt_name
                    }
            else:
                # 汎用チェック
                return {"passed": True, "message": "Post types list retrieved successfully"}
                
        except Exception as e:
            logger.error(f"❌ CPTテストエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_acf_fields(self, task_id: str) -> Dict[str, Any]:
        """ACFフィールドのテスト"""
        try:
            # ACFフィールドグループを取得
            cmd = "wp acf export --format=json"
            result = await self.cmd_monitor.execute_command(cmd)
            
            if not result.get("success"):
                # ACFコマンドがない場合
                logger.warning("⚠️ ACF WP-CLIコマンドが利用できません")
                return {
                    "passed": False,
                    "error": "ACF CLI not available"
                }
            
            # フィールドグループの存在確認
            field_groups = json.loads(result.get("stdout", "[]"))
            
            if field_groups and len(field_groups) > 0:
                logger.info(f"✅ ACFフィールドグループ: {len(field_groups)}個")
                return {
                    "passed": True,
                    "field_group_count": len(field_groups)
                }
            else:
                return {
                    "passed": False,
                    "error": "No ACF field groups found"
                }
                
        except Exception as e:
            logger.error(f"❌ ACFテストエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_post_creation(self, task_id: str) -> Dict[str, Any]:
        """投稿作成のテスト"""
        try:
            # テスト投稿を作成
            test_title = f"Test Post {datetime.now().strftime('%Y%m%d_%H%M%S')}"
            cmd = f'wp post create --post_title="{test_title}" --post_content="Test content" --post_status=draft --porcelain'
            
            result = await self.cmd_monitor.execute_command(cmd)
            
            if result.get("success"):
                post_id = result.get("stdout", "").strip()
                logger.info(f"✅ テスト投稿作成成功: ID={post_id}")
                
                # 作成した投稿を削除
                delete_cmd = f"wp post delete {post_id} --force"
                await self.cmd_monitor.execute_command(delete_cmd)
                
                return {
                    "passed": True,
                    "test_post_id": post_id
                }
            else:
                return {
                    "passed": False,
                    "error": result.get("stderr", "Post creation failed")
                }
                
        except Exception as e:
            logger.error(f"❌ 投稿作成テストエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_plugin_activation(self, task_id: str) -> Dict[str, Any]:
        """プラグイン有効化のテスト"""
        try:
            # アクティブなプラグイン一覧
            cmd = "wp plugin list --status=active --format=json"
            result = await self.cmd_monitor.execute_command(cmd)
            
            if result.get("success"):
                plugins = json.loads(result.get("stdout", "[]"))
                logger.info(f"✅ アクティブなプラグイン: {len(plugins)}個")
                
                return {
                    "passed": True,
                    "active_plugin_count": len(plugins),
                    "plugins": [p.get("name") for p in plugins]
                }
            else:
                return {
                    "passed": False,
                    "error": "Failed to list plugins"
                }
                
        except Exception as e:
            logger.error(f"❌ プラグインテストエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_wp_health(self) -> Dict[str, Any]:
        """WordPress全体の健全性チェック"""
        try:
            checks = []
            
            # 1. WordPressバージョン
            result = await self.cmd_monitor.execute_command("wp core version")
            checks.append({
                "check": "WordPress Version",
                "passed": result.get("success", False),
                "value": result.get("stdout", "").strip()
            })
            
            # 2. データベース接続
            result = await self.cmd_monitor.execute_command("wp db check")
            checks.append({
                "check": "Database Connection",
                "passed": result.get("success", False)
            })
            
            # 3. テーマ
            result = await self.cmd_monitor.execute_command("wp theme list --status=active")
            checks.append({
                "check": "Active Theme",
                "passed": result.get("success", False)
            })
            
            all_passed = all(c["passed"] for c in checks)
            
            return {
                "passed": all_passed,
                "checks": checks
            }
            
        except Exception as e:
            logger.error(f"❌ 健全性チェックエラー: {e}")
            return {"passed": False, "error": str(e)}
    
    # ========================================
    # ユーティリティ
    # ========================================
    
    def _extract_cpt_name_from_task(self, task_id: str) -> Optional[str]:
        """タスクIDからCPT名を抽出"""
        # 例: Task 54 → ma_case
        if "54" in task_id or "M&A案件" in task_id:
            return "ma_case"
        
        # 他のパターンをここに追加
        
        return None
    
    async def _save_test_result(self, task_id: str, result: Dict[str, Any]):
        """テスト結果を保存"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = self.test_results_dir / f"{task_id}_{timestamp}.json"
            
            result_with_metadata = {
                "task_id": task_id,
                "timestamp": datetime.now().isoformat(),
                **result
            }
            
            await asyncio.to_thread(
                filename.write_text,
                json.dumps(result_with_metadata, indent=2, ensure_ascii=False)
            )
            
            logger.info(f"💾 テスト結果保存: {filename}")
            
        except Exception as e:
            logger.error(f"❌ テスト結果保存エラー: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """統計情報を取得"""
        success_rate = 0.0
        if self.stats["total_tests"] > 0:
            success_rate = self.stats["passed_tests"] / self.stats["total_tests"]
        
        return {
            **self.stats,
            "success_rate": success_rate
        }

#wp_utils.py
"""WordPressユーティリティ (Google Drive対応版)
このモジュールは、WordPressタスクの処理に必要な各種ユーティリティクラスを提供します。
主な機能:
- タスク内容の取得（Google Drive、JSON、ローカルファイル対応）
- タスクタイプの分析と判定
- WordPressプラグイン・設定管理
- HTMLクリーニング・最適化
"""

import re
import logging
from typing import Optional, Tuple, Dict, List
from pathlib import Path
import json

# ロガーの初期化
logger = logging.getLogger(__name__)


# ============================================================================
# TaskContentFetcher: タスク内容取得クラス
# ============================================================================

class TaskContentFetcher:
    """タスク内容取得ユーティリティ (Google Drive対応)
    
    複数のソースから記事コンテンツを取得する機能を提供:
    1. Google Driveリンク（最優先）
    2. JSONファイルパス
    3. ローカルMarkdownファイル
    4. task_logシート（フォールバック）
    """
    
    @staticmethod
    def extract_task_id(description: str) -> Optional[int]:
        """説明文からtask_idを抽出
        
        対応形式:
        - task_id 39
        - task id 39
        - タスクID 39
        
        Args:
            description: タスク説明文
            
        Returns:
            抽出されたtask_id、見つからない場合はNone
        """
        # 複数のパターンでtask_idを検索
        patterns = [
            r'task[_\s]+id[\s　]*(\d+)',  # task_id, task id形式
            r'タスク[\s　]*ID[\s　]*(\d+)',  # 日本語形式
        ]
        
        for pattern in patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                task_id = int(match.group(1))
                logger.info(f"✅ task_id抽出: {task_id}")
                return task_id
        
        logger.debug("task_idが見つかりませんでした")
        return None

    @staticmethod
    async def get_task_content(sheets_manager, task_id: int) -> Optional[str]:
        """指定されたtask_idの記事内容を取得(超堅牢版)
        
        優先順位:
        1. task_execution_log シートの Google Drive リンク(最優先)
        2. task_execution_log シートの output_data カラム(JSONファイルパス)
        3. task_execution_log シートのローカルマークダウンファイルパス
        4. task_log シート(フォールバック)
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
            task_id: タスクID
            
        Returns:
            記事内容(テキスト)、失敗時はNone
        """
        try:
            logger.info("="*60)
            logger.info(f"【記事取得開始】task_id={task_id}")
            logger.info("="*60)
            
            # === パート1: sheets_managerの検証 ===
            if not TaskContentFetcher._validate_sheets_manager(sheets_manager):
                return None
            
            # === パート2: スプレッドシートを開く ===
            sheet = TaskContentFetcher._open_spreadsheet(sheets_manager)
            if not sheet:
                return None
            
            # === パート3: task_execution_logから取得を試みる ===
            logger.info("\n【優先度1】task_execution_logから取得を試みます")
            content = await TaskContentFetcher._get_from_execution_log(
                sheet, task_id, sheets_manager
            )
            
            if content:
                logger.info(f"✅ 記事取得成功: {len(content)}文字")
                return content
            
            # === パート4: フォールバック - task_logから取得 ===
            logger.info("\n【優先度2】task_logから取得を試みます(フォールバック)")
            content = await TaskContentFetcher._get_from_task_log(
                sheet, task_id
            )
            
            if content:
                logger.info(f"✅ 記事取得成功(task_log): {len(content)}文字")
                return content
            
            logger.error("❌ すべての方法で記事取得に失敗しました")
            return None
            
        except Exception as e:
            logger.error(f"❌ task_id {task_id} の内容取得エラー: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _validate_sheets_manager(sheets_manager) -> bool:
        """sheets_managerの妥当性を検証
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            検証成功時True、失敗時False
        """
        if not sheets_manager:
            logger.error("❌ sheets_managerが設定されていません")
            return False
        
        if not sheets_manager.gc:
            logger.error("❌ Google Sheetsクライアントが初期化されていません")
            return False
        
        logger.info("✅ sheets_manager検証完了")
        return True

    @staticmethod
    def _open_spreadsheet(sheets_manager):
        """スプレッドシートを開く
        
        Args:
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            スプレッドシートオブジェクト、失敗時None
        """
        logger.info(f"📊 スプレッドシートを開く: {sheets_manager.spreadsheet_id}")
        try:
            sheet = sheets_manager.gc.open_by_key(sheets_manager.spreadsheet_id)
            logger.info("✅ スプレッドシート接続成功")
            return sheet
        except Exception as e:
            logger.error(f"❌ スプレッドシート接続失敗: {e}")
            return None

    @staticmethod
    async def _get_from_execution_log(sheet, task_id: int, sheets_manager) -> Optional[str]:
        """task_execution_log シートから取得(超詳細ログ版)
        
        優先順位:
        1. Google Driveリンク
        2. output_data(JSONファイルパス)
        3. ローカルマークダウンファイル
        
        Args:
            sheet: スプレッドシートオブジェクト
            task_id: タスクID
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            記事内容、失敗時None
        """
        try:
            # === パート1: シートを開く ===
            logger.debug("【切り分け1】task_execution_logシートを開く")
            try:
                execution_log_sheet = sheet.worksheet("task_execution_log")
                logger.info("✅ task_execution_logシート発見")
            except Exception as e:
                logger.warning(f"❌ task_execution_logシートが見つかりません: {e}")
                return None
            
            # === パート2: シートデータを取得 ===
            logger.debug("【切り分け2】シートデータを取得")
            execution_log_data = execution_log_sheet.get_all_values()
            
            if len(execution_log_data) == 0:
                logger.warning("❌ task_execution_logシートが空です")
                return None
            
            logger.info(f"✅ {len(execution_log_data)}行のデータを取得")
            
            # === パート3: ヘッダー行を解析してカラムインデックスを特定 ===
            column_indices = TaskContentFetcher._parse_header_columns(execution_log_data[0])
            if column_indices['task_id_col'] is None:
                logger.warning("❌ task_id カラムが見つかりません")
                return None
            
            # === パート4: 対象のtask_idを検索 ===
            logger.debug(f"【切り分け6】task_id={task_id}を検索中...")
            for row_idx, row in enumerate(execution_log_data[1:], start=2):
                if len(row) <= column_indices['task_id_col']:
                    continue
                
                try:
                    task_id_in_row = int(row[column_indices['task_id_col']])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"✅ task_id {task_id} を行 {row_idx} で発見")
                    logger.debug(f"行内容: {row[:min(len(row), 10)]}...")
                    
                    # === パート5: データソースから記事を取得 ===
                    content = await TaskContentFetcher._fetch_content_from_sources(
                        row, column_indices, sheets_manager
                    )
                    
                    if content:
                        return content
                    
                    logger.warning(f"❌ task_id {task_id} のデータがすべて空です")
                    return None
            
            logger.warning(f"❌ task_id {task_id} が task_execution_log に見つかりませんでした")
            return None
            
        except Exception as e:
            logger.error(f"❌ task_execution_log からの取得エラー: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _parse_header_columns(headers: List[str]) -> Dict[str, Optional[int]]:
        """ヘッダー行を解析してカラムインデックスを特定
        
        Args:
            headers: ヘッダー行のリスト
            
        Returns:
            カラムインデックスの辞書
        """
        logger.debug("【切り分け3】ヘッダー行を解析")
        logger.debug(f"ヘッダー: {headers}")
        
        column_indices = {
            'task_id_col': None,
            'output_data_col': None,
            'markdown_file_col': None,
            'drive_link_col': None
        }
        
        logger.debug("【切り分け4】カラムインデックスを特定")
        for i, header in enumerate(headers):
            header_lower = header.lower().strip()
            
            if 'task_id' in header_lower or 'タスクid' in header_lower:
                column_indices['task_id_col'] = i
                logger.debug(f"  → task_id列: {i}")
            elif 'output_data' in header_lower or 'full_text' in header_lower or '出力データ' in header_lower or '出力' in header_lower:
                column_indices['output_data_col'] = i
                logger.debug(f"  → output_data列: {i}")
            elif 'drive' in header_lower or 'link' in header_lower or 'url' in header_lower or 'リンク' in header_lower:
                column_indices['drive_link_col'] = i
                logger.debug(f"  → drive_link列: {i}")
            elif 'markdown' in header_lower or 'file' in header_lower or 'ファイル' in header_lower:
                column_indices['markdown_file_col'] = i
                logger.debug(f"  → markdown列: {i}")
        
        logger.debug(f"【切り分け5】カラム特定結果")
        for key, value in column_indices.items():
            logger.debug(f"  {key}: {value}")
        
        return column_indices

    @staticmethod
    async def _fetch_content_from_sources(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """複数のソースから記事内容を取得（優先順位付き）
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            記事内容、失敗時None
        """
        # 優先度1: Google Driveリンク
        content = await TaskContentFetcher._fetch_from_drive_link(
            row, column_indices, sheets_manager
        )
        if content:
            return content
        
        # 優先度2: output_data(JSONファイルまたは直接テキスト)
        content = TaskContentFetcher._fetch_from_output_data(
            row, column_indices
        )
        if content:
            return content
        
        # 優先度3: ローカルマークダウンファイル
        content = TaskContentFetcher._fetch_from_markdown_file(
            row, column_indices
        )
        if content:
            return content
        
        return None

    @staticmethod
    async def _fetch_from_drive_link(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """Google Driveリンクから記事を取得
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            sheets_manager: GoogleSheetsManagerインスタンス
            
        Returns:
            記事内容、失敗時None
        """
        logger.debug("【切り分け7】Google Driveリンクをチェック")
        drive_link_col = column_indices.get('drive_link_col')
        
        if drive_link_col is not None and len(row) > drive_link_col:
            drive_link = row[drive_link_col].strip()
            logger.debug(f"  drive_link列の値: '{drive_link}'")
            
            if drive_link and len(drive_link) > 0:
                logger.info(f"🔗 Google Drive リンクを発見")
                logger.debug(f"  URL: {drive_link[:80]}...")
                
                # Google Driveから読み込み
                logger.debug("【切り分け8】Google Driveから記事を読み込み中...")
                content = sheets_manager.read_file_from_drive(drive_link)
                
                if content:
                    logger.info(f"✅ Google Driveから記事取得成功")
                    logger.debug(f"  文字数: {len(content)}")
                    logger.debug(f"  先頭100文字: {content[:100]}...")
                    return content
                else:
                    logger.warning("❌ Google Driveからの読み込みに失敗")
            else:
                logger.debug("  → drive_link列が空")
        else:
            logger.debug("  → drive_link列なし")
        
        return None

    @staticmethod
    def _fetch_from_output_data(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """output_dataカラムから記事を取得（JSONまたは直接テキスト）
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            
        Returns:
            記事内容、失敗時None
        """
        logger.debug("【切り分け9】output_dataをチェック")
        output_data_col = column_indices.get('output_data_col')
        
        if output_data_col is not None and len(row) > output_data_col:
            output_data = row[output_data_col].strip()
            logger.debug(f"  output_data列の長さ: {len(output_data)}文字")
            
            if output_data and len(output_data) > 0:
                # JSONファイルパスかどうかを判定
                if output_data.endswith('.json'):
                    logger.info(f"  → JSONファイルと判定: {output_data}")
                    return TaskContentFetcher._read_json_file(output_data)
                else:
                    # 通常のテキストとして扱う
                    logger.info(f"✅ output_data から記事取得(直接)")
                    logger.debug(f"  先頭100文字: {output_data[:100]}...")
                    return output_data
            else:
                logger.debug("  → output_data列が空")
        else:
            logger.debug("  → output_data列なし")
        
        return None

    @staticmethod
    def _read_json_file(json_path_str: str) -> Optional[str]:
        """JSONファイルから記事を読み込む
        
        Args:
            json_path_str: JSONファイルパス
            
        Returns:
            記事内容、失敗時None
        """
        json_path = Path(json_path_str)
        
        # 絶対パスでない場合、候補パスを試す
        if not json_path.is_absolute():
            candidates = [
                Path.cwd() / json_path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / json_path.name,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / json_path.name,
            ]
            for candidate in candidates:
                if candidate.exists():
                    json_path = candidate
                    break
        
        if json_path.exists():
            logger.info(f"  → JSONファイル読み込み: {json_path}")
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                # html_contentを取得
                html_content = json_data.get('html_content', '')
                if html_content:
                    logger.info(f"✅ JSONからHTML記事取得成功: {len(html_content)}文字")
                    logger.debug(f"  先頭100文字: {html_content[:100]}...")
                    return html_content
                else:
                    logger.warning("❌ JSONにhtml_contentがありません")
            except Exception as e:
                logger.error(f"❌ JSONファイル読み込みエラー: {e}")
        else:
            logger.warning(f"❌ JSONファイルが見つかりません: {json_path}")
        
        return None

    @staticmethod
    def _fetch_from_markdown_file(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """ローカルマークダウンファイルから記事を取得
        
        Args:
            row: データ行
            column_indices: カラムインデックス辞書
            
        Returns:
            記事内容、失敗時None
        """
        logger.debug("【切り分け10】ローカルファイルをチェック")
        markdown_file_col = column_indices.get('markdown_file_col')
        
        if markdown_file_col is not None and len(row) > markdown_file_col:
            markdown_path = row[markdown_file_col]
            logger.debug(f"  markdown列の値: '{markdown_path}'")
            
            if markdown_path and len(markdown_path.strip()) > 0:
                content = TaskContentFetcher._read_local_markdown_file(markdown_path)
                if content:
                    return content
            else:
                logger.debug("  → markdown列が空")
        else:
            logger.debug("  → markdown列なし")
        
        return None

    @staticmethod
    async def _get_from_task_log(sheet, task_id: int) -> Optional[str]:
        """task_log シートから取得(フォールバック)
        
        Args:
            sheet: スプレッドシートオブジェクト
            task_id: タスクID
            
        Returns:
            記事内容、失敗時None
        """
        try:
            task_log_sheet = sheet.worksheet("task_log")
            task_log_data = task_log_sheet.get_all_values()
            
            if len(task_log_data) == 0:
                return None
            
            headers = task_log_data[0]
            
            # カラムインデックスを特定
            task_id_col = None
            output_data_col = None
            
            for i, header in enumerate(headers):
                if 'task_id' in header.lower():
                    task_id_col = i
                elif 'output_data' in header.lower() or 'full_text' in header.lower():
                    output_data_col = i
            
            # デフォルト値を設定
            if task_id_col is None:
                task_id_col = 1
            
            if output_data_col is None:
                output_data_col = len(headers) - 1
            
            # task_idを検索
            for row_idx, row in enumerate(task_log_data[1:], start=2):
                if len(row) <= task_id_col:
                    continue
                
                try:
                    task_id_in_row = int(row[task_id_col])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"✅ task_id {task_id} を task_log の行 {row_idx} で発見")
                    
                    if output_data_col and len(row) > output_data_col:
                        full_text = row[output_data_col]
                        if full_text and len(full_text) > 0:
                            logger.info(f"✅ task_log から取得 ({len(full_text)}文字)")
                            return full_text
            
            return None
            
        except Exception as e:
            logger.error(f"task_log からの取得エラー: {e}")
            return None

    @staticmethod
    def _read_local_markdown_file(file_path: str) -> Optional[str]:
        """ローカルのマークダウンファイルを読み込む(強化版)
        
        Args:
            file_path: ファイルパス
            
        Returns:
            ファイル内容、失敗時None
        """
        try:
            logger.debug("【ローカルファイル読み込み】")
            logger.debug(f"  ファイルパス: {file_path}")
            
            path = Path(file_path.strip())
            
            # 絶対パスの場合
            if path.is_absolute():
                logger.debug("  → 絶対パスとして処理")
                if path.exists():
                    logger.debug(f"  → ファイル存在確認: OK")
                    with open(path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    logger.info(f"✅ ファイル読み込み成功: {len(content)}文字")
                    logger.debug(f"  先頭100文字: {content[:100]}...")
                    
                    # タイトルと本文を抽出
                    content = TaskContentFetcher._extract_title_and_body(content)
                    
                    return content
                else:
                    logger.warning(f"❌ ファイルが見つかりません: {path}")
                    return None
            
            # 相対パスの場合、候補パスを試す
            logger.debug("  → 相対パスとして処理")
            candidates = [
                Path.cwd() / path,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "AI_Agent" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / path.name,
            ]
            
            logger.debug(f"  候補パス数: {len(candidates)}")
            
            for i, candidate in enumerate(candidates, 1):
                logger.debug(f"  候補{i}: {candidate}")
                if candidate.exists():
                    logger.info(f"  → ファイル発見: {candidate}")
                    path = candidate
                    break
            
            if not path.exists():
                logger.warning(f"❌ すべての候補でファイルが見つかりません")
                for candidate in candidates:
                    logger.warning(f"  試行: {candidate}")
                return None
            
            logger.info(f"📄 ファイル読み込み中: {path}")
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            logger.info(f"✅ ファイル読み込み成功: {len(content)}文字")
            logger.debug(f"  先頭100文字: {content[:100]}...")
            
            # タイトルと本文を抽出
            content = TaskContentFetcher._extract_title_and_body(content)
            
            return content
            
        except Exception as e:
            logger.error(f"❌ ファイル読み込みエラー: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    @staticmethod
    def _extract_title_and_body(content: str) -> str:
        """マークダウンファイルからタイトルと本文を抽出
        
        <!-- メタデータ --> や <!-- コメント --> を除去し、
        タイトル(# で始まる行)と本文のみを抽出
        
        Args:
            content: 元のマークダウンコンテンツ
            
        Returns:
            クリーニングされたコンテンツ
        """
        try:
            lines = content.split('\n')
            result_lines = []
            in_comment = False
            
            for line in lines:
                # HTMLコメント開始
                if '<!--' in line:
                    in_comment = True
                    continue
                
                # HTMLコメント終了
                if '-->' in line:
                    in_comment = False
                    continue
                
                # コメント内はスキップ
                if in_comment:
                    continue
                
                # 空行が連続する場合は1つだけにする
                if line.strip() == '':
                    if result_lines and result_lines[-1].strip() == '':
                        continue
                
                result_lines.append(line)
            
            # 先頭と末尾の空行を削除
            while result_lines and result_lines[0].strip() == '':
                result_lines.pop(0)
            
            while result_lines and result_lines[-1].strip() == '':
                result_lines.pop()
            
            cleaned_content = '\n'.join(result_lines)
            
            logger.debug(f"【記事クリーンアップ完了】")
            logger.debug(f"  元の文字数: {len(content)}")
            logger.debug(f"  処理後の文字数: {len(cleaned_content)}")
            logger.debug(f"  先頭100文字: {cleaned_content[:100]}...")
            
            return cleaned_content
            
        except Exception as e:
            logger.warning(f"記事クリーンアップエラー: {e}")
            return content


# ============================================================================
# TaskTypeAnalyzer: タスクタイプ分析クラス
# ============================================================================

class TaskTypeAnalyzer:
    """タスク内容からタイプを判定
    
    タスクの説明文を解析して、適切なタスクタイプを返す。
    """

    @staticmethod
    def analyze(description: str) -> str:
        """タスク内容からタイプを判定
        
        Args:
            description: タスク説明文
            
        Returns:
            タスクタイプ文字列
        """
        description_lower = description.lower()
        
        # 新しい判定ルールを追加
        if 'polylang' in description_lower and '言語' in description_lower:
            return 'edit_post'
        
        if '投稿' in description and '探して' in description and (
            '変更' in description or '編集' in description or '書き換え' in description
        ):
            return 'edit_post'
        
        if 'プラグイン' in description and (
            '変更' in description or '設定' in description
        ) and 'インストール' not in description:
            return 'plugin_settings'
        
        if 'プラグイン' in description and 'インストール' in description:
            return 'plugin_install'
        
        if 'テーマ' in description or 'theme' in description_lower:
            return 'theme_change'
        
        if '設定' in description or 'setting' in description_lower:
            return 'setting_change'
        
        if ('投稿' in description or '記事' in description or 'post' in description_lower) and (
            '作成' in description or '保存' in description
        ):
            return 'content_create'
        
        if 'テスト' in description or 'test' in description_lower:
            return 'test_functionality'
        
        return 'generic'


# ============================================================================
# WordPressConfig: WordPress設定クラス
# ============================================================================

class WordPressConfig:
    """WordPress設定クラス
    
    WordPress関連の設定値を一元管理する。
    - WordPress URL
    - Polylang言語コード
    - ACFフィールドタイプ
    - 推奨プラグイン
    - M&A案件デフォルトフィールド
    - FacetWPデフォルト設定
    """
    
    # WordPress URLの設定(実際のサイトURLに変更してください)
    WORDPRESS_URL = "https://your-site.com"
    
    # Polylang言語コード定義
    POLYLANG_LANGS = {
        'ja': 'ja',           # 日本語
        'en': 'en',           # 英語
        'ru': 'ru',           # ロシア語
        'uz': 'uz_UZ',        # ウズベク語
        'zh': 'zh_CN',        # 中国語(簡体字)
        'ko': 'ko_KR',        # 韓国語
        'tr': 'tr_TR'         # トルコ語
    }
    
    # ACFフィールドタイプ定義
    ACF_FIELD_TYPES = {
        # テキスト系
        'text': 'テキスト(1行)',
        'textarea': 'テキストエリア(複数行)',
        'number': '数値',
        'email': 'メールアドレス',
        'url': 'URL',
        'password': 'パスワード',
        
        # 選択系
        'select': 'セレクトメニュー',
        'checkbox': 'チェックボックス',
        'radio': 'ラジオボタン',
        'true_false': '真偽値',
        
        # 日付時刻系
        'date_picker': '日付選択',
        'date_time_picker': '日付時刻選択',
        'time_picker': '時刻選択',
        
        # ファイル系
        'file': 'ファイル',
        'image': '画像',
        'gallery': 'ギャラリー',
        
        # リレーション系
        'post_object': '投稿オブジェクト',
        'relationship': 'リレーションシップ',
        'taxonomy': 'タクソノミー',
        'user': 'ユーザー',
        
        # レイアウト系
        'repeater': 'リピーター',
        'flexible_content': 'フレキシブルコンテンツ',
        'group': 'グループ',
        
        # その他
        'wysiwyg': 'WYSIWYGエディタ',
        'oembed': 'oEmbed',
        'google_map': 'Googleマップ',
        'color_picker': 'カラーピッカー'
    }
    
    # WordPressプラグイン定義
    WORDPRESS_PLUGINS = {
        # 必須プラグイン
        'required': [
            {
                'name': 'Advanced Custom Fields PRO',
                'slug': 'advanced-custom-fields-pro',
                'version': '6.2+',
                'purpose': 'カスタムフィールド管理',
                'priority': 'critical'
            },
            {
                'name': 'Custom Post Type UI',
                'slug': 'custom-post-type-ui',
                'version': '1.15+',
                'purpose': 'カスタム投稿タイプ管理',
                'priority': 'critical'
            },
            {
                'name': 'Polylang Pro',
                'slug': 'polylang-pro',
                'version': '3.5+',
                'purpose': '多言語対応',
                'priority': 'critical'
            }
        ],
        
        # 推奨プラグイン(検索強化)
        'search': [
            {
                'name': 'FacetWP',
                'slug': 'facetwp',
                'purpose': '絞り込み検索',
                'priority': 'high'
            },
            {
                'name': 'Relevanssi',
                'slug': 'relevanssi',
                'purpose': '検索精度向上',
                'priority': 'high'
            },
            {
                'name': 'SearchWP',
                'slug': 'searchwp',
                'purpose': '検索機能強化',
                'priority': 'medium'
            }
        ],
        
        # 推奨プラグイン(ユーザー管理)
        'user_management': [
            {
                'name': 'User Role Editor',
                'slug': 'user-role-editor',
                'purpose': 'ユーザーロール管理',
                'priority': 'high'
            },
            {
                'name': 'Members',
                'slug': 'members',
                'purpose': '権限管理',
                'priority': 'medium'
            }
        ],
        
        # 推奨プラグイン(セキュリティ)
        'security': [
            {
                'name': 'Wordfence Security',
                'slug': 'wordfence',
                'purpose': '総合セキュリティ',
                'priority': 'high'
            },
            {
                'name': 'iThemes Security',
                'slug': 'ithemes-security-pro',
                'purpose': 'セキュリティ強化',
                'priority': 'medium'
            }
        ],
        
        # 推奨プラグイン(パフォーマンス)
        'performance': [
            {
                'name': 'WP Rocket',
                'slug': 'wp-rocket',
                'purpose': 'キャッシュ・最適化',
                'priority': 'high'
            },
            {
                'name': 'Autoptimize',
                'slug': 'autoptimize',
                'purpose': 'CSS/JS最適化',
                'priority': 'medium'
            }
        ]
    }
    
    # M&A案件デフォルトフィールド設定
    MA_CASE_DEFAULT_FIELDS = {
        'case_id': {
            'type': 'text',
            'label': '案件ID',
            'required': True
        },
        'ma_scheme': {
            'type': 'select',
            'label': 'M&Aスキーム',
            'choices': ['株式譲渡', '事業譲渡', '合併', '会社分割'],
            'required': True
        },
        'desired_price': {
            'type': 'number',
            'label': '希望価格',
            'min': 0,
            'step': 1000000,
            'required': False
        },
        'industry_category': {
            'type': 'taxonomy',
            'label': '業種',
            'taxonomy': 'industry_category',
            'required': True
        },
        'region': {
            'type': 'taxonomy',
            'label': '地域',
            'taxonomy': 'region',
            'required': True
        },
        'established_year': {
            'type': 'number',
            'label': '設立年',
            'min': 1900,
            'max': 2025,
            'required': False
        },
        'employees': {
            'type': 'number',
            'label': '従業員数',
            'min': 0,
            'required': False
        },
        'annual_revenue': {
            'type': 'number',
            'label': '年商',
            'min': 0,
            'required': False
        },
        'annual_profit': {
            'type': 'number',
            'label': '年間利益',
            'required': False
        },
        'reason_for_sale': {
            'type': 'textarea',
            'label': '売却理由',
            'required': False
        },
        'strengths': {
            'type': 'textarea',
            'label': '強み',
            'required': False
        }
    }
    
    # FacetWPデフォルト設定
    FACETWP_DEFAULT_FACETS = [
        {
            'name': '業種フィルター',
            'type': 'checkboxes',
            'source': 'tax/industry_category',
            'label': '業種で絞り込む'
        },
        {
            'name': '価格帯フィルター',
            'type': 'slider',
            'source': 'cf/desired_price',
            'label': '希望価格',
            'min': 0,
            'max': 1000000000,
            'step': 10000000,
            'format': '¥{value}'
        },
        {
            'name': '地域フィルター',
            'type': 'dropdown',
            'source': 'tax/region',
            'label': '地域で絞り込む'
        },
        {
            'name': '従業員数フィルター',
            'type': 'slider',
            'source': 'cf/employees',
            'label': '従業員数',
            'min': 0,
            'max': 1000,
            'step': 10
        }
    ]


# ============================================================================
# TaskRouter: タスク振り分けクラス
# ============================================================================

class TaskRouter:
    """タスクの振り分けを行うユーティリティクラス
    
    タスクの内容を解析して、適切なタイプ(M&A/記事生成/レビュー/デフォルト)を判定する。
    """
    
    # M&A関連の強力なキーワード
    MA_STRONG_KEYWORDS = [
        'custom post type', 'カスタム投稿タイプ', 'cpt',
        'acf設定', 'acf', 'カスタムフィールド', 'custom field',
        'taxonomy', 'タクソノミー', 'カテゴリ作成',
        'm&a案件', 'ma_case', 'ma case',
        '企業検索', '案件管理', '案件投稿',
        'facetwp', 'facet', '絞り込み検索',
        'user role', 'ユーザーロール', '権限管理'
    ]
    
    # 記事生成関連のキーワード
    CONTENT_KEYWORDS = [
        '記事作成', '記事執筆', 'article', 'content creation',
        '【日本語】', '【英語】', '【ロシア語】', '【ウズベク語】',
        '【中国語】', '【韓国語】', '【トルコ語】',
        'ブログ', 'blog post', 'seo記事'
    ]
    
    # 記事生成系エージェント
    CONTENT_AGENTS = [
        'writer', 'writer_ja', 'writer_en', 'writer_ru',
        'writer_uz', 'writer_zh', 'writer_ko', 'writer_tr',
        'content'
    ]
    
    # M&A関連パラメータキー
    MA_PARAMETER_KEYS = [
        'cpt_slug', 'cpt_labels', 'cpt_supports',
        'acf_field_group_name', 'acf_fields', 'acf_location_rules',
        'taxonomy_slug', 'taxonomy_labels', 'taxonomy_post_types',
        'facets', 'role_slug', 'role_name'
    ]
    
    # 記事生成関連パラメータキー
    CONTENT_PARAMETER_KEYS = [
        'language', 'polylang_lang', 'seo_keywords',
        'target_audience', 'target_url', 'article_type'
    ]
    
    @staticmethod
    def determine_task_type(task: dict) -> str:
        """タスクのタイプを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            'ma' - M&A/企業検索タスク
            'content' - 記事生成タスク
            'review' - レビュータスク
            'default' - その他のタスク
        """
        description = task.get('description', '').lower()
        agent = task.get('required_role', '').lower()
        parameters = task.get('parameters', {})
        
        # 1. レビュータスクの判定(最優先)
        if agent == 'review' or 'review_target_task_id' in parameters:
            return 'review'
        
        # 2. M&A関連タスクの判定
        # 2-1. 強力なキーワードマッチング
        if any(keyword in description for keyword in TaskRouter.MA_STRONG_KEYWORDS):
            logger.debug(f"M&Aタスク判定: キーワードマッチ")
            return 'ma'
        
        # 2-2. パラメータ判定
        if any(key in parameters for key in TaskRouter.MA_PARAMETER_KEYS):
            logger.debug(f"M&Aタスク判定: パラメータマッチ")
            return 'ma'
        
        # 2-3. エージェントと説明の組み合わせ
        if agent in ['wordpress', 'plugin']:
            # WordPressエージェントで特定の機能
            if any(word in description for word in ['設定', '作成', 'setup', 'configure']):
                logger.debug(f"M&Aタスク判定: WordPressエージェント+設定")
                return 'ma'
        
        # 3. 記事生成タスクの判定
        # 3-1. エージェント判定(最も確実)
        if agent in TaskRouter.CONTENT_AGENTS:
            logger.debug(f"記事生成タスク判定: エージェントマッチ")
            return 'content'
        
        # 3-2. パラメータ判定
        if any(key in parameters for key in TaskRouter.CONTENT_PARAMETER_KEYS):
            logger.debug(f"記事生成タスク判定: パラメータマッチ")
            return 'content'
        
        # 3-3. キーワード判定
        if any(keyword in description for keyword in TaskRouter.CONTENT_KEYWORDS):
            logger.debug(f"記事生成タスク判定: キーワードマッチ")
            return 'content'
        
        # 4. その他のタスク
        logger.debug(f"デフォルトタスク判定")
        return 'default'
    
    @staticmethod
    def is_ma_task(task: dict) -> bool:
        """M&A関連タスクかどうかを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            M&Aタスクの場合True
        """
        return TaskRouter.determine_task_type(task) == 'ma'
    
    @staticmethod
    def is_content_task(task: dict) -> bool:
        """記事生成タスクかどうかを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            記事生成タスクの場合True
        """
        return TaskRouter.determine_task_type(task) == 'content'
    
    @staticmethod
    def is_review_task(task: dict) -> bool:
        """レビュータスクかどうかを判定
        
        Args:
            task: タスク辞書
            
        Returns:
            レビュータスクの場合True
        """
        return TaskRouter.determine_task_type(task) == 'review'


# ============================================================================
# グローバルインスタンスの作成
# ============================================================================

# グローバルインスタンスを作成
wp_config = WordPressConfig()
task_router = TaskRouter()


# ============================================================================
# PluginNameExtractor: プラグイン名抽出クラス
# ============================================================================

class PluginNameExtractor:
    """タスク説明からプラグイン名を抽出"""

    @staticmethod
    def extract(description: str) -> str:
        """タスク説明からプラグイン名を抽出
        
        Args:
            description: タスク説明文
            
        Returns:
            抽出されたプラグイン名
        """
        # 「」『』で囲まれた部分を抽出
        match = re.search(r'[「『](.+?)[」』]', description)
        if match:
            return match.group(1)
        
        # 見つからない場合は説明の先頭50文字を返す
        return description[:50]


# ============================================================================
# HTMLCleaner: HTMLクリーニングクラス
# ============================================================================

class HTMLCleaner:
    """HTML記事のクリーニングユーティリティ
    
    WordPress投稿用にHTMLを最適化・クリーニングする機能を提供。
    - 不正なネストの修正
    - WordPressクラスの追加
    - Gutenbergブロック対応
    - タイトル・本文の分離
    """
        
    @staticmethod
    def clean_html_content(html_content: str) -> str:
        """HTMLコンテンツをクリーニング - WordPress用に最適化
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            クリーニングされたHTML
        """
        try:
            logger.info("WordPress用にHTMLをクリーニング中...")
            
            # 基本的なクリーニング
            cleaned = html_content
            
            # 1. 不正なネストを修正
            cleaned = re.sub(r'<p>\s*<div', '<div', cleaned)
            cleaned = re.sub(r'</div>\s*</p>', '</div>', cleaned)
            cleaned = re.sub(r'<p>\s*</p>', '', cleaned)
            
            # 2. 適切な改行を追加(読みやすさのため)
            cleaned = re.sub(r'></(h1|h2|h3|h4|h5|h6|p|div|section|article)>', r'></\1>\n\n', cleaned)
            cleaned = re.sub(r'<(h1|h2|h3|h4|h5|h6|p|div|section|article)([^>]*)>', r'<\1\2>\n', cleaned)
            
            # 3. 連続する空白を単一スペースに
            cleaned = re.sub(r'\s+', ' ', cleaned)
            
            # 4. タグ間の空白を正規化
            cleaned = re.sub(r'>\s+<', '> <', cleaned)
            
            # 5. WordPress用のクラスを追加
            cleaned = HTMLCleaner._add_wordpress_classes(cleaned)
            
            # 6. セマンティックな構造を確認
            lines = cleaned.split('\n')
            cleaned_lines = []
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                    
                # 明らかに不正な行をスキップ
                if line in ['<p><div', '</div></p>']:
                    continue
                    
                cleaned_lines.append(line)
            
            cleaned = '\n'.join(cleaned_lines)
            
            logger.info(f"HTMLクリーニング完了: {len(html_content)} → {len(cleaned)}文字")
            return cleaned
            
        except Exception as e:
            logger.error(f"HTMLクリーニングエラー: {e}")
            return html_content
    
    @staticmethod
    def _add_wordpress_classes(html_content: str) -> str:
        """WordPress用のクラスを追加してスタイルを適用
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            WordPressクラスが追加されたHTML
        """
        try:
            # 見出しにWordPressのクラスを追加
            html_content = re.sub(r'<h1([^>]*)>', r'<h1\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h2([^>]*)>', r'<h2\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h3([^>]*)>', r'<h3\1 class="wp-block-heading has-medium-font-size">', html_content)
            
            # 段落にクラスを追加
            html_content = re.sub(r'<p([^>]*)>', r'<p\1 class="wp-block-paragraph">', html_content)
            
            # セクションにクラスを追加
            html_content = re.sub(r'<section([^>]*)>', r'<section\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<article([^>]*)>', r'<article\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<div class="article-meta"', r'<div class="wp-block-group article-meta"', html_content)
            html_content = re.sub(r'<div class="intro"', r'<div class="wp-block-group intro"', html_content)
            html_content = re.sub(r'<div class="main-content"', r'<div class="wp-block-group main-content"', html_content)
            
            return html_content
            
        except Exception as e:
            logger.error(f"WordPressクラス追加エラー: {e}")
            return html_content
        
    @staticmethod
    def validate_html_structure(html_content: str) -> bool:
        """HTML構造の基本的な検証
        
        Args:
            html_content: 検証するHTMLコンテンツ
            
        Returns:
            構造が正しい場合True
        """
        try:
            # 基本的なタグのバランスをチェック
            open_tags = len(re.findall(r'<(\w+)[^>]*>', html_content))
            close_tags = len(re.findall(r'</(\w+)>', html_content))
                
            # divタグのバランスを特別にチェック
            div_open = html_content.count('<div')
            div_close = html_content.count('</div>')
                
            logger.info(f"HTML構造検証: タグ{open_tags}/{close_tags}, div{div_open}/{div_close}")
                
            # divタグのバランスが取れているか
            if div_open != div_close:
                logger.warning(f"divタグのバランスが取れていません: {div_open} != {div_close}")
                return False
                    
            return True
                
        except Exception as e:
            logger.error(f"HTML検証エラー: {e}")
            return False
        
    @staticmethod
    def extract_title_from_html(html_content: str) -> Tuple[str, str]:
        """HTMLからタイトルと本文を分離
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            (タイトル, クリーニングされたHTML本文)のタプル
        """
        try:
            logger.info("HTMLからタイトルを抽出中...")
                
            # 複数のパターンでタイトルを検索
            title_patterns = [
                r'<h1[^>]*>(.*?)</h1>',
                r'<title[^>]*>(.*?)</title>',
                r'<h2[^>]*>(.*?)</h2>',
                r'<h3[^>]*>(.*?)</h3>'
            ]
                
            for pattern in title_patterns:
                match = re.search(pattern, html_content, re.IGNORECASE | re.DOTALL)
                if match:
                    title_html = match.group(1)
                    # HTMLタグを除去してタイトルを取得
                    title = re.sub(r'<[^>]+>', '', title_html).strip()
                        
                    if title and len(title) > 5:  # 最低5文字以上
                        logger.info(f"✅ HTMLからタイトル抽出成功: {title}")
                            
                        # タイトル部分を除去した本文を作成
                        body = re.sub(pattern, '', html_content, flags=re.IGNORECASE | re.DOTALL)
                        body = body.strip()
                            
                        # 本文をクリーニング
                        body = HTMLCleaner.clean_html_content(body)
                            
                        return title, body
                
            logger.warning("❌ HTMLからタイトルを抽出できませんでした")
            return "タイトル不明", HTMLCleaner.clean_html_content(html_content)
                
        except Exception as e:
            logger.error(f"HTMLタイトル抽出エラー: {e}")
            return "タイトル抽出エラー", html_content
        
    @staticmethod
    def prepare_html_for_wordpress(html_content: str) -> Tuple[str, str]:
        """WordPress用にHTMLを準備(改善版)
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            (タイトル, WordPress用HTML本文)のタプル
        """
        try:
            logger.info("WordPress用にHTMLを準備中...")
            
            # タイトルと本文を分離
            title, body = HTMLCleaner.extract_title_from_html(html_content)
            
            # HTMLをWordPress用に最適化
            wp_html = HTMLCleaner._optimize_for_wordpress_gutenberg(body)
            
            logger.info(f"✅ WordPress用HTML準備完了: タイトル='{title}', 本文={len(wp_html)}文字")
            return title, wp_html
            
        except Exception as e:
            logger.error(f"WordPress用HTML準備エラー: {e}")
            return "HTML処理エラー", html_content
        
    @staticmethod
    def _optimize_for_wordpress(html_content: str) -> str:
        """WordPress用にHTMLを最適化
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            最適化されたHTML
        """
        try:
            optimized = html_content
                
            # 1. セマンティックなタグを維持
            # 2. 不正なネストを修正
            optimized = re.sub(r'<p>\s*<(div|section|article)', r'<\1', optimized)
            optimized = re.sub(r'</(div|section|article)>\s*</p>', r'</\1>', optimized)
                
            # 3. 空の段落を削除
            optimized = re.sub(r'<p>\s*</p>', '', optimized)
                
            # 4. 連続する改行を整理
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
                
            # 5. 基本的なHTML構造を確保
            if not optimized.strip().startswith('<'):
                optimized = f'<div class="article-content">\n{optimized}\n</div>'
                
            return optimized
                
        except Exception as e:
            logger.error(f"HTML最適化エラー: {e}")
            return html_content
    
    @staticmethod
    def _optimize_for_wordpress_gutenberg(html_content: str) -> str:
        """Gutenbergエディタ用にHTMLを最適化
        
        Args:
            html_content: 元のHTMLコンテンツ
            
        Returns:
            Gutenberg最適化されたHTML
        """
        try:
            # まず基本クリーニング
            optimized = HTMLCleaner.clean_html_content(html_content)
            
            # Gutenbergブロック用の構造を追加
            optimized = HTMLCleaner._wrap_in_gutenberg_blocks(optimized)
            
            # 最終的な改行調整
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
            optimized = optimized.strip()
            
            return optimized
            
        except Exception as e:
            logger.error(f"Gutenberg最適化エラー: {e}")
            return html_content
    
    @staticmethod
    def _wrap_in_gutenberg_blocks(html_content: str) -> str:
        """
        HTMLをGutenbergブロックでラップ
        """
        try:
            blocks = []
            lines = html_content.split('\n')
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # 見出しブロック
                if line.startswith('<h1') or line.startswith('<h2') or line.startswith('<h3'):
                    blocks.append(f'<!-- wp:heading -->\n{line}\n<!-- /wp:heading -->')
                
                # 段落ブロック
                elif line.startswith('<p'):
                    blocks.append(f'<!-- wp:paragraph -->\n{line}\n<!-- /wp:paragraph -->')
                
                # グループブロック(セクション、記事メタなど)
                elif line.startswith('<section') or line.startswith('<article') or line.startswith('<div class="wp-block-group"'):
                    if line.startswith('</section') or line.startswith('</article') or line.startswith('</div'):
                        blocks.append(line)
                    else:
                        blocks.append(f'<!-- wp:group -->\n{line}')
                
                # その他の要素
                else:
                    blocks.append(line)
            
            # 閉じタグの処理
            result = []
            for block in blocks:
                if any(tag in block for tag in ['</section>', '</article>', '</div>']):
                    result.append(f'{block}\n<!-- /wp:group -->')
                else:
                    result.append(block)
            
            return '\n\n'.join(result)
            
        except Exception as e:
            logger.error(f"Gutenbergブロックラップエラー: {e}")
            return html_content
        
    @staticmethod
    def is_valid_html(html_content: str) -> bool:
        """
        HTMLが有効かチェック
        """
        try:
            # 基本的なチェック
            if not html_content or len(html_content.strip()) < 10:
                return False
                
            # HTMLタグの存在をチェック
            if '<' not in html_content or '>' not in html_content:
                return False
                
            # 基本的なタグのバランスをチェック
            return HTMLCleaner.validate_html_structure(html_content)
                
        except Exception as e:
            logger.error(f"HTML有効性チェックエラー: {e}")
            return False