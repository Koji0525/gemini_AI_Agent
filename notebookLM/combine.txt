#__init__.py
ï»¿# data_models/__init__.py
"""ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸"""
from .data_models import (
    ErrorSeverity,
    ErrorCategory,
    ErrorContextModel,
    BugFixTask,
    FixResult
)
__all__ = ['ErrorSeverity', 'ErrorCategory', 'ErrorContextModel', 'BugFixTask', 'FixResult']
__version__ = '1.0.0'

#auto_fix_agent.py
# auto_fix_agent.py
import asyncio
import ast
import tokenize
import logging
from pathlib import Path
from typing import Dict, List, Optional
import difflib

logger = logging.getLogger(__name__)

class AutoFixAgent:
    """è‡ªå‹•ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    FIX_SYSTEM_PROMPT = """ã‚ãªãŸã¯å„ªç§€ãªPythonãƒ‡ãƒãƒƒã‚°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ã‚’åˆ†æã™ã‚‹
- å…·ä½“çš„ãªä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’ææ¡ˆã™ã‚‹
- ä¿®æ­£ã®ç†ç”±ã‚’èª¬æ˜ã™ã‚‹
- å®Œå…¨ãªä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æä¾›ã™ã‚‹

ã€å‡ºåŠ›å½¢å¼ã€‘
ä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
  "analysis": "ã‚¨ãƒ©ãƒ¼ã®åŸå› åˆ†æ",
  "fix_reason": "ä¿®æ­£ã®ç†ç”±",
  "fixed_code": "ä¿®æ­£å¾Œã®å®Œå…¨ãªã‚³ãƒ¼ãƒ‰",
  "changes": [
    {
      "file": "ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«å",
      "line": è¡Œç•ªå·,
      "original": "å…ƒã®ã‚³ãƒ¼ãƒ‰",
      "fixed": "ä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰",
      "reason": "ä¿®æ­£ç†ç”±"
    }
  ],
  "confidence": 0.8,
  "next_step": "æ¬¡ã®å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰"
}"""

#brower_cookie_and_session.py
# browser_cookie_and_session.py
"""ã‚¯ãƒƒã‚­ãƒ¼ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹"""
import json
import time
from pathlib import Path
from typing import Optional, Dict, List
from playwright.async_api import BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class CookieSessionManager:
    """ã‚¯ãƒƒã‚­ãƒ¼ã¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç®¡ç†ã‚’æ‹…å½“"""
    
    def __init__(self, context: BrowserContext, cookies_file: Path):
        self.context = context
        self.cookies_file = cookies_file
    
    async def save_cookies(self) -> None:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.context or not self.cookies_file:
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
                return
            
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("ä¿å­˜ã™ã‚‹ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return
                
            with open(self.cookies_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ: {len(cookies)}å€‹ã®ã‚¯ãƒƒã‚­ãƒ¼")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜")
            logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸãŒç¶šè¡Œã—ã¾ã™")

    async def load_cookies(self) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.cookies_file or not self.cookies_file.exists():
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“")
                return False
                
            if not self.context:
                logger.warning("ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            with open(self.cookies_file, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
            
            if not cookies:
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã™")
                return False
                
            current_url = "https://gemini.google.com"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆURL
            domain_cookies = []
            
            for cookie in cookies:
                if 'domain' in cookie and cookie['domain'].startswith('.'):
                    cookie['domain'] = cookie['domain'][1:]
                
                if 'expires' in cookie and cookie['expires'] < time.time():
                    continue
                    
                domain_cookies.append(cookie)
            
            if domain_cookies:
                await self.context.add_cookies(domain_cookies)
                logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {len(domain_cookies)}å€‹")
                return True
            else:
                logger.warning("æœ‰åŠ¹ãªã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
                
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿")
            return False
    
    async def check_google_login_status(self) -> bool:
        """Googleãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒšãƒ¼ã‚¸ãŒå¿…è¦ãªå ´åˆã«å®Ÿè£…ï¼‰"""
        # ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒšãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒå¿…è¦ãªãŸã‚ã€
        # å¿…è¦ã«å¿œã˜ã¦AIChatAgentã«ç§»å‹•ã¾ãŸã¯ã“ã“ã§å®Ÿè£…
        logger.info("Googleãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ï¼ˆå®Ÿè£…äºˆå®šï¼‰")
        return False

#browser_ai_chat_agent.py
# browser_ai_chat_agent.py
"""AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ï¼ˆGemini/DeepSeekå¯¾å¿œï¼‰"""
import asyncio
import time
import json
import re
from datetime import datetime
from typing import Optional, Dict
from playwright.async_api import Page
import logging

from config_utils import ErrorHandler, FileNameGenerator

logger = logging.getLogger(__name__)

class AIChatAgent:
    """AIã‚µãƒ¼ãƒ“ã‚¹ï¼ˆGemini/DeepSeekï¼‰ã¨ã®å¯¾è©±ã‚’æ‹…å½“"""
    
    def __init__(self, page: Page, service: str = "google", credentials: Dict = None):
        self.page = page
        self.service = service.lower()
        self.credentials = credentials or {}
    
    async def navigate_to_gemini(self) -> None:
        """Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆã‚¯ãƒ©ãƒƒã‚·ãƒ¥æ¤œçŸ¥å¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            
            logger.info("Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)
                    
                    logger.info("âœ… Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                    
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸ")
                        logger.error("æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        input("Geminiãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await asyncio.sleep(5)
            
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            
            await self.handle_welcome_screens()
            logger.info("âœ… Geminiã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiã‚¢ã‚¯ã‚»ã‚¹")
            logger.info("æ‰‹å‹•ã§Geminiãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
            input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆCloudflareãƒœãƒƒãƒˆæ¤œè¨¼å¯¾å¿œç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            logger.info("DeepSeekã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"DeepSeekã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    await self.page.goto("https://chat.deepseek.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(5000)
                    logger.info("DeepSeekã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        input("DeepSeekãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            
            # Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ãƒã‚§ãƒƒã‚¯
            logger.info("Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...")
            cloudflare_check = await self.page.evaluate('''
                () => {
                    const body = document.body.innerText || '';
                    if (body.includes('Verifying you are human') || 
                        body.includes('ã‚ãªãŸãŒãƒœãƒƒãƒˆã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèª') ||
                        body.includes('Just a moment') ||
                        body.includes('Checking your browser')) {
                        return true;
                    }
                    return false;
                }
            ''')
            
            if cloudflare_check:
                logger.warning("âš ï¸ Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ")
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã§è‡ªå‹•çš„ã«ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™...")
                
                start_time = time.time()
                while time.time() - start_time < 60:
                    await self.page.wait_for_timeout(3000)
                    
                    still_checking = await self.page.evaluate('''
                        () => {
                            const body = document.body.innerText || '';
                            if (body.includes('Verifying you are human') || 
                                body.includes('ã‚ãªãŸãŒãƒœãƒƒãƒˆã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèª') ||
                                body.includes('Just a moment') ||
                                body.includes('Checking your browser')) {
                                return true;
                            }
                            return false;
                        }
                    ''')
                    
                    if not still_checking:
                        logger.info("âœ… Cloudflareæ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ")
                        break
                    
                    elapsed = int(time.time() - start_time)
                    if elapsed % 10 == 0:
                        logger.info(f"å¾…æ©Ÿä¸­... {elapsed}ç§’çµŒé")
                
                await self.page.wait_for_timeout(3000)
                current_url = self.page.url
                logger.info(f"æ¤œè¨¼å¾Œã®URL: {current_url}")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                logger.info("\n" + "="*60)
                logger.info("âš ï¸ DeepSeekã¸ã®ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
                logger.info("="*60)
                logger.info("")
                logger.info("ğŸ“Œ ãƒ­ã‚°ã‚¤ãƒ³æ‰‹é †ï¼š")
                logger.info("1. ãƒ–ãƒ©ã‚¦ã‚¶ã§ã€ŒLog in with Googleã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
                logger.info("2. Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠï¼ˆã¾ãŸã¯å…¥åŠ›ï¼‰")
                logger.info(f"   ä½¿ç”¨ã™ã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ: {self.credentials.get('email', 'B2ã‚»ãƒ«ã®Google ID')}")
                logger.info("3. ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†ã‚’å¾…ã¤")
                logger.info("4. ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€ã“ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«æˆ»ã£ã¦Enterã‚­ãƒ¼ã‚’æŠ¼ã™")
                logger.info("")
                logger.info("ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼š")
                logger.info("  - ã€ŒChrome ã¯è‡ªå‹•ãƒ†ã‚¹ãƒˆ...ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–ã—ã¦ãã ã•ã„")
                logger.info("  - Googleãƒ­ã‚°ã‚¤ãƒ³ã¯é€šå¸¸é€šã‚Šå‹•ä½œã—ã¾ã™")
                logger.info("  - 2å›ç›®ä»¥é™ã¯Cookieã§è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³ã•ã‚Œã¾ã™")
                logger.info("="*60)
                
                input("\nâœ… ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                
                await self.page.wait_for_timeout(2000)
                current_url = self.page.url
                logger.info(f"ãƒ­ã‚°ã‚¤ãƒ³å¾Œã®URL: {current_url}")
                
                if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                    logger.warning("âš ï¸ ã¾ã ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã¾ã™")
                    logger.info("ã‚‚ã†ä¸€åº¦ã€ŒLog in with Googleã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„")
                    input("å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    await self.page.wait_for_timeout(2000)
            
            # ãƒãƒ£ãƒƒãƒˆç”»é¢ã«åˆ°é”ã§ãã¦ã„ã‚‹ã‹ç¢ºèª
            await self.page.wait_for_timeout(3000)
            chat_ready = await self.page.evaluate('''
                () => {
                    const inputs = document.querySelectorAll('textarea, input[type="text"]');
                    return inputs.length > 0;
                }
            ''')
            
            if not chat_ready:
                logger.warning("âš ï¸ ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ãã ã•ã„")
                input("\nâœ… ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            else:
                logger.info("âœ… ãƒãƒ£ãƒƒãƒˆç”»é¢ã‚’ç¢ºèªã—ã¾ã—ãŸ")
            
            logger.info("âœ… DeepSeekã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "DeepSeekã‚¢ã‚¯ã‚»ã‚¹")
            logger.info("æ‰‹å‹•ã§DeepSeekãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
            input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
    
    async def handle_welcome_screens(self) -> None:
        """åˆ©ç”¨è¦ç´„ã‚„ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’å‡¦ç†"""
        try:
            if not self.page:
                return
            logger.info("ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚„ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’ç¢ºèªä¸­...")
            continue_buttons = [
                'text=ç¶šè¡Œ', 'text=é–‹å§‹', 'text=åŒæ„', 'text=Continue',
                'text=Get started', 'text=Agree', 'text=Got it', 'text=OK',
                '[data-testid="continue-button"]'
            ]
            start_time = time.time()
            found_buttons = 0
            while time.time() - start_time < 10 and found_buttons < 3:
                for button_selector in continue_buttons:
                    try:
                        button = await self.page.query_selector(button_selector)
                        if button and await button.is_visible():
                            await button.click()
                            await self.page.wait_for_timeout(2000)
                            logger.info(f"ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ: {button_selector}")
                            found_buttons += 1
                            break
                    except Exception:
                        continue
                await self.page.wait_for_timeout(1000)
            if found_buttons > 0:
                logger.info(f"{found_buttons}å€‹ã®ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’å‡¦ç†ã—ã¾ã—ãŸ")
            else:
                logger.info("ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼ˆæ­£å¸¸ï¼‰")
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢å‡¦ç†")
    
    async def ensure_normal_chat_mode(self) -> None:
        """é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆStorybookã‚’å›é¿ï¼‰- å¼·åŒ–ç‰ˆ"""
        try:
            if not self.page:
                return
            logger.info("ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’ç¢ºèªä¸­...")
            current_url = self.page.url
            if 'storybook' in current_url.lower():
                logger.warning("Storybookã®URLãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã™...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã—ãŸ")
                return
            storybook_active = await self.page.evaluate('''
                () => {
                    const buttons = document.querySelectorAll('button');
                    for (const btn of buttons) {
                        const text = btn.textContent || '';
                        const ariaLabel = btn.getAttribute('aria-label') || '';
                        if ((text.includes('Storybook') || ariaLabel.includes('Storybook')) &&
                            (btn.getAttribute('aria-pressed') === 'true' || 
                             btn.classList.contains('active') ||
                             btn.classList.contains('selected'))) {
                            return true;
                        }
                    }
                    return false;
                }
            ''')
            if storybook_active:
                logger.warning("Storybookãƒ¢ãƒ¼ãƒ‰ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã™...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã—ãŸ")
            else:
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã™")
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ç¢ºèª")
    
    async def send_prompt(self, prompt: str) -> None:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦é€ä¿¡ï¼ˆã‚µãƒ¼ãƒ“ã‚¹è‡ªå‹•åˆ¤åˆ¥ç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            await self.ensure_normal_chat_mode()
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ä¸­: {prompt[:50]}...")
            
            if self.service == "deepseek":
                await self.send_prompt_deepseek(prompt)
            else:
                await self.send_prompt_gemini(prompt)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_gemini(self, prompt: str) -> None:
        """Geminiã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡(ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å¯¾å¿œç‰ˆ)"""
        try:
            # å…¥åŠ›æ¬„ã‚’æ¢ã™
            input_selectors = [
                'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ Gemini ã«é€ä¿¡"]',
                'textarea[placeholder*="Send a message to Gemini"]',
                'div[contenteditable="true"][role="textbox"]',
                'textarea[data-testid="message-input"]',
                'div.ql-editor[contenteditable="true"]',
                'textarea.ql-editor',
                '[data-message-input]',
                'div[contenteditable="true"][aria-label*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
                'div[contenteditable="true"][aria-label*="message"]',
                'div[contenteditable="true"][tabindex="0"]',
                'textarea[aria-label*="Gemini"]',
                '[data-testid="input-area"] textarea',
                '[data-testid="input-area"] div[contenteditable="true"]',
            ]
            
            input_element = None
            for selector in input_selectors:
                try:
                    await self.page.wait_for_selector(selector, timeout=5000)
                    input_element = await self.page.query_selector(selector)
                    if input_element:
                        logger.info(f"å…¥åŠ›æ¬„ã‚’ç™ºè¦‹: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                await self.page.screenshot(path="debug_input_not_found.png")
                raise Exception("å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã‚‹å‡¦ç†
            try:
                # 1. ãƒ¡ãƒ¼ãƒ«é…ä¿¡ç™»éŒ²ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã€Œå¾Œã§ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
                later_button_selectors = [
                    'button:has-text("å¾Œã§")',
                    'button:has-text("Later")',
                    '[aria-label*="å¾Œã§"]',
                    '[aria-label*="Later"]'
                ]
                
                for selector in later_button_selectors:
                    try:
                        later_button = await self.page.query_selector(selector)
                        if later_button and await later_button.is_visible():
                            await later_button.click()
                            await self.page.wait_for_timeout(1000)
                            logger.info("âœ… ãƒ¡ãƒ¼ãƒ«é…ä¿¡ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã¾ã—ãŸ")
                            break
                    except:
                        continue
                
                # 2. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å…¨ä½“ã‚’é–‰ã˜ã‚‹ï¼ˆãƒãƒƒã‚¯ãƒ‰ãƒ­ãƒƒãƒ—ã‚¯ãƒªãƒƒã‚¯ï¼‰
                overlay_backdrop = await self.page.query_selector('.cdk-overlay-backdrop')
                if overlay_backdrop:
                    try:
                        await overlay_backdrop.click()
                        await self.page.wait_for_timeout(500)
                        logger.info("âœ… ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã¾ã—ãŸ")
                    except:
                        pass
                
                # 3. Escã‚­ãƒ¼ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹ï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰
                await self.page.keyboard.press('Escape')
                await self.page.wait_for_timeout(500)
                
            except Exception as e:
                logger.debug(f"ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å‡¦ç†: {e}")
            
            # å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªãƒƒã‚¯
            await input_element.click()
            await self.page.wait_for_timeout(500)
            
            # æ—¢å­˜ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
            await self.page.keyboard.press("Control+a")
            await self.page.wait_for_timeout(500)
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›
            await input_element.fill(prompt)
            await self.page.wait_for_timeout(1500)
            
            # é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            send_selectors = [
                'button[data-testid="send-button"]',
                '[data-testid="send-button"]'
            ]
            
            sent = False
            for selector in send_selectors:
                try:
                    send_button = await self.page.query_selector(selector)
                    if send_button and await send_button.is_enabled():
                        await send_button.click()
                        logger.info("é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
                        sent = True
                        break
                except:
                    continue
            
            if not sent:
                await input_element.press('Enter')
                logger.info("Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã—ãŸ")
            
            await self.page.wait_for_timeout(3000)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_deepseek(self, prompt: str) -> None:
        """DeepSeekã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        # ã¾ãšã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®ã£ã¦çŠ¶æ…‹ã‚’ç¢ºèª
        debug_screenshot = f"debug_deepseek_before_input_{datetime.now().strftime('%H%M%S')}.png"
        try:
            await self.page.screenshot(path=debug_screenshot)
            logger.info(f"ğŸ“¸ å…¥åŠ›å‰ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {debug_screenshot}")
        except:
            pass
        
        # è¤‡æ•°ã®å¯èƒ½æ€§ã®ã‚ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ã‚’è©¦ã™
        input_selectors = [
            'textarea[placeholder*="Ask"]',
            'textarea[placeholder*="Type"]',
            'textarea[placeholder*="message"]',
            'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'textarea[placeholder*="å…¥åŠ›"]',
            'div[contenteditable="true"][role="textbox"]',
            'div[contenteditable="true"]',
            'textarea',
            'input[type="text"]',
        ]
        
        input_element = None
        used_selector = None
        
        # å„ã‚»ãƒ¬ã‚¯ã‚¿ã‚’é †ç•ªã«è©¦ã™
        for selector in input_selectors:
            try:
                logger.info(f"å…¥åŠ›æ¬„ã‚’æ¢ç´¢ä¸­: {selector}")
                element = await self.page.query_selector(selector)
                if element:
                    # è¦ç´ ãŒè¦‹ãˆã¦ã„ã‚‹ã‹ç¢ºèª
                    is_visible = await element.is_visible()
                    if is_visible:
                        input_element = element
                        used_selector = selector
                        logger.info(f"âœ… å…¥åŠ›æ¬„ã‚’ç™ºè¦‹: {selector}")
                        break
                    else:
                        logger.info(f"è¦ç´ ã¯å­˜åœ¨ã™ã‚‹ãŒéè¡¨ç¤º: {selector}")
            except Exception as e:
                logger.debug(f"ã‚»ãƒ¬ã‚¯ã‚¿ {selector} ã§ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        if not input_element:
            # å…¨ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—ã—ãŸå ´åˆ
            await self.page.screenshot(path="debug_deepseek_input_not_found.png")
            logger.error("âŒ DeepSeekå…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            logger.error("ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š")
            logger.error("1. ãƒ­ã‚°ã‚¤ãƒ³ãŒå®Œäº†ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ")
            logger.error("2. ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿ")
            logger.error("3. Cloudflareã®æ¤œè¨¼ã¯å®Œäº†ã—ã¾ã—ãŸã‹ï¼Ÿ")
            
            # ãƒšãƒ¼ã‚¸ã®HTMLã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
            page_content = await self.page.evaluate('document.body.innerText')
            logger.info(f"ãƒšãƒ¼ã‚¸å†…å®¹ï¼ˆå…ˆé ­500æ–‡å­—ï¼‰:\n{page_content[:500]}")
            
            # æ‰‹å‹•ä»‹å…¥ã‚’ä¿ƒã™
            logger.info("\næ‰‹å‹•ã§å…¥åŠ›æ¬„ãŒè¦‹ãˆã‚‹ã¾ã§æ“ä½œã—ã¦ãã ã•ã„")
            input("å…¥åŠ›æ¬„ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            
            # å†åº¦æ¢ã™
            for selector in input_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element and await element.is_visible():
                        input_element = element
                        used_selector = selector
                        logger.info(f"âœ… å…¥åŠ›æ¬„ã‚’ç™ºè¦‹ï¼ˆ2å›ç›®ï¼‰: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                raise Exception("å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆ2å›ç›®ã®è©¦è¡Œå¾Œï¼‰")
        
        # å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
        await input_element.click()
        await self.page.wait_for_timeout(500)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›
        await input_element.fill(prompt)
        await self.page.wait_for_timeout(1500)
        
        # é€ä¿¡ãƒœã‚¿ãƒ³ã‚’æ¢ã™
        send_button = None
        send_selectors = [
            'button[type="submit"]',
            'button[aria-label*="Send"]',
            'button[aria-label*="é€ä¿¡"]',
            'button:has-text("é€ä¿¡")',
            'button:has-text("Send")',
            'button svg',  # ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³
        ]
        
        for selector in send_selectors:
            try:
                btn = await self.page.query_selector(selector)
                if btn and await btn.is_visible() and await btn.is_enabled():
                    send_button = btn
                    logger.info(f"é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ç™ºè¦‹: {selector}")
                    break
            except:
                continue
        
        if send_button:
            await send_button.click()
            logger.info("âœ… DeepSeeké€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
        else:
            # ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯Enterã‚­ãƒ¼ã§é€ä¿¡
            logger.info("é€ä¿¡ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã™")
            await input_element.press("Enter")
            logger.info("âœ… Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã—ãŸ")
        
        await self.page.wait_for_timeout(3000)
    
    async def wait_for_text_generation(self, max_wait: int = 120) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã¾ã§å¾…æ©Ÿ"""
        try:
            if not self.page:
                return False
            logger.info("ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã‚’å¾…æ©Ÿä¸­...")
            start_time = time.time()
            check_interval = 2
            await self.page.wait_for_timeout(5000)
            while time.time() - start_time < max_wait:
                await self.page.wait_for_timeout(check_interval * 1000)
                elapsed = int(time.time() - start_time)
                is_complete = await self.page.evaluate('''
                    () => {
                        const allButtons = document.querySelectorAll('button');
                        for (const btn of allButtons) {
                            const text = btn.textContent || '';
                            const ariaLabel = btn.getAttribute('aria-label') || '';
                            if (text.includes('å†ç”Ÿæˆ') || text.includes('Regenerate') ||
                                ariaLabel.includes('å†ç”Ÿæˆ') || ariaLabel.includes('Regenerate')) {
                                return true;
                            }
                        }
                        const sendButtons = document.querySelectorAll('[data-testid="send-button"], button[type="submit"]');
                        for (const btn of sendButtons) {
                            if (!btn.disabled && !btn.hasAttribute('disabled')) {
                                return true;
                            }
                        }
                        const loadingElements = document.querySelectorAll('[data-testid="loading"], .loading, .spinner');
                        if (loadingElements.length === 0) {
                            return true;
                        }
                        return false;
                    }
                ''')
                if is_complete:
                    logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã‚’æ¤œå‡º")
                    await self.page.wait_for_timeout(2000)
                    return True
                if elapsed % 10 == 0 and elapsed > 0:
                    logger.info(f"â³ å¾…æ©Ÿä¸­... {elapsed}ç§’çµŒé")
            logger.warning(f"â° ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå¾…æ©Ÿ")
            return False
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """
        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿã‚’ä¸€æ‹¬å‡¦ç†ï¼ˆæ¨å¥¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰
        
        Args:
            prompt: é€ä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            max_wait: æœ€å¤§å¾…æ©Ÿæ™‚é–“ï¼ˆç§’ï¼‰
            
        Returns:
            bool: æˆåŠŸæ™‚ True
        """
        try:
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡
            await self.send_prompt(prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.wait_for_text_generation(max_wait)
            
            if success:
                logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©ŸãŒå®Œäº†ã—ã¾ã—ãŸ")
            else:
                logger.warning("âš ï¸ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¯æˆåŠŸã—ã¾ã—ãŸãŒã€å¿œç­”å¾…æ©ŸãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
            
            return success
            
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¾…æ©Ÿä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    
    async def extract_latest_text_response(self) -> str:
        """æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆã‚µãƒ¼ãƒ“ã‚¹è‡ªå‹•åˆ¤åˆ¥ç‰ˆï¼‰"""
        try:
            if self.service == "deepseek":
                return await self.extract_latest_text_response_deepseek()
            else:
                return await self.extract_latest_text_response_gemini()
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º")
            return None
    
    async def extract_latest_text_response_gemini(self) -> str:
        """Geminiã®æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ä¿®æ­£ç‰ˆï¼‰"""
        try:
            logger.info("=" * 60)
            logger.info("â˜…â˜…â˜… Geminiãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºé–‹å§‹ â˜…â˜…â˜…")
            logger.info("=" * 60)
            
            all_results = {}
            
            # æ–¹æ³•1: ãƒ¢ãƒ‡ãƒ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ‡ãƒ¼ã‚¿å±æ€§ã‹ã‚‰å–å¾—
            try:
                method1_text = await self.page.evaluate('''() => {
                    const modelMessages = document.querySelectorAll('[data-message-author="model"]');
                    if (modelMessages.length === 0) return null;
                    
                    const latestMessage = modelMessages[modelMessages.length - 1];
                    return latestMessage.innerText || latestMessage.textContent || '';
                }''')
                all_results['æ–¹æ³•1'] = method1_text
                logger.info(f"æ–¹æ³•1çµæœ: {len(method1_text) if method1_text else 0}æ–‡å­—")
            except Exception as e:
                logger.debug(f"æ–¹æ³•1å¤±æ•—: {e}")
                all_results['æ–¹æ³•1'] = None

            # æ–¹æ³•2: ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‹ã‚‰å–å¾—
            try:
                method2_text = await self.page.evaluate('''() => {
                    const markdownContainers = document.querySelectorAll('[class*="markdown"]');
                    if (markdownContainers.length === 0) return null;
                    
                    let longest = '';
                    for (const container of markdownContainers) {
                        const text = container.innerText || container.textContent || '';
                        if (text.length > longest.length) {
                            longest = text;
                        }
                    }
                    return longest;
                }''')
                all_results['æ–¹æ³•2'] = method2_text
                logger.info(f"æ–¹æ³•2çµæœ: {len(method2_text) if method2_text else 0}æ–‡å­—")
            except Exception as e:
                logger.debug(f"æ–¹æ³•2å¤±æ•—: {e}")
                all_results['æ–¹æ³•2'] = None

            # æ–¹æ³•3: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¯ãƒ©ã‚¹ã‹ã‚‰å–å¾—
            try:
                method3_text = await self.page.evaluate('''() => {
                    const messages = document.querySelectorAll('[class*="message"]');
                    if (messages.length === 0) return null;
                    
                    let modelTexts = [];
                    for (const msg of messages) {
                        const text = msg.innerText || msg.textContent || '';
                        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é™¤å¤–ï¼ˆçŸ­ã„ã¾ãŸã¯ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
                        if (text.length > 100 && 
                            !text.includes('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª') &&
                            !text.includes('ã€ã‚ãªãŸã®å½¹å‰²ã€‘') &&
                            !text.includes('ã€åŸ·ç­†ä¾é ¼ã€‘')) {
                            modelTexts.push(text);
                        }
                    }
                    return modelTexts.length > 0 ? modelTexts[modelTexts.length - 1] : null;
                }''')
                all_results['æ–¹æ³•3'] = method3_text
                logger.info(f"æ–¹æ³•3çµæœ: {len(method3_text) if method3_text else 0}æ–‡å­—")
            except Exception as e:
                logger.debug(f"æ–¹æ³•3å¤±æ•—: {e}")
                all_results['æ–¹æ³•3'] = None
            
            # å„ªå…ˆé †ä½ã§é¸æŠï¼ˆã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§æ¤œè¨¼ã‚’ç·©å’Œï¼‰
            priority_order = ['æ–¹æ³•1', 'æ–¹æ³•2', 'æ–¹æ³•3']
            best_result = None
            best_method = None
            
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 100:
                    text = all_results[method]
                    
                    # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ··å…¥ã—ã¦ã„ãªã„ã‹æœ€çµ‚ãƒã‚§ãƒƒã‚¯
                    if ('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª' in text or 
                        'ã€ã‚ãªãŸã®å½¹å‰²ã€‘' in text or
                        'ã€åŸ·ç­†ä¾é ¼ã€‘' in text):
                        logger.warning(f"{method}ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ··å…¥ - ã‚¹ã‚­ãƒƒãƒ—")
                        continue
                    
                    # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æ¤œè¨¼ï¼ˆç·©å’Œç‰ˆï¼‰
                    validation_result = self._validate_code_block_completeness_enhanced(text)
                    
                    if validation_result['is_complete']:
                        logger.info(f"âœ… {method}: å®Œå…¨ãªå¿œç­”ã‚’æ¤œå‡º")
                        best_result = text.strip()
                        best_method = method
                        break
                    else:
                        # ä¸å®Œå…¨ã§ã‚‚é•·æ–‡ã®å ´åˆã¯è­¦å‘Šã‚’å‡ºã—ã¦æ¡ç”¨ã™ã‚‹
                        if len(text) > 1500:  # é•·æ–‡ã®å ´åˆã¯è¨±å®¹
                            logger.warning(f"âš ï¸ {method}: ä¸å®Œå…¨ã ãŒé•·æ–‡ã®ãŸã‚æ¡ç”¨ - {validation_result['reason']}")
                            best_result = text.strip()
                            best_method = method
                            break
                        else:
                            logger.warning(f"âš ï¸ {method}: ä¸å®Œå…¨ãªå¿œç­” - {validation_result['reason']}")
            
            if best_result:
                logger.info(f"\nğŸ¯ æ¡ç”¨: {best_method} ({len(best_result)}æ–‡å­—)")
                logger.info(f"å…ˆé ­200æ–‡å­—:\n{best_result[:200]}")
                return best_result
            
            # ã™ã¹ã¦å¤±æ•—ã—ãŸå ´åˆã§ã‚‚ã€æœ€é•·ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã™ï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰
            fallback_text = None
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 500:
                    fallback_text = all_results[method]
                    logger.warning(f"âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¡ç”¨: {method} ({len(fallback_text)}æ–‡å­—)")
                    break
            
            if fallback_text:
                return fallback_text.strip()
            
            # æœ¬å½“ã«ä½•ã‚‚å–å¾—ã§ããªã„å ´åˆ
            logger.error("\nâŒ å…¨æ–¹æ³•å¤±æ•— - Geminiã®å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
            
            # ãƒ‡ãƒãƒƒã‚°ç”¨: ãƒšãƒ¼ã‚¸ã®æ§‹é€ ã‚’ç¢ºèª
            page_structure = await self.page.evaluate('''() => {
                return {
                    messageCount: document.querySelectorAll('[class*="message"]').length,
                    modelMessages: document.querySelectorAll('[data-message-author="model"]').length,
                    markdownContainers: document.querySelectorAll('[class*="markdown"]').length
                };
            }''')
            logger.info(f"ãƒšãƒ¼ã‚¸æ§‹é€ : {page_structure}")
            
            return None
                    
        except Exception as e:
            logger.error(f"âŒ æŠ½å‡ºå…¨ä½“ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
        
    def _validate_code_block_completeness_enhanced(self, text: str) -> Dict:
        """
        ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®å®Œå…¨æ€§ã‚’æ¤œè¨¼(ç·©å’Œç‰ˆ - å°‚é–€æ–‡æ›¸ãƒ»é•·æ–‡å¯¾å¿œå¼·åŒ–)
            
        Returns:
            Dict: {
                'is_complete': bool,
                'reason': str,
                'details': str,
                'incomplete_blocks': List[Dict]
            }
        """
        try:
            # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯(```)ã®ãƒšã‚¢ãƒã‚§ãƒƒã‚¯(ä¸»è¦ãƒã‚§ãƒƒã‚¯)
            code_fence_pattern = r'```(\w+)?\n(.*?)```'
            code_blocks = re.findall(code_fence_pattern, text, re.DOTALL)
                
            # é–‹å§‹ã‚¿ã‚°ã®ã¿ã§çµ‚äº†ã‚¿ã‚°ãŒãªã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
            open_fences = re.findall(r'```(\w+)?(?![\s\S]*?```)', text, re.DOTALL)
                
            if open_fences:
                # é–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œå‡º
                incomplete_blocks = []
                for lang in open_fences:
                    # è©²å½“ç®‡æ‰€ã®ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’å–å¾—
                    pattern = f'```{lang}' if lang else '```'
                    idx = text.find(pattern)
                    snippet = text[idx:idx+100] + '...' if idx != -1 else 'N/A'
                        
                    incomplete_blocks.append({
                        'type': f'code({lang})' if lang else 'code(unknown)',
                        'snippet': snippet
                    })
                    
                return {
                    'is_complete': False,
                    'reason': 'ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“',
                    'details': f'{len(open_fences)}å€‹ã®æœªé–‰ã˜ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œå‡º',
                    'incomplete_blocks': incomplete_blocks
                }
                
            # PHPã‚³ãƒ¼ãƒ‰ã®å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
            if '<?php' in text:
                php_blocks = re.findall(r'```php\n(.*?)```', text, re.DOTALL)
                for php_code in php_blocks:
                    # é–¢æ•°å®šç¾©ã®é–‹å§‹ã¨çµ‚äº†ã®æ³¢æ‹¬å¼§ã®æ•°ã‚’ãƒã‚§ãƒƒã‚¯
                    open_braces = php_code.count('{')
                    close_braces = php_code.count('}')
                        
                    if open_braces > close_braces:
                        # æœ€å¾Œã®10è¡Œã‚’å–å¾—
                        last_lines = '\n'.join(php_code.split('\n')[-10:])
                            
                        return {
                            'is_complete': False,
                            'reason': 'PHPã‚³ãƒ¼ãƒ‰ã®æ³¢æ‹¬å¼§ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“',
                            'details': f'é–‹å§‹: {open_braces}, çµ‚äº†: {close_braces}',
                            'incomplete_blocks': [{
                                'type': 'php',
                                'snippet': f'...æœ€å¾Œã®10è¡Œ:\n{last_lines}'
                            }]
                        }
                
            # JSONã‚³ãƒ¼ãƒ‰ã®å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
            json_blocks = re.findall(r'```json\n(.*?)```', text, re.DOTALL)
            for json_code in json_blocks:
                try:
                    json.loads(json_code)
                except json.JSONDecodeError as e:
                    return {
                        'is_complete': False,
                        'reason': 'JSONã‚³ãƒ¼ãƒ‰ãŒä¸æ­£ã§ã™',
                        'details': f'JSONã‚¨ãƒ©ãƒ¼: {str(e)}',
                        'incomplete_blocks': [{
                            'type': 'json',
                            'snippet': json_code[-200:] if len(json_code) > 200 else json_code
                        }]
                    }
                
            # ========================================
            # ğŸ”§ Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ã®æ¤œè¨¼ï¼ˆæ–°è¦è¿½åŠ ï¼‰
            # ========================================
            if 'from pydantic import' in text or 'class ' in text and 'BaseModel' in text:
                # Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ã®ã‚¯ãƒ©ã‚¹æ§‹é€ ãƒã‚§ãƒƒã‚¯
                pydantic_class_pattern = r'class\s+(\w+)\(BaseModel\):(.*?)(?=\nclass\s|\Z)'
                pydantic_classes = re.findall(pydantic_class_pattern, text, re.DOTALL)
                    
                for class_name, class_body in pydantic_classes:
                    # ã‚¯ãƒ©ã‚¹æœ¬ä½“ãŒç©ºã§ãªã„ã‹ç¢ºèª
                    if not class_body.strip():
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticãƒ¢ãƒ‡ãƒ« {class_name} ã®å®šç¾©ãŒç©ºã§ã™',
                            'details': 'ã‚¯ãƒ©ã‚¹æœ¬ä½“ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ãŒå¿…è¦',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': f'class {class_name}(BaseModel): ...'
                            }]
                        }
                        
                    # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ãŒå°‘ãªãã¨ã‚‚1ã¤ã‚ã‚‹ã‹ç¢ºèª
                    field_pattern = r'^\s+\w+:\s*\w+'
                    if not re.search(field_pattern, class_body, re.MULTILINE):
                        return {
                            'is_complete': False,
                            'reason': f'Pydanticãƒ¢ãƒ‡ãƒ« {class_name} ã«ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©ãŒã‚ã‚Šã¾ã›ã‚“',
                            'details': 'ãƒ¢ãƒ‡ãƒ«ã«ã¯å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå¿…è¦',
                            'incomplete_blocks': [{
                                'type': 'pydantic',
                                'snippet': class_body[:200]
                            }]
                        }
                
            # ========================================
            # ğŸ”§ OpenAPIã‚¹ã‚­ãƒ¼ãƒã®æ¤œè¨¼ï¼ˆæ–°è¦è¿½åŠ ï¼‰
            # ========================================
            if 'openapi:' in text.lower() or '"openapi"' in text.lower():
                # OpenAPI/Swaggerã‚¹ã‚­ãƒ¼ãƒã®åŸºæœ¬æ§‹é€ ã‚’ãƒã‚§ãƒƒã‚¯
                required_openapi_keys = ['openapi', 'info', 'paths']
                    
                # YAMLã¾ãŸã¯JSONå½¢å¼ã®æ¤œå‡º
                if 'openapi:' in text:
                    # YAMLå½¢å¼ã®æ¤œè¨¼
                    for key in required_openapi_keys:
                        if f'{key}:' not in text:
                            return {
                                'is_complete': False,
                                'reason': f'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«å¿…é ˆã‚­ãƒ¼ "{key}" ãŒã‚ã‚Šã¾ã›ã‚“',
                                'details': 'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«ã¯ openapi, info, paths ãŒå¿…è¦',
                                'incomplete_blocks': [{
                                    'type': 'openapi_yaml',
                                    'snippet': text[:300]
                                }]
                            }
                else:
                    # JSONå½¢å¼ã®æ¤œè¨¼
                    try:
                        # JSONæŠ½å‡ºè©¦è¡Œ
                        json_match = re.search(r'\{.*\}', text, re.DOTALL)
                        if json_match:
                            openapi_json = json.loads(json_match.group(0))
                            for key in required_openapi_keys:
                                if key not in openapi_json:
                                    return {
                                        'is_complete': False,
                                        'reason': f'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«å¿…é ˆã‚­ãƒ¼ "{key}" ãŒã‚ã‚Šã¾ã›ã‚“',
                                        'details': 'OpenAPIã‚¹ã‚­ãƒ¼ãƒã«ã¯ openapi, info, paths ãŒå¿…è¦',
                                        'incomplete_blocks': [{
                                            'type': 'openapi_json',
                                            'snippet': json_match.group(0)[:300]
                                        }]
                                    }
                    except (json.JSONDecodeError, AttributeError):
                        pass  # JSONå½¢å¼ã§ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                
            # ========================================
            # ğŸ”§ æ–‡ç« ã®çªç„¶ã®çµ‚äº†ãƒã‚§ãƒƒã‚¯ã‚’å¤§å¹…ç·©å’Œï¼ˆå°‚é–€æ–‡æ›¸å¯¾å¿œï¼‰
            # ========================================
            text_stripped = text.strip()
            if text_stripped:
                last_char = text_stripped[-1]
                    
                # å°‚é–€æ–‡æ›¸ã‚„æŠ€è¡“æ–‡æ›¸ã®çµ‚äº†ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ‹¡å¼µ
                japanese_section_endings = [
                    'é …', 'ç« ', 'ç›®', 'ç¯€', 'æ¡', 'æ¬¾', 'ç‚¹',  # æ—¢å­˜
                    'ã€‚', 'ï¼‰', ')', '}', ']', '`', '>', '"',  # æ–°è¦è¿½åŠ 
                    'äº†', 'æˆ', 'å®š', 'æ˜', 'ç¤º', 'ç”¨', 'ç†'   # å°‚é–€ç”¨èªæœ«å°¾
                ]
                    
                # å³æ ¼ãªçµ‚äº†æ–‡å­—ãƒªã‚¹ãƒˆï¼ˆã“ã‚Œã‚‰ã§çµ‚ã‚ã‚Œã°OKï¼‰
                strict_end_chars = ['.', 'ã€‚', '!', '!', '?', '?', '`', '}', ']', ')']
                    
                if (last_char not in strict_end_chars and 
                    last_char not in japanese_section_endings and
                    not text_stripped.endswith('```')):
                        
                    # ========================================
                    # ğŸ”§ é•·æ–‡ãƒ»å°‚é–€æ–‡æ›¸ã®å ´åˆã¯å¤§å¹…ã«ç·©å’Œï¼ˆæ–°ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
                    # ========================================
                        
                    # æ¡ä»¶1: 3000æ–‡å­—ä»¥ä¸Šã®è¶…é•·æ–‡ã¯çµ‚äº†æ–‡å­—ã‚’ãƒã‚§ãƒƒã‚¯ã—ãªã„
                    if len(text_stripped) > 3000:
                        logger.info(f"âœ… è¶…é•·æ–‡({len(text_stripped)}æ–‡å­—)ã®ãŸã‚çµ‚äº†æ–‡å­—ãƒã‚§ãƒƒã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—")
                        return {
                            'is_complete': True,
                            'reason': 'è¶…é•·æ–‡ã®ãŸã‚çµ‚äº†æ–‡å­—ãƒã‚§ãƒƒã‚¯ã‚’å…é™¤',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}, æœ€å¾Œã®æ–‡å­—: {last_char}'
                        }
                        
                    # æ¡ä»¶2: 2000æ–‡å­—ä»¥ä¸Šã§ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒ3å€‹ä»¥ä¸Šã‚ã‚‹å ´åˆã¯è¨±å®¹
                    if len(text_stripped) > 2000 and len(code_blocks) >= 3:
                        logger.info(f"âœ… é•·æ–‡({len(text_stripped)}æ–‡å­—)ã‹ã¤ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯{len(code_blocks)}å€‹ã®ãŸã‚è¨±å®¹")
                        return {
                            'is_complete': True,
                            'reason': 'é•·æ–‡ã‹ã¤å¤šæ•°ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å«ã‚€ãŸã‚è¨±å®¹',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}, ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æ•°: {len(code_blocks)}'
                        }
                        
                    # æ¡ä»¶3: Pydanticãƒ¢ãƒ‡ãƒ«ã‚„ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‚’å«ã‚€å ´åˆã¯è¨±å®¹
                    if ('from pydantic import' in text or 
                        'class ' in text and 'BaseModel' in text or
                        'openapi:' in text.lower()):
                        logger.info("âœ… å°‚é–€çš„ãªæŠ€è¡“æ–‡æ›¸(Pydantic/OpenAPI)ã®ãŸã‚è¨±å®¹")
                        return {
                            'is_complete': True,
                            'reason': 'å°‚é–€çš„ãªæŠ€è¡“æ–‡æ›¸ã¨ã—ã¦è¨±å®¹',
                            'details': 'Pydanticãƒ¢ãƒ‡ãƒ«ã¾ãŸã¯ã‚¹ã‚­ãƒ¼ãƒå®šç¾©ã‚’å«ã‚€'
                        }
                        
                    # æ¡ä»¶4: 1500æ–‡å­—ä»¥ä¸Šã§ã€Œã¾ã¨ã‚ã€ã€Œçµè«–ã€ã€Œä»¥ä¸Šã€ãªã©ã®ç· ã‚ããã‚Šè¡¨ç¾ãŒã‚ã‚‹å ´åˆ
                    conclusion_patterns = [
                        'ã¾ã¨ã‚', 'çµè«–', 'ä»¥ä¸Š', 'å®Œäº†', 'çµ‚ã‚ã‚Š',
                        'summary', 'conclusion', 'end', 'complete'
                    ]
                    if len(text_stripped) > 1500 and any(pattern in text_stripped[-500:].lower() for pattern in conclusion_patterns):
                        logger.info("âœ… é•·æ–‡ã§ç· ã‚ããã‚Šè¡¨ç¾ã‚’å«ã‚€ãŸã‚è¨±å®¹")
                        return {
                            'is_complete': True,
                            'reason': 'é•·æ–‡ã§ç· ã‚ããã‚Šè¡¨ç¾ã‚’å«ã‚€',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}'
                        }
                        
                    # ä¸Šè¨˜æ¡ä»¶ã«è©²å½“ã—ãªã„çŸ­æ–‡ã¯ä¸å®Œå…¨ã¨åˆ¤å®š
                    if len(text_stripped) < 1500:
                        last_50_chars = text_stripped[-50:]
                            
                        return {
                            'is_complete': False,
                            'reason': 'æ–‡ç« ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
                            'details': f'æœ€å¾Œã®æ–‡å­—: "{last_char}"',
                            'incomplete_blocks': [{
                                'type': 'text',
                                'snippet': f'...æœ€å¾Œã®50æ–‡å­—: {last_50_chars}'
                            }]
                        }
                    else:
                        # 1500æ–‡å­—ä»¥ä¸Šã ãŒæ¡ä»¶ã«è©²å½“ã—ãªã„å ´åˆã¯è­¦å‘Šã®ã¿ã§è¨±å®¹
                        logger.warning(f"âš ï¸ é•·æ–‡({len(text_stripped)}æ–‡å­—)ã ãŒçµ‚äº†æ–‡å­—ãŒä¸æ˜ç­: '{last_char}'")
                        return {
                            'is_complete': True,
                            'reason': 'é•·æ–‡ã®ãŸã‚è­¦å‘Šä»˜ãã§è¨±å®¹',
                            'details': f'æ–‡å­—æ•°: {len(text_stripped)}, æœ€å¾Œã®æ–‡å­—: {last_char}'
                        }
                
            # ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯ã‚’ãƒ‘ã‚¹
            return {
                'is_complete': True,
                'reason': 'ã™ã¹ã¦ã®æ¤œè¨¼ã«åˆæ ¼',
                'details': f'ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æ•°: {len(code_blocks)}'
            }
                
        except Exception as e:
            logger.error(f"ã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨å´ã«å€’ã—ã¦ä¸å®Œå…¨ã¨ã¿ãªã™
            return {
                'is_complete': False,
                'reason': 'æ¤œè¨¼å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ',
                'details': str(e),
                'incomplete_blocks': []
            }
    
    async def extract_latest_text_response_deepseek(self) -> str:
        """DeepSeekã®æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆæ”¹è‰¯ç‰ˆï¼‰"""
        try:
            logger.info("=" * 60)
            logger.info("â˜…â˜…â˜… DeepSeekãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºé–‹å§‹ â˜…â˜…â˜…")
            logger.info("=" * 60)
            
            # DeepSeekç‰¹æœ‰ã®ã‚»ãƒ¬ã‚¯ã‚¿ã§å¿œç­”ã‚’å–å¾—
            response_text = await self.page.evaluate('''() => {
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒŠã‚’æ¢ã™
                const messages = document.querySelectorAll('[class*="message"], [class*="chat"], div[role="article"]');
                let longest = '';
                
                for (const msg of messages) {
                    const text = msg.innerText || '';
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é™¤å¤–
                    if (text.length > 100 && text.length > longest.length) {
                        // ã‚·ã‚¹ãƒ†ãƒ ã‚„ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿
                        const isUserMessage = msg.querySelector('[class*="user"]') || 
                                            msg.classList.toString().includes('user');
                        if (!isUserMessage) {
                            longest = text;
                        }
                    }
                }
                
                if (!longest) {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å¾Œã®é•·ã„divã‚’å–å¾—
                    const divs = document.querySelectorAll('div');
                    for (const d of divs) {
                        const t = d.innerText || '';
                        if (t.length > longest.length && t.length > 200) {
                            longest = t;
                        }
                    }
                }
                
                return longest;
            }''')
            
            if response_text and len(response_text) > 50:
                logger.info(f"âœ… DeepSeekå¿œç­”æŠ½å‡ºæˆåŠŸ: {len(response_text)}æ–‡å­—")
                logger.info(f"å…ˆé ­500æ–‡å­—:\n{response_text[:500]}")
                
                # æ¤œè¨¼ã‚’å®Ÿè¡Œï¼ˆç·©å’Œç‰ˆï¼‰
                validation_result = self._validate_code_block_completeness_enhanced(response_text)
                
                if not validation_result['is_complete'] and len(response_text) > 1500:
                    logger.warning(f"âš ï¸ DeepSeekå¿œç­”ä¸å®Œå…¨ã ãŒé•·æ–‡ã®ãŸã‚æ¡ç”¨: {validation_result['reason']}")
                    # é•·æ–‡ã®å ´åˆã¯ä¸å®Œå…¨ã§ã‚‚æ¡ç”¨
                    return response_text.strip()
                elif validation_result['is_complete']:
                    logger.info("âœ… DeepSeekå¿œç­”æ¤œè¨¼åˆæ ¼")
                    return response_text.strip()
                else:
                    logger.warning(f"âš ï¸ DeepSeekå¿œç­”ä¸å®Œå…¨: {validation_result['reason']}")
                    return response_text.strip()  # ä¸å®Œå…¨ã§ã‚‚è¿”ã™ï¼ˆä»¥å‰ã¯Noneã‚’è¿”ã—ã¦ã„ãŸï¼‰
            else:
                logger.error("âŒ DeepSeekå¿œç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
                
        except Exception as e:
            logger.error(f"âŒ DeepSeekæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    # === æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤‰æ›´ãªã—ï¼ˆextract_json_from_text ãªã©ï¼‰ ===

    # æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã§ç½®ãæ›ãˆã‚‹ãŸã‚ã®äº’æ›æ€§ãƒ¬ã‚¤ãƒ¤ãƒ¼
    def _validate_code_block_completeness(self, text: str) -> Dict:
        """
        æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ãƒ¡ã‚½ãƒƒãƒ‰ - æ–°ã—ã„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
        ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ç¶­æŒã®ãŸã‚ï¼‰
        """
        return self._validate_code_block_completeness_enhanced(text)

    def extract_json_from_text(self, text: str) -> str:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰JSONéƒ¨åˆ†ã‚’æŠ½å‡º"""
        try:
            if not text:
                return None
                
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json ... ``` ã«å›²ã¾ã‚ŒãŸJSON
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡º
            json_match = re.search(r'^\s*(\{.*\})\s*$', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³3: å…ˆé ­ã‹ã‚‰JSONã‚’æ¢ã™
            start_idx = text.find('{')
            if start_idx != -1:
                # { ã‹ã‚‰å§‹ã‚ã¦ã€å¯¾å¿œã™ã‚‹ } ã¾ã§ã‚’æ¢ã™
                brace_count = 0
                for i, char in enumerate(text[start_idx:]):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            potential_json = text[start_idx:start_idx+i+1]
                            try:
                                json.loads(potential_json)
                                return potential_json.strip()
                            except:
                                continue
            return None
        except Exception as e:
            logger.error(f"JSONæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
        
    

#browser_controller.py
# browser_controller.py
"""ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ã‚¯ãƒ©ã‚¹ï¼ˆåˆ†å‰²ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ç‰ˆï¼‰"""
import asyncio
from pathlib import Path
from typing import Optional, Dict
import logging

from browser_lifecycle import BrowserLifecycleManager
from brower_cookie_and_session import CookieSessionManager  # ãƒ•ã‚¡ã‚¤ãƒ«åä¿®æ­£
from browser_ai_chat_agent import AIChatAgent
from browser_wp_session_manager import WPSessionManager
from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserController:
    """ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, download_folder: Path, mode: str = "image", service: str = "google", credentials: Dict = None):
        self.download_folder = download_folder
        self.mode = mode
        self.service = service.lower()
        self.credentials = credentials or {}
        
        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        self.cookies_file = Path(config.COOKIES_FILE) if config.COOKIES_FILE else None
        self.browser_data_dir = Path(config.BROWSER_DATA_DIR) if config.BROWSER_DATA_DIR else None
        self.wp_cookies_file = Path(config.BROWSER_DATA_DIR) / "wp_cookies.json" if config.BROWSER_DATA_DIR else None
        
        # ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–ï¼ˆsetup_browserã§å®Œå…¨åˆæœŸåŒ–ï¼‰
        self.lifecycle_manager: Optional[BrowserLifecycleManager] = None
        self.session_manager: Optional[CookieSessionManager] = None
        self.ai_agent: Optional[AIChatAgent] = None
        self.wp_manager: Optional[WPSessionManager] = None
    
    async def setup_browser(self) -> None:
        """ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— - ã™ã¹ã¦ã®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–"""
        try:
            # ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–ã¨ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            self.lifecycle_manager = BrowserLifecycleManager(
                browser_data_dir=self.browser_data_dir,
                download_folder=self.download_folder
            )
            await self.lifecycle_manager.setup_browser()
            
            # ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
            self.session_manager = CookieSessionManager(
                context=self.lifecycle_manager.context,
                cookies_file=self.cookies_file
            )
            
            # AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
            self.ai_agent = AIChatAgent(
                page=self.lifecycle_manager.page,
                service=self.service,
                credentials=self.credentials
            )
            
            # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
            self.wp_manager = WPSessionManager(
                context=self.lifecycle_manager.context,
                wp_cookies_file=self.wp_cookies_file
            )
            
            logger.info(f"âœ… ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰åˆæœŸåŒ–å®Œäº†ï¼ˆã‚µãƒ¼ãƒ“ã‚¹: {self.service}ï¼‰")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚¡ã‚µãƒ¼ãƒ‰ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—")
            raise
    
    # ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å§”è­²
    @property
    def context(self):
        return self.lifecycle_manager.context if self.lifecycle_manager else None
    
    @property
    def page(self):
        return self.lifecycle_manager.page if self.lifecycle_manager else None
    
    @property
    def wp_page(self):
        return self.wp_manager.wp_page if self.wp_manager else None
    
    @property
    def is_logged_in(self):
        return self.wp_manager.is_logged_in if self.wp_manager else False
    
    # AIãƒãƒ£ãƒƒãƒˆé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ã®å§”è­²
    async def navigate_to_gemini(self) -> None:
        """Geminiã«ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.navigate_to_gemini()
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekã«ãƒŠãƒ“ã‚²ãƒ¼ãƒˆ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.navigate_to_deepseek()
    
    async def send_prompt(self, prompt: str) -> None:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.send_prompt(prompt)
    
    async def wait_for_text_generation(self, max_wait: int = 180) -> bool:
        """
        ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã‚’å¾…æ©Ÿï¼ˆå¼·åŒ–ç‰ˆï¼‰
            
        Args:
            max_wait: æœ€å¤§å¾…æ©Ÿæ™‚é–“ï¼ˆç§’ï¼‰
                
        Returns:
            bool: ç”Ÿæˆå®Œäº†ãƒ•ãƒ©ã‚°
        """
        try:
            logger.info(f"â±ï¸ ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå¾…æ©Ÿé–‹å§‹ï¼ˆæœ€å¤§{max_wait}ç§’ï¼‰")
                
            start_time = asyncio.get_event_loop().time()
            check_interval = 2.0  # 2ç§’ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
            last_length = 0
            stable_count = 0
            required_stable = 3  # 3å›é€£ç¶šã§å¤‰åŒ–ãªã—ã§å®Œäº†ã¨åˆ¤å®š
                
            while True:
                elapsed = asyncio.get_event_loop().time() - start_time
                    
                if elapsed > max_wait:
                    logger.warning(f"â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
                    return False
                    
                # ç¾åœ¨ã®ãƒ†ã‚­ã‚¹ãƒˆé•·ã‚’å–å¾—
                try:
                    current_text = await self._get_current_text_quick()
                    current_length = len(current_text)
                        
                    # ãƒ†ã‚­ã‚¹ãƒˆãŒå¢—ãˆã¦ã„ã‚‹ã‹ç¢ºèª
                    if current_length > last_length:
                        logger.info(f"ğŸ“ ç”Ÿæˆä¸­: {current_length}æ–‡å­—ï¼ˆçµŒé: {int(elapsed)}ç§’ï¼‰")
                        last_length = current_length
                        stable_count = 0
                    else:
                        # é•·ã•ãŒå¤‰ã‚ã‚‰ãªã„
                        stable_count += 1
                        logger.info(f"â¸ï¸ å®‰å®š: {stable_count}/{required_stable}ï¼ˆ{current_length}æ–‡å­—ï¼‰")
                            
                        if stable_count >= required_stable:
                            logger.info(f"âœ… ç”Ÿæˆå®Œäº†ï¼ˆ{current_length}æ–‡å­—ã€{int(elapsed)}ç§’ï¼‰")
                            return True
                    
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
                    
                # å¾…æ©Ÿ
                await asyncio.sleep(check_interval)
            
        except Exception as e:
            logger.error(f"âŒ å¾…æ©Ÿã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def extract_latest_text_response(self, allow_partial: bool = True) -> Optional[str]:
        """
        æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆå¼·åŒ–ç‰ˆï¼‰
        
        Args:
            allow_partial: éƒ¨åˆ†çš„ãªå¿œç­”ã‚‚è¨±å¯ã™ã‚‹ã‹
            
        Returns:
            Optional[str]: æŠ½å‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ
        """
        try:
            logger.info("="*60)
            logger.info("â˜…â˜…â˜… Geminiå¿œç­”æŠ½å‡ºé–‹å§‹ï¼ˆå¼·åŒ–ç‰ˆï¼‰ â˜…â˜…â˜…")
            logger.info("="*60)
            
            results = {}
            
            # ============================================================
            # === æ–¹æ³•1: model-response-text ã‚¯ãƒ©ã‚¹ ===
            # ============================================================
            try:
                message_divs = await self.page.query_selector_all('div.model-response-text')
                if message_divs:
                    last_message = message_divs[-1]
                    text1 = await last_message.inner_text()
                    if text1 and len(text1) > 100:
                        results['method1'] = text1
                        logger.info(f"âœ… æ–¹æ³•1æˆåŠŸ: {len(text1)}æ–‡å­—")
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•1å¤±æ•—: {e}")
            
            # ============================================================
            # === æ–¹æ³•2: markdown-container ã‚¯ãƒ©ã‚¹ ===
            # ============================================================
            try:
                markdown_divs = await self.page.query_selector_all('div.markdown-container')
                if markdown_divs:
                    last_markdown = markdown_divs[-1]
                    text2 = await last_markdown.inner_text()
                    if text2 and len(text2) > 100:
                        results['method2'] = text2
                        logger.info(f"âœ… æ–¹æ³•2æˆåŠŸ: {len(text2)}æ–‡å­—")
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•2å¤±æ•—: {e}")
            
            # ============================================================
            # === æ–¹æ³•3: message-content ã‚¯ãƒ©ã‚¹ ===
            # ============================================================
            try:
                content_divs = await self.page.query_selector_all('div.message-content')
                if content_divs:
                    # æœ€å¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
                    for div in reversed(content_divs):
                        text3 = await div.inner_text()
                        if text3 and len(text3) > 100 and 'model-response' not in text3.lower():
                            results['method3'] = text3
                            logger.info(f"âœ… æ–¹æ³•3æˆåŠŸ: {len(text3)}æ–‡å­—")
                            break
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•3å¤±æ•—: {e}")
            
            # ============================================================
            # === æ–¹æ³•4: data-test-id å±æ€§ ===
            # ============================================================
            try:
                test_divs = await self.page.query_selector_all('[data-test-id*="conversation-turn"]')
                if test_divs:
                    last_turn = test_divs[-1]
                    text4 = await last_turn.inner_text()
                    if text4 and len(text4) > 100:
                        results['method4'] = text4
                        logger.info(f"âœ… æ–¹æ³•4æˆåŠŸ: {len(text4)}æ–‡å­—")
            except Exception as e:
                logger.warning(f"âš ï¸ æ–¹æ³•4å¤±æ•—: {e}")
            
            # ============================================================
            # === çµæœé¸æŠï¼ˆæœ€é•·ã®ã‚‚ã®ã‚’é¸æŠï¼‰ ===
            # ============================================================
            if not results:
                logger.error("âŒ å…¨æ–¹æ³•å¤±æ•— - å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
                
                # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
                try:
                    page_content = await self.page.content()
                    logger.info(f"ğŸ“„ ãƒšãƒ¼ã‚¸é•·: {len(page_content)}æ–‡å­—")
                except:
                    pass
                
                return None
            
            # æœ€ã‚‚é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’é¸æŠ
            best_method = max(results.items(), key=lambda x: len(x[1]))
            selected_text = best_method[1]
            
            logger.info(f"âœ… æœ€é©çµæœé¸æŠ: {best_method[0]} ({len(selected_text)}æ–‡å­—)")
            
            # ============================================================
            # === å“è³ªãƒã‚§ãƒƒã‚¯ï¼ˆç·©å’Œç‰ˆï¼‰ ===
            # ============================================================
            warnings = []
            
            # é•·ã•ãƒã‚§ãƒƒã‚¯
            if len(selected_text) < 500:
                warnings.append(f'çŸ­ã„å¿œç­”ï¼ˆ{len(selected_text)}æ–‡å­—ï¼‰')
            
            # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯ï¼ˆç·©å’Œï¼‰
            if allow_partial:
                # éƒ¨åˆ†çš„ãªã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚‚è¨±å¯
                if '```' in selected_text:
                    open_count = selected_text.count('```')
                    if open_count % 2 != 0:
                        warnings.append('ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æœªå®Œçµï¼ˆè¨±å¯ï¼‰')
            else:
                # å³å¯†ãªãƒã‚§ãƒƒã‚¯
                open_blocks = selected_text.count('```')
                if open_blocks % 2 != 0:
                    warnings.append('ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æœªå®Œçµ')
            
            # è­¦å‘Šè¡¨ç¤º
            if warnings:
                logger.warning("âš ï¸ å“è³ªè­¦å‘Š:")
                for w in warnings:
                    logger.warning(f"  - {w}")
            
            # éƒ¨åˆ†å¿œç­”ã‚‚è¨±å¯ã™ã‚‹å ´åˆã¯ã€è­¦å‘ŠãŒã‚ã£ã¦ã‚‚è¿”ã™
            if allow_partial:
                logger.info("âœ… éƒ¨åˆ†å¿œç­”ã‚’è¨±å¯ - ãã®ã¾ã¾è¿”å´")
                return selected_text
            
            # å³å¯†ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€é‡å¤§ãªå•é¡ŒãŒã‚ã‚Œã°None
            if len(selected_text) < 100:
                logger.error("âŒ å¿œç­”ãŒçŸ­ã™ãã‚‹ï¼ˆ100æ–‡å­—æœªæº€ï¼‰")
                return None
            
            logger.info("="*60)
            logger.info(f"âœ… å¿œç­”æŠ½å‡ºå®Œäº†: {len(selected_text)}æ–‡å­—")
            logger.info("="*60)
            
            return selected_text
        
        except Exception as e:
            logger.error(f"âŒ å¿œç­”æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    async def send_prompt_and_wait(self, prompt: str, max_wait: int = 120) -> bool:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¾…æ©Ÿ - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.ai_agent.send_prompt_and_wait(prompt, max_wait)
    
    # ã‚¯ãƒƒã‚­ãƒ¼ç®¡ç†ã®å§”è­²
    async def save_cookies(self) -> None:
        """ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ - ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.session_manager:
            raise Exception("ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.session_manager.save_cookies()
    
    async def load_cookies(self) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ - ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.session_manager:
            logger.warning("ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        return await self.session_manager.load_cookies()
    
    # WordPressé–¢é€£ãƒ¡ã‚½ãƒƒãƒ‰ã®å§”è­²
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ– - WPãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.wp_manager:
            raise Exception("WordPressãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.wp_manager.initialize_wp_session(auth_module)
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ - WPãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.wp_manager:
            raise Exception("WordPressãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.wp_manager.save_wordpress_cookies(wp_url)
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPressã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ - WPãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.wp_manager:
            raise Exception("WordPressãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return await self.wp_manager.load_wordpress_cookies(wp_url)
    
    # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã®å§”è­²
    async def cleanup(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— - ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã‚‹
        if self.wp_manager:
            await self.wp_manager.close_wp_session()
        
        # ãƒ¡ã‚¤ãƒ³ã®ãƒ–ãƒ©ã‚¦ã‚¶ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if self.lifecycle_manager:
            await self.lifecycle_manager.cleanup()
    
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
    async def save_text_to_file(self, text: str, filename: str) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ - ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¨ã—ã¦ç¶­æŒ"""
        try:
            save_path = self.download_folder / filename
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(text)
            if save_path.exists():
                file_size = save_path.stat().st_size
                logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                return True
            else:
                logger.error(f"âŒ ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜å¤±æ•—: {filename}")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜")
            return False
    
    # å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰
    async def _is_browser_alive(self) -> bool:
        """ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèª - ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã«å§”è­²"""
        if not self.lifecycle_manager:
            return False
        return await self.lifecycle_manager._is_browser_alive()
    
    async def handle_welcome_screens(self) -> None:
        """ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢å‡¦ç† - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.handle_welcome_screens()
    
    async def ensure_normal_chat_mode(self) -> None:
        """é€šå¸¸ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ç¢ºèª - AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«å§”è­²"""
        if not self.ai_agent:
            raise Exception("AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        await self.ai_agent.ensure_normal_chat_mode()
    
    # éæ¨å¥¨ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ï¼‰
    async def _wait_for_generation_complete(self, max_wait: int = 120) -> bool:
        """éæ¨å¥¨ãƒ¡ã‚½ãƒƒãƒ‰ - å¾Œæ–¹äº’æ›æ€§ã®ãŸã‚ç¶­æŒ"""
        logger.warning("âš ï¸ éæ¨å¥¨ãƒ¡ã‚½ãƒƒãƒ‰ _wait_for_generation_complete ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ")
        return await self.wait_for_text_generation(max_wait)
    
async def ensure_browser_ready(self) -> bool:
    """
    ãƒ–ãƒ©ã‚¦ã‚¶ã®æº–å‚™å®Œäº†ã‚’ç¢ºèªï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†å¼·åŒ–ç‰ˆï¼‰
        
    Returns:
        bool: æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°
    """
    try:
        # ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ã—ã¦ã„ã‚‹ã‹ç¢ºèª
        if not self.browser:
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ã—ã¦ã„ã¾ã›ã‚“")
            return False
            
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæœ‰åŠ¹ã‹ç¢ºèª
        if not self.context:
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚Šã¾ã›ã‚“")
            return False
            
        # ãƒšãƒ¼ã‚¸ãŒæœ‰åŠ¹ã‹ç¢ºèª
        if not self.page:
            logger.error("âŒ ãƒšãƒ¼ã‚¸ãŒã‚ã‚Šã¾ã›ã‚“")
            return False
            
        # ãƒšãƒ¼ã‚¸ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ã‹ç¢ºèª
        try:
            is_closed = self.page.is_closed()
            if is_closed:
                logger.error("âŒ ãƒšãƒ¼ã‚¸ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã™ - å†ä½œæˆ")
                self.page = await self.context.new_page()
                await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
                await asyncio.sleep(3)
                logger.info("âœ… ãƒšãƒ¼ã‚¸ã‚’å†ä½œæˆã—ã¾ã—ãŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒšãƒ¼ã‚¸çŠ¶æ…‹ç¢ºèªã‚¨ãƒ©ãƒ¼: {e}")
            
        # Geminiãƒšãƒ¼ã‚¸ã«ã„ã‚‹ã‹ç¢ºèª
        current_url = self.page.url
        if 'gemini.google.com' not in current_url:
            logger.warning(f"âš ï¸ Geminiãƒšãƒ¼ã‚¸ã§ã¯ã‚ã‚Šã¾ã›ã‚“: {current_url}")
            logger.info("ğŸ”„ Geminiãƒšãƒ¼ã‚¸ã«ç§»å‹•ä¸­...")
            await self.page.goto('https://gemini.google.com/app', wait_until='networkidle')
            await asyncio.sleep(3)
            
        logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶æº–å‚™å®Œäº†")
        return True
        
    except Exception as e:
        logger.error(f"âŒ ãƒ–ãƒ©ã‚¦ã‚¶æº–å‚™ç¢ºèªã‚¨ãƒ©ãƒ¼: {e}")
        return False
    
async def send_prompt(self, prompt: str) -> bool:
    """
    ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ä»˜ãï¼‰
        
    Args:
        prompt: é€ä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            
    Returns:
        bool: é€ä¿¡æˆåŠŸãƒ•ãƒ©ã‚°
    """
    try:
        # ãƒ–ãƒ©ã‚¦ã‚¶æº–å‚™ç¢ºèª
        if not await self.ensure_browser_ready():
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒæº–å‚™ã§ãã¦ã„ã¾ã›ã‚“")
            return False
            
        logger.info("ğŸ“¤ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ä¸­...")
            
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›æ¬„ã‚’æ¢ã™
        input_selectors = [
            'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'textarea[aria-label*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'div[contenteditable="true"]',
            'textarea.ql-editor',
            'div.ql-editor'
        ]
            
        input_box = None
        for selector in input_selectors:
            try:
                input_box = await self.page.wait_for_selector(selector, timeout=5000)
                if input_box:
                    break
            except:
                continue
            
        if not input_box:
            logger.error("âŒ å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return False
            
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå…¥åŠ›
        await input_box.click()
        await asyncio.sleep(0.5)
        await input_box.fill(prompt)
        await asyncio.sleep(1)
            
        # é€ä¿¡ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
        send_button = await self.page.query_selector('button[aria-label*="é€ä¿¡"]')
        if send_button:
            await send_button.click()
            logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å®Œäº†")
            return True
        else:
            # Enterã‚­ãƒ¼ã§é€ä¿¡
            await self.page.keyboard.press('Enter')
            logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å®Œäº†ï¼ˆEnterï¼‰")
            return True
        
    except Exception as e:
        logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
        return False
    

#browser_lifecycle.py
# browser_lifecycle.py
"""ãƒ–ãƒ©ã‚¦ã‚¶ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹"""
import asyncio
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import async_playwright, Page, BrowserContext
import logging
import psutil

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class BrowserLifecycleManager:
    """ãƒ–ãƒ©ã‚¦ã‚¶ã®èµ·å‹•ãƒ»çµ‚äº†ãƒ»ç”Ÿå­˜ç®¡ç†ã‚’æ‹…å½“"""
    
    def __init__(self, browser_data_dir: Path, download_folder: Path):
        self.browser_data_dir = browser_data_dir
        self.download_folder = download_folder
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.playwright = None
        
        self.download_folder.mkdir(exist_ok=True, parents=True)
        if self.browser_data_dir:
            self.browser_data_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup_browser(self) -> None:
        """ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ï¼ˆãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œç‰ˆï¼‰"""
        try:
            logger.info("="*60)
            logger.info("ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•é–‹å§‹...")
            logger.info("="*60)
            
            # æ—¢å­˜ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            await self._cleanup_existing_browser_processes()
            
            self.playwright = await async_playwright().start()
            logger.info(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.browser_data_dir}")
            
            # ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œ: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’æŒ‡å®š
            window_width = 1280
            window_height = 700
            x_position = 0
            y_position = 0
            
            # ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ï¼ˆä½ç½®ã¨ã‚µã‚¤ã‚ºæŒ‡å®šï¼‰
            self.context = await self.playwright.chromium.launch_persistent_context(
                user_data_dir=str(self.browser_data_dir),
                viewport={'width': window_width, 'height': window_height},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                accept_downloads=True,
                ignore_https_errors=True,
                no_viewport=False,
                **config.BROWSER_CONFIG
            )
            
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½œæˆæˆåŠŸ")
            
            # ãƒšãƒ¼ã‚¸ä½œæˆ
            self.page = await self.context.new_page()
            
            # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æŒ‡å®šä½ç½®ã«ç§»å‹•
            await self.page.evaluate(f"""
                window.moveTo({x_position}, {y_position});
                window.resizeTo({window_width}, {window_height});
            """)
            
            logger.info(f"âœ… ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½ç½® ({x_position}, {y_position}) ã«é…ç½®")
            
            # ãƒ–ãƒ©ã‚¦ã‚¶ãŒæ­£å¸¸ã«èµ·å‹•ã—ãŸã‹ç¢ºèª
            await asyncio.sleep(2)
            if not await self._is_browser_alive():
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ç›´å¾Œã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ")
            
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèªå®Œäº†")
            
            # è‡ªå‹•åŒ–æ¤œå‡ºã‚’å›é¿
            await self.page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false,
                });
                window.navigator.chrome = {
                    runtime: {},
                };
                const originalQuery = window.navigator.permissions.query;
                window.navigator.permissions.query = (parameters) => (
                    parameters.name === 'notifications' ?
                        Promise.resolve({ state: Notification.permission }) :
                        originalQuery(parameters)
                );
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['ja-JP', 'ja', 'en-US', 'en'],
                });
            """)
            
            self.page.set_default_timeout(config.PAGE_TIMEOUT)
            self.page.set_default_navigation_timeout(config.PAGE_TIMEOUT)
            
            logger.info("="*60)
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•å®Œäº†")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•")
            logger.error("="*60)
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•å¤±æ•—")
            logger.error("="*60)
            
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            logger.error(f"ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.browser_data_dir}")
            
            await self._cleanup_existing_browser_processes()
            raise Exception(f"ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}")
    
    async def _is_browser_alive(self) -> bool:
        """ãƒ–ãƒ©ã‚¦ã‚¶ãŒç”Ÿãã¦ã„ã‚‹ã‹ç¢ºèª"""
        try:
            if not self.page:
                return False
            result = await self.page.evaluate("1 + 1")
            return result == 2
        except Exception as e:
            logger.warning(f"ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèªå¤±æ•—: {e}")
            return False
    
    async def _cleanup_existing_browser_processes(self):
        """æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            logger.info("æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¢ºèªä¸­...")
            
            killed_count = 0
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if 'chrome' in proc.info['name'].lower() or 'chromium' in proc.info['name'].lower():
                        cmdline = proc.cmdline()
                        if str(self.browser_data_dir) in ' '.join(cmdline):
                            logger.warning(f"æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†: PID={proc.info['pid']}")
                            proc.kill()
                            killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if killed_count > 0:
                logger.info(f"âœ… {killed_count}å€‹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ã—ã¾ã—ãŸ")
                await asyncio.sleep(2)
            else:
                logger.info("æ—¢å­˜ãƒ—ãƒ­ã‚»ã‚¹ãªã—")
                
        except ImportError:
            logger.warning("psutilãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ—")
        except Exception as e:
            logger.warning(f"ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
    
    async def cleanup(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            logger.info("ğŸ”„ ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™...")

            # éåŒæœŸã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            try:
                tasks = [t for t in asyncio.all_tasks() 
                        if t is not asyncio.current_task()]
                        
                if tasks:
                    logger.info(f"ğŸ”„ {len(tasks)}å€‹ã®éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­...")
                    for task in tasks:
                        task.cancel()
                            
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=5.0
                    )
                    logger.info("âœ… éåŒæœŸã‚¿ã‚¹ã‚¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
            except asyncio.TimeoutError:
                logger.warning("âš ï¸ ã‚¿ã‚¹ã‚¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")

            # ãƒšãƒ¼ã‚¸ã®ã‚¯ãƒ­ãƒ¼ã‚º
            if self.page:
                try:
                    await self.page.close()
                    logger.info("âœ… ãƒšãƒ¼ã‚¸ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

            # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¯ãƒ­ãƒ¼ã‚º
            if self.context:
                try:
                    await self.context.close()
                    logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

            # Playwrightã®åœæ­¢
            if self.playwright:
                try:
                    await self.playwright.stop()
                    logger.info("âœ… Playwrightã‚’åœæ­¢ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ Playwrightåœæ­¢ä¸­ã®è­¦å‘Š: {e}")

            logger.info("âœ… ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")

        except Exception as e:
            logger.error(f"âŒ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")

#browser_wp_session_manager.py
# browser_wp_session_manager.py
"""WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹"""
import json
import time
from pathlib import Path
from typing import Optional, Dict
from playwright.async_api import Page, BrowserContext
import logging

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)

class WPSessionManager:
    """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ç®¡ç†ã‚’æ‹…å½“"""
    
    def __init__(self, context: BrowserContext, wp_cookies_file: Path):
        self.context = context
        self.wp_cookies_file = wp_cookies_file
        self.wp_page: Optional[Page] = None
        self.is_logged_in = False
    
    async def initialize_wp_session(self, auth_module=None) -> bool:
        """
        WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
            
        Args:
            auth_module: WordPressèªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆä»»æ„ï¼‰
            
        Returns:
            bool: åˆæœŸåŒ–æˆåŠŸæ™‚ True
        """
        try:
            logger.info("="*60)
            logger.info("ğŸ” WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
                
            # Phase 1: æ–°ã—ã„ã‚¿ãƒ–ã‚’ä½œæˆ
            if not self.context:
                logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            self.wp_page = await self.context.new_page()
            logger.info("âœ… WordPress å°‚ç”¨ã‚¿ãƒ–ã‚’ä½œæˆã—ã¾ã—ãŸ")
                
            # Phase 2: èªè¨¼æƒ…å ±ã®æ¤œè¨¼
            if not auth_module:
                logger.warning("âš ï¸ WordPress èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                logger.info("æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
                
            # Phase 3: ãƒ­ã‚°ã‚¤ãƒ³å®Ÿè¡Œï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            logger.info("ğŸ”„ WordPressèªè¨¼ã‚’å®Ÿè¡Œä¸­...")
            
            if auth_module:
                login_success = await auth_module.login(self.wp_page)
            else:
                # èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒãªã„å ´åˆã¯æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚’ä¿ƒã™
                login_success = await self._manual_wp_login()
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("âœ… WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†")
                logger.info("  èªè¨¼æ–¹æ³•: ã‚¯ãƒƒã‚­ãƒ¼ or æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³")
                logger.info("  ãƒšãƒ¼ã‚¸URL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("âŒ WordPress ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                logger.error("  åŸå› : èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                logger.error("  å¯¾ç­–: èªè¨¼æƒ…å ±ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                logger.error("="*60)
                    
                # ãƒ‡ãƒãƒƒã‚°ç”¨: å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("ğŸ“¸ ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _manual_wp_login(self) -> bool:
        """æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†"""
        try:
            logger.info("="*60)
            logger.info("ğŸ” æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
            logger.info("="*60)
            logger.info("")
            logger.info("ğŸ“Œ ãƒ­ã‚°ã‚¤ãƒ³æ‰‹é †ï¼š")
            logger.info("1. ãƒ–ãƒ©ã‚¦ã‚¶ã§WordPressç®¡ç†ç”»é¢ã‚’é–‹ã")
            logger.info("2. ãƒ¦ãƒ¼ã‚¶ãƒ¼å/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã§ãƒ­ã‚°ã‚¤ãƒ³")
            logger.info("3. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã“ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«æˆ»ã‚‹")
            logger.info("4. Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ç¶šè¡Œ")
            logger.info("")
            logger.info("ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼š")
            logger.info("  - ãƒ­ã‚°ã‚¤ãƒ³å¾Œã¯ã“ã®ã‚¿ãƒ–ã‚’é–‰ã˜ãªã„ã§ãã ã•ã„")
            logger.info("  - ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¯Cookieã§ç¶­æŒã•ã‚Œã¾ã™")
            logger.info("="*60)
            
            # ä¸€èˆ¬çš„ãªWordPressãƒ­ã‚°ã‚¤ãƒ³URLã«ç§»å‹•
            await self.wp_page.goto("/wp-admin", wait_until="domcontentloaded")
            
            input("\nâœ… ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸã‚’ç¢ºèª
            current_url = self.wp_page.url
            if 'wp-admin' in current_url or 'dashboard' in current_url.lower():
                logger.info("âœ… WordPressãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸã‚’ç¢ºèª")
                return True
            else:
                logger.warning("âš ï¸ WordPressç®¡ç†ç”»é¢ã«åˆ°é”ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
                return False
                
        except Exception as e:
            logger.error(f"æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def save_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPresså°‚ç”¨ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜"""
        try:
            if not self.context or not self.wp_cookies_file:
                logger.warning("âš ï¸ ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
            
            # ç¾åœ¨ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’å–å¾—
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("ä¿å­˜ã™ã‚‹ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
            
            # WordPressé–¢é€£ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_cookies = [c for c in cookies if wp_domain in c.get('domain', '')]
            
            if not wp_cookies:
                logger.warning("WordPressé–¢é€£ã®ã‚¯ãƒƒã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            # æ—¢å­˜ã®ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            all_cookies = {}
            if self.wp_cookies_file.exists():
                try:
                    with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                        all_cookies = json.load(f)
                except Exception as e:
                    logger.warning(f"æ—¢å­˜ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
                    all_cookies = {}
            
            # WordPress ã‚¯ãƒƒã‚­ãƒ¼ã‚’æ›´æ–°
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            all_cookies[wp_key] = {
                'cookies': wp_cookies,
                'timestamp': time.time(),
                'domain': wp_url
            }
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            self.wp_cookies_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self.wp_cookies_file, 'w', encoding='utf-8') as f:
                json.dump(all_cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"âœ… WordPress ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜å®Œäº†: {len(wp_cookies)}å€‹")
            return True
            
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def load_wordpress_cookies(self, wp_url: str) -> bool:
        """WordPresså°‚ç”¨ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿"""
        try:
            if not self.wp_cookies_file or not self.wp_cookies_file.exists():
                logger.warning("WordPress ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“")
                return False
            
            if not self.context:
                logger.warning("ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
            with open(self.wp_cookies_file, 'r', encoding='utf-8') as f:
                all_cookies = json.load(f)
            
            # WordPress ã‚¯ãƒƒã‚­ãƒ¼ã‚’å–å¾—
            wp_domain = wp_url.replace('https://', '').replace('http://', '').split('/')[0]
            wp_key = f"wp_{wp_domain.replace('.', '_')}"
            
            if wp_key not in all_cookies:
                logger.warning(f"WordPress ã‚¯ãƒƒã‚­ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {wp_key}")
                return False
            
            wp_cookie_data = all_cookies[wp_key]
            cookies = wp_cookie_data.get('cookies', [])
            
            if not cookies:
                logger.warning("æœ‰åŠ¹ãª WordPress ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
            
            # æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
            valid_cookies = []
            for cookie in cookies:
                if 'expires' in cookie:
                    if cookie['expires'] > time.time():
                        valid_cookies.append(cookie)
                else:
                    # expires ãŒãªã„ã‚¯ãƒƒã‚­ãƒ¼ã¯ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒƒã‚­ãƒ¼
                    valid_cookies.append(cookie)
            
            if not valid_cookies:
                logger.warning("æœ‰åŠ¹æœŸé™åˆ‡ã‚Œã®ã‚¯ãƒƒã‚­ãƒ¼ã®ã¿å­˜åœ¨ã—ã¾ã™")
                return False
            
            # ã‚¯ãƒƒã‚­ãƒ¼ã‚’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ 
            await self.context.add_cookies(valid_cookies)
            logger.info(f"âœ… WordPress ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿å®Œäº†: {len(valid_cookies)}å€‹")
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def close_wp_session(self) -> None:
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã‚‹"""
        try:
            if self.wp_page:
                await self.wp_page.close()
                self.wp_page = None
                self.is_logged_in = False
                logger.info("âœ… WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’é–‰ã˜ã¾ã—ãŸ")
        except Exception as e:
            logger.warning(f"WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

#cache_manager.py
"""
CacheManager - ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

é »ç¹ãªã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€ä¿®æ­£æ¸ˆã¿ã‚¨ãƒ©ãƒ¼ã®è¨˜éŒ²ã€
é¡ä¼¼ã‚¨ãƒ©ãƒ¼ã®æ¤œå‡ºã¨é«˜é€Ÿä¿®æ­£ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹æœŸé™ç®¡ç†ã‚’æä¾›ã™ã‚‹ã€‚
"""

import json
import hashlib
import pickle
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import Counter
import logging

logger = logging.getLogger(__name__)


@dataclass
class ErrorPattern:
    """ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³"""
    error_type: str
    error_message_pattern: str
    stack_trace_pattern: str
    file_pattern: str
    frequency: int = 0
    last_seen: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "error_type": self.error_type,
            "error_message_pattern": self.error_message_pattern,
            "stack_trace_pattern": self.stack_trace_pattern,
            "file_pattern": self.file_pattern,
            "frequency": self.frequency,
            "last_seen": self.last_seen.isoformat()
        }


@dataclass
class CachedFix:
    """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸä¿®æ­£"""
    error_hash: str
    fix_code: str
    fix_description: str
    success_rate: float
    application_count: int
    created_at: datetime
    last_used: datetime
    ttl_hours: int = 168  # 1é€±é–“
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_expired(self) -> bool:
        """æœ‰åŠ¹æœŸé™åˆ‡ã‚Œã‹ãƒã‚§ãƒƒã‚¯"""
        expiry = self.created_at + timedelta(hours=self.ttl_hours)
        return datetime.now() > expiry
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "error_hash": self.error_hash,
            "fix_code": self.fix_code,
            "fix_description": self.fix_description,
            "success_rate": self.success_rate,
            "application_count": self.application_count,
            "created_at": self.created_at.isoformat(),
            "last_used": self.last_used.isoformat(),
            "ttl_hours": self.ttl_hours,
            "metadata": self.metadata
        }


class CacheManagerAgent:
    """
    ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ä¸»ãªæ©Ÿèƒ½:
    1. ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å­¦ç¿’ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    2. ä¿®æ­£æ¸ˆã¿ã‚¨ãƒ©ãƒ¼ã®è¨˜éŒ²
    3. é¡ä¼¼ã‚¨ãƒ©ãƒ¼ã®é«˜é€Ÿæ¤œå‡º
    4. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹æœŸé™ç®¡ç†
    5. ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ã®æœ€é©åŒ–
    """
    
    def __init__(self, 
                 cache_dir: str = ".cache",
                 similarity_threshold: float = 0.85,
                 max_cache_size: int = 1000):
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self.similarity_threshold = similarity_threshold
        self.max_cache_size = max_cache_size
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
        self.fix_cache: Dict[str, CachedFix] = {}
        self.error_patterns: Dict[str, ErrorPattern] = {}
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "cache_hits": 0,
            "cache_misses": 0,
            "patterns_learned": 0,
            "fixes_cached": 0,
            "successful_applications": 0,
            "failed_applications": 0
        }
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ã‚¡ã‚¤ãƒ«
        self.cache_file = self.cache_dir / "fix_cache.pkl"
        self.patterns_file = self.cache_dir / "error_patterns.json"
        
        # èµ·å‹•æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’èª­ã¿è¾¼ã‚€
        self._load_cache()
        
        logger.info(f"CacheManagerAgent initialized (cache_dir={cache_dir})")
    
    def compute_error_hash(self, error_context: Dict[str, Any]) -> str:
        """
        ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—
        
        é¡ä¼¼ã—ãŸã‚¨ãƒ©ãƒ¼ã¯åŒã˜ãƒãƒƒã‚·ãƒ¥ã‚’æŒã¤ã‚ˆã†ã«æ­£è¦åŒ–ã™ã‚‹
        """
        # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰å¤‰æ•°åã‚„å€¤ã‚’é™¤å»ã—ã¦æ­£è¦åŒ–
        error_type = error_context.get("error_type", "")
        error_message = error_context.get("error_message", "")
        source_file = error_context.get("source_file", "")
        
        # æ­£è¦åŒ–: æ•°å­—ã€ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®å…·ä½“çš„ãªéƒ¨åˆ†ã‚’é™¤å»
        normalized_message = self._normalize_error_message(error_message)
        normalized_file = Path(source_file).name if source_file else ""
        
        # ãƒãƒƒã‚·ãƒ¥ç”¨ã®æ–‡å­—åˆ—ã‚’ä½œæˆ
        hash_string = f"{error_type}|{normalized_message}|{normalized_file}"
        
        return hashlib.sha256(hash_string.encode()).hexdigest()[:16]
    
    def _normalize_error_message(self, message: str) -> str:
        """ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ­£è¦åŒ–"""
        import re
        
        # æ•°å­—ã‚’é™¤å»
        message = re.sub(r'\d+', 'N', message)
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’é™¤å»
        message = re.sub(r'[/\\][^\s]+', '<PATH>', message)
        
        # å¤‰æ•°åã‚’ä¸€èˆ¬åŒ–ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        message = re.sub(r"'[^']+'" , '<VAR>', message)
        message = re.sub(r'"[^"]+"', '<VAR>', message)
        
        return message.lower().strip()
    
    def cache_fix(self,
                 error_context: Dict[str, Any],
                 fix_code: str,
                 fix_description: str,
                 ttl_hours: int = 168) -> str:
        """
        ä¿®æ­£ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            fix_code: ä¿®æ­£ã‚³ãƒ¼ãƒ‰
            fix_description: ä¿®æ­£ã®èª¬æ˜
            ttl_hours: æœ‰åŠ¹æœŸé™ï¼ˆæ™‚é–“ï¼‰
        
        Returns:
            ã‚¨ãƒ©ãƒ¼ãƒãƒƒã‚·ãƒ¥
        """
        error_hash = self.compute_error_hash(error_context)
        
        if error_hash in self.fix_cache:
            # æ—¢å­˜ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
            cached_fix = self.fix_cache[error_hash]
            cached_fix.last_used = datetime.now()
            logger.debug(f"Updated existing cache entry: {error_hash}")
        else:
            # æ–°ã—ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒˆãƒªã‚’ä½œæˆ
            cached_fix = CachedFix(
                error_hash=error_hash,
                fix_code=fix_code,
                fix_description=fix_description,
                success_rate=0.0,
                application_count=0,
                created_at=datetime.now(),
                last_used=datetime.now(),
                ttl_hours=ttl_hours,
                metadata={
                    "error_type": error_context.get("error_type"),
                    "original_message": error_context.get("error_message", "")[:200]
                }
            )
            self.fix_cache[error_hash] = cached_fix
            self.stats["fixes_cached"] += 1
            logger.info(f"Cached new fix: {error_hash}")
        
        # ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’
        self._learn_error_pattern(error_context)
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿å­˜
        self._save_cache()
        
        # ã‚µã‚¤ã‚ºåˆ¶é™ã‚’ãƒã‚§ãƒƒã‚¯
        self._enforce_cache_size_limit()
        
        return error_hash
    
    def get_cached_fix(self, error_context: Dict[str, Any]) -> Optional[CachedFix]:
        """
        ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ä¿®æ­£ã‚’å–å¾—
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
        
        Returns:
            ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸä¿®æ­£ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯Noneï¼‰
        """
        error_hash = self.compute_error_hash(error_context)
        
        # å®Œå…¨ä¸€è‡´ã‚’æ¢ã™
        if error_hash in self.fix_cache:
            cached_fix = self.fix_cache[error_hash]
            
            # æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
            if cached_fix.is_expired():
                logger.info(f"Cache entry expired: {error_hash}")
                del self.fix_cache[error_hash]
                self._save_cache()
                self.stats["cache_misses"] += 1
                return None
            
            # ä½¿ç”¨æƒ…å ±ã‚’æ›´æ–°
            cached_fix.last_used = datetime.now()
            self.stats["cache_hits"] += 1
            logger.info(f"Cache hit: {error_hash}")
            
            return cached_fix
        
        # é¡ä¼¼ã—ãŸã‚¨ãƒ©ãƒ¼ã‚’æ¢ã™
        similar_fix = self._find_similar_fix(error_context)
        
        if similar_fix:
            self.stats["cache_hits"] += 1
            logger.info(f"Similar cache hit: {similar_fix.error_hash}")
            return similar_fix
        
        self.stats["cache_misses"] += 1
        logger.debug(f"Cache miss: {error_hash}")
        
        return None
    
    def _find_similar_fix(self, error_context: Dict[str, Any]) -> Optional[CachedFix]:
        """é¡ä¼¼ã—ãŸã‚¨ãƒ©ãƒ¼ã®ä¿®æ­£ã‚’æ¤œç´¢"""
        error_type = error_context.get("error_type", "")
        error_message = error_context.get("error_message", "")
        
        # åŒã˜ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒˆãƒªã‚’æ¤œç´¢
        candidates = []
        
        for cached_fix in self.fix_cache.values():
            if cached_fix.metadata.get("error_type") == error_type:
                # é¡ä¼¼åº¦ã‚’è¨ˆç®—
                similarity = self._calculate_similarity(
                    error_message,
                    cached_fix.metadata.get("original_message", "")
                )
                
                if similarity >= self.similarity_threshold:
                    candidates.append((similarity, cached_fix))
        
        if not candidates:
            return None
        
        # æœ€ã‚‚é¡ä¼¼åº¦ã®é«˜ã„ã‚‚ã®ã‚’è¿”ã™
        best_similarity, best_fix = max(candidates, key=lambda x: x[0])
        logger.debug(f"Found similar fix with similarity: {best_similarity:.2f}")
        
        return best_fix
    
    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """2ã¤ã®ãƒ†ã‚­ã‚¹ãƒˆã®é¡ä¼¼åº¦ã‚’è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
        if not text1 or not text2:
            return 0.0
        
        # æ­£è¦åŒ–
        text1 = self._normalize_error_message(text1)
        text2 = self._normalize_error_message(text2)
        
        # å˜èªãƒ¬ãƒ™ãƒ«ã®Jaccardé¡ä¼¼åº¦
        words1 = set(text1.split())
        words2 = set(text2.split())
        
        if not words1 or not words2:
            return 0.0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)
    
    def record_fix_result(self, error_hash: str, success: bool):
        """
        ä¿®æ­£çµæœã‚’è¨˜éŒ²ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ä¿¡é ¼æ€§ã‚’æ›´æ–°
        
        Args:
            error_hash: ã‚¨ãƒ©ãƒ¼ãƒãƒƒã‚·ãƒ¥
            success: ä¿®æ­£ãŒæˆåŠŸã—ãŸã‹
        """
        if error_hash not in self.fix_cache:
            logger.warning(f"Error hash not found in cache: {error_hash}")
            return
        
        cached_fix = self.fix_cache[error_hash]
        cached_fix.application_count += 1
        
        if success:
            self.stats["successful_applications"] += 1
        else:
            self.stats["failed_applications"] += 1
        
        # æˆåŠŸç‡ã‚’æ›´æ–°ï¼ˆç§»å‹•å¹³å‡ï¼‰
        old_rate = cached_fix.success_rate
        new_rate = 1.0 if success else 0.0
        
        # æŒ‡æ•°ç§»å‹•å¹³å‡ï¼ˆã‚ˆã‚Šæœ€è¿‘ã®çµæœã‚’é‡è¦–ï¼‰
        alpha = 0.3
        cached_fix.success_rate = alpha * new_rate + (1 - alpha) * old_rate
        
        logger.debug(f"Updated fix success rate: {error_hash} -> {cached_fix.success_rate:.2f}")
        
        self._save_cache()
    
    def _learn_error_pattern(self, error_context: Dict[str, Any]):
        """ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ç¿’"""
        error_type = error_context.get("error_type", "")
        error_message = error_context.get("error_message", "")
        stack_trace = error_context.get("stack_trace", "")
        source_file = error_context.get("source_file", "")
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚­ãƒ¼ã‚’ä½œæˆ
        pattern_key = f"{error_type}_{self._normalize_error_message(error_message)[:50]}"
        
        if pattern_key in self.error_patterns:
            # æ—¢å­˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®é »åº¦ã‚’å¢—ã‚„ã™
            pattern = self.error_patterns[pattern_key]
            pattern.frequency += 1
            pattern.last_seen = datetime.now()
        else:
            # æ–°ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¨˜éŒ²
            pattern = ErrorPattern(
                error_type=error_type,
                error_message_pattern=self._normalize_error_message(error_message),
                stack_trace_pattern=self._extract_stack_pattern(stack_trace),
                file_pattern=Path(source_file).name if source_file else "",
                frequency=1,
                last_seen=datetime.now()
            )
            self.error_patterns[pattern_key] = pattern
            self.stats["patterns_learned"] += 1
        
        self._save_patterns()
    
    def _extract_stack_pattern(self, stack_trace: str) -> str:
        """ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‹ã‚‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º"""
        import re
        
        # ãƒ•ã‚¡ã‚¤ãƒ«åã¨è¡Œç•ªå·ã‚’é™¤ã„ã¦ã€é–¢æ•°åã®ã¿ã‚’æŠ½å‡º
        lines = stack_trace.split('\n')
        functions = []
        
        for line in lines:
            # "in <function_name>" ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
            match = re.search(r'in (\w+)', line)
            if match:
                functions.append(match.group(1))
        
        return ' -> '.join(functions[:5])  # æœ€åˆã®5ã¤ã®é–¢æ•°ã®ã¿
    
    def get_frequent_errors(self, limit: int = 10) -> List[Tuple[str, ErrorPattern]]:
        """é »ç¹ã«ç™ºç”Ÿã™ã‚‹ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å–å¾—"""
        sorted_patterns = sorted(
            self.error_patterns.items(),
            key=lambda x: x[1].frequency,
            reverse=True
        )
        
        return sorted_patterns[:limit]
    
    def get_best_fixes(self, limit: int = 10) -> List[CachedFix]:
        """æˆåŠŸç‡ã®é«˜ã„ä¿®æ­£ã‚’å–å¾—"""
        valid_fixes = [
            fix for fix in self.fix_cache.values()
            if not fix.is_expired() and fix.application_count >= 3
        ]
        
        sorted_fixes = sorted(
            valid_fixes,
            key=lambda f: f.success_rate,
            reverse=True
        )
        
        return sorted_fixes[:limit]
    
    def get_cache_hit_rate(self) -> float:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ã‚’å–å¾—"""
        total = self.stats["cache_hits"] + self.stats["cache_misses"]
        if total == 0:
            return 0.0
        
        return self.stats["cache_hits"] / total
    
    def cleanup_expired(self) -> int:
        """æœ‰åŠ¹æœŸé™åˆ‡ã‚Œã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤"""
        expired_keys = [
            key for key, fix in self.fix_cache.items()
            if fix.is_expired()
        ]
        
        for key in expired_keys:
            del self.fix_cache[key]
        
        if expired_keys:
            self._save_cache()
            logger.info(f"Cleaned up {len(expired_keys)} expired cache entries")
        
        return len(expired_keys)
    
    def cleanup_low_success_rate(self, threshold: float = 0.3) -> int:
        """æˆåŠŸç‡ã®ä½ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤"""
        low_success_keys = [
            key for key, fix in self.fix_cache.items()
            if fix.application_count >= 5 and fix.success_rate < threshold
        ]
        
        for key in low_success_keys:
            logger.info(f"Removing low success rate fix: {key} "
                       f"(rate={self.fix_cache[key].success_rate:.2f})")
            del self.fix_cache[key]
        
        if low_success_keys:
            self._save_cache()
            logger.info(f"Cleaned up {len(low_success_keys)} low success rate entries")
        
        return len(low_success_keys)
    
    def _enforce_cache_size_limit(self):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ã‚’é©ç”¨"""
        if len(self.fix_cache) <= self.max_cache_size:
            return
        
        # æœ€ã‚‚ä½¿ã‚ã‚Œã¦ã„ãªã„ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤ï¼ˆLRUï¼‰
        sorted_fixes = sorted(
            self.fix_cache.items(),
            key=lambda x: x[1].last_used
        )
        
        to_remove = len(self.fix_cache) - self.max_cache_size
        
        for key, _ in sorted_fixes[:to_remove]:
            del self.fix_cache[key]
        
        logger.info(f"Removed {to_remove} least recently used cache entries")
        self._save_cache()
    
    def get_statistics(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        valid_fixes = sum(1 for fix in self.fix_cache.values() if not fix.is_expired())
        expired_fixes = len(self.fix_cache) - valid_fixes
        
        avg_success_rate = 0.0
        if valid_fixes > 0:
            rates = [
                fix.success_rate for fix in self.fix_cache.values()
                if not fix.is_expired() and fix.application_count >= 3
            ]
            if rates:
                avg_success_rate = sum(rates) / len(rates)
        
        return {
            **self.stats,
            "cache_hit_rate": round(self.get_cache_hit_rate() * 100, 2),
            "total_cached_fixes": len(self.fix_cache),
            "valid_fixes": valid_fixes,
            "expired_fixes": expired_fixes,
            "error_patterns": len(self.error_patterns),
            "avg_fix_success_rate": round(avg_success_rate * 100, 2)
        }
    
    def export_report(self) -> Dict[str, Any]:
        """è©³ç´°ãƒ¬ãƒãƒ¼ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        return {
            "statistics": self.get_statistics(),
            "frequent_errors": [
                {
                    "pattern_key": key,
                    "error_type": pattern.error_type,
                    "frequency": pattern.frequency,
                    "last_seen": pattern.last_seen.isoformat()
                }
                for key, pattern in self.get_frequent_errors()
            ],
            "best_fixes": [
                {
                    "error_hash": fix.error_hash,
                    "success_rate": round(fix.success_rate * 100, 2),
                    "application_count": fix.application_count,
                    "description": fix.fix_description[:100]
                }
                for fix in self.get_best_fixes()
            ],
            "generated_at": datetime.now().isoformat()
        }
    
    def _save_cache(self):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        try:
            with open(self.cache_file, 'wb') as f:
                pickle.dump(self.fix_cache, f)
            logger.debug(f"Cache saved: {len(self.fix_cache)} entries")
        except Exception as e:
            logger.error(f"Failed to save cache: {e}")
    
    def _load_cache(self):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€"""
        if not self.cache_file.exists():
            return
        
        try:
            with open(self.cache_file, 'rb') as f:
                self.fix_cache = pickle.load(f)
            logger.info(f"Cache loaded: {len(self.fix_cache)} entries")
        except Exception as e:
            logger.error(f"Failed to load cache: {e}")
            self.fix_cache = {}
    
    def _save_patterns(self):
        """ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        try:
            patterns_data = {
                key: pattern.to_dict()
                for key, pattern in self.error_patterns.items()
            }
            
            with open(self.patterns_file, 'w', encoding='utf-8') as f:
                json.dump(patterns_data, f, indent=2, ensure_ascii=False)
            
            logger.debug(f"Patterns saved: {len(self.error_patterns)} patterns")
        except Exception as e:
            logger.error(f"Failed to save patterns: {e}")
    
    def _load_patterns(self):
        """ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€"""
        if not self.patterns_file.exists():
            return
        
        try:
            with open(self.patterns_file, 'r', encoding='utf-8') as f:
                patterns_data = json.load(f)
            
            for key, pattern_dict in patterns_data.items():
                pattern = ErrorPattern(
                    error_type=pattern_dict["error_type"],
                    error_message_pattern=pattern_dict["error_message_pattern"],
                    stack_trace_pattern=pattern_dict["stack_trace_pattern"],
                    file_pattern=pattern_dict["file_pattern"],
                    frequency=pattern_dict["frequency"],
                    last_seen=datetime.fromisoformat(pattern_dict["last_seen"])
                )
                self.error_patterns[key] = pattern
            
            logger.info(f"Patterns loaded: {len(self.error_patterns)} patterns")
        except Exception as e:
            logger.error(f"Failed to load patterns: {e}")
            self.error_patterns = {}


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    cache_manager = CacheManagerAgent()
    
    # ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¾‹
    error_context1 = {
        "error_type": "ImportError",
        "error_message": "cannot import name 'foo' from 'bar'",
        "stack_trace": "Traceback...\n  in main\n  in process",
        "source_file": "/path/to/file.py"
    }
    
    # ä¿®æ­£ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    error_hash = cache_manager.cache_fix(
        error_context1,
        fix_code="from bar import foo_new as foo",
        fix_description="Updated import statement",
        ttl_hours=168
    )
    
    print(f"\nCached fix with hash: {error_hash}")
    
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—
    cached_fix = cache_manager.get_cached_fix(error_context1)
    if cached_fix:
        print(f"\nCache hit! Fix: {cached_fix.fix_description}")
    
    # ä¿®æ­£çµæœã‚’è¨˜éŒ²
    cache_manager.record_fix_result(error_hash, success=True)
    cache_manager.record_fix_result(error_hash, success=True)
    cache_manager.record_fix_result(error_hash, success=False)
    
    # é¡ä¼¼ã‚¨ãƒ©ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆ
    error_context2 = {
        "error_type": "ImportError",
        "error_message": "cannot import name 'baz' from 'qux'",
        "stack_trace": "Traceback...\n  in main\n  in process",
        "source_file": "/path/to/other.py"
    }
    
    similar_fix = cache_manager.get_cached_fix(error_context2)
    if similar_fix:
        print(f"\nSimilar fix found! Description: {similar_fix.fix_description}")
    
    # çµ±è¨ˆæƒ…å ±
    stats = cache_manager.get_statistics()
    print(f"\nStatistics:")
    print(json.dumps(stats, indent=2))
    
    # ãƒ¬ãƒãƒ¼ãƒˆ
    report = cache_manager.export_report()
    print(f"\nReport:")
    print(json.dumps(report, indent=2))


#cloud_fix_agent.py
# cloud_fix_agent.py
"""
ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
è¤‡é›‘ãªã‚¨ãƒ©ãƒ¼ã‚’ã‚¯ãƒ©ã‚¦ãƒ‰AIã§ä¿®æ­£
"""

import asyncio
import logging
import os
import json
from typing import Dict, Any, Optional, List
from datetime import datetime
from pathlib import Path

from data_models import BugFixTask, FixResult, ErrorContextModel

logger = logging.getLogger(__name__)


class CloudFixAgent:
    """
    ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ç‰¹å¾´:
    - é«˜æ€§èƒ½AIï¼ˆGPT-4o, Claude Opus, Geminiç­‰ï¼‰
    - è¤‡é›‘ãªã‚¨ãƒ©ãƒ¼å¯¾å¿œ
    - ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç†è§£ãŒæ·±ã„
    - å¤§è¦æ¨¡ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å¯¾å¿œ
    """
    
    def __init__(
        self,
        command_monitor,
        wp_tester=None,
        api_provider: str = "openai",  # openai, anthropic, google
        api_key: Optional[str] = None,
        model_name: Optional[str] = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_tester: WordPressTester
            api_provider: APIãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
            api_key: APIã‚­ãƒ¼
            model_name: ãƒ¢ãƒ‡ãƒ«åï¼ˆçœç•¥æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        """
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        self.api_provider = api_provider
        self.api_key = api_key or os.getenv(f"{api_provider.upper()}_API_KEY")
        
        # ãƒ¢ãƒ‡ãƒ«åã®è¨­å®š
        self.model_name = model_name or self._get_default_model()
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        self.backup_dir = Path("./backups/cloud_fix")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # ä¿®æ­£å±¥æ­´
        self.fix_history = []
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0,
            "total_api_calls": 0,
            "total_tokens_used": 0
        }
        
        # ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–
        self._init_api_client()
        
        logger.info(f"âœ… CloudFixAgent åˆæœŸåŒ–å®Œäº† (provider={api_provider}, model={self.model_name})")
    
    def _get_default_model(self) -> str:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«åã‚’å–å¾—"""
        defaults = {
            "openai": "gpt-4o",
            "anthropic": "claude-opus-4",
            "google": "gemini-2.0-flash-exp"
        }
        return defaults.get(self.api_provider, "gpt-4o")
    
    def _init_api_client(self):
        """APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–"""
        if self.api_provider == "openai":
            try:
                import openai
                self.client = openai.OpenAI(api_key=self.api_key)
                logger.info(f"âœ… OpenAI API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº† (model={self.model_name})")
            except ImportError:
                logger.error("âŒ openai ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.client = None
        
        elif self.api_provider == "anthropic":
            try:
                import anthropic
                self.client = anthropic.Anthropic(api_key=self.api_key)
                logger.info(f"âœ… Anthropic API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº† (model={self.model_name})")
            except ImportError:
                logger.error("âŒ anthropic ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.client = None
        
        elif self.api_provider == "google":
            try:
                import google.generativeai as genai
                genai.configure(api_key=self.api_key)
                self.client = genai.GenerativeModel(self.model_name)
                logger.info(f"âœ… Google Gemini API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº† (model={self.model_name})")
            except ImportError:
                logger.error("âŒ google-generativeai ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.client = None
    
    async def execute_bug_fix_task(self, bug_fix_task: BugFixTask) -> FixResult:
        """
        ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰AIä½¿ç”¨ï¼‰
        
        Args:
            bug_fix_task: ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯
            
        Returns:
            FixResult: ä¿®æ­£çµæœ
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        try:
            logger.info("=" * 60)
            logger.info(f"â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_id}")
            logger.info("=" * 60)
            
            self.stats["total_fixes"] += 1
            
            # 1. è©³ç´°ãªä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            fix_prompt = self._build_detailed_fix_prompt(bug_fix_task.error_context)
            logger.info(f"ğŸ“ è©³ç´°ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰å®Œäº† ({len(fix_prompt)}æ–‡å­—)")
            
            # 2. ã‚¯ãƒ©ã‚¦ãƒ‰AIã«ä¿®æ­£ã‚’ä¾é ¼
            ai_result = await self._request_cloud_ai_fix(fix_prompt)
            
            if not ai_result['success']:
                self.stats["failed_fixes"] += 1
                return self._create_failed_result(
                    task_id,
                    f"ã‚¯ãƒ©ã‚¦ãƒ‰AIä¿®æ­£ä¾é ¼å¤±æ•—: {ai_result.get('error')}",
                    start_time
                )
            
            generated_code = ai_result['generated_code']
            modified_files = ai_result.get('modified_files', bug_fix_task.target_files)
            confidence = ai_result.get('confidence', 0.0)
            reasoning = ai_result.get('reasoning', '')
            
            logger.info(f"ğŸ¤– ã‚¯ãƒ©ã‚¦ãƒ‰AIä¿®æ­£ã‚³ãƒ¼ãƒ‰å–å¾— ({len(generated_code)}æ–‡å­—, ä¿¡é ¼åº¦={confidence})")
            
            # 3. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
            backup_path = await self._create_backup(bug_fix_task.target_files)
            logger.info(f"ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ: {backup_path}")
            
            # 4. ä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’é©ç”¨
            apply_result = await self._apply_fix_code(modified_files, generated_code)
            
            if not apply_result['success']:
                self.stats["failed_fixes"] += 1
                return self._create_failed_result(
                    task_id,
                    f"ä¿®æ­£ã‚³ãƒ¼ãƒ‰é©ç”¨å¤±æ•—: {apply_result.get('error')}",
                    start_time
                )
            
            # 5. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            test_passed = True
            if self.wp_tester and bug_fix_task.run_tests:
                test_result = await self._run_tests(bug_fix_task)
                test_passed = test_result['success']
                
                if not test_passed:
                    logger.warning(f"âš ï¸ ãƒ†ã‚¹ãƒˆå¤±æ•—: {test_result.get('error')}")
                    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ
                    await self._restore_from_backup(backup_path)
                    self.stats["failed_fixes"] += 1
                    return self._create_failed_result(
                        task_id,
                        f"ãƒ†ã‚¹ãƒˆå¤±æ•—: {test_result.get('error')}",
                        start_time
                    )
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            # ä¿®æ­£å±¥æ­´ã«è¿½åŠ 
            self.fix_history.append({
                "task_id": task_id,
                "timestamp": datetime.now().isoformat(),
                "provider": self.api_provider,
                "model": self.model_name,
                "confidence": confidence,
                "success": True,
                "execution_time": execution_time
            })
            
            self.stats["successful_fixes"] += 1
            
            logger.info(f"âœ… ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£å®Œäº†: {task_id} ({execution_time:.2f}ç§’)")
            
            return FixResult(
                task_id=task_id,
                success=True,
                modified_files=modified_files,
                generated_code=generated_code,
                test_passed=test_passed,
                execution_time=execution_time,
                confidence_score=confidence,
                reasoning=reasoning,
                backup_path=str(backup_path)
            )
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_fixes"] += 1
            return self._create_failed_result(task_id, str(e), start_time)
    
    def _build_detailed_fix_prompt(self, error_context: ErrorContextModel) -> str:
        """
        ã‚¯ãƒ©ã‚¦ãƒ‰AIç”¨ã®è©³ç´°ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            str: è©³ç´°ãªä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        prompt_parts = []
        
        # ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        prompt_parts.append("""ã‚ãªãŸã¯ç†Ÿç·´ã—ãŸPythoné–‹ç™ºè€…ã§ã‚ã‚Šã€ã‚¨ãƒ©ãƒ¼ä¿®æ­£ã®ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆã§ã™ã€‚
ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ã‚’åˆ†æã—ã€æœ€é©ãªä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

## å‡ºåŠ›å½¢å¼
ä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
    "analysis": "ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ãªåˆ†æ",
    "root_cause": "æ ¹æœ¬åŸå› ",
    "fix_strategy": "ä¿®æ­£æˆ¦ç•¥",
    "modified_files": {
        "ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹1": "å®Œå…¨ãªä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰",
        "ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹2": "å®Œå…¨ãªä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰"
    },
    "confidence": 0.95,
    "reasoning": "ã“ã®ä¿®æ­£ã‚’é¸ã‚“ã ç†ç”±",
    "test_suggestions": ["ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹1", "ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹2"],
    "potential_side_effects": ["å‰¯ä½œç”¨1", "å‰¯ä½œç”¨2"]
}
```
""")
        prompt_parts.append("")
        
        # ã‚¨ãƒ©ãƒ¼æƒ…å ±ï¼ˆè©³ç´°ï¼‰
        prompt_parts.append("=" * 60)
        prompt_parts.append("ã€ã‚¨ãƒ©ãƒ¼æƒ…å ±ã€‘")
        prompt_parts.append("=" * 60)
        prompt_parts.append(f"ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: {error_context.error_type}")
        prompt_parts.append(f"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_context.error_message}")
        prompt_parts.append(f"æ·±åˆ»åº¦: {error_context.severity.value}")
        prompt_parts.append(f"ã‚«ãƒ†ã‚´ãƒª: {error_context.error_category.value}")
        prompt_parts.append(f"ç™ºç”Ÿãƒ•ã‚¡ã‚¤ãƒ«: {error_context.file_path}:{error_context.line_number}")
        prompt_parts.append("")
        
        # ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ï¼ˆå…¨ä½“ï¼‰
        if error_context.full_traceback:
            prompt_parts.append("ã€å®Œå…¨ãªã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã€‘")
            prompt_parts.append("```python")
            prompt_parts.append(error_context.full_traceback)
            prompt_parts.append("```")
            prompt_parts.append("")
        
        # å‘¨è¾ºã‚³ãƒ¼ãƒ‰ï¼ˆè©³ç´°ï¼‰
        if error_context.surrounding_code:
            prompt_parts.append("ã€å‘¨è¾ºã‚³ãƒ¼ãƒ‰ï¼ˆå‰å¾Œ10è¡Œï¼‰ã€‘")
            prompt_parts.append("```python")
            prompt_parts.append(error_context.surrounding_code)
            prompt_parts.append("```")
            prompt_parts.append("")
        
        # ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ï¼ˆå…¨ä½“ï¼‰
        if error_context.local_variables:
            prompt_parts.append("ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®çŠ¶æ…‹ã€‘")
            prompt_parts.append("```python")
            for var_name, var_value in error_context.local_variables.items():
                prompt_parts.append(f"{var_name} = {var_value}")
            prompt_parts.append("```")
            prompt_parts.append("")
        
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±
        if error_context.context_info:
            prompt_parts.append("ã€è¿½åŠ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€‘")
            for key, value in error_context.context_info.items():
                prompt_parts.append(f"- {key}: {value}")
            prompt_parts.append("")
        
        # éå»ã®ä¿®æ­£å±¥æ­´ï¼ˆå‚è€ƒï¼‰
        if self.fix_history:
            prompt_parts.append("ã€éå»ã®ä¿®æ­£å±¥æ­´ï¼ˆå‚è€ƒï¼‰ã€‘")
            recent_fixes = self.fix_history[-3:]  # ç›´è¿‘3ä»¶
            for fix in recent_fixes:
                if fix.get('success'):
                    prompt_parts.append(f"- {fix['task_id']}: æˆåŠŸ (ä¿¡é ¼åº¦={fix.get('confidence', 'N/A')})")
            prompt_parts.append("")
        
        prompt_parts.append("=" * 60)
        prompt_parts.append("ä¸Šè¨˜ã®æƒ…å ±ã‚’åŸºã«ã€æœ€é©ãªä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’JSONå½¢å¼ã§æä¾›ã—ã¦ãã ã•ã„ã€‚")
        prompt_parts.append("=" * 60)
        
        return "\n".join(prompt_parts)
    
    async def _request_cloud_ai_fix(self, prompt: str) -> Dict[str, Any]:
        """
        ã‚¯ãƒ©ã‚¦ãƒ‰AIã«ä¿®æ­£ã‚’ä¾é ¼
        
        Args:
            prompt: ä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            
        Returns:
            Dict: AIå¿œç­”çµæœ
        """
        try:
            self.stats["total_api_calls"] += 1
            
            if self.api_provider == "openai":
                return await self._request_openai(prompt)
            elif self.api_provider == "anthropic":
                return await self._request_anthropic(prompt)
            elif self.api_provider == "google":
                return await self._request_google(prompt)
            else:
                return {
                    "success": False,
                    "error": f"æœªã‚µãƒãƒ¼ãƒˆã®ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼: {self.api_provider}"
                }
                
        except Exception as e:
            logger.error(f"âŒ AI APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _request_openai(self, prompt: str) -> Dict[str, Any]:
        """OpenAI APIã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆ"""
        try:
            response = await asyncio.to_thread(
                self.client.chat.completions.create,
                model=self.model_name,
                messages=[
                    {"role": "system", "content": "ã‚ãªãŸã¯ç†Ÿç·´ã—ãŸPythoné–‹ç™ºè€…ã§ã™ã€‚"},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                response_format={"type": "json_object"}
            )
            
            content = response.choices[0].message.content
            self.stats["total_tokens_used"] += response.usage.total_tokens
            
            result = json.loads(content)
            
            return {
                "success": True,
                "generated_code": result.get("modified_files", {}),
                "modified_files": list(result.get("modified_files", {}).keys()),
                "confidence": result.get("confidence", 0.8),
                "reasoning": result.get("reasoning", ""),
                "analysis": result.get("analysis", ""),
                "test_suggestions": result.get("test_suggestions", [])
            }
            
        except Exception as e:
            logger.error(f"âŒ OpenAI API ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _request_anthropic(self, prompt: str) -> Dict[str, Any]:
        """Anthropic APIã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆ"""
        try:
            response = await asyncio.to_thread(
                self.client.messages.create,
                model=self.model_name,
                max_tokens=4096,
                temperature=0.3,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            
            content = response.content[0].text
            self.stats["total_tokens_used"] += response.usage.input_tokens + response.usage.output_tokens
            
            result = json.loads(content)
            
            return {
                "success": True,
                "generated_code": result.get("modified_files", {}),
                "modified_files": list(result.get("modified_files", {}).keys()),
                "confidence": result.get("confidence", 0.8),
                "reasoning": result.get("reasoning", ""),
                "analysis": result.get("analysis", "")
            }
            
        except Exception as e:
            logger.error(f"âŒ Anthropic API ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _request_google(self, prompt: str) -> Dict[str, Any]:
        """Google Gemini APIã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆ"""
        try:
            response = await asyncio.to_thread(
                self.client.generate_content,
                prompt,
                generation_config={
                    "temperature": 0.3,
                    "response_mime_type": "application/json"
                }
            )
            
            content = response.text
            result = json.loads(content)
            
            return {
                "success": True,
                "generated_code": result.get("modified_files", {}),
                "modified_files": list(result.get("modified_files", {}).keys()),
                "confidence": result.get("confidence", 0.8),
                "reasoning": result.get("reasoning", "")
            }
            
        except Exception as e:
            logger.error(f"âŒ Google Gemini API ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _create_backup(self, target_files: List[str]) -> Path:
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_subdir = self.backup_dir / timestamp
        backup_subdir.mkdir(parents=True, exist_ok=True)
        
        for file_path in target_files:
            src = Path(file_path)
            if src.exists():
                dst = backup_subdir / src.name
                await asyncio.to_thread(dst.write_text, src.read_text(encoding='utf-8'))
        
        return backup_subdir
    
    async def _apply_fix_code(self, modified_files: Dict[str, str], code: str) -> Dict[str, Any]:
        """ä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’é©ç”¨"""
        try:
            if isinstance(code, dict):
                # è¾æ›¸å½¢å¼ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: ã‚³ãƒ¼ãƒ‰ï¼‰
                for file_path, file_code in code.items():
                    target = Path(file_path)
                    await asyncio.to_thread(target.write_text, file_code, encoding='utf-8')
                    logger.info(f"âœ… ä¿®æ­£é©ç”¨: {file_path}")
            else:
                # å˜ä¸€ã‚³ãƒ¼ãƒ‰
                if modified_files:
                    target = Path(modified_files[0])
                    await asyncio.to_thread(target.write_text, code, encoding='utf-8')
                    logger.info(f"âœ… ä¿®æ­£é©ç”¨: {modified_files[0]}")
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"âŒ ä¿®æ­£ã‚³ãƒ¼ãƒ‰é©ç”¨ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _restore_from_backup(self, backup_path: Path):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ"""
        try:
            for backup_file in backup_path.glob("*"):
                # å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ¨å®šï¼ˆç°¡æ˜“ç‰ˆï¼‰
                original_path = Path(backup_file.name)
                if original_path.exists():
                    content = await asyncio.to_thread(backup_file.read_text, encoding='utf-8')
                    await asyncio.to_thread(original_path.write_text, content, encoding='utf-8')
                    logger.info(f"â™»ï¸ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ: {original_path}")
        except Exception as e:
            logger.error(f"âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¾©å…ƒã‚¨ãƒ©ãƒ¼: {e}")
    
    async def _run_tests(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ"""
        if not self.wp_tester:
            return {"success": True, "message": "ãƒ†ã‚¹ã‚¿ãƒ¼æœªè¨­å®š"}
        
        try:
            test_result = await self.wp_tester.run_tests(bug_fix_task.task_id)
            return {
                "success": test_result.get("passed", False),
                "error": test_result.get("error") if not test_result.get("passed") else None
            }
        except Exception as e:
            logger.error(f"âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    def _create_failed_result(
        self, 
        task_id: str, 
        error_message: str, 
        start_time: datetime
    ) -> FixResult:
        """å¤±æ•—çµæœã‚’ä½œæˆ"""
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return FixResult(
            task_id=task_id,
            success=False,
            modified_files=[],
            generated_code="",
            test_passed=False,
            execution_time=execution_time,
            error_message=error_message,
            confidence_score=0.0
        )
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_fixes"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_fixes"]
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "provider": self.api_provider,
            "model": self.model_name
        }

#cloud_storage_manager.py
# cloud_storage_manager.py
"""
ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
ãƒ­ãƒ¼ã‚«ãƒ«ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®é€éçš„ãªé€£æº
"""

import asyncio
import logging
import os
import json
from typing import Dict, Any, Optional, Union
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class CloudStorageManager:
    """
    ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
    
    æ©Ÿèƒ½:
    - ãƒ­ãƒ¼ã‚«ãƒ«ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®é€éçš„ãªã‚¢ã‚¯ã‚»ã‚¹
    - è‡ªå‹•åŒæœŸ
    - ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
    - è¤‡æ•°ã®ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼å¯¾å¿œ
    """
    
    def __init__(
        self,
        provider: str = "local",  # local, gcs, s3, azure
        bucket_name: Optional[str] = None,
        local_cache_dir: str = "./storage_cache",
        auto_sync: bool = True
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            provider: ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
            bucket_name: ãƒã‚±ãƒƒãƒˆ/ã‚³ãƒ³ãƒ†ãƒŠå
            local_cache_dir: ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            auto_sync: è‡ªå‹•åŒæœŸãƒ•ãƒ©ã‚°
        """
        self.provider = provider
        self.bucket_name = bucket_name
        self.local_cache_dir = Path(local_cache_dir)
        self.auto_sync = auto_sync
        
        # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        self.local_cache_dir.mkdir(parents=True, exist_ok=True)
        
        # ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
        self.client = None
        self.bucket = None
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "uploads": 0,
            "downloads": 0,
            "cache_hits": 0,
            "cache_misses": 0
        }
        
        # ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼åˆæœŸåŒ–
        if provider != "local":
            self._init_cloud_provider()
        
        logger.info(f"âœ… CloudStorageManager åˆæœŸåŒ–å®Œäº† (provider={provider})")
    
    def _init_cloud_provider(self):
        """ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã‚’åˆæœŸåŒ–"""
        try:
            if self.provider == "gcs":
                self._init_gcs()
            elif self.provider == "s3":
                self._init_s3()
            elif self.provider == "azure":
                self._init_azure()
            else:
                logger.warning(f"âš ï¸ æœªã‚µãƒãƒ¼ãƒˆã®ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼: {self.provider}")
        
        except Exception as e:
            logger.error(f"âŒ ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            logger.warning("âš ï¸ ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¢ãƒ¼ãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
            self.provider = "local"
    
    def _init_gcs(self):
        """Google Cloud StorageåˆæœŸåŒ–"""
        try:
            from google.cloud import storage
            self.client = storage.Client()
            self.bucket = self.client.bucket(self.bucket_name)
            logger.info(f"âœ… GCS ãƒã‚±ãƒƒãƒˆæ¥ç¶š: {self.bucket_name}")
        except ImportError:
            logger.error("âŒ google-cloud-storage ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            raise
    
    def _init_s3(self):
        """AWS S3åˆæœŸåŒ–"""
        try:
            import boto3
            self.client = boto3.client('s3')
            self.bucket_name = self.bucket_name
            logger.info(f"âœ… S3 ãƒã‚±ãƒƒãƒˆæ¥ç¶š: {self.bucket_name}")
        except ImportError:
            logger.error("âŒ boto3 ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            raise
    
    def _init_azure(self):
        """Azure Blob StorageåˆæœŸåŒ–"""
        try:
            from azure.storage.blob import BlobServiceClient
            connection_string = os.getenv("AZURE_STORAGE_CONNECTION_STRING")
            self.client = BlobServiceClient.from_connection_string(connection_string)
            self.bucket = self.client.get_container_client(self.bucket_name)
            logger.info(f"âœ… Azure ã‚³ãƒ³ãƒ†ãƒŠæ¥ç¶š: {self.bucket_name}")
        except ImportError:
            logger.error("âŒ azure-storage-blob ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            raise
    
    # ========================================
    # åŸºæœ¬æ“ä½œï¼ˆé€éçš„APIï¼‰
    # ========================================
    
    async def read_file(
        self, 
        file_path: str,
        encoding: Optional[str] = 'utf-8'
    ) -> Union[str, bytes]:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«/ã‚¯ãƒ©ã‚¦ãƒ‰é€éçš„ï¼‰
        
        Args:
            file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            encoding: ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼ˆNoneã®å ´åˆã¯ãƒã‚¤ãƒŠãƒªï¼‰
            
        Returns:
            Union[str, bytes]: ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹
        """
        try:
            # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
            cached_path = self._get_cache_path(file_path)
            
            if cached_path.exists():
                self.stats["cache_hits"] += 1
                logger.debug(f"ğŸ“¦ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ: {file_path}")
                
                if encoding:
                    return await asyncio.to_thread(
                        cached_path.read_text,
                        encoding=encoding
                    )
                else:
                    return await asyncio.to_thread(cached_path.read_bytes)
            
            self.stats["cache_misses"] += 1
            
            # ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰èª­ã¿è¾¼ã¿
            if self.provider != "local":
                content = await self._download_from_cloud(file_path)
                
                # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
                if self.auto_sync:
                    await self._save_to_cache(file_path, content)
                
                if encoding and isinstance(content, bytes):
                    return content.decode(encoding)
                return content
            
            # ãƒ­ãƒ¼ã‚«ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
            local_path = Path(file_path)
            if encoding:
                return await asyncio.to_thread(
                    local_path.read_text,
                    encoding=encoding
                )
            else:
                return await asyncio.to_thread(local_path.read_bytes)
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {file_path} - {e}")
            raise
    
    async def write_file(
        self,
        file_path: str,
        content: Union[str, bytes],
        encoding: Optional[str] = 'utf-8'
    ):
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«/ã‚¯ãƒ©ã‚¦ãƒ‰é€éçš„ï¼‰
        
        Args:
            file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            content: æ›¸ãè¾¼ã‚€å†…å®¹
            encoding: ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
        """
        try:
            # ãƒ­ãƒ¼ã‚«ãƒ«ã«æ›¸ãè¾¼ã¿
            local_path = Path(file_path)
            local_path.parent.mkdir(parents=True, exist_ok=True)
            
            if isinstance(content, str):
                await asyncio.to_thread(
                    local_path.write_text,
                    content,
                    encoding=encoding
                )
            else:
                await asyncio.to_thread(local_path.write_bytes, content)
            
            # ã‚¯ãƒ©ã‚¦ãƒ‰ã«åŒæœŸ
            if self.provider != "local" and self.auto_sync:
                await self._upload_to_cloud(file_path, content)
            
            # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
            await self._save_to_cache(file_path, content)
            
            logger.debug(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿æˆåŠŸ: {file_path}")
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿ã‚¨ãƒ©ãƒ¼: {file_path} - {e}")
            raise
    
    async def file_exists(self, file_path: str) -> bool:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª"""
        try:
            # ãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚§ãƒƒã‚¯
            if Path(file_path).exists():
                return True
            
            # ã‚¯ãƒ©ã‚¦ãƒ‰ãƒã‚§ãƒƒã‚¯
            if self.provider != "local":
                return await self._exists_in_cloud(file_path)
            
            return False
            
        except Exception as e:
            logger.error(f"âŒ å­˜åœ¨ç¢ºèªã‚¨ãƒ©ãƒ¼: {file_path} - {e}")
            return False
    
    async def delete_file(self, file_path: str):
        """ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤"""
        try:
            # ãƒ­ãƒ¼ã‚«ãƒ«å‰Šé™¤
            local_path = Path(file_path)
            if local_path.exists():
                await asyncio.to_thread(local_path.unlink)
            
            # ã‚¯ãƒ©ã‚¦ãƒ‰å‰Šé™¤
            if self.provider != "local":
                await self._delete_from_cloud(file_path)
            
            # ã‚­ãƒ£ãƒƒã‚·ãƒ¥å‰Šé™¤
            cached_path = self._get_cache_path(file_path)
            if cached_path.exists():
                await asyncio.to_thread(cached_path.unlink)
            
            logger.debug(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤æˆåŠŸ: {file_path}")
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤ã‚¨ãƒ©ãƒ¼: {file_path} - {e}")
            raise
    
    # ========================================
    # ã‚¯ãƒ©ã‚¦ãƒ‰æ“ä½œï¼ˆãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼åˆ¥ï¼‰
    # ========================================
    
    async def _download_from_cloud(self, file_path: str) -> bytes:
        """ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"""
        self.stats["downloads"] += 1
        
        if self.provider == "gcs":
            return await self._download_from_gcs(file_path)
        elif self.provider == "s3":
            return await self._download_from_s3(file_path)
        elif self.provider == "azure":
            return await self._download_from_azure(file_path)
        else:
            raise ValueError(f"Unsupported provider: {self.provider}")
    
    async def _upload_to_cloud(self, file_path: str, content: Union[str, bytes]):
        """ã‚¯ãƒ©ã‚¦ãƒ‰ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"""
        self.stats["uploads"] += 1
        
        if isinstance(content, str):
            content = content.encode('utf-8')
        
        if self.provider == "gcs":
            await self._upload_to_gcs(file_path, content)
        elif self.provider == "s3":
            await self._upload_to_s3(file_path, content)
        elif self.provider == "azure":
            await self._upload_to_azure(file_path, content)
    
    async def _exists_in_cloud(self, file_path: str) -> bool:
        """ã‚¯ãƒ©ã‚¦ãƒ‰ã§ã®å­˜åœ¨ç¢ºèª"""
        if self.provider == "gcs":
            return await self._exists_in_gcs(file_path)
        elif self.provider == "s3":
            return await self._exists_in_s3(file_path)
        elif self.provider == "azure":
            return await self._exists_in_azure(file_path)
        return False
    
    async def _delete_from_cloud(self, file_path: str):
        """ã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰å‰Šé™¤"""
        if self.provider == "gcs":
            await self._delete_from_gcs(file_path)
        elif self.provider == "s3":
            await self._delete_from_s3(file_path)
        elif self.provider == "azure":
            await self._delete_from_azure(file_path)
    
    # ========================================
    # GCSæ“ä½œ
    # ========================================
    
    async def _download_from_gcs(self, file_path: str) -> bytes:
        """GCSã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"""
        blob = self.bucket.blob(file_path)
        return await asyncio.to_thread(blob.download_as_bytes)
    
    async def _upload_to_gcs(self, file_path: str, content: bytes):
        """GCSã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"""
        blob = self.bucket.blob(file_path)
        await asyncio.to_thread(blob.upload_from_string, content)
    
    async def _exists_in_gcs(self, file_path: str) -> bool:
        """GCSã§ã®å­˜åœ¨ç¢ºèª"""
        blob = self.bucket.blob(file_path)
        return await asyncio.to_thread(blob.exists)
    
    async def _delete_from_gcs(self, file_path: str):
        """GCSã‹ã‚‰å‰Šé™¤"""
        blob = self.bucket.blob(file_path)
        await asyncio.to_thread(blob.delete)
    
    # ========================================
    # S3æ“ä½œ
    # ========================================
    
    async def _download_from_s3(self, file_path: str) -> bytes:
        """S3ã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"""
        response = await asyncio.to_thread(
            self.client.get_object,
            Bucket=self.bucket_name,
            Key=file_path
        )
        return response['Body'].read()
    
    async def _upload_to_s3(self, file_path: str, content: bytes):
        """S3ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"""
        await asyncio.to_thread(
            self.client.put_object,
            Bucket=self.bucket_name,
            Key=file_path,
            Body=content
        )
    
    async def _exists_in_s3(self, file_path: str) -> bool:
        """S3ã§ã®å­˜åœ¨ç¢ºèª"""
        try:
            await asyncio.to_thread(
                self.client.head_object,
                Bucket=self.bucket_name,
                Key=file_path
            )
            return True
        except:
            return False
    
    async def _delete_from_s3(self, file_path: str):
        """S3ã‹ã‚‰å‰Šé™¤"""
        await asyncio.to_thread(
            self.client.delete_object,
            Bucket=self.bucket_name,
            Key=file_path
        )
    
    # ========================================
    # Azureæ“ä½œ
    # ========================================
    
    async def _download_from_azure(self, file_path: str) -> bytes:
        """Azureã‹ã‚‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰"""
        blob_client = self.bucket.get_blob_client(file_path)
        return await asyncio.to_thread(blob_client.download_blob().readall)
    
    async def _upload_to_azure(self, file_path: str, content: bytes):
        """Azureã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰"""
        blob_client = self.bucket.get_blob_client(file_path)
        await asyncio.to_thread(blob_client.upload_blob, content, overwrite=True)
    
    async def _exists_in_azure(self, file_path: str) -> bool:
        """Azureã§ã®å­˜åœ¨ç¢ºèª"""
        blob_client = self.bucket.get_blob_client(file_path)
        return await asyncio.to_thread(blob_client.exists)
    
    async def _delete_from_azure(self, file_path: str):
        """Azureã‹ã‚‰å‰Šé™¤"""
        blob_client = self.bucket.get_blob_client(file_path)
        await asyncio.to_thread(blob_client.delete_blob)
    
    # ========================================
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
    # ========================================
    
    def _get_cache_path(self, file_path: str) -> Path:
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‘ã‚¹ã‚’å–å¾—"""
        # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã®ãƒ‘ã‚¹ã«å¤‰æ›
        safe_path = file_path.replace("/", "_").replace("\\", "_")
        return self.local_cache_dir / safe_path
    
    async def _save_to_cache(self, file_path: str, content: Union[str, bytes]):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜"""
        try:
            cached_path = self._get_cache_path(file_path)
            
            if isinstance(content, str):
                await asyncio.to_thread(
                    cached_path.write_text,
                    content,
                    encoding='utf-8'
                )
            else:
                await asyncio.to_thread(cached_path.write_bytes, content)
            
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜å¤±æ•—: {file_path} - {e}")
    
    async def clear_cache(self):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢"""
        try:
            for cache_file in self.local_cache_dir.glob("*"):
                await asyncio.to_thread(cache_file.unlink)
            
            logger.info("âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢å®Œäº†")
            
        except Exception as e:
            logger.error(f"âŒ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢ã‚¨ãƒ©ãƒ¼: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        cache_hit_rate = 0.0
        total_cache_ops = self.stats["cache_hits"] + self.stats["cache_misses"]
        
        if total_cache_ops > 0:
            cache_hit_rate = self.stats["cache_hits"] / total_cache_ops
        
        return {
            **self.stats,
            "cache_hit_rate": cache_hit_rate,
            "provider": self.provider
        }

#code_review_agent.py
# code_review_agent.py
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class CodeReviewAgent:
    """ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚³ãƒ¼ãƒ‰ã®æ”¹å–„ã‚’ææ¡ˆ"""
    
    CODE_REVIEW_PROMPT = """ã‚ãªãŸã¯å„ªç§€ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã€æ”¹å–„ç‚¹ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚

ã€ã‚³ãƒ¼ãƒ‰æƒ…å ±ã€‘
- ãƒ•ã‚¡ã‚¤ãƒ«å: {filename}
- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå: {agent_name}
- ã‚³ãƒ¼ãƒ‰è¡Œæ•°: {line_count}
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: {file_size}æ–‡å­—

ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼è¦³ç‚¹ã€‘
1. ãƒã‚°ã‚„ã‚¨ãƒ©ãƒ¼ã®å¯èƒ½æ€§ãŒã‚ã‚‹éƒ¨åˆ†
2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ã§ãã‚‹éƒ¨åˆ†  
3. å¯èª­æ€§ãƒ»ä¿å®ˆæ€§å‘ä¸Šã®ææ¡ˆ
4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡Œ
5. Pythonã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹é•å

ã€ã‚³ãƒ¼ãƒ‰å†…å®¹ã€‘
```python
{code_content}
ã€å‡ºåŠ›å½¢å¼ã€‘

ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ: {agent_name}
ğŸ” ç™ºè¦‹ã—ãŸå•é¡Œç‚¹
å•é¡Œ1: [å…·ä½“çš„ãªå•é¡Œã¨å ´æ‰€]

å•é¡Œ2: [å…·ä½“çš„ãªå•é¡Œã¨å ´æ‰€]

ğŸ’¡ æ”¹å–„ææ¡ˆ
ææ¡ˆ1: [å…·ä½“çš„ãªæ”¹å–„æ–¹æ³•]

ææ¡ˆ2: [å…·ä½“çš„ãªæ”¹å–„æ–¹æ³•]

ğŸš€ æ¨å¥¨ä¿®æ­£ä¾‹

# ä¿®æ­£å‰
[å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰]

# ä¿®æ­£å¾Œ  
[æ”¹å–„ã—ãŸã‚³ãƒ¼ãƒ‰]


ğŸ“Š ç·åˆè©•ä¾¡
[ã‚³ãƒ¼ãƒ‰ã®å“è³ªã‚’ç°¡å˜ã«è©•ä¾¡]"""

def __init__(self, browser_controller):
    self.browser = browser_controller

async def review_code(self, agent_name, code_data):
    """ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦æ”¹å–„ææ¡ˆ"""
    try:
        logger.info(f"ğŸ” {agent_name} ã®ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹")
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
        prompt = self.CODE_REVIEW_PROMPT.format(
            filename=code_data['filename'],
            agent_name=agent_name,
            line_count=code_data['content'].count('\n') + 1,
            file_size=len(code_data['content']),
            code_content=code_data['content'][:3000]  # æœ€åˆã®3000æ–‡å­—ã®ã¿
        )
        
        # AIã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¾é ¼
        await self.browser.send_prompt(prompt)
        success = await self.browser.wait_for_text_generation(max_wait=120)
        
        if not success:
            return None
        
        # çµæœå–å¾—
        review_result = await self.browser.extract_latest_text_response()
        return review_result
        
    except Exception as e:
        logger.error(f"âŒ ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
        return None
    




#command_monitor_agent.py
# command_monitor_agent.py - ACFç›£è¦–å¼·åŒ–ç‰ˆ
import asyncio
import re
import subprocess
import logging
from pathlib import Path
from typing import List, Dict, Optional, Callable
from datetime import datetime

logger = logging.getLogger(__name__)

class CommandMonitorAgent:
    """ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã¨å‡ºåŠ›ç›£è¦– - ACF/WP-CLIç‰¹åŒ–ç‰ˆ"""
    

    def __init__(self, browser_controller, sheets_manager):
        self.browser_controller = browser_controller
        self.sheets_manager = sheets_manager
    
        # æ—¢å­˜ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
        self.error_patterns = [
            r'Error:', r'Exception:', r'Traceback'
        ]
    
        # === æ–°è¦è¿½åŠ : PHPå›ºæœ‰ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ ===
        self.php_error_patterns = [
            r'Parse error:',
            r'Syntax error',
            r'Fatal error:',
            r'Warning:',
            r'Notice:',
            r'Undefined function',
            r'Undefined variable',
            r'Class.*not found',
            r'Call to undefined function',
            r'Cannot modify header information',
        ]
    
        # WP-CLIå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå¼·åŒ–ç‰ˆï¼‰
        self.wp_cli_error_patterns = [
            r'Error:\s+',
            r'Fatal error:',
            r'Plugin not found',
            r'Could not create',
            r'Database connection error',
            r'Warning:\s+[A-Z]',
            # === æ–°è¦è¿½åŠ : CPTç™»éŒ²é–¢é€£ã‚¨ãƒ©ãƒ¼ ===
            r'Invalid post type',
            r'Post type.*already exists',
            r'register_post_type.*failed',
            r'Permission denied',
            r'Failed to create',
        ]
    
        # === æ–°è¦è¿½åŠ : ACFå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ ===
        self.acf_error_patterns = [
            r'ACF:\s+Error',
            r'Field group not found',
            r'Invalid field group',
            r'JSON decode error',
            r'acf_add_local_field_group.*failed',
            r'ACF.*not activated',
        ]
    
        self.wp_cli_success_patterns = [
            r'Success:',
            r'Plugin .* activated',
            r'Updated \d+ post',
            r'Created \d+ post',
            # === æ–°è¦è¿½åŠ : CPTç™»éŒ²æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ ===
            r'Post type.*registered',
            r'Custom post type.*created',
            r'Registration of.*successful',
        ]
    
        # === æ–°è¦è¿½åŠ : CPTè­¦å‘Šãƒ‘ã‚¿ãƒ¼ãƒ³ ===
        self.cpt_warning_patterns = [
            r'Post type.*already registered',
            r'Duplicate post type',
            r'Menu position conflict',
            r'Rewrite rules may need to be flushed',
        ]
    
    def _detect_errors(self, output: str) -> bool:
        """ã‚¨ãƒ©ãƒ¼æ¤œå‡º - ACFå¯¾å¿œå¼·åŒ–"""
        # æ±ç”¨ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
        for pattern in self.error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                return True
        
        # WP-CLIå°‚ç”¨ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
        for pattern in self.wp_cli_error_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.warning(f"âš ï¸ WP-CLI/ACFã‚¨ãƒ©ãƒ¼æ¤œå‡º: {pattern}")
                return True
        
        return False
    
    def _validate_wp_cli_success(self, output: str, expected_action: str) -> bool:
        """WP-CLIå®Ÿè¡Œã®æˆåŠŸæ¤œè¨¼ - ACFå¯¾å¿œ"""
        # æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒãƒƒãƒãƒ³ã‚°
        for pattern in self.wp_cli_success_patterns:
            if re.search(pattern, output, re.IGNORECASE):
                logger.info(f"âœ… WP-CLIæˆåŠŸ: {expected_action}")
                return True
        
        logger.error(f"âŒ WP-CLIæˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœªæ¤œå‡º: {expected_action}")
        return False
    
    def _extract_acf_field_group_info(self, output: str) -> Optional[Dict]:
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã®æŠ½å‡ºï¼ˆæ–°è¦è¿½åŠ ï¼‰"""
        try:
            info = {}
            
            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚­ãƒ¼ã®æŠ½å‡º
            key_match = re.search(r'group_([a-z0-9_]+)', output)
            if key_match:
                info['key'] = key_match.group(0)
            
            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°ã®æŠ½å‡º
            fields_match = re.search(r'(\d+)\s+field', output, re.IGNORECASE)
            if fields_match:
                info['field_count'] = int(fields_match.group(1))
            
            # ã‚¨ãƒ©ãƒ¼ã®æŠ½å‡º
            errors = self._extract_errors(output)
            if errors:
                info['errors'] = errors
            
            # è­¦å‘Šã®æŠ½å‡º
            warnings = self._extract_acf_warnings(output)
            if warnings:
                info['warnings'] = warnings
            
            return info if info else None
            
        except Exception as e:
            logger.error(f"ACFæƒ…å ±æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _extract_acf_warnings(self, output: str) -> List[str]:
        """ACFè­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡ºï¼ˆæ–°è¦è¿½åŠ ï¼‰"""
        warnings = []
        lines = output.split('\n')
        
        for i, line in enumerate(lines):
            for pattern in self.acf_warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        return warnings
    
    async def execute_command(self, command: str, timeout: int = 300) -> Dict:
        """ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦å‡ºåŠ›ã‚’ç›£è¦– - ACFæƒ…å ±æŠ½å‡ºè¿½åŠ """
        try:
            logger.info(f"ğŸ”§ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                stdin=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await asyncio.wait_for(
                process.communicate(),
                timeout=timeout
            )
            
            output = stdout.decode('utf-8', errors='ignore')
            error_output = stderr.decode('utf-8', errors='ignore')
            return_code = process.returncode
            
            # === æ–°è¦è¿½åŠ : ACFã‚³ãƒãƒ³ãƒ‰ã®ç‰¹åˆ¥å‡¦ç† ===
            acf_info = None
            if 'wp acf' in command:
                acf_info = self._extract_acf_field_group_info(output + error_output)
                if acf_info:
                    logger.info(f"ğŸ“‹ ACFæƒ…å ±: {acf_info}")
            
            result = {
                'command': command,
                'return_code': return_code,
                'stdout': output,
                'stderr': error_output,
                'timestamp': datetime.now().isoformat(),
                'has_errors': self._detect_errors(output + error_output),
                'errors': self._extract_errors(output + error_output),
                'warnings': self._extract_warnings(output + error_output),
                'acf_info': acf_info  # ACFå›ºæœ‰æƒ…å ±
            }
            
            # çµæœã®ã‚µãƒãƒªãƒ¼ãƒ­ã‚°
            if result['has_errors']:
                logger.error(f"âŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {command}")
                for error in result['errors']:
                    logger.error(f"   {error}")
            elif result['warnings']:
                logger.warning(f"âš ï¸ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œè­¦å‘Š: {command}")
                for warning in result['warnings']:
                    logger.warning(f"   {warning}")
            else:
                logger.info(f"âœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡ŒæˆåŠŸ: {command}")
            
            return result
            
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ã‚³ãƒãƒ³ãƒ‰ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’): {command}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': f'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)',
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [f'å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)'],
                'warnings': [],
                'acf_info': None
            }
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'command': command,
                'return_code': -1,
                'stdout': '',
                'stderr': str(e),
                'timestamp': datetime.now().isoformat(),
                'has_errors': True,
                'errors': [str(e)],
                'warnings': [],
                'acf_info': None
            }
    
    def _extract_errors(self, output: str) -> List[str]:
        """ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º"""
        errors = []
        lines = output.split('\n')
        
        # æ±ç”¨ã‚¨ãƒ©ãƒ¼ + WP-CLI/ACFã‚¨ãƒ©ãƒ¼
        all_error_patterns = self.error_patterns + self.wp_cli_error_patterns
        
        for i, line in enumerate(lines):
            for pattern in all_error_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    # ã‚¨ãƒ©ãƒ¼è¡Œã¨ãã®å‰å¾Œ2è¡Œã‚’å–å¾—
                    start = max(0, i - 2)
                    end = min(len(lines), i + 3)
                    context = '\n'.join(lines[start:end])
                    errors.append(context)
                    break
        
        return errors
    
    def _extract_warnings(self, output: str) -> List[str]:
        """è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º"""
        warnings = []
        lines = output.split('\n')
        
        warning_patterns = [r'Warning:', r'Notice:']
        
        for i, line in enumerate(lines):
            for pattern in warning_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    context = '\n'.join(lines[max(0, i-1):min(len(lines), i+2)])
                    warnings.append(context)
                    break
        
        # ACFè­¦å‘Šã‚‚è¿½åŠ 
        acf_warnings = self._extract_acf_warnings(output)
        warnings.extend(acf_warnings)
        
        return warnings
    
    async def monitor_acf_import_process(self, json_path: Path, timeout: int = 180) -> Dict:
        """ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ—ãƒ­ã‚»ã‚¹ã®å°‚ç”¨ç›£è¦–ï¼ˆæ–°è¦è¿½åŠ ï¼‰"""
        try:
            logger.info(f"ğŸ“¥ ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆç›£è¦–é–‹å§‹: {json_path}")
            
            # WP-CLIã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
            command = f"wp acf import {json_path}"
            result = await self.execute_command(command, timeout=timeout)
            
            # æˆåŠŸæ¤œè¨¼
            is_success = (
                result['return_code'] == 0 and
                not result['has_errors'] and
                self._validate_wp_cli_success(result['stdout'], 'ACF import')
            )
            
            if is_success:
                logger.info("âœ… ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ")
            else:
                logger.error("âŒ ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—")
            
            return {
                'success': is_success,
                'command_result': result,
                'acf_info': result.get('acf_info'),
                'errors': result.get('errors', []),
                'warnings': result.get('warnings', [])
            }
            
        except Exception as e:
            logger.error(f"ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆç›£è¦–ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#compatibility_fix.py
"""
Python 3.13 éåŒæœŸäº’æ›æ€§ä¿®æ­£
Windowsç’°å¢ƒã§ã®asyncioãƒ—ãƒ­ã‚¢ã‚¯ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã®å•é¡Œã‚’è§£æ±º
"""

import asyncio
import sys
import warnings

def apply_windows_async_fix():
    """Windowsç’°å¢ƒã§ã®éåŒæœŸå•é¡Œã‚’ä¿®æ­£"""
    if sys.platform == "win32":
        # ResourceWarningã‚’ç„¡è¦–ï¼ˆä¸€æ™‚çš„å¯¾å¿œï¼‰
        warnings.filterwarnings("ignore", category=ResourceWarning)
        
        # ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãƒãƒªã‚·ãƒ¼ã‚’è¨­å®š
        if sys.version_info >= (3, 13):
            try:
                asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
            except Exception:
                # æ—¢ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ç„¡è¦–
                pass

def safe_async_shutdown():
    """å®‰å…¨ãªéåŒæœŸã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            loop.stop()
        if not loop.is_closed():
            loop.close()
    except Exception:
        pass

#config_hybrid.py
# config_hybrid.py
"""
ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹è‡ªå¾‹ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  - è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«
"""

import os
from pathlib import Path
from typing import Optional
from dataclasses import dataclass, field


@dataclass
class HybridFixConfig:
    """ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã®è¨­å®š"""
    
    # ========================================
    # åŸºæœ¬è¨­å®š
    # ========================================
    
    # å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰
    run_mode: str = field(
        default_factory=lambda: os.getenv("RUN_MODE", "local")
    )  # local, cloud, hybrid
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä¿®æ­£æˆ¦ç•¥
    default_strategy: str = field(
        default_factory=lambda: os.getenv("DEFAULT_STRATEGY", "ADAPTIVE")
    )  # LOCAL_ONLY, CLOUD_ONLY, LOCAL_FIRST, CLOUD_FIRST, PARALLEL, ADAPTIVE
    
    # ========================================
    # ãƒ­ãƒ¼ã‚«ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨­å®š
    # ========================================
    
    # ãƒ­ãƒ¼ã‚«ãƒ«AIä½¿ç”¨ãƒ•ãƒ©ã‚°
    use_local_ai: bool = field(
        default_factory=lambda: os.getenv("USE_LOCAL_AI", "true").lower() == "true"
    )
    
    # ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰
    local_timeout: int = field(
        default_factory=lambda: int(os.getenv("LOCAL_TIMEOUT", "30"))
    )
    
    # ========================================
    # ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¨­å®š
    # ========================================
    
    # ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
    cloud_provider: str = field(
        default_factory=lambda: os.getenv("CLOUD_PROVIDER", "openai")
    )  # openai, anthropic, google
    
    # ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ¢ãƒ‡ãƒ«å
    cloud_model: str = field(
        default_factory=lambda: os.getenv("CLOUD_MODEL", "gpt-4o")
    )
    
    # ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰
    cloud_timeout: int = field(
        default_factory=lambda: int(os.getenv("CLOUD_TIMEOUT", "120"))
    )
    
    # APIã‚­ãƒ¼
    openai_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("OPENAI_API_KEY")
    )
    
    anthropic_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("ANTHROPIC_API_KEY")
    )
    
    google_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("GOOGLE_API_KEY")
    )
    
    # ========================================
    # ãƒ†ã‚¹ãƒˆè¨­å®š
    # ========================================
    
    # è‡ªå‹•ãƒ†ã‚¹ãƒˆæœ‰åŠ¹åŒ–
    enable_auto_tests: bool = field(
        default_factory=lambda: os.getenv("ENABLE_AUTO_TESTS", "true").lower() == "true"
    )
    
    # WordPressãƒ‘ã‚¹
    wp_path: str = field(
        default_factory=lambda: os.getenv("WP_PATH", "/var/www/html")
    )
    
    # ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰
    test_timeout: int = field(
        default_factory=lambda: int(os.getenv("TEST_TIMEOUT", "60"))
    )
    
    # ========================================
    # GitHubè¨­å®š
    # ========================================
    
    # è‡ªå‹•PRä½œæˆæœ‰åŠ¹åŒ–
    enable_auto_pr: bool = field(
        default_factory=lambda: os.getenv("ENABLE_AUTO_PR", "false").lower() == "true"
    )
    
    # GitHubãƒˆãƒ¼ã‚¯ãƒ³
    github_token: Optional[str] = field(
        default_factory=lambda: os.getenv("GITHUB_TOKEN")
    )
    
    # ãƒªãƒã‚¸ãƒˆãƒªãƒ‘ã‚¹
    repo_path: str = field(
        default_factory=lambda: os.getenv("REPO_PATH", ".")
    )
    
    # ãƒªãƒã‚¸ãƒˆãƒªã‚ªãƒ¼ãƒŠãƒ¼
    repo_owner: Optional[str] = field(
        default_factory=lambda: os.getenv("REPO_OWNER")
    )
    
    # ãƒªãƒã‚¸ãƒˆãƒªå
    repo_name: Optional[str] = field(
        default_factory=lambda: os.getenv("REPO_NAME")
    )
    
    # PRã®è‡ªå‹•ãƒãƒ¼ã‚¸
    github_auto_merge: bool = field(
        default_factory=lambda: os.getenv("GITHUB_AUTO_MERGE", "false").lower() == "true"
    )
    
    # ========================================
    # ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è¨­å®š
    # ========================================
    
    # ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
    storage_provider: str = field(
        default_factory=lambda: os.getenv("STORAGE_PROVIDER", "local")
    )  # local, gcs, s3, azure
    
    # ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒã‚±ãƒƒãƒˆå
    storage_bucket: Optional[str] = field(
        default_factory=lambda: os.getenv("STORAGE_BUCKET")
    )
    
    # è‡ªå‹•åŒæœŸ
    auto_sync_storage: bool = field(
        default_factory=lambda: os.getenv("AUTO_SYNC_STORAGE", "true").lower() == "true"
    )
    
    # ========================================
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®š
    # ========================================
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
    backup_dir: str = field(
        default_factory=lambda: os.getenv("BACKUP_DIR", "./backups")
    )
    
    # æœ€å¤§ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°
    max_backups: int = field(
        default_factory=lambda: int(os.getenv("MAX_BACKUPS", "10"))
    )
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿æŒæ—¥æ•°
    backup_retention_days: int = field(
        default_factory=lambda: int(os.getenv("BACKUP_RETENTION_DAYS", "30"))
    )
    
    # ========================================
    # ãƒªãƒˆãƒ©ã‚¤è¨­å®š
    # ========================================
    
    # æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
    max_retry_count: int = field(
        default_factory=lambda: int(os.getenv("MAX_RETRY_COUNT", "3"))
    )
    
    # ãƒªãƒˆãƒ©ã‚¤é–“éš”ï¼ˆç§’ï¼‰
    retry_delay: int = field(
        default_factory=lambda: int(os.getenv("RETRY_DELAY", "5"))
    )
    
    # ========================================
    # ãƒ­ã‚°è¨­å®š
    # ========================================
    
    # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«
    log_level: str = field(
        default_factory=lambda: os.getenv("LOG_LEVEL", "INFO")
    )
    
    # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«
    log_file: Optional[str] = field(
        default_factory=lambda: os.getenv("LOG_FILE", "./logs/hybrid_fix.log")
    )
    
    # ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    log_rotation: str = field(
        default_factory=lambda: os.getenv("LOG_ROTATION", "10 MB")
    )
    
    # ========================================
    # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­å®š
    # ========================================
    
    # ä¸¦åˆ—å®Ÿè¡Œã®æœ€å¤§æ•°
    max_parallel_fixes: int = field(
        default_factory=lambda: int(os.getenv("MAX_PARALLEL_FIXES", "3"))
    )
    
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹åŒ–
    enable_cache: bool = field(
        default_factory=lambda: os.getenv("ENABLE_CACHE", "true").lower() == "true"
    )
    
    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥TTLï¼ˆç§’ï¼‰
    cache_ttl: int = field(
        default_factory=lambda: int(os.getenv("CACHE_TTL", "3600"))
    )
    
    # ========================================
    # é€šçŸ¥è¨­å®š
    # ========================================
    
    # Slacké€šçŸ¥
    enable_slack_notifications: bool = field(
        default_factory=lambda: os.getenv("ENABLE_SLACK_NOTIFICATIONS", "false").lower() == "true"
    )
    
    slack_webhook_url: Optional[str] = field(
        default_factory=lambda: os.getenv("SLACK_WEBHOOK_URL")
    )
    
    # ãƒ¡ãƒ¼ãƒ«é€šçŸ¥
    enable_email_notifications: bool = field(
        default_factory=lambda: os.getenv("ENABLE_EMAIL_NOTIFICATIONS", "false").lower() == "true"
    )
    
    email_recipients: str = field(
        default_factory=lambda: os.getenv("EMAIL_RECIPIENTS", "")
    )
    
    # ========================================
    # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯è¨­å®š
    # ========================================
    
    # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯é–“éš”ï¼ˆç§’ï¼‰
    health_check_interval: int = field(
        default_factory=lambda: int(os.getenv("HEALTH_CHECK_INTERVAL", "60"))
    )
    
    # ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
    enable_metrics: bool = field(
        default_factory=lambda: os.getenv("ENABLE_METRICS", "true").lower() == "true"
    )
    
    # ========================================
    # ãƒ‡ãƒãƒƒã‚°è¨­å®š
    # ========================================
    
    # ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰
    debug_mode: bool = field(
        default_factory=lambda: os.getenv("DEBUG_MODE", "false").lower() == "true"
    )
    
    # è©³ç´°ãƒ­ã‚°
    verbose_logging: bool = field(
        default_factory=lambda: os.getenv("VERBOSE_LOGGING", "false").lower() == "true"
    )
    
    # ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³ï¼ˆå®Ÿéš›ã®ä¿®æ­£ã‚’é©ç”¨ã—ãªã„ï¼‰
    dry_run: bool = field(
        default_factory=lambda: os.getenv("DRY_RUN", "false").lower() == "true"
    )
    
    def __post_init__(self):
        """åˆæœŸåŒ–å¾Œã®å‡¦ç†"""
        # ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
        Path(self.backup_dir).mkdir(parents=True, exist_ok=True)
        
        if self.log_file:
            Path(self.log_file).parent.mkdir(parents=True, exist_ok=True)
    
    def validate(self) -> bool:
        """è¨­å®šã‚’æ¤œè¨¼"""
        errors = []
        
        # æˆ¦ç•¥ã®æ¤œè¨¼
        valid_strategies = [
            "LOCAL_ONLY", "CLOUD_ONLY", "LOCAL_FIRST", 
            "CLOUD_FIRST", "PARALLEL", "ADAPTIVE"
        ]
        if self.default_strategy not in valid_strategies:
            errors.append(f"Invalid strategy: {self.default_strategy}")
        
        # ã‚¯ãƒ©ã‚¦ãƒ‰ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®æ¤œè¨¼
        valid_providers = ["openai", "anthropic", "google"]
        if self.cloud_provider not in valid_providers:
            errors.append(f"Invalid cloud provider: {self.cloud_provider}")
        
        # APIã‚­ãƒ¼ã®æ¤œè¨¼
        if self.cloud_provider == "openai" and not self.openai_api_key:
            errors.append("OpenAI API key is required")
        
        if self.cloud_provider == "anthropic" and not self.anthropic_api_key:
            errors.append("Anthropic API key is required")
        
        if self.cloud_provider == "google" and not self.google_api_key:
            errors.append("Google API key is required")
        
        # GitHubè¨­å®šã®æ¤œè¨¼
        if self.enable_auto_pr:
            if not self.github_token:
                errors.append("GitHub token is required for auto PR")
            if not self.repo_owner or not self.repo_name:
                errors.append("GitHub repo owner and name are required for auto PR")
        
        # ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è¨­å®šã®æ¤œè¨¼
        valid_storage_providers = ["local", "gcs", "s3", "azure"]
        if self.storage_provider not in valid_storage_providers:
            errors.append(f"Invalid storage provider: {self.storage_provider}")
        
        if self.storage_provider != "local" and not self.storage_bucket:
            errors.append(f"Storage bucket is required for {self.storage_provider}")
        
        if errors:
            for error in errors:
                print(f"âŒ è¨­å®šã‚¨ãƒ©ãƒ¼: {error}")
            return False
        
        return True
    
    def print_config(self):
        """è¨­å®šã‚’è¡¨ç¤º"""
        print("\n" + "=" * 80)
        print("âš™ï¸  ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  è¨­å®š")
        print("=" * 80)
        print(f"å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰: {self.run_mode}")
        print(f"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæˆ¦ç•¥: {self.default_strategy}")
        print(f"\nã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€‘")
        print(f"  ãƒ­ãƒ¼ã‚«ãƒ«AI: {'æœ‰åŠ¹' if self.use_local_ai else 'ç„¡åŠ¹'}")
        print(f"  ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {self.local_timeout}ç§’")
        print(f"\nã€ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€‘")
        print(f"  ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼: {self.cloud_provider}")
        print(f"  ãƒ¢ãƒ‡ãƒ«: {self.cloud_model}")
        print(f"  ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {self.cloud_timeout}ç§’")
        print(f"\nã€ãƒ†ã‚¹ãƒˆã€‘")
        print(f"  è‡ªå‹•ãƒ†ã‚¹ãƒˆ: {'æœ‰åŠ¹' if self.enable_auto_tests else 'ç„¡åŠ¹'}")
        print(f"  WPãƒ‘ã‚¹: {self.wp_path}")
        print(f"\nã€GitHubã€‘")
        print(f"  è‡ªå‹•PR: {'æœ‰åŠ¹' if self.enable_auto_pr else 'ç„¡åŠ¹'}")
        if self.enable_auto_pr:
            print(f"  ãƒªãƒã‚¸ãƒˆãƒª: {self.repo_owner}/{self.repo_name}")
        print(f"\nã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã€‘")
        print(f"  ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼: {self.storage_provider}")
        if self.storage_provider != "local":
            print(f"  ãƒã‚±ãƒƒãƒˆ: {self.storage_bucket}")
        print(f"\nã€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã€‘")
        print(f"  ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.backup_dir}")
        print(f"  æœ€å¤§ä¿æŒæ•°: {self.max_backups}")
        print(f"\nã€ãã®ä»–ã€‘")
        print(f"  ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰: {'æœ‰åŠ¹' if self.debug_mode else 'ç„¡åŠ¹'}")
        print(f"  ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³: {'æœ‰åŠ¹' if self.dry_run else 'ç„¡åŠ¹'}")
        print("=" * 80 + "\n")
    
    @classmethod
    def from_env_file(cls, env_file: str = ".env"):
        """ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        if Path(env_file).exists():
            from dotenv import load_dotenv
            load_dotenv(env_file)
        
        return cls()
    
    def to_dict(self) -> dict:
        """è¾æ›¸å½¢å¼ã«å¤‰æ›"""
        return {
            key: getattr(self, key)
            for key in self.__dataclass_fields__.keys()
        }


# ========================================
# ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®š
# ========================================

class DevelopmentConfig(HybridFixConfig):
    """é–‹ç™ºç’°å¢ƒç”¨è¨­å®š"""
    
    def __init__(self):
        super().__init__()
        self.run_mode = "local"
        self.default_strategy = "LOCAL_FIRST"
        self.use_local_ai = True
        self.enable_auto_pr = False
        self.debug_mode = True
        self.verbose_logging = True
        self.dry_run = True


class ProductionConfig(HybridFixConfig):
    """æœ¬ç•ªç’°å¢ƒç”¨è¨­å®š"""
    
    def __init__(self):
        super().__init__()
        self.run_mode = "hybrid"
        self.default_strategy = "ADAPTIVE"
        self.use_local_ai = True
        self.enable_auto_tests = True
        self.enable_auto_pr = True
        self.storage_provider = "gcs"
        self.debug_mode = False
        self.dry_run = False


class CloudOnlyConfig(HybridFixConfig):
    """ã‚¯ãƒ©ã‚¦ãƒ‰ã®ã¿ã®è¨­å®š"""
    
    def __init__(self):
        super().__init__()
        self.run_mode = "cloud"
        self.default_strategy = "CLOUD_ONLY"
        self.use_local_ai = False
        self.enable_auto_tests = True
        self.enable_auto_pr = True


# ========================================
# è¨­å®šãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
# ========================================

def get_config(env: str = "development") -> HybridFixConfig:
    """
    ç’°å¢ƒã«å¿œã˜ãŸè¨­å®šã‚’å–å¾—
    
    Args:
        env: ç’°å¢ƒå (development, production, cloud_only)
        
    Returns:
        HybridFixConfig: è¨­å®šã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    """
    configs = {
        "development": DevelopmentConfig,
        "production": ProductionConfig,
        "cloud_only": CloudOnlyConfig
    }
    
    config_class = configs.get(env, HybridFixConfig)
    config = config_class()
    
    # ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¿½åŠ ã§èª­ã¿è¾¼ã¿
    if os.getenv("CONFIG_FROM_ENV", "false").lower() == "true":
        config = HybridFixConfig.from_env_file()
    
    return config


if __name__ == "__main__":
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    config = get_config("development")
    
    print("è¨­å®šã®æ¤œè¨¼ä¸­...")
    if config.validate():
        print("âœ… è¨­å®šã¯æœ‰åŠ¹ã§ã™")
        config.print_config()
    else:
        print("âŒ è¨­å®šã«å•é¡ŒãŒã‚ã‚Šã¾ã™")

#config_utils.py
import logging
import uuid
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import time

# config_utils.py ã® SmartLogFormatter ã‚¯ãƒ©ã‚¹ã‚’ä¿®æ­£

class SmartLogFormatter(logging.Formatter):
    """ã‚¹ãƒãƒ¼ãƒˆãªãƒ­ã‚°ãƒ•ã‚©ãƒ¼ãƒãƒƒã‚¿ - çŸ­ç¸®è­˜åˆ¥ç‰ˆ"""
    
    # ã‚¯ãƒ©ã‚¹å¤‰æ•°ã¨ã—ã¦çŠ¶æ…‹ã‚’ä¿æŒ
    _message_count = 0
    _last_timestamp_display = 0
    _last_date_display = ""
    _lock = False
    
    # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥ã®çµµæ–‡å­—ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆçŸ­ç¸®ç‰ˆï¼‰
    AGENT_EMOJIS = {
        # ğŸƒâ€â™‚ï¸ å®Ÿè¡Œç³»
        'run_multi_agent': 'ğŸš€ multi-agent',
        '__main__': 'ğŸ main',
    
        # ğŸ‘‘ PMç³»
        'pm_agent': 'ğŸ‘‘ pm-agent',
        'pm_system_prompts': 'ğŸ“‹ pm-prompts',
    
        # âš™ï¸ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œç³»
        'task_executor': 'âš™ï¸ task-exec',
        'task_executor_content': 'ğŸ“ task-content',
        'task_executor_ma': 'ğŸ” task-ma',
        'task_coordinator': 'ğŸ¯ task-coord',
        'content_task_executor': 'ğŸ“„ content-exec',
        'system_cli_executor': 'ğŸ’» cli-exec',
        'workflow_executor': 'ğŸ”„ workflow',
        'test_tasks': 'ğŸ§ª test-tasks',
    
        # ğŸ¨ ãƒ‡ã‚¶ã‚¤ãƒ³ç³»
        'design_agent': 'ğŸ¨ design',
        'ui_agent': 'ğŸ“± ui',
    
        # ğŸ’» é–‹ç™ºç³»
        'dev_agent': 'ğŸ’» dev',
        'dev_agent_acf': 'ğŸ”Œ dev-acf',
    
        # âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ç³»
        'review_agent': 'âœ… review',
        'review_agent_prompts': 'ğŸ“‹ review-prompts',
        'review_agent_prompts_ACF': 'ğŸ”§ review-acf',
    
        # ğŸ•·ï¸ ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ç³»
        'browser_controller': 'ğŸ•·ï¸ browser',
        'browser_cookie_and_session': 'ğŸª cookie-session',
        'browser_lifecycle': 'ğŸ” browser-life',
        'browser_ai_chat_agent': 'ğŸ¤– browser-ai',
        'browser_wp_session_manager': 'ğŸŒ wp-session',
    
        # ğŸ“Š ãƒ‡ãƒ¼ã‚¿é€£æºç³»
        'sheets_manager': 'ğŸ“Š sheets-mgr',
    
        # ğŸ”§ ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ç³»
        'config_utils': 'âš™ï¸ config',
        'command_monitor_agent': 'ğŸ‘ï¸ monitor',
        'compatibility_fix': 'ğŸ”§ compat-fix',
        'quick_fix': 'âš¡ quick-fix',
        'error_handler_enhanced': 'ğŸš¨ error-handler',
    
        # âœï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ç³»
        'base_writer': 'âœï¸ writer-base',
        'ja_writer_agent': 'ğŸ—¾ ja-writer',
        'en_writer_agent': 'ğŸ”  en-writer',
        'ru_writer_agent': 'ğŸ‡·ğŸ‡º ru-writer',
        'uz_writer_agent': 'ğŸ‡ºğŸ‡¿ uz-writer',
        'zh_writer_agent': 'ğŸ‡¨ğŸ‡³ zh-writer',
        'ko_writer_agent': 'ğŸ‡°ğŸ‡· ko-writer',
        'tr_writer_agent': 'ğŸ‡¹ğŸ‡· tr-writer',
        
        # ğŸ†• M&Aå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        'ma_executor': 'ğŸ’¼ ma-exec',
        'ma_requirements': 'ğŸ“‹ ma-req',
        'ma_data_migration': 'ğŸ”„ ma-migrate',
        'ma_api_integration': 'ğŸ”— ma-api',
    
        # ğŸŒ WordPressç³»
        'wp_agent': 'ğŸŒ wp-agent',
        'wp_auth': 'ğŸ” wp-auth',
        'wp_post_editor': 'ğŸ“ wp-editor',
        'wp_post_creator': 'ğŸ†• wp-creator',
        'wp_plugin_manager': 'ğŸ”Œ wp-plugin',
        'wp_settings_manager': 'âš™ï¸ wp-config',
        'wp_design': 'ğŸ¨ wp-design',
        'wp_dev': 'ğŸ”§ wp-dev',
        'wp_tester': 'ğŸ§ª wp-test',
        'wp_utils': 'ğŸ› ï¸ wp-utils',
    
    }
    
    def format(self, record):
        # å†å¸°å‘¼ã³å‡ºã—é˜²æ­¢
        if SmartLogFormatter._lock:
            return super().format(record)
        
        SmartLogFormatter._lock = True
        try:
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚«ã‚¦ãƒ³ãƒˆ
            SmartLogFormatter._message_count += 1
            current_time = time.time()
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè­˜åˆ¥
            agent_name = record.name
            # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åã‹ã‚‰çŸ­ç¸®åã‚’å–å¾—
            if '.' in agent_name:
                agent_short = agent_name.split('.')[-1]  # æœ€å¾Œã®éƒ¨åˆ†
            else:
                agent_short = agent_name
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµµæ–‡å­—ã‚’å–å¾—
            agent_display = self.AGENT_EMOJIS.get(agent_short, f'ğŸ“‹ {agent_short[:6]}')
            
            # ãƒ¬ãƒ™ãƒ«åˆ¥ã®çµµæ–‡å­—ã¨è‰²ï¼ˆã‚¨ãƒ©ãƒ¼ã‚’å¼·èª¿ï¼‰
            level_info = {
                'INFO': ('ğŸ’¬', ''),
                'WARNING': ('âš ï¸', 'WARN'),
                'ERROR': ('âŒ', 'ERROR'),
                'DEBUG': ('ğŸ›', 'DEBUG'),
                'CRITICAL': ('ğŸ’¥', 'CRITICAL')
            }
            
            level_emoji, level_prefix = level_info.get(record.levelname, ('ğŸ“', ''))
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            message = record.getMessage()
            
            # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—åˆ¤å®š
            current_date = time.strftime('%Y-%m-%d')
            show_date = (SmartLogFormatter._last_date_display != current_date)
            show_timestamp = (
                SmartLogFormatter._message_count % 30 == 1 or 
                current_time - SmartLogFormatter._last_timestamp_display > 300 or
                show_date
            )
            
            # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ§‹ç¯‰
            parts = []
            
            # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
            if show_date:
                SmartLogFormatter._last_date_display = current_date
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%Y-%m-%d %H:%M')
                parts.append(f"ğŸ•’ {timestamp}")
            elif show_timestamp:
                SmartLogFormatter._last_timestamp_display = current_time
                timestamp = time.strftime('%H:%M')
                parts.append(f"ğŸ•’ {timestamp}")
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåï¼ˆå¸¸ã«è¡¨ç¤ºï¼‰
            parts.append(agent_display)
            
            # ãƒ¬ãƒ™ãƒ«ï¼ˆã‚¨ãƒ©ãƒ¼/è­¦å‘Šæ™‚ã¯å¼·èª¿ï¼‰
            if level_prefix:
                # ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒ™ãƒ«ã®å ´åˆã¯èµ¤è‰²ã§è¡¨ç¤ºï¼ˆã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§è‰²ä»˜ã‘ï¼‰
                if record.levelname in ['ERROR', 'CRITICAL']:
                    parts.append(f"{level_emoji} \033[91m{level_prefix}\033[0m")  # èµ¤è‰²
                elif record.levelname == 'WARNING':
                    parts.append(f"{level_emoji} \033[93m{level_prefix}\033[0m")  # é»„è‰²
                else:
                    parts.append(f"{level_emoji} {level_prefix}")
            else:
                parts.append(level_emoji)
            
            # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            parts.append(message)
            
            # çµåˆ
            result = ' '.join(parts)
            
            return result
            
        finally:
            SmartLogFormatter._lock = False


def setup_optimized_logging():
    """æœ€é©åŒ–ã•ã‚ŒãŸãƒ­ã‚°è¨­å®šï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè­˜åˆ¥å¼·åŒ–ç‰ˆï¼‰"""
    
    # ãƒ«ãƒ¼ãƒˆãƒ­ã‚¬ãƒ¼
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)  # â† INFO ã‚’ DEBUG ã«å¤‰æ›´
    
    # æ—¢å­˜ã®ãƒãƒ³ãƒ‰ãƒ©ã‚’ã‚¯ãƒªã‚¢
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãƒãƒ³ãƒ‰ãƒ©ï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè­˜åˆ¥å¼·åŒ–ï¼‰
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(SmartLogFormatter())
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ©ï¼ˆè©³ç´°ãƒ­ã‚°ï¼‰
    file_handler = logging.FileHandler('gemini_automation.log', encoding='utf-8')
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(file_formatter)
    
    # ãƒãƒ³ãƒ‰ãƒ©è¿½åŠ 
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)


# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å®Ÿè¡Œ
setup_optimized_logging()


class Config:
    """è¨­å®šã‚¯ãƒ©ã‚¹"""
    SPREADSHEET_ID = "1qpMLT9HKlPT9qY17fpqOkSIbehKH77wZ8bA1yfPSO_s"
    DOWNLOAD_IMAGE_FOLDER: Optional[str] = None
    DOWNLOAD_TEXT_FOLDER: Optional[str] = None
    SERVICE_ACCOUNT_FILE: Optional[str] = None
    COOKIES_FILE: Optional[str] = None
    BROWSER_DATA_DIR: Optional[str] = None
    GENERATION_MODE: Optional[str] = None
    TEXT_FORMAT: Optional[str] = None
    SERVICE_TYPE: Optional[str] = None
    AGENT_OUTPUT_FOLDER = None
    MAX_ITERATIONS = 3
    DRIVE_TEXT_FOLDER_ID = "16QVK_-z8JVmhLQuLVprOx9_DnoNc4eUc"
    DRIVE_IMAGE_FOLDER_ID = "1jkuMH1UNeBvNNvrz8iVidyVMmtmYrHiS"
    
    BROWSER_CONFIG = {
        "headless": False,
        "slow_mo": 800,
        "args": [
            "--disable-blink-features=AutomationControlled",
            "--disable-web-security",
            "--disable-features=VizDisplayCompositor",
            "--no-sandbox",
            "--disable-dev-shm-usage"
            # âš ï¸ --single-process ã‚’å‰Šé™¤ï¼ˆWindowsã§ä¸å®‰å®šãªãŸã‚ï¼‰
        ],
        "timeout": 60000
    }
    
    def __init__(self):
        self.WP_COOKIES_FILE = os.environ.get('WP_COOKIES_FILE', 
                                            os.path.join(Path.home(), 'Documents', 'gemini_auto_generate', 'wordpress_cookies.json'))
            
        # ã‚¯ãƒƒã‚­ãƒ¼æœ‰åŠ¹æœŸé™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ30æ—¥ï¼‰
        self.WP_COOKIE_EXPIRY_DAYS = int(os.environ.get('WP_COOKIE_EXPIRY_DAYS', '30'))
        
    VIEWPORT_SIZE = {'width': 1024, 'height': 768}
    PAGE_TIMEOUT = 60000
    IMAGE_GENERATION_TIMEOUT = 180
    TEXT_GENERATION_TIMEOUT = 120
    
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]


class FileNameGenerator:
    """ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ"""
    
    @staticmethod
    def generate_unique_filename(index: int, extension: str = ".png", mode: str = "image") -> str:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        unique_id = str(uuid.uuid4())[:8]
        
        if mode == "text":
            prefix = "gemini_text"
            ext = ".txt"
        else:
            prefix = "gemini_image"
            ext = extension
        
        return f"{prefix}_{index:03d}_{timestamp}_{unique_id}{ext}"
    
    @staticmethod
    def validate_filename(filename: str) -> bool:
        try:
            invalid_chars = '<>:"/\\|?*'
            return not any(char in filename for char in invalid_chars)
        except:
            return False


class ErrorHandler:
    """ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°"""
    
    @staticmethod
    def log_error(error: Exception, context: str = "") -> None:
        logger = logging.getLogger(__name__)
        logger.error(f"{context}: {str(error)}")
    
    @staticmethod
    def handle_missing_attribute_error(obj, attr_name: str, default_value=None):
        logger = logging.getLogger(__name__)
        if not hasattr(obj, attr_name):
            logger.warning(f"å±æ€§ '{attr_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨")
            setattr(obj, attr_name, default_value)
        return getattr(obj, attr_name)


class PathManager:
    """ãƒ‘ã‚¹ç®¡ç†"""
    
    @staticmethod
    def ensure_directory_exists(path: Path) -> None:
        path.mkdir(parents=True, exist_ok=True)
    
    @staticmethod
    def get_safe_path(base_path: str) -> Path:
        path = Path(base_path)
        PathManager.ensure_directory_exists(path)
        return path


config = Config()

#config_validator.py
"""
ConfigValidator - è¨­å®šæ¤œè¨¼ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹æ–‡ãƒã‚§ãƒƒã‚¯ã€APIã‚­ãƒ¼ã®æœ‰åŠ¹æ€§ç¢ºèªã€ç’°å¢ƒå¤‰æ•°ã®æ¤œè¨¼ã€
ä¾å­˜é–¢ä¿‚ã®ç¢ºèªã€è¨­å®šã®æ¨å¥¨å€¤ææ¡ˆã‚’æä¾›ã™ã‚‹ã€‚
"""

import os
import json
import yaml
import re
import requests
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class ValidationLevel(Enum):
    """æ¤œè¨¼ãƒ¬ãƒ™ãƒ«"""
    ERROR = "error"  # è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼
    WARNING = "warning"  # è­¦å‘Š
    INFO = "info"  # æƒ…å ±
    SUCCESS = "success"  # æˆåŠŸ


@dataclass
class ValidationResult:
    """æ¤œè¨¼çµæœ"""
    level: ValidationLevel
    category: str
    message: str
    field: Optional[str] = None
    expected: Optional[Any] = None
    actual: Optional[Any] = None
    suggestion: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "level": self.level.value,
            "category": self.category,
            "message": self.message,
            "field": self.field,
            "expected": self.expected,
            "actual": self.actual,
            "suggestion": self.suggestion
        }


@dataclass
class ConfigSchema:
    """è¨­å®šã‚¹ã‚­ãƒ¼ãƒå®šç¾©"""
    required_fields: Set[str]
    optional_fields: Set[str]
    field_types: Dict[str, type]
    field_validators: Dict[str, Any]  # ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚¿
    recommended_values: Dict[str, Any]
    
    def get_all_fields(self) -> Set[str]:
        return self.required_fields | self.optional_fields


class ConfigValidatorAgent:
    """
    è¨­å®šæ¤œè¨¼ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ä¸»ãªæ©Ÿèƒ½:
    1. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
    2. APIã‚­ãƒ¼ã®æœ‰åŠ¹æ€§ç¢ºèª
    3. ç’°å¢ƒå¤‰æ•°ã®æ¤œè¨¼
    4. ä¾å­˜é–¢ä¿‚ã®ç¢ºèª
    5. è¨­å®šã®æ¨å¥¨å€¤ææ¡ˆ
    """
    
    def __init__(self):
        self.validation_results: List[ValidationResult] = []
        
        # è¨­å®šã‚¹ã‚­ãƒ¼ãƒã®å®šç¾©
        self.schemas = {
            "browser": self._define_browser_schema(),
            "ai": self._define_ai_schema(),
            "wordpress": self._define_wordpress_schema(),
            "system": self._define_system_schema()
        }
        
        logger.info("ConfigValidatorAgent initialized")
    
    def _define_browser_schema(self) -> ConfigSchema:
        """ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã‚¹ã‚­ãƒ¼ãƒ"""
        return ConfigSchema(
            required_fields={"headless", "user_data_dir"},
            optional_fields={"window_size", "disable_gpu", "no_sandbox"},
            field_types={
                "headless": bool,
                "user_data_dir": str,
                "window_size": tuple,
                "disable_gpu": bool,
                "no_sandbox": bool
            },
            field_validators={
                "window_size": lambda v: len(v) == 2 and all(isinstance(x, int) for x in v)
            },
            recommended_values={
                "headless": True,  # ã‚¯ãƒ©ã‚¦ãƒ‰ç’°å¢ƒã§ã¯æ¨å¥¨
                "window_size": (1920, 1080)
            }
        )
    
    def _define_ai_schema(self) -> ConfigSchema:
        """AIè¨­å®šã‚¹ã‚­ãƒ¼ãƒ"""
        return ConfigSchema(
            required_fields={"provider", "model", "api_key"},
            optional_fields={"temperature", "max_tokens", "timeout"},
            field_types={
                "provider": str,
                "model": str,
                "api_key": str,
                "temperature": float,
                "max_tokens": int,
                "timeout": int
            },
            field_validators={
                "provider": lambda v: v in ["openai", "anthropic", "google", "deepseek"],
                "temperature": lambda v: 0.0 <= v <= 2.0,
                "max_tokens": lambda v: v > 0
            },
            recommended_values={
                "temperature": 0.7,
                "max_tokens": 4000,
                "timeout": 60
            }
        )
    
    def _define_wordpress_schema(self) -> ConfigSchema:
        """WordPressè¨­å®šã‚¹ã‚­ãƒ¼ãƒ"""
        return ConfigSchema(
            required_fields={"url", "username", "password"},
            optional_fields={"wp_cli_path", "ssh_host", "ssh_user"},
            field_types={
                "url": str,
                "username": str,
                "password": str,
                "wp_cli_path": str,
                "ssh_host": str,
                "ssh_user": str
            },
            field_validators={
                "url": lambda v: v.startswith("http://") or v.startswith("https://")
            },
            recommended_values={}
        )
    
    def _define_system_schema(self) -> ConfigSchema:
        """ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã‚¹ã‚­ãƒ¼ãƒ"""
        return ConfigSchema(
            required_fields={"run_mode"},
            optional_fields={"log_level", "max_retries", "timeout"},
            field_types={
                "run_mode": str,
                "log_level": str,
                "max_retries": int,
                "timeout": int
            },
            field_validators={
                "run_mode": lambda v: v in ["local", "cloud"],
                "log_level": lambda v: v in ["DEBUG", "INFO", "WARNING", "ERROR"]
            },
            recommended_values={
                "log_level": "INFO",
                "max_retries": 3,
                "timeout": 300
            }
        )
    
    def validate_config_file(self, filepath: str) -> List[ValidationResult]:
        """
        è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œè¨¼
        
        Args:
            filepath: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        self.validation_results = []
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
        if not os.path.exists(filepath):
            self.validation_results.append(ValidationResult(
                level=ValidationLevel.ERROR,
                category="file",
                message=f"Configuration file not found: {filepath}",
                suggestion="Create the configuration file or check the path"
            ))
            return self.validation_results
        
        # ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã®åˆ¤å®šã¨èª­ã¿è¾¼ã¿
        try:
            config_data = self._load_config_file(filepath)
        except Exception as e:
            self.validation_results.append(ValidationResult(
                level=ValidationLevel.ERROR,
                category="syntax",
                message=f"Failed to parse configuration file: {str(e)}",
                suggestion="Check file syntax (JSON/YAML format)"
            ))
            return self.validation_results
        
        # å„ã‚«ãƒ†ã‚´ãƒªã®è¨­å®šã‚’æ¤œè¨¼
        for category, schema in self.schemas.items():
            if category in config_data:
                self._validate_category(category, config_data[category], schema)
            else:
                self.validation_results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category=category,
                    message=f"Category '{category}' not found in configuration",
                    suggestion=f"Consider adding '{category}' configuration"
                ))
        
        return self.validation_results
    
    def _load_config_file(self, filepath: str) -> Dict[str, Any]:
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€"""
        suffix = Path(filepath).suffix.lower()
        
        with open(filepath, 'r', encoding='utf-8') as f:
            if suffix == '.json':
                return json.load(f)
            elif suffix in ['.yaml', '.yml']:
                return yaml.safe_load(f)
            elif suffix == '.py':
                # Pythonè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ç°¡æ˜“èª­ã¿è¾¼ã¿
                # æ³¨æ„: å®Ÿè¡Œã¯å±é™ºãªã®ã§ã€å¤‰æ•°å®šç¾©ã®ã¿ã‚’ãƒ‘ãƒ¼ã‚¹
                content = f.read()
                config = {}
                # ç°¡æ˜“ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆå®Ÿéš›ã«ã¯astãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ã†ã¹ãï¼‰
                for line in content.split('\n'):
                    if '=' in line and not line.strip().startswith('#'):
                        try:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = eval(value.strip())
                            config[key] = value
                        except:
                            pass
                return config
            else:
                raise ValueError(f"Unsupported file format: {suffix}")
    
    def _validate_category(self, 
                          category: str,
                          config: Dict[str, Any],
                          schema: ConfigSchema):
        """ã‚«ãƒ†ã‚´ãƒªè¨­å®šã‚’æ¤œè¨¼"""
        # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
        for field in schema.required_fields:
            if field not in config:
                self.validation_results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category=category,
                    field=field,
                    message=f"Required field '{field}' is missing",
                    suggestion=f"Add '{field}' to the configuration"
                ))
        
        # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹ãƒã‚§ãƒƒã‚¯
        for field, value in config.items():
            if field in schema.field_types:
                expected_type = schema.field_types[field]
                if not isinstance(value, expected_type):
                    self.validation_results.append(ValidationResult(
                        level=ValidationLevel.ERROR,
                        category=category,
                        field=field,
                        message=f"Field '{field}' has wrong type",
                        expected=expected_type.__name__,
                        actual=type(value).__name__,
                        suggestion=f"Change type to {expected_type.__name__}"
                    ))
            
            # ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯
            if field in schema.field_validators:
                validator = schema.field_validators[field]
                try:
                    if not validator(value):
                        self.validation_results.append(ValidationResult(
                            level=ValidationLevel.ERROR,
                            category=category,
                            field=field,
                            message=f"Field '{field}' failed validation",
                            actual=value,
                            suggestion="Check the value against requirements"
                        ))
                except Exception as e:
                    self.validation_results.append(ValidationResult(
                        level=ValidationLevel.ERROR,
                        category=category,
                        field=field,
                        message=f"Validation error for '{field}': {str(e)}",
                        actual=value
                    ))
        
        # æ¨å¥¨å€¤ã®ãƒã‚§ãƒƒã‚¯
        for field, recommended in schema.recommended_values.items():
            if field in config and config[field] != recommended:
                self.validation_results.append(ValidationResult(
                    level=ValidationLevel.INFO,
                    category=category,
                    field=field,
                    message=f"Field '{field}' differs from recommended value",
                    expected=recommended,
                    actual=config[field],
                    suggestion=f"Consider using recommended value: {recommended}"
                ))
    
    def validate_api_keys(self, config: Dict[str, Any]) -> List[ValidationResult]:
        """
        APIã‚­ãƒ¼ã®æœ‰åŠ¹æ€§ã‚’ç¢ºèª
        
        Args:
            config: è¨­å®šãƒ‡ãƒ¼ã‚¿
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        results = []
        
        # OpenAI APIã‚­ãƒ¼
        if "ai" in config and "api_key" in config["ai"]:
            api_key = config["ai"]["api_key"]
            provider = config["ai"].get("provider", "")
            
            if provider == "openai":
                is_valid, message = self._test_openai_key(api_key)
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS if is_valid else ValidationLevel.ERROR,
                    category="api_key",
                    field="openai_api_key",
                    message=message,
                    suggestion="Check your API key in the OpenAI dashboard" if not is_valid else None
                ))
            elif provider == "anthropic":
                is_valid, message = self._test_anthropic_key(api_key)
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS if is_valid else ValidationLevel.ERROR,
                    category="api_key",
                    field="anthropic_api_key",
                    message=message,
                    suggestion="Check your API key in the Anthropic console" if not is_valid else None
                ))
        
        return results
    
    def _test_openai_key(self, api_key: str) -> Tuple[bool, str]:
        """OpenAI APIã‚­ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆ"""
        try:
            headers = {"Authorization": f"Bearer {api_key}"}
            response = requests.get(
                "https://api.openai.com/v1/models",
                headers=headers,
                timeout=10
            )
            
            if response.status_code == 200:
                return True, "OpenAI API key is valid"
            elif response.status_code == 401:
                return False, "OpenAI API key is invalid"
            else:
                return False, f"OpenAI API returned status {response.status_code}"
        except Exception as e:
            return False, f"Failed to test OpenAI API key: {str(e)}"
    
    def _test_anthropic_key(self, api_key: str) -> Tuple[bool, str]:
        """Anthropic APIã‚­ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆ"""
        try:
            headers = {
                "x-api-key": api_key,
                "anthropic-version": "2023-06-01",
                "content-type": "application/json"
            }
            # ç°¡æ˜“çš„ãªãƒ†ã‚¹ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            payload = {
                "model": "claude-3-haiku-20240307",
                "max_tokens": 10,
                "messages": [{"role": "user", "content": "Hi"}]
            }
            response = requests.post(
                "https://api.anthropic.com/v1/messages",
                headers=headers,
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                return True, "Anthropic API key is valid"
            elif response.status_code == 401:
                return False, "Anthropic API key is invalid"
            else:
                return False, f"Anthropic API returned status {response.status_code}"
        except Exception as e:
            return False, f"Failed to test Anthropic API key: {str(e)}"
    
    def validate_environment_variables(self, 
                                      required_vars: List[str]) -> List[ValidationResult]:
        """
        ç’°å¢ƒå¤‰æ•°ã‚’æ¤œè¨¼
        
        Args:
            required_vars: å¿…é ˆç’°å¢ƒå¤‰æ•°ã®ãƒªã‚¹ãƒˆ
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        results = []
        
        for var_name in required_vars:
            value = os.getenv(var_name)
            
            if value is None:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="environment",
                    field=var_name,
                    message=f"Required environment variable '{var_name}' is not set",
                    suggestion=f"Set {var_name} in your environment"
                ))
            elif not value.strip():
                results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category="environment",
                    field=var_name,
                    message=f"Environment variable '{var_name}' is empty",
                    suggestion=f"Provide a value for {var_name}"
                ))
            else:
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="environment",
                    field=var_name,
                    message=f"Environment variable '{var_name}' is set"
                ))
        
        return results
    
    def validate_dependencies(self, 
                            requirements_file: str = "requirements.txt") -> List[ValidationResult]:
        """
        ä¾å­˜é–¢ä¿‚ã‚’æ¤œè¨¼
        
        Args:
            requirements_file: requirements.txtã®ãƒ‘ã‚¹
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        results = []
        
        if not os.path.exists(requirements_file):
            results.append(ValidationResult(
                level=ValidationLevel.WARNING,
                category="dependencies",
                message=f"Requirements file not found: {requirements_file}",
                suggestion="Create a requirements.txt file"
            ))
            return results
        
        # requirements.txtã‚’èª­ã¿è¾¼ã‚€
        with open(requirements_file, 'r', encoding='utf-8') as f:
            requirements = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        # å„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®å­˜åœ¨ã‚’ç¢ºèª
        for req in requirements:
            # ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®šã‚’åˆ†é›¢
            package_name = re.split(r'[<>=!]', req)[0].strip()
            
            try:
                __import__(package_name.replace('-', '_'))
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="dependencies",
                    field=package_name,
                    message=f"Package '{package_name}' is installed"
                ))
            except ImportError:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="dependencies",
                    field=package_name,
                    message=f"Package '{package_name}' is not installed",
                    suggestion=f"Run: pip install {req}"
                ))
        
        return results
    
    def check_directory_structure(self, 
                                 base_dir: str,
                                 required_dirs: List[str]) -> List[ValidationResult]:
        """
        å¿…è¦ãªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã‚’æ¤œè¨¼
        
        Args:
            base_dir: ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            required_dirs: å¿…é ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒªã‚¹ãƒˆ
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        results = []
        base_path = Path(base_dir)
        
        for dir_name in required_dirs:
            dir_path = base_path / dir_name
            
            if not dir_path.exists():
                results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category="directory_structure",
                    field=dir_name,
                    message=f"Required directory not found: {dir_name}",
                    suggestion=f"Create directory: mkdir {dir_path}"
                ))
            elif not dir_path.is_dir():
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="directory_structure",
                    field=dir_name,
                    message=f"Path exists but is not a directory: {dir_name}",
                    suggestion=f"Remove file and create directory: {dir_path}"
                ))
            else:
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="directory_structure",
                    field=dir_name,
                    message=f"Directory exists: {dir_name}"
                ))
        
        return results
    
    def validate_network_connectivity(self, 
                                    urls: List[str]) -> List[ValidationResult]:
        """
        ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šæ€§ã‚’æ¤œè¨¼
        
        Args:
            urls: ãƒ†ã‚¹ãƒˆã™ã‚‹URLã®ãƒªã‚¹ãƒˆ
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        results = []
        
        for url in urls:
            try:
                response = requests.head(url, timeout=5, allow_redirects=True)
                
                if response.status_code < 400:
                    results.append(ValidationResult(
                        level=ValidationLevel.SUCCESS,
                        category="network",
                        field=url,
                        message=f"URL is accessible: {url}"
                    ))
                else:
                    results.append(ValidationResult(
                        level=ValidationLevel.WARNING,
                        category="network",
                        field=url,
                        message=f"URL returned status {response.status_code}: {url}",
                        suggestion="Check if the service is running"
                    ))
            except requests.exceptions.Timeout:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="network",
                    field=url,
                    message=f"Connection timeout: {url}",
                    suggestion="Check network connectivity or firewall settings"
                ))
            except requests.exceptions.ConnectionError:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="network",
                    field=url,
                    message=f"Connection failed: {url}",
                    suggestion="Check if the service is running and accessible"
                ))
            except Exception as e:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="network",
                    field=url,
                    message=f"Network error for {url}: {str(e)}"
                ))
        
        return results
    
    def validate_file_permissions(self, 
                                 files: List[str],
                                 required_permissions: str = "rw") -> List[ValidationResult]:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ã‚’æ¤œè¨¼
        
        Args:
            files: ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆ
            required_permissions: å¿…è¦ãªãƒ‘ãƒ¼ãƒŸãƒƒã‚·ãƒ§ãƒ³ ('r', 'w', 'x' ã®çµ„ã¿åˆã‚ã›)
        
        Returns:
            æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        """
        results = []
        
        for filepath in files:
            if not os.path.exists(filepath):
                results.append(ValidationResult(
                    level=ValidationLevel.WARNING,
                    category="permissions",
                    field=filepath,
                    message=f"File not found: {filepath}",
                    suggestion=f"Create the file: {filepath}"
                ))
                continue
            
            has_read = os.access(filepath, os.R_OK)
            has_write = os.access(filepath, os.W_OK)
            has_execute = os.access(filepath, os.X_OK)
            
            missing = []
            if 'r' in required_permissions and not has_read:
                missing.append('read')
            if 'w' in required_permissions and not has_write:
                missing.append('write')
            if 'x' in required_permissions and not has_execute:
                missing.append('execute')
            
            if missing:
                results.append(ValidationResult(
                    level=ValidationLevel.ERROR,
                    category="permissions",
                    field=filepath,
                    message=f"Insufficient permissions for {filepath}: missing {', '.join(missing)}",
                    suggestion=f"Grant {', '.join(missing)} permission to the file"
                ))
            else:
                results.append(ValidationResult(
                    level=ValidationLevel.SUCCESS,
                    category="permissions",
                    field=filepath,
                    message=f"File has correct permissions: {filepath}"
                ))
        
        return results
    
    def generate_validation_report(self, 
                                  results: List[ValidationResult]) -> Dict[str, Any]:
        """
        æ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            results: æ¤œè¨¼çµæœã®ãƒªã‚¹ãƒˆ
        
        Returns:
            ãƒ¬ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
        """
        errors = [r for r in results if r.level == ValidationLevel.ERROR]
        warnings = [r for r in results if r.level == ValidationLevel.WARNING]
        info = [r for r in results if r.level == ValidationLevel.INFO]
        success = [r for r in results if r.level == ValidationLevel.SUCCESS]
        
        # ã‚«ãƒ†ã‚´ãƒªåˆ¥é›†è¨ˆ
        by_category = {}
        for result in results:
            if result.category not in by_category:
                by_category[result.category] = {
                    "errors": 0,
                    "warnings": 0,
                    "info": 0,
                    "success": 0
                }
            by_category[result.category][result.level.value + "s"] += 1
        
        return {
            "summary": {
                "total": len(results),
                "errors": len(errors),
                "warnings": len(warnings),
                "info": len(info),
                "success": len(success),
                "is_valid": len(errors) == 0
            },
            "by_category": by_category,
            "details": {
                "errors": [r.to_dict() for r in errors],
                "warnings": [r.to_dict() for r in warnings],
                "info": [r.to_dict() for r in info]
            },
            "generated_at": datetime.now().isoformat()
        }
    
    def auto_fix_config(self, 
                       config: Dict[str, Any],
                       validation_results: List[ValidationResult]) -> Tuple[Dict[str, Any], List[str]]:
        """
        è¨­å®šã‚’è‡ªå‹•ä¿®æ­£ï¼ˆå¯èƒ½ãªç¯„å›²ã§ï¼‰
        
        Args:
            config: è¨­å®šãƒ‡ãƒ¼ã‚¿
            validation_results: æ¤œè¨¼çµæœ
        
        Returns:
            (ä¿®æ­£ã•ã‚ŒãŸè¨­å®š, é©ç”¨ã•ã‚ŒãŸä¿®æ­£ã®ãƒªã‚¹ãƒˆ)
        """
        fixed_config = config.copy()
        applied_fixes = []
        
        for result in validation_results:
            # æ¨å¥¨å€¤ã®é©ç”¨
            if result.level == ValidationLevel.INFO and result.expected is not None:
                category = result.category
                field = result.field
                
                if category in fixed_config and field:
                    fixed_config[category][field] = result.expected
                    applied_fixes.append(
                        f"Applied recommended value for {category}.{field}: {result.expected}"
                    )
            
            # ä¸è¶³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è¿½åŠ ï¼ˆæ¨å¥¨å€¤ãŒã‚ã‚‹å ´åˆï¼‰
            if result.level == ValidationLevel.ERROR and "missing" in result.message.lower():
                category = result.category
                field = result.field
                
                if category in self.schemas:
                    schema = self.schemas[category]
                    if field in schema.recommended_values:
                        if category not in fixed_config:
                            fixed_config[category] = {}
                        
                        fixed_config[category][field] = schema.recommended_values[field]
                        applied_fixes.append(
                            f"Added missing field {category}.{field} with recommended value"
                        )
        
        return fixed_config, applied_fixes
    
    def export_validation_report(self, 
                               results: List[ValidationResult],
                               filepath: str):
        """
        æ¤œè¨¼ãƒ¬ãƒãƒ¼ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        
        Args:
            results: æ¤œè¨¼çµæœ
            filepath: å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        """
        report = self.generate_validation_report(results)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Validation report exported to {filepath}")
    
    def get_summary(self, results: List[ValidationResult]) -> str:
        """
        æ¤œè¨¼çµæœã®ã‚µãƒãƒªãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            results: æ¤œè¨¼çµæœ
        
        Returns:
            ã‚µãƒãƒªãƒ¼ãƒ†ã‚­ã‚¹ãƒˆ
        """
        errors = sum(1 for r in results if r.level == ValidationLevel.ERROR)
        warnings = sum(1 for r in results if r.level == ValidationLevel.WARNING)
        success = sum(1 for r in results if r.level == ValidationLevel.SUCCESS)
        
        if errors == 0 and warnings == 0:
            return f"âœ… All validations passed ({success} checks)"
        elif errors == 0:
            return f"âš ï¸  Validation passed with {warnings} warnings"
        else:
            return f"âŒ Validation failed with {errors} errors and {warnings} warnings"


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    validator = ConfigValidatorAgent()
    
    # ãƒ†ã‚¹ãƒˆç”¨ã®è¨­å®š
    test_config = {
        "browser": {
            "headless": False,
            "user_data_dir": "./user_data",
            "window_size": (1920, 1080)
        },
        "ai": {
            "provider": "openai",
            "model": "gpt-4",
            "api_key": "sk-test-key",
            "temperature": 0.7
        },
        "wordpress": {
            "url": "https://example.com",
            "username": "admin"
            # password ãŒä¸è¶³ï¼ˆã‚¨ãƒ©ãƒ¼ï¼‰
        },
        "system": {
            "run_mode": "local",
            "log_level": "INFO"
        }
    }
    
    # è¨­å®šã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    config_file = "test_config.json"
    with open(config_file, 'w') as f:
        json.dump(test_config, f, indent=2)
    
    # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œè¨¼
    print("\n=== Validating Configuration File ===")
    results = validator.validate_config_file(config_file)
    
    for result in results:
        print(f"[{result.level.value.upper()}] {result.category}: {result.message}")
        if result.suggestion:
            print(f"  ğŸ’¡ {result.suggestion}")
    
    # ç’°å¢ƒå¤‰æ•°ã‚’æ¤œè¨¼
    print("\n=== Validating Environment Variables ===")
    env_results = validator.validate_environment_variables([
        "OPENAI_API_KEY",
        "WP_USERNAME",
        "WP_PASSWORD"
    ])
    
    for result in env_results:
        print(f"[{result.level.value.upper()}] {result.field}: {result.message}")
    
    # ä¾å­˜é–¢ä¿‚ã‚’æ¤œè¨¼ï¼ˆå®Ÿéš›ã®requirements.txtãŒã‚ã‚‹å ´åˆï¼‰
    # dep_results = validator.validate_dependencies()
    
    # ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
    print("\n=== Validation Report ===")
    all_results = results + env_results
    report = validator.generate_validation_report(all_results)
    print(json.dumps(report["summary"], indent=2))
    
    # ã‚µãƒãƒªãƒ¼
    print("\n" + validator.get_summary(all_results))
    
    # è‡ªå‹•ä¿®æ­£
    print("\n=== Auto-fixing Configuration ===")
    fixed_config, applied_fixes = validator.auto_fix_config(test_config, results)
    
    for fix in applied_fixes:
        print(f"âœ“ {fix}")
    
    # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    os.remove(config_file)


#content_task_executor.py
"""
content_task_executor.py - ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
AIã‚µã‚¤ãƒˆã¨ã®å¯¾è©±ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã€å¿œç­”æŠ½å‡ºã€æ¤œè¨¼ã‚’æ‹…å½“
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path

# è¨­å®š
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """
    ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã®å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ã‚’é€šã˜ãŸAIå¯¾è©±ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã€
    æŠ½å‡ºã€æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ±åˆ
    """
    
    def __init__(
        self,
        browser_controller,
        sheets_manager: GoogleSheetsManager
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        
        # AIè¨­å®š
        self.ai_sites = {
            'gemini': 'https://gemini.google.com',
            'deepseek': 'https://chat.deepseek.com',
            'claude': 'https://claude.ai'
        }
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆAI
        self.default_ai = 'gemini'
        
        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
        self.default_timeout = 180.0
        self.generation_timeout = 240.0
        
        logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
    
    async def execute_content_task(self, task: Dict) -> Dict:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
            
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
                
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("=" * 60)
            logger.info(f"âœï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info("=" * 60)
                
            # ========================================
            # ğŸ†• ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—åˆ¤å®šã¨å°‚é–€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé©ç”¨ï¼ˆå¼·åŒ–ç‰ˆï¼‰
            # ========================================
            content_type = self._determine_content_type(task)
            logger.info(f"ğŸ“‹ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—: {content_type}")
                
            # å°‚é–€æ–‡æ›¸ã‚¿ã‚¤ãƒ—ã®å ´åˆã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å·®ã—æ›¿ãˆ
            if content_type == 'pydantic_migration':
                task['prompt'] = self._build_pydantic_migration_prompt(task)
                logger.info("ğŸ”§ Pydanticç§»è¡Œãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é©ç”¨")
            elif content_type == 'openapi_schema':
                task['prompt'] = self._build_openapi_schema_prompt(task)
                logger.info("ğŸ“ OpenAPIã‚¹ã‚­ãƒ¼ãƒãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é©ç”¨")
            elif content_type == 'requirements_document':
                task['prompt'] = self._build_requirements_document_prompt(task)
                logger.info("ğŸ“„ è¦ä»¶å®šç¾©æ›¸ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é©ç”¨")
                
            # ========================================
            # æ—¢å­˜ã®å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
            # ========================================
                
            # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æŠ½å‡º
            prompt = task.get('prompt', task.get('description', ''))
            ai_site = task.get('ai_site', self.default_ai).lower()
            output_format = task.get('output_format', 'markdown')
                
            # ãƒ–ãƒ©ã‚¦ã‚¶ãƒã‚§ãƒƒã‚¯
            if not self.browser:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
                
            # AIã‚µã‚¤ãƒˆãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
            nav_result = await self._navigate_to_ai_site(ai_site)
            if not nav_result['success']:
                return nav_result
                
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿ
            response_result = await self._send_prompt_and_wait(
                prompt, 
                timeout=self.generation_timeout
            )
            if not response_result['success']:
                return response_result
                
            # å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º
            extract_result = await self._extract_response_text()
            if not extract_result['success']:
                return extract_result
                
            content = extract_result['content']
                
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œè¨¼
            validation_result = self._validate_content(content, task)
            if not validation_result['valid']:
                logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œè¨¼è­¦å‘Š: {validation_result['message']}")
                
            # å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            output_file = await self._save_content_output(
                task_id, 
                content, 
                output_format
            )
                
            logger.info(f"âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ {task_id} å®Œäº†")
                
            return {
                'success': True,
                'content': content,
                'output_file': output_file,
                'ai_site': ai_site,
                'content_type': content_type,  # ã‚¿ã‚¤ãƒ—æƒ…å ±ã‚’è¿½åŠ 
                'validation': validation_result,
                'full_text': content,
                'summary': content[:500] if len(content) > 500 else content
            }
                
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ {task_id} ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
            return {
                'success': False,
                'error': f'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({self.generation_timeout}ç§’)'
            }
            
        except Exception as e:
            logger.error(f"âŒ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_content_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _navigate_to_ai_site(self, ai_site: str) -> Dict:
        """
        AIã‚µã‚¤ãƒˆã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        
        Args:
            ai_site: AIã‚µã‚¤ãƒˆè­˜åˆ¥å­ ('gemini', 'deepseek', 'claude')
            
        Returns:
            Dict: ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³çµæœ
        """
        try:
            logger.info(f"ğŸŒ {ai_site.upper()} ã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ä¸­...")
            
            # ã‚µã‚¤ãƒˆURLå–å¾—
            if ai_site not in self.ai_sites:
                logger.warning(f"âš ï¸ æœªçŸ¥ã®AIã‚µã‚¤ãƒˆ: {ai_site}, ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ {self.default_ai} ã‚’ä½¿ç”¨")
                ai_site = self.default_ai
            
            url = self.ai_sites[ai_site]
            
            # ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—
            if ai_site == 'gemini':
                if hasattr(self.browser, 'navigate_to_gemini'):
                    result = await self.browser.navigate_to_gemini()
                else:
                    result = await self.browser.navigate_to_url(url)
            elif ai_site == 'deepseek':
                if hasattr(self.browser, 'navigate_to_deepseek'):
                    result = await self.browser.navigate_to_deepseek()
                else:
                    result = await self.browser.navigate_to_url(url)
            else:
                result = await self.browser.navigate_to_url(url)
            
            if result:
                logger.info(f"âœ… {ai_site.upper()} ã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³æˆåŠŸ")
                return {'success': True}
            else:
                logger.error(f"âŒ {ai_site.upper()} ã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—")
                return {'success': False, 'error': f'{ai_site} ã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—'}
        
        except Exception as e:
            logger.error(f"âŒ AIã‚µã‚¤ãƒˆãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _send_prompt_and_wait(
        self, 
        prompt: str, 
        timeout: float = None
    ) -> Dict:
        """
        ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ã—ã¦å¿œç­”ã‚’å¾…æ©Ÿ
        
        Args:
            prompt: é€ä¿¡ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            timeout: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            if timeout is None:
                timeout = self.generation_timeout
            
            logger.info(f"ğŸ“¤ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ä¸­... (ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {timeout}ç§’)")
            
            # çµ±åˆãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
            if hasattr(self.browser, 'send_prompt_and_wait'):
                result = await self.browser.send_prompt_and_wait(
                    prompt, 
                    timeout=timeout
                )
                if result:
                    logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿå®Œäº†")
                    return {'success': True}
                else:
                    logger.error("âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¾ãŸã¯å¿œç­”å¾…æ©Ÿå¤±æ•—")
                    return {'success': False, 'error': 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å¤±æ•—'}
            else:
                # å€‹åˆ¥ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨ï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰
                if hasattr(self.browser, 'send_prompt'):
                    await self.browser.send_prompt(prompt)
                else:
                    logger.error("âŒ send_prompt ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return {'success': False, 'error': 'send_prompt ãƒ¡ã‚½ãƒƒãƒ‰æœªå®Ÿè£…'}
                
                # å¿œç­”å¾…æ©Ÿ
                if hasattr(self.browser, 'wait_for_text_generation'):
                    await self.browser.wait_for_text_generation(timeout)
                    logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¨å¿œç­”å¾…æ©Ÿå®Œäº†")
                    return {'success': True}
                else:
                    logger.warning("âš ï¸ wait_for_text_generation ãƒ¡ã‚½ãƒƒãƒ‰ãªã— - å›ºå®šå¾…æ©Ÿ")
                    await asyncio.sleep(30)  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾…æ©Ÿ
                    return {'success': True}
        
        except asyncio.TimeoutError:
            logger.error(f"â±ï¸ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå¿œç­”ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)")
            return {'success': False, 'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'}
        
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _extract_response_text(self) -> Dict:
        """
        AIã‹ã‚‰ã®å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º
        
        Returns:
            Dict: æŠ½å‡ºçµæœ {'success': bool, 'content': str}
        """
        try:
            logger.info("ğŸ“¥ å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºä¸­...")
            
            if not hasattr(self.browser, 'extract_latest_text_response'):
                logger.error("âŒ extract_latest_text_response ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {'success': False, 'error': 'å¿œç­”æŠ½å‡ºãƒ¡ã‚½ãƒƒãƒ‰æœªå®Ÿè£…'}
            
            content = await self.browser.extract_latest_text_response()
            
            if not content:
                logger.warning("âš ï¸ æŠ½å‡ºã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒç©ºã§ã™")
                return {'success': False, 'error': 'æŠ½å‡ºã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãªã—'}
            
            logger.info(f"âœ… å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºå®Œäº† ({len(content)}æ–‡å­—)")
            return {'success': True, 'content': content}
        
        except Exception as e:
            logger.error(f"âŒ å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    def _validate_content(self, content: str, task: Dict) -> Dict:
        """
        ç”Ÿæˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ¤œè¨¼
        
        Args:
            content: æ¤œè¨¼å¯¾è±¡ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±
            
        Returns:
            Dict: æ¤œè¨¼çµæœ {'valid': bool, 'message': str, 'warnings': list}
        """
        warnings = []
        
        # æœ€å°æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯
        min_length = task.get('min_length', 100)
        if len(content.strip()) < min_length:
            warnings.append(f'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒçŸ­ã™ãã¾ã™ï¼ˆ{len(content)}æ–‡å­— < {min_length}æ–‡å­—ï¼‰')
        
        # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
        if '```' in content:
            code_block_count = content.count('```')
            if code_block_count % 2 != 0:
                warnings.append('ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒä¸å®Œå…¨ã§ã™ï¼ˆé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Šã¾ã™ï¼‰')
        
        # PHPã‚³ãƒ¼ãƒ‰å®Œå…¨æ€§ãƒã‚§ãƒƒã‚¯
        if '<?php' in content:
            if '?>' not in content and not content.rstrip().endswith('}'):
                warnings.append('PHPã‚³ãƒ¼ãƒ‰ãŒä¸å®Œå…¨ãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™')
        
        # å¿…é ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
        required_keywords = task.get('required_keywords', [])
        missing_keywords = [kw for kw in required_keywords if kw.lower() not in content.lower()]
        if missing_keywords:
            warnings.append(f'å¿…é ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ä¸è¶³: {", ".join(missing_keywords)}')
        
        valid = len(warnings) == 0
        message = 'æ¤œè¨¼åˆæ ¼' if valid else f'{len(warnings)}ä»¶ã®è­¦å‘Š'
        
        return {
            'valid': valid,
            'message': message,
            'warnings': warnings
        }
    
    async def _save_content_output(
        self, 
        task_id: str, 
        content: str, 
        output_format: str = 'markdown'
    ) -> str:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            content: ä¿å­˜ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            output_format: å‡ºåŠ›å½¢å¼ ('markdown', 'text', 'html')
            
        Returns:
            str: ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        """
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ãƒãƒƒãƒ”ãƒ³ã‚°
            ext_map = {
                'markdown': '.md',
                'text': '.txt',
                'html': '.html',
                'php': '.php'
            }
            ext = ext_map.get(output_format, '.txt')
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"content_{task_id}_{timestamp}{ext}"
            
            # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç¢ºä¿
            output_dir = Path(config.OUTPUT_DIR) if hasattr(config, 'OUTPUT_DIR') else Path('./outputs')
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
            output_path = output_dir / filename
            
            if hasattr(self.browser, 'save_text_to_file'):
                # BrowserControllerã®ä¿å­˜ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
                logger.info(f"âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¿å­˜å®Œäº†: {saved_path}")
                return str(saved_path)
            else:
                # ç›´æ¥ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                logger.info(f"âœ… ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¿å­˜å®Œäº†: {output_path}")
                return str(output_path)
        
        except Exception as e:
            logger.error(f"âŒ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "ContentTaskExecutor._save_content_output")
            return ""
    
    async def execute_multi_step_content_task(self, task: Dict) -> Dict:
        """
        è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        ä¾‹: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ1 â†’ å¿œç­”æŠ½å‡º â†’ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ2 â†’ æœ€çµ‚å‡ºåŠ›
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸ï¼ˆ'steps'ã‚­ãƒ¼ã«è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©ï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("âš ï¸ ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©ãªã— - å˜ä¸€ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ")
            return await self.execute_content_task(task)
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ”„ ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_id}")
            logger.info(f"ã‚¹ãƒ†ãƒƒãƒ—æ•°: {len(steps)}")
            logger.info("=" * 60)
            
            results = []
            accumulated_content = ""
            
            for i, step in enumerate(steps, 1):
                logger.info(f"\n--- ã‚¹ãƒ†ãƒƒãƒ— {i}/{len(steps)} ---")
                
                # ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯æ§‹ç¯‰
                step_task = {
                    **task,  # è¦ªã‚¿ã‚¹ã‚¯ã®å±æ€§ã‚’ç¶™æ‰¿
                    'task_id': f"{task_id}_step{i}",
                    'prompt': step.get('prompt', ''),
                    'description': step.get('description', f'ã‚¹ãƒ†ãƒƒãƒ—{i}'),
                }
                
                # å‰ã‚¹ãƒ†ãƒƒãƒ—ã®çµæœã‚’å‚ç…§ã™ã‚‹å ´åˆ
                if step.get('use_previous_output') and accumulated_content:
                    step_task['prompt'] = step_task['prompt'].replace(
                        '{previous_output}', 
                        accumulated_content
                    )
                
                # ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
                step_result = await self.execute_content_task(step_task)
                
                if not step_result.get('success'):
                    logger.error(f"âŒ ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—")
                    return {
                        'success': False,
                        'error': f"ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—: {step_result.get('error')}",
                        'completed_steps': i - 1,
                        'step_results': results
                    }
                
                results.append(step_result)
                accumulated_content = step_result.get('content', '')
                
                logger.info(f"âœ… ã‚¹ãƒ†ãƒƒãƒ— {i} å®Œäº†")
                
                # ã‚¹ãƒ†ãƒƒãƒ—é–“å¾…æ©Ÿ
                if i < len(steps):
                    await asyncio.sleep(2)
            
            logger.info(f"âœ… å…¨ {len(steps)} ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†")
            
            return {
                'success': True,
                'content': accumulated_content,
                'steps_completed': len(steps),
                'step_results': results,
                'full_text': accumulated_content,
                'summary': accumulated_content[:500] if len(accumulated_content) > 500 else accumulated_content
            }
        
        except Exception as e:
            logger.error(f"âŒ ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"ContentTaskExecutor.execute_multi_step_content_task({task_id})")
            return {
                'success': False,
                'error': str(e),
                'step_results': results
            }
    
    def display_suggested_tasks(self, tasks: List[Dict]):
        """
        ææ¡ˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’è¡¨ç¤º
        
        Args:
            tasks: ææ¡ˆã‚¿ã‚¹ã‚¯ã®ãƒªã‚¹ãƒˆ
        """
        print("\n" + "="*60)
        print("ğŸ“‹ ææ¡ˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯:")
        print("="*60)
        for i, task in enumerate(tasks, 1):
            print(f"\n{i}. {task.get('description', 'N/A')}")
            print(f"   AI: {task.get('ai_site', 'gemini')}")
            print(f"   å½¢å¼: {task.get('output_format', 'markdown')}")
            print(f"   å„ªå…ˆåº¦: {task.get('priority', 'medium')}")
        print("="*60)
    
    async def edit_suggested_tasks(self, tasks: List[Dict]) -> List[Dict]:
        """
        ææ¡ˆã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†
        
        Args:
            tasks: ç·¨é›†å¯¾è±¡ã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
            
        Returns:
            List[Dict]: ç·¨é›†å¾Œã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
        """
        edited_tasks = []
        
        for i, task in enumerate(tasks, 1):
            print(f"\n--- ã‚¿ã‚¹ã‚¯ {i}/{len(tasks)} ã®ç·¨é›† ---")
            print(f"ç¾åœ¨ã®èª¬æ˜: {task.get('description', 'N/A')}")
            
            edit = input("ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†ã—ã¾ã™ã‹? (y/n/s=ã‚¹ã‚­ãƒƒãƒ—): ").lower()
            
            if edit == 's':
                print("ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                continue
            elif edit == 'y':
                new_desc = input("æ–°ã—ã„èª¬æ˜ (Enter=å¤‰æ›´ãªã—): ")
                if new_desc:
                    task['description'] = new_desc
                
                new_ai = input(f"AI (ç¾åœ¨: {task.get('ai_site', 'gemini')}, Enter=å¤‰æ›´ãªã—): ")
                if new_ai:
                    task['ai_site'] = new_ai
                
                new_format = input(f"å‡ºåŠ›å½¢å¼ (ç¾åœ¨: {task.get('output_format', 'markdown')}, Enter=å¤‰æ›´ãªã—): ")
                if new_format:
                    task['output_format'] = new_format
            
            edited_tasks.append(task)
        
        return edited_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """
        æ‰‹å‹•ã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
        
        Returns:
            List[Dict]: ä½œæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
        """
        manual_tasks = []
        
        print("\n" + "="*60)
        print("âœï¸ æ‰‹å‹•ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯ä½œæˆ")
        print("="*60)
        
        while True:
            print(f"\n--- ã‚¿ã‚¹ã‚¯ {len(manual_tasks) + 1} ---")
            
            description = input("ã‚¿ã‚¹ã‚¯èª¬æ˜ (Enter=å®Œäº†): ")
            if not description:
                break
            
            prompt = input("ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ (Enter=èª¬æ˜ã¨åŒã˜): ")
            if not prompt:
                prompt = description
            
            ai_site = input("AI (gemini/deepseek/claude, Enter=gemini): ") or 'gemini'
            output_format = input("å‡ºåŠ›å½¢å¼ (markdown/text/html, Enter=markdown): ") or 'markdown'
            priority = input("å„ªå…ˆåº¦ (high/medium/low, Enter=medium): ") or 'medium'
            
            task = {
                'description': description,
                'prompt': prompt,
                'ai_site': ai_site,
                'output_format': output_format,
                'priority': priority,
                'required_role': 'content'
            }
            
            manual_tasks.append(task)
            print(f"âœ… ã‚¿ã‚¹ã‚¯ {len(manual_tasks)} è¿½åŠ å®Œäº†")
            
            continue_add = input("\nåˆ¥ã®ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã™ã‹? (y/n): ").lower()
            if continue_add != 'y':
                break
        
        print(f"\nâœ… {len(manual_tasks)}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã¾ã—ãŸ")
        return manual_tasks
    
    def _determine_content_type(self, task: Dict) -> str:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
        
        # è¨˜äº‹ç”Ÿæˆ
        if any(kw in description or kw in prompt for kw in ['è¨˜äº‹', 'article', 'ãƒ–ãƒ­ã‚°', 'blog']):
            return 'article'
        
        # ç¿»è¨³
        if any(kw in description or kw in prompt for kw in ['ç¿»è¨³', 'translate', 'translation']):
            return 'translation'
        
        # æŠ€è¡“æ–‡æ›¸
        if any(kw in description or kw in prompt for kw in ['è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ä»•æ§˜æ›¸', 'technical', 'spec']):
            return 'technical_document'
        
        return 'generic'
    
    async def _execute_article_generation(self, task: Dict) -> Dict:
        """
        è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“° è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_article_prompt(task)
            
            # AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦ç”Ÿæˆ
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=180)
                
                if success:
                    # å¿œç­”å–å¾—
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 100:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'article',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'è¨˜äº‹ç”Ÿæˆå¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'è¨˜äº‹ç”Ÿæˆå¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ è¨˜äº‹ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_translation_task(self, task: Dict) -> Dict:
        """
        ç¿»è¨³ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸŒ ç¿»è¨³ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # ç¿»è¨³ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_translation_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'translation',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'ç¿»è¨³å¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'ç¿»è¨³å¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ ç¿»è¨³ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_technical_document_task(self, task: Dict) -> Dict:
        """
        æŠ€è¡“æ–‡æ›¸ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“‹ æŠ€è¡“æ–‡æ›¸ç”Ÿæˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # æŠ€è¡“æ–‡æ›¸ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_technical_document_prompt(task)
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=300)  # é•·ã‚ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    # æŠ€è¡“æ–‡æ›¸ã¯éƒ¨åˆ†çš„ãªæˆåŠŸã‚‚è¨±å®¹
                    if response_text and len(response_text) > 500:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': len(response_text) > 2000  # å®Œå…¨æ€§ãƒ•ãƒ©ã‚°
                        }
                    elif response_text and len(response_text) > 200:
                        # éƒ¨åˆ†çš„ãªæˆåŠŸ
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'technical_document',
                            'word_count': len(response_text),
                            'is_complete': False,
                            'partial_success': True,
                            'warning': 'æ–‡æ›¸ãŒå®Œå…¨ã§ã¯ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'æŠ€è¡“æ–‡æ›¸ç”Ÿæˆå¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'æŠ€è¡“æ–‡æ›¸ç”Ÿæˆå¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ æŠ€è¡“æ–‡æ›¸ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_generic_content_task(self, task: Dict) -> Dict:
        """
        æ±ç”¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“„ æ±ç”¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            prompt = task.get('prompt', '')
            if not prompt:
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            if self.browser and hasattr(self.browser, 'send_prompt_and_wait'):
                success = await self.browser.send_prompt_and_wait(prompt, max_wait=120)
                
                if success:
                    response_text = await self.browser.extract_latest_text_response()
                    
                    if response_text and len(response_text) > 50:
                        return {
                            'success': True,
                            'content': response_text,
                            'full_text': response_text,
                            'content_type': 'generic',
                            'word_count': len(response_text)
                        }
                    else:
                        return {
                            'success': False,
                            'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—: å¿œç­”ãŒçŸ­ã™ãã¾ã™'
                        }
                else:
                    return {
                        'success': False,
                        'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—: AIå¿œç­”å¾…æ©Ÿã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    }
            else:
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“'
                }
                
        except Exception as e:
            logger.error(f"âŒ æ±ç”¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }    
    
    def _build_article_prompt(self, task: Dict) -> str:
            """è¨˜äº‹ç”Ÿæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
            base_prompt = task.get('prompt', '')
            language = task.get('language', 'ja')
            
            if language == 'ja':
                return f"""ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒã§è³ªã®é«˜ã„è¨˜äº‹ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

    {base_prompt}

    ã€è¨˜äº‹ã®è¦ä»¶ã€‘
    - å°‚é–€çš„ã‹ã¤åˆ†ã‹ã‚Šã‚„ã™ã„å†…å®¹
    - å…·ä½“çš„ãªäº‹ä¾‹ã‚„ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚ã‚‹
    - èª­è€…ã®é–¢å¿ƒã‚’å¼•ãå°å…¥éƒ¨
    - æ˜ç¢ºãªçµè«–ã§ç· ã‚ããã‚‹
    - 1500æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°

    ã€å‡ºåŠ›å½¢å¼ã€‘
    - è¦‹å‡ºã—ã‚’é©åˆ‡ã«ä½¿ç”¨
    - æ®µè½åˆ†ã‘ã‚’æ˜ç¢ºã«
    - èª­ã¿ã‚„ã™ã„æ–‡ä½“ã§"""
            
            else:
                return f"""Generate a high-quality article on the following topic:

    {base_prompt}

    ã€Article Requirementsã€‘
    - Professional yet accessible content
    - Include specific examples and data
    - Engaging introduction
    - Clear conclusion
    - Detailed description over 1500 words

    ã€Output Formatã€‘
    - Use appropriate headings
    - Clear paragraph breaks
    - Readable writing style"""
        
    def _build_translation_prompt(self, task: Dict) -> str:
        """ç¿»è¨³ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        source_text = task.get('source_text', '')
        target_language = task.get('target_language', 'ja')
        source_language = task.get('source_language', 'en')
        
        return f"""ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’{source_language}ã‹ã‚‰{target_language}ã«ç¿»è¨³ã—ã¦ãã ã•ã„ï¼š

    {source_text}

    ã€ç¿»è¨³è¦ä»¶ã€‘
    - è‡ªç„¶ã§æµæš¢ãªè¡¨ç¾
    - å°‚é–€ç”¨èªã¯é©åˆ‡ã«è¨³ã™
    - æ–‡åŒ–çš„ãªé•ã„ã‚’è€ƒæ…®
    - åŸæ–‡ã®æ„å‘³ã‚’æ­£ç¢ºã«ä¼ãˆã‚‹"""
        
    def _build_technical_document_prompt(self, task: Dict) -> str:
        """æŠ€è¡“æ–‡æ›¸ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        base_prompt = task.get('prompt', '')
        
        return f"""ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦è©³ç´°ãªæŠ€è¡“æ–‡æ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š

    {base_prompt}

    ã€æ–‡æ›¸è¦ä»¶ã€‘
    - æŠ€è¡“çš„ã«æ­£ç¢ºãªå†…å®¹
    - ä½“ç³»çš„ãªæ§‹æˆ
    - å…·ä½“çš„ãªå®Ÿè£…ä¾‹ã‚„ã‚³ãƒ¼ãƒ‰ã‚µãƒ³ãƒ—ãƒ«
    - ã‚ã‹ã‚Šã‚„ã™ã„èª¬æ˜
    - 2000æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°

    ã€å‡ºåŠ›å½¢å¼ã€‘
    - ç« ç«‹ã¦ã‚’æ˜ç¢ºã«
    - ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯é©åˆ‡ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    - è¡¨ã‚„ãƒªã‚¹ãƒˆã‚’å¿…è¦ã«å¿œã˜ã¦ä½¿ç”¨
    - å°‚é–€ç”¨èªã¯åˆå‡ºæ™‚ã«ç°¡æ½”ã«èª¬æ˜"""
    
    
    def _build_pydantic_migration_prompt(self, task: Dict) -> str:
        """
        Pydanticãƒ¢ãƒ‡ãƒ«ç§»è¡Œå°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
    
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
        Returns:
            str: Pydanticãƒ¢ãƒ‡ãƒ«ç§»è¡Œãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        base_prompt = task.get('prompt', '')
        current_implementation = task.get('current_implementation', '')
    
        return f"""ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’Pydanticãƒ¢ãƒ‡ãƒ«ã«ç§»è¡Œã—ã¦ãã ã•ã„:

    {base_prompt}

    ã€ç¾åœ¨ã®å®Ÿè£…ã€‘
    {current_implementation if current_implementation else 'â€»ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®è©³ç´°ã¯è¦ä»¶å®šç¾©æ›¸ã‚’å‚ç…§'}

    ã€Pydanticç§»è¡Œè¦ä»¶ã€‘
    1. **Pydanticãƒ¢ãƒ‡ãƒ«å®šç¾©**
        - ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’Pydantic BaseModelã‚¯ãƒ©ã‚¹ã¨ã—ã¦å®šç¾©
        - å‹ãƒ’ãƒ³ãƒˆ(Type Hints)ã‚’æ˜ç¢ºã«æŒ‡å®š
        - Field()ã‚’ä½¿ç”¨ã—ãŸãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
        - Optionalå‹ã®é©åˆ‡ãªä½¿ç”¨

    2. **ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…**
        - å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©
        - ãƒ‡ãƒ¼ã‚¿å‹ã®å³æ ¼ãªãƒã‚§ãƒƒã‚¯
        - ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚¿ã®å®Ÿè£…
        - ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ—¥æœ¬èªåŒ–

    3. **JSONã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆ**
        - model.schema_json()ã«ã‚ˆã‚‹ã‚¹ã‚­ãƒ¼ãƒå‡ºåŠ›
        - OpenAPIäº’æ›æ€§ã®ç¢ºä¿
        - ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ–‡å­—åˆ—ã®è¨˜è¿°

    4. **è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰**
        - pytestå¯¾å¿œã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        - æ­£å¸¸ç³»ãƒ»ç•°å¸¸ç³»ã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
        - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼ã®ç¢ºèª

    ã€å‡ºåŠ›å½¢å¼ã€‘
    ```python
    from pydantic import BaseModel, Field, validator
    from typing import Optional, List
    from datetime import datetime
    # (å®Œå…¨ãªPydanticãƒ¢ãƒ‡ãƒ«å®šç¾©ã‚³ãƒ¼ãƒ‰)
    ã€å¿…é ˆè¦ç´ ã€‘

    ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å‹ãƒ’ãƒ³ãƒˆã¨Field()ã«ã‚ˆã‚‹èª¬æ˜
    @validatorãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã«ã‚ˆã‚‹ã‚«ã‚¹ã‚¿ãƒ æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
    repr()ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
    model_configè¨­å®š(alias, extra='forbid'ãªã©)

    2000æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚"""
    
    def _build_openapi_schema_prompt(self, task: Dict) -> str:
        """
        OpenAPIã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆå°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: OpenAPIã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        base_prompt = task.get('prompt', '')
        api_endpoints = task.get('api_endpoints', [])
        
        endpoints_list = '\n'.join([f"  - {ep}" for ep in api_endpoints]) if api_endpoints else 'â€»è¦ä»¶å®šç¾©æ›¸å‚ç…§'
        
        return f"""ä»¥ä¸‹ã®APIä»•æ§˜ã«åŸºã¥ã„ã¦ã€å®Œå…¨ãªOpenAPI 3.0ã‚¹ã‚­ãƒ¼ãƒã‚’ç”Ÿæˆã—ã¦ãã ã•ã„:
    {base_prompt}
    ã€å¯¾è±¡APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã€‘
    {endpoints_list}
    ã€OpenAPIã‚¹ã‚­ãƒ¼ãƒè¦ä»¶ã€‘

    1.åŸºæœ¬æ§‹é€ 
    OpenAPI 3.0.0æº–æ‹ 
    info(ã‚¿ã‚¤ãƒˆãƒ«ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€èª¬æ˜)
    servers(é–‹ç™ºãƒ»æœ¬ç•ªç’°å¢ƒ)
    paths(å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ)
    components/schemas(ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«)


    2.ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©
    HTTPãƒ¡ã‚½ãƒƒãƒ‰(GET, POST, PUT, DELETE)
    ãƒ‘ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£(application/json)
    ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ã‚­ãƒ¼ãƒ(200, 400, 500)
    èªè¨¼è¦ä»¶(bearerAuth)


    3.ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©
    ã™ã¹ã¦ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‹
    ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å‹ã¨èª¬æ˜
    requiredé…åˆ—ã®å®šç¾©
    exampleå€¤ã®æä¾›

    4.ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å®šç¾©
    securitySchemeså®šç¾©
    JWTèªè¨¼ã®è¨­å®š
    OAuth2ãƒ•ãƒ­ãƒ¼(è©²å½“ã™ã‚‹å ´åˆ)

    ã€å‡ºåŠ›å½¢å¼ã€‘
    openapi: 3.0.0
    info:
      title: (APIã‚¿ã‚¤ãƒˆãƒ«)
      version: 1.0.0
      description: (APIèª¬æ˜)
    servers:
      - url: https://api.example.com/v1
    paths:
      # (å®Œå…¨ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®šç¾©)
    components:
      schemas:
        # (å®Œå…¨ãªãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©)
      securitySchemes:
        bearerAuth:
          type: http
          scheme: bearer
          bearerFormat: JWT
    2500æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚"""
    def _build_requirements_document_prompt(self, task: Dict) -> str:
        """
        è¦ä»¶å®šç¾©æ›¸ä½œæˆå°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
    
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
        Returns:
            str: è¦ä»¶å®šç¾©æ›¸ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        base_prompt = task.get('prompt', '')
        project_name = task.get('project_name', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ')
    
        return f"""ä»¥ä¸‹ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ã¤ã„ã¦ã€åŒ…æ‹¬çš„ãªè¦ä»¶å®šç¾©æ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„:
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå: {project_name}
    {base_prompt}
    ã€è¦ä»¶å®šç¾©æ›¸ã®æ§‹æˆã€‘
    1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦

    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®èƒŒæ™¯ã¨ç›®çš„
    å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ»ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¹ã‚³ãƒ¼ãƒ—
    æˆåŠŸæŒ‡æ¨™(KPI)

    2. æ©Ÿèƒ½è¦ä»¶
    2.1 ãƒ¦ãƒ¼ã‚¶ãƒ¼æ©Ÿèƒ½

    ä¼šå“¡ç™»éŒ²ãƒ»ãƒ­ã‚°ã‚¤ãƒ³
    ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç®¡ç†
    (ãã®ä»–æ©Ÿèƒ½ã‚’åˆ—æŒ™)

    2.2 ç®¡ç†æ©Ÿèƒ½

    ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç®¡ç†
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†
    ãƒ¬ãƒãƒ¼ãƒˆãƒ»åˆ†æ

    2.3 APIä»•æ§˜

    ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¸€è¦§
    èªè¨¼æ–¹å¼
    ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ

    3. éæ©Ÿèƒ½è¦ä»¶
    3.1 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶

    ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ç›®æ¨™
    åŒæ™‚æ¥ç¶šæ•°
    ãƒ‡ãƒ¼ã‚¿é‡ã®æƒ³å®š

    3.2 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶

    èªè¨¼ãƒ»èªå¯æ–¹å¼
    ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–
    è„†å¼±æ€§å¯¾ç­–

    3.3 å¯ç”¨æ€§ãƒ»æ‹¡å¼µæ€§

    SLAç›®æ¨™
    ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ãƒªã‚«ãƒãƒª
    ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£

    4. æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
    4.1 ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

    ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯/ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
    çŠ¶æ…‹ç®¡ç†
    UI/UXãƒ©ã‚¤ãƒ–ãƒ©ãƒª

    4.2 ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

    è¨€èªãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
    ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
    APIã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

    4.3 ã‚¤ãƒ³ãƒ•ãƒ©

    ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°ç’°å¢ƒ
    CI/CD
    ç›£è¦–ãƒ»ãƒ­ã‚°

    5. ãƒ‡ãƒ¼ã‚¿è¨­è¨ˆ
    5.1 ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

    ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ä¸€è¦§
    ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—
    ä¸»è¦ãªåˆ¶ç´„

    5.2 ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

    ãƒ‡ãƒ¼ã‚¿ã®æµã‚Œ
    å¤–éƒ¨é€£æº
    ãƒãƒƒãƒå‡¦ç†

    6. ç”»é¢è¨­è¨ˆ
    6.1 ç”»é¢ä¸€è¦§

    ç”»é¢åã¨å½¹å‰²
    ç”»é¢é·ç§»å›³
    ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ æ¦‚è¦

    7. å¤–éƒ¨é€£æº

    æ±ºæ¸ˆAPI
    ãƒ¡ãƒ¼ãƒ«é€ä¿¡
    ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ­ã‚°ã‚¤ãƒ³

    8. é‹ç”¨ãƒ»ä¿å®ˆ

    ãƒªãƒªãƒ¼ã‚¹è¨ˆç”»
    é‹ç”¨ä½“åˆ¶
    ã‚µãƒãƒ¼ãƒˆä½“åˆ¶

    9. ãƒªã‚¹ã‚¯ç®¡ç†

    æƒ³å®šãƒªã‚¹ã‚¯
    å¯¾ç­–
    ç·Šæ€¥æ™‚å¯¾å¿œ

    10. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

    ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³
    å„ãƒ•ã‚§ãƒ¼ã‚ºã®æœŸé–“
    ãƒªãƒªãƒ¼ã‚¹æ—¥

    ã€è¨˜è¿°è¦ä»¶ã€‘

    å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’å…·ä½“çš„ã‹ã¤è©³ç´°ã«è¨˜è¿°
    æŠ€è¡“çš„ãªå®Ÿè£…æ¡ˆã‚‚å«ã‚ã‚‹
    æ•°å€¤ç›®æ¨™ã‚’æ˜ç¢ºã«è¨­å®š
    å›³è¡¨ã®èª¬æ˜ã‚‚å«ã‚ã‚‹(å®Ÿéš›ã®å›³ã¯åˆ¥é€”)

    3000æ–‡å­—ä»¥ä¸Šã§è©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚"""
   
    def _determine_content_type(self, task: Dict) -> str:
        """
        ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
    
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
        
        Returns:
            str: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¤ãƒ—
        """
        description = task.get('description', '').lower()
        prompt = task.get('prompt', '').lower()
    
        # ========================================
        # ğŸ†• å°‚é–€æ–‡æ›¸ã‚¿ã‚¤ãƒ—ã®åˆ¤å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰
        # ========================================
    
        # Pydanticç§»è¡Œã‚¿ã‚¹ã‚¯
        if any(kw in description or kw in prompt for kw in ['pydantic', 'ãƒ¢ãƒ‡ãƒ«ç§»è¡Œ', 'model migration', 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³']):
            return 'pydantic_migration'
    
        # OpenAPIã‚¹ã‚­ãƒ¼ãƒç”Ÿæˆ
        if any(kw in description or kw in prompt for kw in ['openapi', 'swagger', 'apiä»•æ§˜', 'api schema']):
            return 'openapi_schema'
    
        # è¦ä»¶å®šç¾©æ›¸ä½œæˆ
        if any(kw in description or kw in prompt for kw in ['è¦ä»¶å®šç¾©æ›¸', 'è¦ä»¶å®šç¾©', 'requirements document', 'ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶']):
            return 'requirements_document'
    
        # ========================================
        # æ—¢å­˜ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
        # ========================================
    
        # è¨˜äº‹ç”Ÿæˆ
        if any(kw in description or kw in prompt for kw in ['è¨˜äº‹', 'article', 'ãƒ–ãƒ­ã‚°', 'blog']):
            return 'article'
    
        # ç¿»è¨³
        if any(kw in description or kw in prompt for kw in ['ç¿»è¨³', 'translate', 'translation']):
            return 'translation'
    
        # æŠ€è¡“æ–‡æ›¸
        if any(kw in description or kw in prompt for kw in ['è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ä»•æ§˜æ›¸', 'technical', 'spec']):
            return 'technical_document'
    
        return 'generic'
    
    def _is_partial_success(self, result: Dict) -> bool:
        """
        éƒ¨åˆ†çš„ãªæˆåŠŸã‹åˆ¤å®š
        
        Args:
            result: å®Ÿè¡Œçµæœ
            
        Returns:
            bool: éƒ¨åˆ†æˆåŠŸãªã‚‰True
        """
        if not result:
            return False
        
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹ç¨‹åº¦ã‚ã‚Œã°éƒ¨åˆ†æˆåŠŸã¨ã¿ãªã™
        content = result.get('content') or result.get('full_text')
        if content and len(str(content)) > 500:
            return True
        
        # æŠ€è¡“æ–‡æ›¸ã§ä¸å®Œå…¨ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆ
        if result.get('content_type') == 'technical_document' and content and len(str(content)) > 200:
            return True
        
        return False
    
    
    

#content_writer_agent.py
# content_writer_agent.py
import asyncio
import logging
import json
from pathlib import Path
from typing import Dict
from datetime import datetime

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class ContentWriterAgent:
    """å¼·åŒ–ç‰ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI - ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªæ§‹é€ åŒ–HTMLè¨˜äº‹ã‚’ç”Ÿæˆ"""
    
    CONTENT_WRITER_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aå¸‚å ´ã«é–¢ã™ã‚‹å°‚é–€çŸ¥è­˜ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- æŒ‡å®šã•ã‚ŒãŸURLã®è¨˜äº‹ã‚’èª­ã¿ã€ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aã«èˆˆå‘³ãŒã‚ã‚‹ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼å‘ã‘ã«æœ‰ç›Šãªè¨˜äº‹ã‚’ä½œæˆ
- ãƒ–ãƒ­ã‚°ã«ãã®ã¾ã¾æ²è¼‰ã§ãã‚‹é«˜å“è³ªã®æ§‹é€ åŒ–HTMLè¨˜äº‹ã‚’åŸ·ç­†
- SEOã‚’æ„è­˜ã—ãŸæ§‹æˆã¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰é…ç½®
- å¤šè¨€èªå¯¾å¿œï¼ˆæ—¥æœ¬èª/è‹±èª/ãƒ­ã‚·ã‚¢èªãªã©ï¼‰

ã€åŸ·ç­†ã®åŸå‰‡ã€‘
1. ã€Œäº†è§£ã—ã¾ã—ãŸï¼ã€ãªã©ã®æŒ¨æ‹¶ã¯ä¸€åˆ‡ä¸è¦
2. æœ€åˆã‹ã‚‰å®Œå…¨ãªHTMLå½¢å¼ã§å‡ºåŠ›
3. æ•°å­—ã‚„é‡è¦ãªéƒ¨åˆ†ã¯<strong>ã‚¿ã‚°ã§å¼·èª¿
4. é©åˆ‡ãªè¦‹å‡ºã—æ§‹é€ ï¼ˆh2, h3ï¼‰ã¨æ®µè½ã§èª­ã¿ã‚„ã™ã
5. ãƒªã‚¹ãƒˆã‚’æ´»ç”¨ã—ãŸæ§‹é€ åŒ–
6. ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…ï¼ˆãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼ã€æŠ•è³‡å®¶ï¼‰ã®é–¢å¿ƒã«åˆã‚ã›ãŸå†…å®¹

ã€è¨˜äº‹ã®é•·ã•ã€‘
- ç›®æ¨™æ–‡å­—æ•°: 1800ã€œ3500æ–‡å­—ã€2000~3000æ–‡å­—ç¨‹åº¦ãŒæœ€ã‚‚ãƒ™ã‚¹ãƒˆ
- ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ä¾¡å€¤ã®é«˜ã„å†…å®¹ã«é›†ä¸­
- å†—é•·ãªèª¬æ˜ã‚’é¿ã‘ã€é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã®ã¿ã‚’è¨˜è¼‰

ã€å‡ºåŠ›å½¢å¼ - ã‚·ãƒ³ãƒ—ãƒ«ãªHTMLæ§‹é€ ã€‘
ä»¥ä¸‹ã®HTMLæ§‹é€ ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

<article class="mna-article">
  <h1>è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ« - é­…åŠ›çš„ã§SEOã‚’æ„è­˜</h1>
  
  <div class="article-meta">
    <span class="publish-date">å…¬é–‹æ—¥: YYYYå¹´MMæœˆDDæ—¥</span>
    <span class="target-region">å¯¾è±¡åœ°åŸŸ: ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³</span>
  </div>
  
  <section class="intro">
    <h2>ã¯ã˜ã‚ã«</h2>
    <p>ã“ã®è¨˜äº‹ã®ãƒ†ãƒ¼ãƒã¨ä¾¡å€¤ã‚’ç°¡æ½”ã«èª¬æ˜ï¼ˆ2-3æ–‡ï¼‰</p>
  </section>
  
  <section class="main-content">
    <h2>ä¸»è¦ãƒã‚¤ãƒ³ãƒˆ</h2>
    <p>é‡è¦ãªæƒ…å ±ã‚’ç°¡æ½”ã«èª¬æ˜ï¼ˆ3-4æ®µè½ï¼‰</p>
    
    <div class="key-points">
      <h3>æ³¨ç›®ã™ã¹ãç‚¹</h3>
      <ul>
        <li><strong>ãƒã‚¤ãƒ³ãƒˆ1</strong>: ç°¡æ½”ãªèª¬æ˜</li>
        <li><strong>ãƒã‚¤ãƒ³ãƒˆ2</strong>: ç°¡æ½”ãªèª¬æ˜</li>
        <li><strong>ãƒã‚¤ãƒ³ãƒˆ3</strong>: ç°¡æ½”ãªèª¬æ˜</li>
      </ul>
    </div>
  </section>
  
  <section class="business-value">
    <h2>ãƒ“ã‚¸ãƒã‚¹æ©Ÿä¼š</h2>
    <p>ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aå¸‚å ´ã«ãŠã‘ã‚‹å…·ä½“çš„ãªæ©Ÿä¼šï¼ˆ2-3æ®µè½ï¼‰</p>
  </section>
  
  <section class="conclusion">
    <h2>ã¾ã¨ã‚</h2>
    <p>è¦ç‚¹ã‚’2-3æ–‡ã§ã¾ã¨ã‚ã‚‹</p>
  </section>
  
  <div class="article-footer">
    <p><strong>å‚ç…§å…ƒ</strong>: <a href="å…ƒè¨˜äº‹URL" target="_blank">å…ƒè¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«</a></p>
  </div>
</article>

ã€é‡è¦ãªåˆ¶ç´„ã€‘
- å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ç°¡æ½”ã«ï¼ˆ1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚ãŸã‚Š200-300æ–‡å­—ï¼‰
- å†—é•·ãªè¡¨ç¾ã‚’é¿ã‘ã‚‹
- å¿…ãšæœ€å¾Œï¼ˆ</article>ã‚¿ã‚°ï¼‰ã¾ã§å®Œçµã•ã›ã‚‹
"""

    def __init__(self, browser: BrowserController, output_folder: Path = None):
        self.browser = browser
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
            else:
                self.output_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
                self.output_folder.mkdir(exist_ok=True, parents=True)
        else:
            self.output_folder = output_folder
    
    async def process_task(self, task: Dict) -> Dict:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç† - ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªæ§‹é€ åŒ–HTMLå‡ºåŠ›"""
        try:
            logger.info(f"ğŸ”§ å¼·åŒ–ç‰ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI: ã‚¿ã‚¹ã‚¯å‡¦ç†é–‹å§‹")
            logger.info(f"ã‚¿ã‚¹ã‚¯: {task['description'][:100]}...")
            
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰è¦ä»¶ã‚’æŠ½å‡º
            task_info = self._parse_task_requirements(task['description'])
            
            # ã‚¿ã‚¹ã‚¯ã«æ˜ç¤ºçš„ãªè¨€èªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã‚ã‚‹å ´åˆã¯å„ªå…ˆ
            if 'language' in task and task['language']:
                task_info['language'] = task['language']
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰è¨€èªã‚’å–å¾—: {task_info['language']}")
            
            logger.info(f"  URL: {task_info['url'][:60] if task_info['url'] else '(URLãªã—)'}...")
            logger.info(f"  è¨€èª: {task_info['language']}")
            logger.info(f"  ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: {task_info['target_audience']}")
            
            # è¨€èªåˆ¥ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆèª¿æ•´
            language_specific_prompt = self._get_language_specific_prompt(task_info['language'])
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰ï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆç‰ˆï¼‰
            full_prompt = f"""{self.CONTENT_WRITER_PROMPT}

{language_specific_prompt}

ã€å…·ä½“çš„ãªåŸ·ç­†ä¾é ¼ã€‘
å‚ç…§URL: {task_info['url']}
ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…: {task_info['target_audience']}
è¨€èª: {task_info['language']}

ã€å³å®ˆäº‹é …ã€‘
1. ä¸Šè¨˜URLã®è¨˜äº‹ã‚’èª­ã¿ã€{task_info['target_audience']}å‘ã‘ã«æœ‰ç›Šãªè¨˜äº‹ã‚’ä½œæˆ
2. ç›®æ¨™æ–‡å­—æ•°: 1500ã€œ1800æ–‡å­—ï¼ˆã“ã‚Œã‚’çµ¶å¯¾ã«è¶…ãˆãªã„ï¼‰
3. å®Œå…¨ãªHTMLå½¢å¼ã§å‡ºåŠ›ï¼ˆãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ä¸å¯ï¼‰
4. è¦‹å‡ºã—æ§‹é€ ï¼ˆh1, h2, h3ï¼‰ã‚’é©åˆ‡ã«ä½¿ç”¨
5. é‡è¦ãªæ•°å­—ã¯<strong>ã‚¿ã‚°ã§å¼·èª¿
6. è¨˜äº‹å…¨ä½“ã‚’{task_info['language']}ã§åŸ·ç­†
7. å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ç°¡æ½”ã«ï¼ˆ1ã‚»ã‚¯ã‚·ãƒ§ãƒ³200-300æ–‡å­—ï¼‰

ã€æœ€é‡è¦ã€‘
- è¨˜äº‹ã¯å¿…ãšå®Œçµã•ã›ã‚‹ï¼ˆé€”ä¸­ã§çµ‚ã‚ã‚‰ãªã„ï¼‰
- </article>ã‚¿ã‚°ã§å¿…ãšé–‰ã˜ã‚‹
- conclusionã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨article-footerã‚’å¿…ãšå«ã‚ã‚‹
- é•·ã™ãã‚‹è¨˜äº‹ã¯é€”ä¸­ã§åˆ‡ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«æ›¸ã

**1800æ–‡å­—ä»¥å†…ã§ã€HTMLã‚¿ã‚°ã‚’ä½¿ç”¨ã—ãŸå®Œå…¨ãªè¨˜äº‹ã‚’æœ€å¾Œã¾ã§æ›¸ãåˆ‡ã£ã¦ãã ã•ã„ã€‚**"""
            
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªæ§‹é€ åŒ–HTMLè¨˜äº‹ä½œæˆã‚’ä¾é ¼ä¸­...")
            logger.info(f"  ç›®æ¨™æ–‡å­—æ•°: 1500ã€œ1800æ–‡å­—")
            logger.info(f"  ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé•·: {len(full_prompt)}æ–‡å­—")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªã®ã§çŸ­ã‚ã§OKï¼‰
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                return {
                    'success': False,
                    'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
            
            # å¿œç­”ã‚’å–å¾—
            article_html = await self.browser.extract_latest_text_response()
            
            if not article_html:
                return {
                    'success': False,
                    'error': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AI: è¨˜äº‹å–å¾—å¤±æ•—'
                }
            
            logger.info(f"âœ… æ§‹é€ åŒ–HTMLè¨˜äº‹ç”Ÿæˆå®Œäº†: {len(article_html)}æ–‡å­—")
            
            # HTMLã®å®Œå…¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if not self._validate_html_completeness(article_html):
                logger.warning("âš ï¸ è¨˜äº‹ãŒé€”ä¸­ã§é€”åˆ‡ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
            
            # ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºï¼ˆæœ€åˆã®<h1>ã‚¿ã‚°ï¼‰
            import re
            title_match = re.search(r'<h1[^>]*>(.+?)</h1>', article_html, re.IGNORECASE | re.DOTALL)
            article_title = title_match.group(1).strip() if title_match else "ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜ï¼‰"
            
            logger.info(f"  è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«: {article_title}")
            
            # JSONå½¢å¼ã§ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ã¨ã‚‚ã«ä¿å­˜
            article_data = {
                'task_id': task['task_id'],
                'title': article_title,
                'html_content': article_html,
                'language': task_info['language'],
                'target_audience': task_info['target_audience'],
                'source_url': task_info['url'],
                'created_at': datetime.now().isoformat(),
                'word_count': len(article_html),
                'content_type': 'structured_html_compact',
                'is_complete': self._validate_html_completeness(article_html)
            }
            
            # JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜
            json_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            json_output_path = self.output_folder / json_filename
            
            with open(json_output_path, 'w', encoding='utf-8') as f:
                json.dump(article_data, f, ensure_ascii=False, indent=2)
            
            logger.info(f"æ§‹é€ åŒ–è¨˜äº‹ã‚’JSONä¿å­˜: {json_filename}")
            
            # HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚‚åˆ¥é€”ä¿å­˜ï¼ˆç¢ºèªç”¨ï¼‰
            html_filename = f"article_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"
            html_output_path = self.output_folder / html_filename
            
            with open(html_output_path, 'w', encoding='utf-8') as f:
                f.write("<!DOCTYPE html>\n")
                f.write("<html lang='ja'>\n")
                f.write("<head>\n")
                f.write("<meta charset='UTF-8'>\n")
                f.write("<meta name='viewport' content='width=device-width, initial-scale=1.0'>\n")
                f.write(f"<title>{article_title}</title>\n")
                f.write("<style>\n")
                f.write("body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.8; margin: 40px; max-width: 800px; margin: 0 auto; padding: 40px; }\n")
                f.write("h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 15px; font-size: 28px; }\n")
                f.write("h2 { color: #34495e; margin-top: 35px; font-size: 22px; border-left: 4px solid #3498db; padding-left: 10px; }\n")
                f.write("h3 { color: #16a085; font-size: 18px; margin-top: 20px; }\n")
                f.write(".article-meta { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 25px 0; font-size: 14px; }\n")
                f.write(".key-points { background: #e8f4fd; padding: 20px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #3498db; }\n")
                f.write(".article-footer { margin-top: 50px; padding-top: 25px; border-top: 2px solid #ddd; color: #666; }\n")
                f.write("ul { line-height: 1.8; }\n")
                f.write("li { margin-bottom: 10px; }\n")
                f.write("strong { color: #e74c3c; }\n")
                f.write("p { margin-bottom: 15px; }\n")
                f.write("</style>\n")
                f.write("</head>\n")
                f.write("<body>\n")
                f.write(article_html)
                f.write("</body>\n")
                f.write("</html>\n")
            
            logger.info(f"HTMLãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚ä¿å­˜: {html_filename}")
            
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ
            article_preview = self._extract_text_preview(article_html)
            
            summary = f"è¨˜äº‹ã‚¿ã‚¤ãƒˆãƒ«: {article_title}\nè¨€èª: {task_info['language']}\næ–‡å­—æ•°: {len(article_html)}\nå®Œå…¨æ€§: {'âœ… å®Œå…¨' if article_data['is_complete'] else 'âš ï¸ ä¸å®Œå…¨'}\nãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼: {article_preview}"
            
            return {
                'success': True,
                'output_file': str(json_output_path),
                'html_file': str(html_output_path),
                'summary': summary,
                'full_text': article_html,
                'article_title': article_title,
                'content_type': 'structured_html_compact',
                'language': task_info['language'],
                'is_complete': article_data['is_complete']
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "å¼·åŒ–ç‰ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼AIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _validate_html_completeness(self, html_content: str) -> bool:
        """HTMLãŒå®Œå…¨ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯"""
        import re
        
        # å¿…é ˆè¦ç´ ãŒã™ã¹ã¦å«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        required_elements = [
            r'<article[^>]*>',           # é–‹å§‹ã‚¿ã‚°
            r'</article>',                # çµ‚äº†ã‚¿ã‚°
            r'<section[^>]*class="conclusion"',  # ã¾ã¨ã‚ã‚»ã‚¯ã‚·ãƒ§ãƒ³
            r'<div[^>]*class="article-footer"'   # ãƒ•ãƒƒã‚¿ãƒ¼
        ]
        
        for pattern in required_elements:
            if not re.search(pattern, html_content, re.IGNORECASE):
                logger.warning(f"âš ï¸ å¿…é ˆè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {pattern}")
                return False
        
        return True
    
    def _get_language_specific_prompt(self, language: str) -> str:
        """è¨€èªåˆ¥ã®è¿½åŠ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¿”ã™"""
        prompts = {
            "æ—¥æœ¬èª": """
ã€æ—¥æœ¬èªè¨˜äº‹ã®ç‰¹å¾´ã€‘
- å¿…ãšæ—¥æœ¬èªï¼ˆã²ã‚‰ãŒãªã€ã‚«ã‚¿ã‚«ãƒŠã€æ¼¢å­—ã‚’å«ã‚€è‡ªç„¶ãªæ—¥æœ¬èªï¼‰ã§åŸ·ç­†
- æ•¬èªã‚’ä½¿ç”¨ã—ã€ãƒ“ã‚¸ãƒã‚¹ãƒ•ã‚©ãƒ¼ãƒãƒ«ãªæ–‡ä½“ã‚’ç¶­æŒ
- å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿ã¨ã¨ã‚‚ã«èª¬æ˜ã‚’å±•é–‹
- ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aå¸‚å ´ã«ãŠã‘ã‚‹æ—¥æœ¬ä¼æ¥­ã®è¦–ç‚¹ã‚’é‡è¦–
- èª­è€…ï¼ˆæ—¥æœ¬ã®ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼ï¼‰ãŒç†è§£ã—ã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ç”¨
- 1500ã€œ1800æ–‡å­—ä»¥å†…ã«ã¾ã¨ã‚ã‚‹

ã€åŸ·ç­†æ™‚ã®æ³¨æ„ç‚¹ã€‘
- è‹±èªã‚„ä»–è¨€èªã¯å›ºæœ‰åè©ãƒ»å°‚é–€ç”¨èªä»¥å¤–ã§ã¯ä½¿ç”¨ã—ãªã„
- æ•°å­—ã¯åŠè§’ã€å˜ä½ã¯å…¨è§’ï¼ˆä¾‹: 6%ã€100å„„å††ï¼‰
- å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ç°¡æ½”ã«200-300æ–‡å­—ç¨‹åº¦
- è¨˜äº‹ã¯å¿…ãšæœ€å¾Œï¼ˆ</article>ã‚¿ã‚°ï¼‰ã¾ã§å®Œçµã•ã›ã‚‹
""",
            "English": """
ã€English Article Featuresã€‘
- Write entirely in English (no Japanese characters except proper nouns)
- Use business formal English throughout
- Include specific data and examples
- Focus on investment opportunities in Uzbekistan's M&A market
- Target international business owners and investors
- Keep article between 1500-1800 characters
- Complete the article with proper conclusion and footer sections
""",
            "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ãƒ­ã‚·ã‚¢èª)": """
ã€Ğ ÑƒÑÑĞºĞ¾ÑĞ·Ñ‹Ñ‡Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ğ¾ÑĞ¾Ğ±ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸ã€‘
- ĞŸĞ¸ÑˆĞ¸Ñ‚Ğµ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼ ÑĞ·Ñ‹ĞºĞµ
- Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ Ğ´ĞµĞ»Ğ¾Ğ²Ğ¾Ğ¹ Ñ€ÑƒÑÑĞºĞ¸Ğ¹ ÑĞ·Ñ‹Ğº
- Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¸ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹
- ĞĞºÑ†ĞµĞ½Ñ‚ Ğ½Ğ° Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑÑ… ÑĞ»Ğ¸ÑĞ½Ğ¸Ğ¹ Ğ¸ Ğ¿Ğ¾Ğ³Ğ»Ğ¾Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ² Ğ£Ğ·Ğ±ĞµĞºĞ¸ÑÑ‚Ğ°Ğ½Ğµ
- Ğ¦ĞµĞ»ĞµĞ²Ğ°Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ñ - Ñ€ÑƒÑÑĞºĞ¾ÑĞ·Ñ‹Ñ‡Ğ½Ñ‹Ğµ Ğ¸Ğ½Ğ²ĞµÑÑ‚Ğ¾Ñ€Ñ‹
- ĞĞ±ÑŠÑ‘Ğ¼ ÑÑ‚Ğ°Ñ‚ÑŒĞ¸: 1500-1800 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
- Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞ¸Ñ‚Ğµ ÑÑ‚Ğ°Ñ‚ÑŒÑ Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ñ‹Ğ¼ Ğ·Ğ°ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ĞµĞ¼
"""
        }
        return prompts.get(language, prompts["æ—¥æœ¬èª"])
    
    def _extract_text_preview(self, html_content: str) -> str:
        """HTMLã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŠ½å‡º"""
        import re
        # HTMLã‚¿ã‚°ã‚’é™¤å»
        text = re.sub(r'<[^>]+>', ' ', html_content)
        # é€£ç¶šã™ã‚‹ç©ºç™½ã‚’å˜ä¸€ã‚¹ãƒšãƒ¼ã‚¹ã«
        text = re.sub(r'\s+', ' ', text)
        # å…ˆé ­200æ–‡å­—ã‚’è¿”ã™
        return text.strip()[:200] + "..." if len(text) > 200 else text
    
    def _parse_task_requirements(self, description: str) -> Dict[str, str]:
        """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰è¦ä»¶ã‚’æŠ½å‡ºï¼ˆæ—¥æœ¬èªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç‰ˆï¼‰"""
        import re
        
        # URLã‚’æŠ½å‡º
        url_match = re.search(r'https?://[^\s]+', description)
        url = url_match.group(0) if url_match else ""
        
        # === è¨€èªæ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæ—¥æœ¬èªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæˆ¦ç•¥ï¼‰ ===
        # åŸºæœ¬æ–¹é‡: æ˜ç¤ºçš„ãªæŒ‡å®šãŒãªã„é™ã‚Šã€å¸¸ã«æ—¥æœ¬èªã§ç”Ÿæˆ
        language = "æ—¥æœ¬èª"  # çµ¶å¯¾çš„ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        
        # æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆéå¸¸ã«å³æ ¼ã«ï¼‰
        explicit_lang_patterns = {
            "English": [
                r'è‹±èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'write in english',
                r'in english(?:\s+language)?',
                r'create.*in english',
                r'è¨€èª[ï¼š:]\s*(?:è‹±èª|English)'
            ],
            "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ãƒ­ã‚·ã‚¢èª)": [
                r'ãƒ­ã‚·ã‚¢èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'Ğ½Ğ° Ñ€ÑƒÑÑĞºĞ¾Ğ¼(?:\s+ÑĞ·Ñ‹ĞºĞµ)?',
                r'in russian',
                r'è¨€èª[ï¼š:]\s*(?:ãƒ­ã‚·ã‚¢èª|Ñ€ÑƒÑÑĞºĞ¸Ğ¹)'
            ],
            "ä¸­æ–‡": [
                r'ä¸­å›½èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'ä¸­æ–‡ã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'in chinese',
                r'ç”¨ä¸­æ–‡',
                r'è¨€èª[ï¼š:]\s*(?:ä¸­å›½èª|ä¸­æ–‡|Chinese)'
            ],
            "í•œêµ­ì–´": [
                r'éŸ“å›½èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'í•œêµ­ì–´ë¡œ',
                r'in korean',
                r'è¨€èª[ï¼š:]\s*(?:éŸ“å›½èª|í•œêµ­ì–´)'
            ],
            "TÃ¼rkÃ§e": [
                r'ãƒˆãƒ«ã‚³èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'tÃ¼rkÃ§e(?:\'de)?',
                r'in turkish',
                r'è¨€èª[ï¼š:]\s*(?:ãƒˆãƒ«ã‚³èª|TÃ¼rkÃ§e)'
            ],
            "O'zbek": [
                r'ã‚¦ã‚ºãƒ™ã‚¯èªã§(?:ä½œæˆ|è¨˜äº‹|åŸ·ç­†|æ›¸)',
                r'o\'zbek tilida',
                r'in uzbek',
                r'è¨€èª[ï¼š:]\s*(?:ã‚¦ã‚ºãƒ™ã‚¯èª|O\'zbek)'
            ]
        }
        
        # æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šã‚’ãƒã‚§ãƒƒã‚¯
        explicit_lang_found = False
        for lang, patterns in explicit_lang_patterns.items():
            for pattern in patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    language = lang
                    explicit_lang_found = True
                    logger.info(f"âœ… æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šã‚’æ¤œå‡º: {language}")
                    logger.info(f"   ãƒãƒƒãƒã—ãŸãƒ‘ã‚¿ãƒ¼ãƒ³: {pattern}")
                    break
            if explicit_lang_found:
                break
        
        # æ˜ç¤ºçš„ãªæŒ‡å®šãŒãªã‹ã£ãŸå ´åˆ
        if not explicit_lang_found:
            logger.info("ğŸ“Œ æ˜ç¤ºçš„ãªè¨€èªæŒ‡å®šãªã— â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ—¥æœ¬èªã‚’ä½¿ç”¨")
            
            # è£œåŠ©çš„ãªåˆ¤å®šï¼ˆæ¥µç«¯ãªã‚±ãƒ¼ã‚¹ã®ã¿ï¼‰
            # ã‚­ãƒªãƒ«æ–‡å­—ãŒå¤§åŠã‚’å ã‚ã‚‹å ´åˆã®ã¿ãƒ­ã‚·ã‚¢èªã¨åˆ¤å®š
            cyrillic_count = len(re.findall(r'[Ğ-Ğ¯Ğ°-ÑĞÑ‘]', description))
            total_chars = len(re.sub(r'\s', '', description))
            
            # ãƒãƒ³ã‚°ãƒ«ãŒå¤§åŠã‚’å ã‚ã‚‹å ´åˆã®ã¿éŸ“å›½èªã¨åˆ¤å®š
            hangul_count = len(re.findall(r'[ê°€-í£]', description))
            
            if total_chars > 0:
                if cyrillic_count > total_chars * 0.3:  # 30%ä»¥ä¸ŠãŒã‚­ãƒªãƒ«æ–‡å­—
                    language = "Ğ ÑƒÑÑĞºĞ¸Ğ¹ (ãƒ­ã‚·ã‚¢èª)"
                    logger.info(f"ğŸ” ã‚­ãƒªãƒ«æ–‡å­—ãŒå¤šæ•°ï¼ˆ{cyrillic_count}/{total_chars}ï¼‰: ãƒ­ã‚·ã‚¢èª")
                elif hangul_count > total_chars * 0.3:  # 30%ä»¥ä¸ŠãŒãƒãƒ³ã‚°ãƒ«
                    language = "í•œêµ­ì–´"
                    logger.info(f"ğŸ” ãƒãƒ³ã‚°ãƒ«ãŒå¤šæ•°ï¼ˆ{hangul_count}/{total_chars}ï¼‰: éŸ“å›½èª")
                else:
                    # ãã‚Œä»¥å¤–ã¯å…¨ã¦æ—¥æœ¬èªï¼ˆã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠãƒ»æ¼¢å­—ãƒ»è‹±æ•°å­—æ··åœ¨å«ã‚€ï¼‰
                    logger.info("ğŸ“ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨€èªç¢ºå®š: æ—¥æœ¬èª")
        
        # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…ã‚’æŠ½å‡º
        target_patterns = [
            r'(.+?)å‘ã‘ã«',
            r'(.+?)å‘ã‘ã®',
            r'ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ[ï¼š:]\s*(.+)',
            r'for (.+?) considering',
            r'Ğ´Ğ»Ñ (.+?),',
            r'å¯¾è±¡èª­è€…[ï¼š:]\s*(.+)'
        ]
        target_audience = ""
        for pattern in target_patterns:
            match = re.search(pattern, description)
            if match:
                target_audience = match.group(1).strip()
                break
        
        if not target_audience:
            target_audience = "ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aã«èˆˆå‘³ãŒã‚ã‚‹ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼"
        
        # ç‰¹åˆ¥ãªè¦ä»¶ã‚’æŠ½å‡º
        requirements = []
        if 'æ§‹é€ åŒ–' in description or 'HTML' in description.upper():
            requirements.append("æ§‹é€ åŒ–HTMLå½¢å¼ã§å‡ºåŠ›")
        if 'ãƒ‡ãƒ¼ã‚¿' in description or 'æ•°å­—' in description:
            requirements.append("å…·ä½“çš„ãªãƒ‡ãƒ¼ã‚¿ã¨æ•°å­—ã‚’å«ã‚ã‚‹")
        if 'äº‹ä¾‹' in description or 'ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£' in description:
            requirements.append("å®Ÿéš›ã®äº‹ä¾‹ã‚„ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£ã‚’å«ã‚ã‚‹")
        
        logger.info(f"ğŸ“ æœ€çµ‚æ±ºå®šè¨€èª: {language}")
        logger.info(f"ğŸ¯ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…: {target_audience}")
        
        def _get_translation_prompt(self, source_language: str, target_language: str) -> str:
            """ç¿»è¨³ã‚¿ã‚¹ã‚¯ç”¨ã®è¿½åŠ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ"""
            return f"""
        ã€ç¿»è¨³ã‚¿ã‚¹ã‚¯ã®æŒ‡ç¤ºã€‘
        ã“ã‚Œã¯ç¿»è¨³ã‚¿ã‚¹ã‚¯ã§ã™ã€‚ä»¥ä¸‹ã®æŒ‡ç¤ºã«å³å¯†ã«å¾“ã£ã¦ãã ã•ã„ï¼š

        1. å…ƒã®è¨˜äº‹ã®å†…å®¹ã‚’{target_language}ã«æ­£ç¢ºã«ç¿»è¨³
        2. HTMLæ§‹é€ ã¨ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç¶­æŒ
        3. æ–‡åŒ–çš„ãªé•ã„ã‚’è€ƒæ…®ã—ãŸè‡ªç„¶ãªè¡¨ç¾ã‚’ä½¿ç”¨
        4. å°‚é–€ç”¨èªã¯æ­£ç¢ºã«ç¿»è¨³
        5. æ•°å­—ã‚„ãƒ‡ãƒ¼ã‚¿ã¯ãã®ã¾ã¾ä¿æŒ

        ç¿»è¨³å…ƒè¨€èª: {source_language}
        ç¿»è¨³å…ˆè¨€èª: {target_language}

        **é‡è¦: ç¿»è¨³å¾Œã®è¨˜äº‹ã¯å®Œå…¨ãªHTMLå½¢å¼ã§ã€å¿…ãš</article>ã‚¿ã‚°ã§çµ‚äº†ã™ã‚‹ã“ã¨**
        """
        
        return {
            'url': url,
            'language': language,
            'target_audience': target_audience,
            'requirements': 'ã€'.join(requirements) if requirements else "æ¨™æº–çš„ãªæ§‹é€ åŒ–è¨˜äº‹"
        }

#data_models.py
"""
data_models.py - è‡ªå¾‹å‹ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©
ErrorContextModelã¨ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã®æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
"""

from pydantic import BaseModel, Field, validator
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum


class ErrorSeverity(str, Enum):
    """ã‚¨ãƒ©ãƒ¼æ·±åˆ»åº¦"""
    CRITICAL = "critical"  # ã‚·ã‚¹ãƒ†ãƒ åœæ­¢ãƒ¬ãƒ™ãƒ«
    HIGH = "high"         # æ©Ÿèƒ½ä¸å…¨
    MEDIUM = "medium"     # éƒ¨åˆ†çš„ãªå•é¡Œ
    LOW = "low"          # è»½å¾®ãªå•é¡Œ


class ErrorCategory(str, Enum):
    """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª"""
    IMPORT_ERROR = "import_error"
    ATTRIBUTE_ERROR = "attribute_error"
    TYPE_ERROR = "type_error"
    SYNTAX_ERROR = "syntax_error"
    WP_CLI_ERROR = "wp_cli_error"
    ACF_ERROR = "acf_error"
    RUNTIME_ERROR = "runtime_error"
    UNKNOWN = "unknown"


class CodeLocation(BaseModel):
    """ã‚³ãƒ¼ãƒ‰ã®ä½ç½®æƒ…å ±"""
    file_path: str = Field(..., description="ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹")
    line_number: int = Field(..., description="ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿè¡Œç•ªå·")
    function_name: Optional[str] = Field(None, description="é–¢æ•°å")
    class_name: Optional[str] = Field(None, description="ã‚¯ãƒ©ã‚¹å")
    
    @validator('line_number')
    def validate_line_number(cls, v):
        if v < 1:
            raise ValueError("è¡Œç•ªå·ã¯1ä»¥ä¸Šã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        return v


class StackTraceFrame(BaseModel):
    """ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã®ãƒ•ãƒ¬ãƒ¼ãƒ æƒ…å ±"""
    file_path: str = Field(..., description="ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹")
    line_number: int = Field(..., description="è¡Œç•ªå·")
    function_name: str = Field(..., description="é–¢æ•°å")
    code_context: Optional[str] = Field(None, description="ã‚³ãƒ¼ãƒ‰æ–‡è„ˆ(å‰å¾Œ3è¡Œ)")


class ErrorContextModel(BaseModel):
    """
    ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ - AIä¿®æ­£ã«å¿…è¦ãªå…¨æƒ…å ±ã‚’æ§‹é€ åŒ–
    
    ã“ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼ã®è©³ç´°æƒ…å ±ã‚’ä¿æŒã—ã€
    AIãŒé©åˆ‡ãªä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®å…¥åŠ›ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹
    """
    
    # åŸºæœ¬æƒ…å ±
    error_id: str = Field(..., description="ã‚¨ãƒ©ãƒ¼ID (task_id + timestamp)")
    timestamp: datetime = Field(default_factory=datetime.now, description="ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚åˆ»")
    task_id: str = Field(..., description="å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯ID")
    agent_name: Optional[str] = Field(None, description="å®Ÿè¡Œä¸­ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå")
    
    # ã‚¨ãƒ©ãƒ¼åˆ†é¡
    error_type: str = Field(..., description="Pythonã‚¨ãƒ©ãƒ¼å‹å (AttributeErrorç­‰)")
    error_category: ErrorCategory = Field(ErrorCategory.UNKNOWN, description="ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª")
    severity: ErrorSeverity = Field(ErrorSeverity.MEDIUM, description="æ·±åˆ»åº¦")
    
    # ã‚¨ãƒ©ãƒ¼è©³ç´°
    error_message: str = Field(..., description="ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
    full_traceback: str = Field(..., description="å®Œå…¨ãªã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹")
    stack_frames: List[StackTraceFrame] = Field(default_factory=list, description="æ§‹é€ åŒ–ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹")
    
    # ã‚³ãƒ¼ãƒ‰æƒ…å ±
    error_location: Optional[CodeLocation] = Field(None, description="ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿä½ç½®")
    problematic_code: Optional[str] = Field(None, description="å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆ")
    surrounding_code: Optional[str] = Field(None, description="å‘¨è¾ºã‚³ãƒ¼ãƒ‰(å‰å¾Œ10è¡Œ)")
    
    # å®Ÿè¡Œã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    local_variables: Dict[str, Any] = Field(default_factory=dict, description="ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®çŠ¶æ…‹")
    global_variables: Dict[str, Any] = Field(default_factory=dict, description="ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã®çŠ¶æ…‹")
    function_arguments: Optional[Dict[str, Any]] = Field(None, description="é–¢æ•°ã®å¼•æ•°")
    
    # ã‚¿ã‚¹ã‚¯æƒ…å ±
    task_description: Optional[str] = Field(None, description="ã‚¿ã‚¹ã‚¯èª¬æ˜")
    task_parameters: Optional[Dict[str, Any]] = Field(None, description="ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿")
    
    # WordPress/ACFå›ºæœ‰æƒ…å ±
    wp_context: Optional[Dict[str, Any]] = Field(None, description="WordPressã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ")
    acf_info: Optional[Dict[str, Any]] = Field(None, description="ACFæƒ…å ±")
    
    # ä¿®æ­£è©¦è¡Œå±¥æ­´
    previous_fix_attempts: List[Dict[str, Any]] = Field(default_factory=list, description="éå»ã®ä¿®æ­£è©¦è¡Œ")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
    
    @validator('error_category', pre=True, always=True)
    def categorize_error(cls, v, values):
        """ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã‹ã‚‰è‡ªå‹•çš„ã«ã‚«ãƒ†ã‚´ãƒªã‚’åˆ¤å®š"""
        if v != ErrorCategory.UNKNOWN:
            return v
        
        error_type = values.get('error_type', '').lower()
        error_message = values.get('error_message', '').lower()
        
        if 'import' in error_type or 'modulenotfound' in error_type:
            return ErrorCategory.IMPORT_ERROR
        elif 'attributeerror' in error_type:
            return ErrorCategory.ATTRIBUTE_ERROR
        elif 'typeerror' in error_type:
            return ErrorCategory.TYPE_ERROR
        elif 'syntaxerror' in error_type:
            return ErrorCategory.SYNTAX_ERROR
        elif 'wp-cli' in error_message or 'wordpress' in error_message:
            return ErrorCategory.WP_CLI_ERROR
        elif 'acf' in error_message:
            return ErrorCategory.ACF_ERROR
        else:
            return ErrorCategory.RUNTIME_ERROR


class BugFixTask(BaseModel):
    """
    ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ - è‡ªå¾‹ä¿®æ­£ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ã‚¿ã‚¹ã‚¯å®šç¾©
    """
    
    task_id: str = Field(..., description="ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ID (FIX_BUG_xxx)")
    original_task_id: str = Field(..., description="å…ƒã®ã‚¿ã‚¹ã‚¯ID")
    error_context: ErrorContextModel = Field(..., description="ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ")
    
    # ã‚¿ã‚¹ã‚¯è¨­å®š
    priority: str = Field("critical", description="å„ªå…ˆåº¦ (critical/high/medium/low)")
    required_role: str = Field("quick_fix", description="å¿…è¦ãªå½¹å‰²")
    
    # ä¿®æ­£æˆ¦ç•¥
    fix_strategy: Optional[str] = Field(None, description="ä¿®æ­£æˆ¦ç•¥ (patch/rewrite/refactor)")
    target_files: List[str] = Field(default_factory=list, description="ä¿®æ­£å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«")
    
    # AIç”Ÿæˆç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    fix_prompt: Optional[str] = Field(None, description="AIä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ")
    
    # æ¤œè¨¼è¦ä»¶
    test_command: Optional[str] = Field(None, description="ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰")
    expected_outcome: Optional[str] = Field(None, description="æœŸå¾…ã•ã‚Œã‚‹çµæœ")
    
    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç®¡ç†
    status: str = Field("pending", description="ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ (pending/in_progress/testing/success/failed)")
    created_at: datetime = Field(default_factory=datetime.now, description="ä½œæˆæ—¥æ™‚")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class FixResult(BaseModel):
    """ä¿®æ­£çµæœãƒ¢ãƒ‡ãƒ«"""
    
    task_id: str = Field(..., description="ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ID")
    success: bool = Field(..., description="ä¿®æ­£æˆåŠŸãƒ•ãƒ©ã‚°")
    
    # ä¿®æ­£å†…å®¹
    modified_files: List[str] = Field(default_factory=list, description="ä¿®æ­£ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«")
    generated_code: Optional[str] = Field(None, description="AIç”Ÿæˆã‚³ãƒ¼ãƒ‰")
    patch_content: Optional[str] = Field(None, description="ãƒ‘ãƒƒãƒå†…å®¹(Diffå½¢å¼)")
    
    # ãƒ†ã‚¹ãƒˆçµæœ
    test_passed: bool = Field(False, description="ãƒ†ã‚¹ãƒˆæˆåŠŸ")
    test_output: Optional[str] = Field(None, description="ãƒ†ã‚¹ãƒˆå‡ºåŠ›")
    test_errors: List[str] = Field(default_factory=list, description="ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼")
    
    # GitHubé€£æºæƒ…å ±
    branch_name: Optional[str] = Field(None, description="ä½œæˆã•ã‚ŒãŸãƒ–ãƒ©ãƒ³ãƒå")
    commit_hash: Optional[str] = Field(None, description="ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥")
    pr_number: Optional[int] = Field(None, description="ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆç•ªå·")
    pr_url: Optional[str] = Field(None, description="ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆURL")
    
    # ãƒ¡ã‚¿æƒ…å ±
    execution_time: float = Field(..., description="å®Ÿè¡Œæ™‚é–“(ç§’)")
    completed_at: datetime = Field(default_factory=datetime.now, description="å®Œäº†æ—¥æ™‚")
    error_message: Optional[str] = Field(None, description="ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸(å¤±æ•—æ™‚)")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


class TestCaseModel(BaseModel):
    """è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãƒ¢ãƒ‡ãƒ«"""
    
    test_id: str = Field(..., description="ãƒ†ã‚¹ãƒˆID")
    test_name: str = Field(..., description="ãƒ†ã‚¹ãƒˆå")
    test_type: str = Field(..., description="ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ— (unit/integration/e2e)")
    
    # ãƒ†ã‚¹ãƒˆå®šç¾©
    test_command: str = Field(..., description="ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰")
    test_file: Optional[str] = Field(None, description="ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹")
    test_function: Optional[str] = Field(None, description="ãƒ†ã‚¹ãƒˆé–¢æ•°å")
    
    # æœŸå¾…å€¤
    expected_return_code: int = Field(0, description="æœŸå¾…ã•ã‚Œã‚‹ãƒªã‚¿ãƒ¼ãƒ³ã‚³ãƒ¼ãƒ‰")
    expected_output_pattern: Optional[str] = Field(None, description="æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ãƒ‘ã‚¿ãƒ¼ãƒ³(æ­£è¦è¡¨ç¾)")
    forbidden_patterns: List[str] = Field(default_factory=list, description="ç¦æ­¢ãƒ‘ã‚¿ãƒ¼ãƒ³(ã‚¨ãƒ©ãƒ¼æ–‡å­—åˆ—)")
    
    # å®Ÿè¡Œçµæœ
    last_run: Optional[datetime] = Field(None, description="æœ€çµ‚å®Ÿè¡Œæ—¥æ™‚")
    last_result: Optional[bool] = Field(None, description="æœ€çµ‚çµæœ")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

#data_models_extended.py
# data_models.py
"""
ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©ï¼ˆæ‹¡å¼µç‰ˆï¼‰
ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰è‡ªå¾‹ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ç”¨
"""

from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field


# ========================================
# Enumå®šç¾©
# ========================================

class ErrorSeverity(str, Enum):
    """ã‚¨ãƒ©ãƒ¼æ·±åˆ»åº¦"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ErrorCategory(str, Enum):
    """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª"""
    SYNTAX = "syntax"
    IMPORT = "import"
    RUNTIME = "runtime"
    LOGIC = "logic"
    DESIGN = "design"
    PERFORMANCE = "performance"
    SECURITY = "security"
    UNKNOWN = "unknown"


class TaskStatus(str, Enum):
    """ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class FixStrategy(str, Enum):
    """ä¿®æ­£æˆ¦ç•¥"""
    LOCAL_ONLY = "local_only"
    CLOUD_ONLY = "cloud_only"
    LOCAL_FIRST = "local_first"
    CLOUD_FIRST = "cloud_first"
    PARALLEL = "parallel"
    ADAPTIVE = "adaptive"


# ========================================
# ã‚¨ãƒ©ãƒ¼é–¢é€£ãƒ¢ãƒ‡ãƒ«
# ========================================

class ErrorContextModel(BaseModel):
    """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ"""
    error_type: str = Field(..., description="ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—")
    error_message: str = Field(..., description="ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
    severity: ErrorSeverity = Field(ErrorSeverity.MEDIUM, description="æ·±åˆ»åº¦")
    error_category: ErrorCategory = Field(ErrorCategory.UNKNOWN, description="ã‚«ãƒ†ã‚´ãƒª")
    
    file_path: Optional[str] = Field(None, description="ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿãƒ•ã‚¡ã‚¤ãƒ«")
    line_number: Optional[int] = Field(None, description="è¡Œç•ªå·")
    
    full_traceback: Optional[str] = Field(None, description="å®Œå…¨ãªãƒˆãƒ¬ãƒ¼ã‚¹ãƒãƒƒã‚¯")
    surrounding_code: Optional[str] = Field(None, description="å‘¨è¾ºã‚³ãƒ¼ãƒ‰")
    local_variables: Optional[Dict[str, Any]] = Field(None, description="ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°")
    
    context_info: Optional[Dict[str, Any]] = Field(None, description="è¿½åŠ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ")
    timestamp: datetime = Field(default_factory=datetime.now, description="ç™ºç”Ÿæ™‚åˆ»")
    
    class Config:
        json_schema_extra = {
            "example": {
                "error_type": "AttributeError",
                "error_message": "'NoneType' object has no attribute 'get'",
                "severity": "high",
                "error_category": "runtime",
                "file_path": "wp_agent.py",
                "line_number": 42
            }
        }


class ErrorClassification(BaseModel):
    """ã‚¨ãƒ©ãƒ¼åˆ†é¡çµæœ"""
    error_type: str
    category: str
    complexity: str
    complexity_score: float
    confidence: float
    recommended_strategy: str
    factors: List[str] = Field(default_factory=list)


# ========================================
# ã‚¿ã‚¹ã‚¯é–¢é€£ãƒ¢ãƒ‡ãƒ«
# ========================================

class BugFixTask(BaseModel):
    """ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯"""
    task_id: str = Field(..., description="ã‚¿ã‚¹ã‚¯ID")
    error_context: ErrorContextModel = Field(..., description="ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ")
    target_files: List[str] = Field(default_factory=list, description="å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«")
    
    priority: int = Field(5, description="å„ªå…ˆåº¦ï¼ˆ1-10ï¼‰")
    run_tests: bool = Field(True, description="ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ•ãƒ©ã‚°")
    create_pr: bool = Field(False, description="PRä½œæˆãƒ•ãƒ©ã‚°")
    
    fix_strategy: Optional[FixStrategy] = Field(None, description="ä¿®æ­£æˆ¦ç•¥")
    timeout: int = Field(300, description="ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆç§’ï¼‰")
    
    metadata: Dict[str, Any] = Field(default_factory=dict, description="ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿")
    created_at: datetime = Field(default_factory=datetime.now)
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "Task-54-Fix",
                "target_files": ["wp_agent.py"],
                "priority": 8,
                "run_tests": True
            }
        }


class Task(BaseModel):
    """æ±ç”¨ã‚¿ã‚¹ã‚¯"""
    task_id: str
    task_type: str
    description: str
    status: TaskStatus = TaskStatus.PENDING
    
    priority: int = 5
    assigned_agent: Optional[str] = None
    
    dependencies: List[str] = Field(default_factory=list)
    parameters: Dict[str, Any] = Field(default_factory=dict)
    
    created_at: datetime = Field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


# ========================================
# ä¿®æ­£çµæœé–¢é€£ãƒ¢ãƒ‡ãƒ«
# ========================================

class FixResult(BaseModel):
    """ä¿®æ­£çµæœ"""
    task_id: str = Field(..., description="ã‚¿ã‚¹ã‚¯ID")
    success: bool = Field(..., description="æˆåŠŸãƒ•ãƒ©ã‚°")
    
    modified_files: List[str] = Field(default_factory=list, description="ä¿®æ­£ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«")
    generated_code: str = Field("", description="ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰")
    
    test_passed: bool = Field(False, description="ãƒ†ã‚¹ãƒˆåˆæ ¼ãƒ•ãƒ©ã‚°")
    execution_time: float = Field(0.0, description="å®Ÿè¡Œæ™‚é–“ï¼ˆç§’ï¼‰")
    
    confidence_score: float = Field(0.0, description="ä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢ï¼ˆ0-1ï¼‰")
    reasoning: str = Field("", description="ä¿®æ­£ç†ç”±")
    
    backup_path: Optional[str] = Field(None, description="ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‘ã‚¹")
    pr_url: Optional[str] = Field(None, description="ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆURL")
    
    error_message: Optional[str] = Field(None, description="ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸")
    warnings: List[str] = Field(default_factory=list, description="è­¦å‘Šãƒªã‚¹ãƒˆ")
    
    metadata: Dict[str, Any] = Field(default_factory=dict, description="ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿")
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæƒ…å ±
    agent_used: Optional[str] = Field(None, description="ä½¿ç”¨ã•ã‚ŒãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ")
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "Task-54-Fix",
                "success": True,
                "modified_files": ["wp_agent.py"],
                "test_passed": True,
                "execution_time": 12.5,
                "confidence_score": 0.92
            }
        }


class TestResult(BaseModel):
    """ãƒ†ã‚¹ãƒˆçµæœ"""
    task_id: str
    passed: bool
    
    total_tests: int = 0
    passed_tests: int = 0
    failed_tests: int = 0
    skipped_tests: int = 0
    
    execution_time: float = 0.0
    
    test_details: List[Dict[str, Any]] = Field(default_factory=list)
    error: Optional[str] = None
    
    timestamp: datetime = Field(default_factory=datetime.now)


# ========================================
# Git/GitHubé–¢é€£ãƒ¢ãƒ‡ãƒ«
# ========================================

class CommitInfo(BaseModel):
    """ã‚³ãƒŸãƒƒãƒˆæƒ…å ±"""
    commit_hash: str
    branch_name: str
    commit_message: str
    author: str = "AutoFixAgent"
    timestamp: datetime = Field(default_factory=datetime.now)
    
    modified_files: List[str] = Field(default_factory=list)


class PullRequestInfo(BaseModel):
    """ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±"""
    pr_number: Optional[int] = None
    pr_url: str
    title: str
    body: str
    
    base_branch: str = "main"
    head_branch: str
    
    status: str = "open"
    created_at: datetime = Field(default_factory=datetime.now)


# ========================================
# çµ±è¨ˆæƒ…å ±ãƒ¢ãƒ‡ãƒ«
# ========================================

class AgentStats(BaseModel):
    """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±è¨ˆæƒ…å ±"""
    agent_name: str
    
    total_tasks: int = 0
    successful_tasks: int = 0
    failed_tasks: int = 0
    
    total_execution_time: float = 0.0
    average_execution_time: float = 0.0
    
    success_rate: float = 0.0
    
    additional_metrics: Dict[str, Any] = Field(default_factory=dict)
    last_updated: datetime = Field(default_factory=datetime.now)


class SystemStats(BaseModel):
    """ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®çµ±è¨ˆ"""
    total_fixes: int = 0
    successful_fixes: int = 0
    failed_fixes: int = 0
    
    local_fixes: int = 0
    cloud_fixes: int = 0
    hybrid_fixes: int = 0
    
    total_tests: int = 0
    passed_tests: int = 0
    
    total_prs: int = 0
    merged_prs: int = 0
    
    uptime_seconds: float = 0.0
    
    agent_stats: Dict[str, AgentStats] = Field(default_factory=dict)
    
    last_updated: datetime = Field(default_factory=datetime.now)


# ========================================
# AIå¿œç­”ãƒ¢ãƒ‡ãƒ«
# ========================================

class AIFixResponse(BaseModel):
    """AIä¿®æ­£å¿œç­”"""
    analysis: str = Field(..., description="ã‚¨ãƒ©ãƒ¼åˆ†æ")
    root_cause: str = Field(..., description="æ ¹æœ¬åŸå› ")
    fix_strategy: str = Field(..., description="ä¿®æ­£æˆ¦ç•¥")
    
    modified_files: Dict[str, str] = Field(..., description="ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: ã‚³ãƒ¼ãƒ‰")
    
    confidence: float = Field(..., ge=0.0, le=1.0, description="ä¿¡é ¼åº¦")
    reasoning: str = Field(..., description="ä¿®æ­£ç†ç”±")
    
    test_suggestions: List[str] = Field(default_factory=list)
    potential_side_effects: List[str] = Field(default_factory=list)
    
    class Config:
        json_schema_extra = {
            "example": {
                "analysis": "AttributeError due to None value",
                "root_cause": "Missing null check",
                "fix_strategy": "Add defensive programming",
                "modified_files": {
                    "wp_agent.py": "def method():\n    if obj is not None:\n        ..."
                },
                "confidence": 0.95,
                "reasoning": "Added null check to prevent AttributeError"
            }
        }


# ========================================
# è¨­å®šãƒ¢ãƒ‡ãƒ«
# ========================================

class HybridFixConfig(BaseModel):
    """ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£è¨­å®š"""
    default_strategy: FixStrategy = FixStrategy.ADAPTIVE
    
    local_timeout: int = 30
    cloud_timeout: int = 120
    
    enable_auto_tests: bool = True
    enable_auto_pr: bool = False
    
    max_retry_count: int = 3
    
    cloud_provider: str = "openai"
    cloud_model: str = "gpt-4o"
    
    github_auto_merge: bool = False
    
    backup_retention_days: int = 30


# ========================================
# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
# ========================================

def create_bug_fix_task_from_exception(
    task_id: str,
    exception: Exception,
    file_path: str,
    line_number: int,
    **kwargs
) -> BugFixTask:
    """ä¾‹å¤–ã‹ã‚‰ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ"""
    import traceback
    
    error_context = ErrorContextModel(
        error_type=type(exception).__name__,
        error_message=str(exception),
        file_path=file_path,
        line_number=line_number,
        full_traceback=traceback.format_exc(),
        **kwargs
    )
    
    return BugFixTask(
        task_id=task_id,
        error_context=error_context,
        target_files=[file_path]
    )


def create_fix_result_success(
    task_id: str,
    modified_files: List[str],
    generated_code: str,
    **kwargs
) -> FixResult:
    """æˆåŠŸçµæœã‚’ä½œæˆ"""
    return FixResult(
        task_id=task_id,
        success=True,
        modified_files=modified_files,
        generated_code=generated_code,
        test_passed=True,
        **kwargs
    )


def create_fix_result_failure(
    task_id: str,
    error_message: str,
    **kwargs
) -> FixResult:
    """å¤±æ•—çµæœã‚’ä½œæˆ"""
    return FixResult(
        task_id=task_id,
        success=False,
        error_message=error_message,
        **kwargs
    )

#dependency_resolver.py
"""
DependencyResolver - ä¾å­˜é–¢ä¿‚è§£æ±ºã¨ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä¾å­˜é–¢ä¿‚ã®åˆ†æã€ç«¶åˆã®æ¤œå‡ºã¨è§£æ±ºã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§ãƒã‚§ãƒƒã‚¯ã€
è‡ªå‹•ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆææ¡ˆã€ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•ã®ç”Ÿæˆã‚’æä¾›ã™ã‚‹ã€‚
"""

import subprocess
import json
import re
from pathlib import Path
from typing import Dict, Any, List, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class DependencyStatus(Enum):
    """ä¾å­˜é–¢ä¿‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"""
    SATISFIED = "satisfied"
    MISSING = "missing"
    OUTDATED = "outdated"
    CONFLICT = "conflict"
    INCOMPATIBLE = "incompatible"


@dataclass
class Package:
    """ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±"""
    name: str
    installed_version: Optional[str] = None
    required_version: Optional[str] = None
    latest_version: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "installed_version": self.installed_version,
            "required_version": self.required_version,
            "latest_version": self.latest_version,
            "dependencies": self.dependencies
        }


@dataclass
class DependencyIssue:
    """ä¾å­˜é–¢ä¿‚ã®å•é¡Œ"""
    status: DependencyStatus
    package: Package
    description: str
    resolution: Optional[str] = None
    severity: str = "medium"  # low, medium, high, critical
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "status": self.status.value,
            "package": self.package.to_dict(),
            "description": self.description,
            "resolution": self.resolution,
            "severity": self.severity
        }


@dataclass
class DependencyGraph:
    """ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•"""
    nodes: Dict[str, Package]
    edges: List[Tuple[str, str]]  # (from_package, to_package)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "nodes": {name: pkg.to_dict() for name, pkg in self.nodes.items()},
            "edges": [{"from": f, "to": t} for f, t in self.edges]
        }


class DependencyResolverAgent:
    """
    ä¾å­˜é–¢ä¿‚è§£æ±ºã¨ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ä¸»ãªæ©Ÿèƒ½:
    1. ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä¾å­˜é–¢ä¿‚ã®åˆ†æ
    2. ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç«¶åˆã®æ¤œå‡ºã¨è§£æ±º
    3. ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
    4. è‡ªå‹•ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆææ¡ˆ
    5. ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•ã®ç”Ÿæˆ
    """
    
    def __init__(self, requirements_file: str = "requirements.txt"):
        self.requirements_file = requirements_file
        
        # ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±
        self.packages: Dict[str, Package] = {}
        self.issues: List[DependencyIssue] = []
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_packages": 0,
            "satisfied": 0,
            "missing": 0,
            "outdated": 0,
            "conflicts": 0
        }
        
        logger.info("DependencyResolverAgent initialized")
    
    def analyze_dependencies(self) -> List[DependencyIssue]:
        """
        ä¾å­˜é–¢ä¿‚ã‚’åˆ†æ
        
        Returns:
            æ¤œå‡ºã•ã‚ŒãŸå•é¡Œã®ãƒªã‚¹ãƒˆ
        """
        self.issues = []
        self.packages = {}
        
        # requirements.txtã‚’èª­ã¿è¾¼ã‚€
        required_packages = self._parse_requirements()
        
        # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’å–å¾—
        installed_packages = self._get_installed_packages()
        
        # å„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’åˆ†æ
        for pkg_spec in required_packages:
            pkg_name, version_spec = self._parse_package_spec(pkg_spec)
            
            package = Package(
                name=pkg_name,
                required_version=version_spec
            )
            
            # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«çŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯
            if pkg_name in installed_packages:
                package.installed_version = installed_packages[pkg_name]
                
                # ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§ã‚’ãƒã‚§ãƒƒã‚¯
                if not self._is_version_compatible(
                    package.installed_version,
                    version_spec
                ):
                    issue = DependencyIssue(
                        status=DependencyStatus.INCOMPATIBLE,
                        package=package,
                        description=f"Installed version {package.installed_version} "
                                  f"does not satisfy requirement {version_spec}",
                        resolution=f"pip install {pkg_name}{version_spec}",
                        severity="high"
                    )
                    self.issues.append(issue)
                    self.stats["conflicts"] += 1
                else:
                    self.stats["satisfied"] += 1
            else:
                # ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãŒæœªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
                issue = DependencyIssue(
                    status=DependencyStatus.MISSING,
                    package=package,
                    description=f"Package {pkg_name} is not installed",
                    resolution=f"pip install {pkg_spec}",
                    severity="critical"
                )
                self.issues.append(issue)
                self.stats["missing"] += 1
            
            self.packages[pkg_name] = package
            self.stats["total_packages"] += 1
        
        # æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
        self._check_latest_versions()
        
        # ä¾å­˜é–¢ä¿‚ã®ä¾å­˜ã‚’ãƒã‚§ãƒƒã‚¯
        self._check_transitive_dependencies()
        
        return self.issues
    
    def _parse_requirements(self) -> List[str]:
        """requirements.txtã‚’ãƒ‘ãƒ¼ã‚¹"""
        if not Path(self.requirements_file).exists():
            logger.warning(f"Requirements file not found: {self.requirements_file}")
            return []
        
        requirements = []
        with open(self.requirements_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # ã‚³ãƒ¡ãƒ³ãƒˆã¨ç©ºè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
                if line and not line.startswith('#'):
                    requirements.append(line)
        
        return requirements
    
    def _get_installed_packages(self) -> Dict[str, str]:
        """ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¸€è¦§ã‚’å–å¾—"""
        try:
            result = subprocess.run(
                ['pip', 'list', '--format=json'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                packages_data = json.loads(result.stdout)
                return {
                    pkg['name'].lower(): pkg['version']
                    for pkg in packages_data
                }
        except Exception as e:
            logger.error(f"Failed to get installed packages: {e}")
        
        return {}
    
    def _parse_package_spec(self, spec: str) -> Tuple[str, Optional[str]]:
        """
        ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æŒ‡å®šã‚’ãƒ‘ãƒ¼ã‚¹
        
        ä¾‹: "package==1.0.0" -> ("package", "==1.0.0")
        """
        # ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®šå­ã‚’æŠ½å‡º
        match = re.match(r'^([a-zA-Z0-9_-]+)(.*)$', spec)
        if match:
            name = match.group(1).lower()
            version_spec = match.group(2).strip() if match.group(2) else None
            return name, version_spec
        
        return spec.lower(), None
    
    def _is_version_compatible(self, 
                              installed: str,
                              required: Optional[str]) -> bool:
        """
        ãƒãƒ¼ã‚¸ãƒ§ãƒ³äº’æ›æ€§ã‚’ãƒã‚§ãƒƒã‚¯
        
        ç°¡æ˜“ç‰ˆã®å®Ÿè£…ï¼ˆã‚ˆã‚Šæ­£ç¢ºã«ã¯packaging.specifiersã‚’ä½¿ç”¨ã™ã¹ãï¼‰
        """
        if not required:
            return True
        
        # ==, >=, <=, >, <, != ãªã©ã®æ¼”ç®—å­ã‚’ãƒ‘ãƒ¼ã‚¹
        operators = ['==', '>=', '<=', '>', '<', '!=', '~=']
        
        for op in operators:
            if op in required:
                version = required.replace(op, '').strip()
                return self._compare_versions(installed, version, op)
        
        return True
    
    def _compare_versions(self, v1: str, v2: str, op: str) -> bool:
        """ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ¯”è¼ƒ"""
        try:
            # ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æ•°å€¤ã®ã‚¿ãƒ—ãƒ«ã«å¤‰æ›
            v1_parts = tuple(int(x) for x in v1.split('.'))
            v2_parts = tuple(int(x) for x in v2.split('.'))
            
            if op == '==':
                return v1_parts == v2_parts
            elif op == '>=':
                return v1_parts >= v2_parts
            elif op == '<=':
                return v1_parts <= v2_parts
            elif op == '>':
                return v1_parts > v2_parts
            elif op == '<':
                return v1_parts < v2_parts
            elif op == '!=':
                return v1_parts != v2_parts
            elif op == '~=':
                # Compatible release (PEP 440)
                # ~=1.4.5 ã¯ >=1.4.5, <1.5.0 ã¨åŒç­‰
                return v1_parts >= v2_parts and v1_parts[0] == v2_parts[0]
        except:
            # ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ¯”è¼ƒã«å¤±æ•—ã—ãŸå ´åˆã¯Trueã‚’è¿”ã™
            return True
        
        return True
    
    def _check_latest_versions(self):
        """æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯"""
        for pkg_name, package in self.packages.items():
            if not package.installed_version:
                continue
            
            try:
                # PyPIã‹ã‚‰æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—
                result = subprocess.run(
                    ['pip', 'index', 'versions', pkg_name],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if result.returncode == 0:
                    # å‡ºåŠ›ã‹ã‚‰æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æŠ½å‡º
                    match = re.search(r'Available versions: ([\d.]+)', result.stdout)
                    if match:
                        latest = match.group(1)
                        package.latest_version = latest
                        
                        # ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                        if self._compare_versions(package.installed_version, latest, '<'):
                            issue = DependencyIssue(
                                status=DependencyStatus.OUTDATED,
                                package=package,
                                description=f"Package {pkg_name} can be updated from "
                                          f"{package.installed_version} to {latest}",
                                resolution=f"pip install --upgrade {pkg_name}",
                                severity="low"
                            )
                            self.issues.append(issue)
                            self.stats["outdated"] += 1
            except Exception as e:
                logger.debug(f"Failed to check latest version for {pkg_name}: {e}")
    
    def _check_transitive_dependencies(self):
        """æ¨ç§»çš„ä¾å­˜é–¢ä¿‚ã‚’ãƒã‚§ãƒƒã‚¯"""
        for pkg_name, package in self.packages.items():
            if not package.installed_version:
                continue
            
            try:
                # ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¾å­˜é–¢ä¿‚ã‚’å–å¾—
                result = subprocess.run(
                    ['pip', 'show', pkg_name],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if result.returncode == 0:
                    # Requiresè¡Œã‹ã‚‰ä¾å­˜é–¢ä¿‚ã‚’æŠ½å‡º
                    for line in result.stdout.split('\n'):
                        if line.startswith('Requires:'):
                            deps = line.replace('Requires:', '').strip()
                            if deps:
                                package.dependencies = [
                                    d.strip() for d in deps.split(',')
                                ]
            except Exception as e:
                logger.debug(f"Failed to check dependencies for {pkg_name}: {e}")
    
    def detect_conflicts(self) -> List[DependencyIssue]:
        """ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç«¶åˆã‚’æ¤œå‡º"""
        conflicts = []
        
        # ã™ã¹ã¦ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ä¾å­˜é–¢ä¿‚ã‚’ãƒã‚§ãƒƒã‚¯
        dependency_requirements = {}
        
        for pkg_name, package in self.packages.items():
            for dep in package.dependencies:
                dep_name, dep_version = self._parse_package_spec(dep)
                
                if dep_name not in dependency_requirements:
                    dependency_requirements[dep_name] = []
                
                dependency_requirements[dep_name].append({
                    'required_by': pkg_name,
                    'version_spec': dep_version
                })
        
        # ç«¶åˆã‚’ãƒã‚§ãƒƒã‚¯
        for dep_name, requirements in dependency_requirements.items():
            if len(requirements) > 1:
                # è¤‡æ•°ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¦æ±‚ãŒã‚ã‚‹å ´åˆã€ç«¶åˆã®å¯èƒ½æ€§
                version_specs = [req['version_spec'] for req in requirements]
                if len(set(version_specs)) > 1:
                    package = self.packages.get(dep_name, Package(name=dep_name))
                    
                    issue = DependencyIssue(
                        status=DependencyStatus.CONFLICT,
                        package=package,
                        description=f"Version conflict for {dep_name}: "
                                  f"required by {', '.join(req['required_by'] for req in requirements)} "
                                  f"with different version specs",
                        resolution="Manually resolve version requirements",
                        severity="high"
                    )
                    conflicts.append(issue)
        
        return conflicts
    
    def generate_dependency_graph(self) -> DependencyGraph:
        """ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•ã‚’ç”Ÿæˆ"""
        nodes = {}
        edges = []
        
        for pkg_name, package in self.packages.items():
            nodes[pkg_name] = package
            
            for dep in package.dependencies:
                dep_name, _ = self._parse_package_spec(dep)
                edges.append((pkg_name, dep_name))
        
        return DependencyGraph(nodes=nodes, edges=edges)
    
    def suggest_updates(self) -> List[Dict[str, Any]]:
        """
        ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæ¨å¥¨ã‚’ç”Ÿæˆ
        
        Returns:
            ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæ¨å¥¨ã®ãƒªã‚¹ãƒˆ
        """
        suggestions = []
        
        for issue in self.issues:
            if issue.status == DependencyStatus.OUTDATED:
                pkg = issue.package
                suggestions.append({
                    "package": pkg.name,
                    "current_version": pkg.installed_version,
                    "latest_version": pkg.latest_version,
                    "command": issue.resolution,
                    "priority": self._calculate_update_priority(pkg)
                })
        
        # å„ªå…ˆåº¦ã§ã‚½ãƒ¼ãƒˆ
        suggestions.sort(key=lambda x: x["priority"], reverse=True)
        
        return suggestions
    
    def _calculate_update_priority(self, package: Package) -> int:
        """ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆå„ªå…ˆåº¦ã‚’è¨ˆç®—ï¼ˆ0-100ï¼‰"""
        if not package.installed_version or not package.latest_version:
            return 0
        
        try:
            current_parts = tuple(int(x) for x in package.installed_version.split('.'))
            latest_parts = tuple(int(x) for x in package.latest_version.split('.'))
            
            # ãƒ¡ã‚¸ãƒ£ãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒç•°ãªã‚‹: é«˜å„ªå…ˆåº¦
            if current_parts[0] < latest_parts[0]:
                return 90
            
            # ãƒã‚¤ãƒŠãƒ¼ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒç•°ãªã‚‹: ä¸­å„ªå…ˆåº¦
            if len(current_parts) > 1 and len(latest_parts) > 1:
                if current_parts[1] < latest_parts[1]:
                    return 60
            
            # ãƒ‘ãƒƒãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã¿: ä½å„ªå…ˆåº¦
            return 30
        except:
            return 50  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    
    def generate_report(self) -> Dict[str, Any]:
        """åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ"""
        # é‡å¤§åº¦åˆ¥ã®å•é¡Œ
        by_severity = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": []
        }
        
        for issue in self.issues:
            by_severity[issue.severity].append(issue.to_dict())
        
        # ä¾å­˜é–¢ä¿‚ã‚°ãƒ©ãƒ•
        graph = self.generate_dependency_graph()
        
        return {
            "summary": {
                **self.stats,
                "total_issues": len(self.issues)
            },
            "issues_by_severity": {
                severity: len(issues)
                for severity, issues in by_severity.items()
            },
            "issues": [issue.to_dict() for issue in self.issues],
            "update_suggestions": self.suggest_updates(),
            "dependency_graph": graph.to_dict()
        }
    
    def export_report(self, filepath: str):
        """ãƒ¬ãƒãƒ¼ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        report = self.generate_report()
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Dependency report exported to {filepath}")
    
    def auto_fix_issues(self, 
                       fix_missing: bool = True,
                       fix_outdated: bool = False) -> List[str]:
        """
        å•é¡Œã‚’è‡ªå‹•ä¿®æ­£
        
        Args:
            fix_missing: æ¬ è½ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
            fix_outdated: å¤ã„ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ
        
        Returns:
            å®Ÿè¡Œã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰ã®ãƒªã‚¹ãƒˆ
        """
        executed_commands = []
        
        for issue in self.issues:
            if not issue.resolution:
                continue
            
            should_fix = False
            
            if fix_missing and issue.status == DependencyStatus.MISSING:
                should_fix = True
            elif fix_outdated and issue.status == DependencyStatus.OUTDATED:
                should_fix = True
            
            if should_fix:
                try:
                    logger.info(f"Executing: {issue.resolution}")
                    result = subprocess.run(
                        issue.resolution.split(),
                        capture_output=True,
                        text=True,
                        timeout=300
                    )
                    
                    if result.returncode == 0:
                        executed_commands.append(issue.resolution)
                        logger.info(f"Successfully fixed: {issue.package.name}")
                    else:
                        logger.error(f"Failed to fix {issue.package.name}: {result.stderr}")
                except Exception as e:
                    logger.error(f"Error fixing {issue.package.name}: {e}")
        
        return executed_commands


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    resolver = DependencyResolverAgent("requirements.txt")
    
    # ä¾å­˜é–¢ä¿‚ã‚’åˆ†æ
    print("\n=== Analyzing Dependencies ===")
    issues = resolver.analyze_dependencies()
    
    print(f"\nFound {len(issues)} issues:")
    for issue in issues[:5]:  # æœ€åˆã®5ä»¶ã‚’è¡¨ç¤º
        print(f"[{issue.status.value}] {issue.package.name}: {issue.description}")
        if issue.resolution:
            print(f"  â†’ {issue.resolution}")
    
    # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    print("\n=== Dependency Report ===")
    report = resolver.generate_report()
    print(json.dumps(report["summary"], indent=2))
    
    # ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆæ¨å¥¨
    print("\n=== Update Suggestions ===")
    suggestions = resolver.suggest_updates()
    for sugg in suggestions[:3]:
        print(f"{sugg['package']}: {sugg['current_version']} â†’ {sugg['latest_version']}")
        print(f"  Priority: {sugg['priority']}/100")
        print(f"  Command: {sugg['command']}")


#design_agent.py
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime

# æœ€åˆã«ãƒ­ã‚¬ãƒ¼ã‚’è¨­å®š
logger = logging.getLogger(__name__)

# åŸå› åˆ‡ã‚Šåˆ†ã‘ã®ãŸã‚ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
try:
    from config_utils import ErrorHandler, PathManager
    CONFIG_UTILS_AVAILABLE = True
    logger.debug("âœ… config_utils ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ")
except ImportError as e:
    logger.error(f"âŒ config_utils ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
    CONFIG_UTILS_AVAILABLE = False
    # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¯ãƒ©ã‚¹
    class ErrorHandler:
        @staticmethod
        def log_error(e, context):
            print(f"ERROR [{context}]: {e}")
    
    class PathManager:
        @staticmethod
        def get_safe_path(path):
            return Path(path)

try:
    from browser_controller import BrowserController
    BROWSER_CONTROLLER_AVAILABLE = True
    logger.debug("âœ… browser_controller ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ")
except ImportError as e:
    logger.error(f"âŒ browser_controller ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
    BROWSER_CONTROLLER_AVAILABLE = False

class DesignAgent:
    """è¨­è¨ˆAI - è¦ä»¶å®šç¾©ã€è¨­è¨ˆæ›¸ã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’ä½œæˆ"""
    
    DESIGN_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆè€…ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- è¦ä»¶å®šç¾©æ›¸ã®ä½œæˆ
- ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®è¨­è¨ˆ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã®è¨­è¨ˆ
- APIä»•æ§˜ã®å®šç¾©
- æŠ€è¡“é¸å®šã¨ç†ç”±ã®èª¬æ˜

ã€è¨­è¨ˆã®åŸå‰‡ã€‘
1. å®Ÿè£…å¯èƒ½æ€§ã‚’æœ€å„ªå…ˆã™ã‚‹
2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã™ã‚‹
3. ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’æ„è­˜ã™ã‚‹
4. é–‹ç™ºè€…ãŒç†è§£ã—ã‚„ã™ã„æ–‡æ›¸ã‚’ä½œæˆ

ã€å‡ºåŠ›å½¢å¼ã€‘
ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã«å¿œã˜ã¦ã€ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

## ã‚¿ã‚¹ã‚¯æ¦‚è¦
ï¼ˆã‚¿ã‚¹ã‚¯ã®ç†è§£ã¨ç›®çš„ï¼‰

## è¨­è¨ˆå†…å®¹
ï¼ˆå…·ä½“çš„ãªè¨­è¨ˆå†…å®¹ï¼‰

## æŠ€è¡“é¸å®š
ï¼ˆä½¿ç”¨ã™ã‚‹æŠ€è¡“ã¨ãã®ç†ç”±ï¼‰

## å®Ÿè£…ã«ãŠã‘ã‚‹æ³¨æ„ç‚¹
ï¼ˆé–‹ç™ºæ™‚ã®æ³¨æ„äº‹é …ï¼‰

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
ï¼ˆã“ã®ã‚¿ã‚¹ã‚¯å¾Œã«è¡Œã†ã¹ãã“ã¨ï¼‰"""

    def __init__(self, browser_controller=None, browser=None, output_folder: Path = None):
        """
        åˆæœŸåŒ– - å¼•æ•°åã®äº’æ›æ€§ã‚’ç¢ºä¿
        
        åŸå› åˆ‡ã‚Šåˆ†ã‘ã®ãŸã‚ã®è©³ç´°ãƒ­ã‚°:
        """
        logger.info("ğŸ” DesignAgent.__init__() é–‹å§‹")
        logger.info(f"   browser_controller: {type(browser_controller)}")
        logger.info(f"   browser: {type(browser)}")
        logger.info(f"   output_folder: {output_folder}")
        
        # åŸå› 1: å¼•æ•°åã®ä¸ä¸€è‡´ã‚’è§£æ±º
        if browser_controller is not None:
            self.browser = browser_controller
            logger.info("âœ… browser_controller ã‚’ä½¿ç”¨")
        elif browser is not None:
            self.browser = browser
            logger.info("âœ… browser ã‚’ä½¿ç”¨")
        else:
            self.browser = None
            logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒæä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
        # åŸå› 2: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®šãƒ­ã‚¸ãƒƒã‚¯
        self.output_folder = self._setup_output_folder(output_folder)
        
        # åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª
        self._validate_initialization()
        
        logger.info("âœ… DesignAgent.__init__() å®Œäº†")

    def _setup_output_folder(self, output_folder: Optional[Path]) -> Path:
        """å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã‚’è¨­å®šï¼ˆåŸå› åˆ‡ã‚Šåˆ†ã‘ä»˜ãï¼‰"""
        logger.info("ğŸ” å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€è¨­å®šé–‹å§‹")
        
        # åŸå› 3: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ãŒç›´æ¥æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆ
        if output_folder is not None:
            safe_path = PathManager.get_safe_path(output_folder) if CONFIG_UTILS_AVAILABLE else Path(output_folder)
            logger.info(f"âœ… ç›´æ¥æŒ‡å®šã®å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {safe_path}")
            return safe_path
        
        # åŸå› 4: configã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
        try:
            from config_utils import config
            if hasattr(config, 'AGENT_OUTPUT_FOLDER') and config.AGENT_OUTPUT_FOLDER:
                safe_path = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"âœ… configã‹ã‚‰å–å¾—ã—ãŸå‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {safe_path}")
                return safe_path
        except Exception as e:
            logger.error(f"âŒ configã‹ã‚‰ã®å–å¾—å¤±æ•—: {e}")
        
        # åŸå› 5: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ‘ã‚¹
        fallback_path = Path(r"C:\Users\color\Documents\gemini_auto_generate\agent_outputs")
        fallback_path.mkdir(exist_ok=True, parents=True)
        logger.warning(f"âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {fallback_path}")
        
        return fallback_path

    def _validate_initialization(self):
        """åˆæœŸåŒ–çŠ¶æ…‹ã‚’æ¤œè¨¼ï¼ˆåŸå› åˆ‡ã‚Šåˆ†ã‘ï¼‰"""
        logger.info("ğŸ” åˆæœŸåŒ–çŠ¶æ…‹æ¤œè¨¼é–‹å§‹")
        
        # åŸå› 6: ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®çŠ¶æ…‹ç¢ºèª
        if self.browser is None:
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
        else:
            logger.info(f"âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼: {type(self.browser)}")
            # ãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ç¢ºèª
            required_methods = ['send_prompt', 'wait_for_text_generation', 'extract_latest_text_response']
            for method in required_methods:
                if hasattr(self.browser, method):
                    logger.info(f"âœ… ãƒ¡ã‚½ãƒƒãƒ‰å­˜åœ¨: {method}")
                else:
                    logger.error(f"âŒ ãƒ¡ã‚½ãƒƒãƒ‰ä¸è¶³: {method}")
        
        # åŸå› 7: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®æ¨©é™ç¢ºèª
        try:
            test_file = self.output_folder / "test_write_permission.txt"
            test_file.write_text("test")
            test_file.unlink()
            logger.info("âœ… å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€æ›¸ãè¾¼ã¿æ¨©é™: OK")
        except Exception as e:
            logger.error(f"âŒ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€æ›¸ãè¾¼ã¿æ¨©é™ã‚¨ãƒ©ãƒ¼: {e}")
        
        # åŸå› 8: å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å¯ç”¨æ€§ç¢ºèª
        logger.info(f"âœ… config_utils å¯ç”¨æ€§: {CONFIG_UTILS_AVAILABLE}")
        logger.info(f"âœ… browser_controller å¯ç”¨æ€§: {BROWSER_CONTROLLER_AVAILABLE}")
        
        logger.info("ğŸ” åˆæœŸåŒ–çŠ¶æ…‹æ¤œè¨¼å®Œäº†")

    async def process_task(self, task: Dict) -> Dict:
        """è¨­è¨ˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆè©³ç´°ãªåŸå› åˆ‡ã‚Šåˆ†ã‘ä»˜ãï¼‰"""
        task_id = task.get('task_id', 'UNKNOWN')
        logger.info(f"\nğŸ¯ DesignAgent.process_task() é–‹å§‹: {task_id}")
        
        try:
            # åŸå› 9: ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
            self._validate_task_data(task)
            
            logger.info(f"è¨­è¨ˆAI: ã‚¿ã‚¹ã‚¯å‡¦ç†é–‹å§‹ - {task['description']}")
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = self._build_prompt(task)
            logger.info(f"ğŸ“ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé•·: {len(full_prompt)}æ–‡å­—")
            
            # åŸå› 10: ãƒ–ãƒ©ã‚¦ã‚¶æ“ä½œå‰ã®çŠ¶æ…‹ç¢ºèª
            if not await self._pre_browser_validation():
                return {
                    'success': False,
                    'error': 'ãƒ–ãƒ©ã‚¦ã‚¶æ¤œè¨¼å¤±æ•—'
                }
            
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«è¨­è¨ˆã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            logger.info("ğŸ”„ ãƒ–ãƒ©ã‚¦ã‚¶æ“ä½œé–‹å§‹...")
            
            send_success = await self.browser.send_prompt(full_prompt)
            if not send_success:
                logger.error("âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å¤±æ•—")
                return {
                    'success': False,
                    'error': 'è¨­è¨ˆAI: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å¤±æ•—'
                }
            
            logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡æˆåŠŸ")
            
            # å¿œç­”å¾…æ©Ÿ
            logger.info("â³ å¿œç­”å¾…æ©Ÿä¸­...")
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                logger.error("âŒ ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
                return {
                    'success': False,
                    'error': 'è¨­è¨ˆAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
            
            logger.info("âœ… ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†")
            
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.error("âŒ å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆå–å¾—å¤±æ•—")
                return {
                    'success': False,
                    'error': 'è¨­è¨ˆAI: å¿œç­”å–å¾—å¤±æ•—'
                }
            
            logger.info(f"âœ… å¿œç­”å–å¾—å®Œäº†: {len(response_text)}æ–‡å­—")
            logger.info(f"è¨­è¨ˆAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # çµæœã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            result = await self._save_results(task, response_text)
            
            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
            return result
            
        except Exception as e:
            # åŸå› 11: è©³ç´°ãªä¾‹å¤–æƒ…å ±
            error_msg = self._analyze_exception(e, task)
            ErrorHandler.log_error(e, "è¨­è¨ˆAIå‡¦ç†")
            
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {task_id} - {error_msg}")
            return {
                'success': False,
                'error': error_msg
            }

    def _validate_task_data(self, task: Dict):
        """ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œè¨¼"""
        logger.info("ğŸ” ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼")
        
        required_fields = ['task_id', 'description']
        for field in required_fields:
            if field not in task:
                raise ValueError(f"å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field}' ãŒã‚ã‚Šã¾ã›ã‚“")
            logger.info(f"âœ… å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: {field}")
        
        logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ID: {task.get('task_id')}")
        logger.info(f"ğŸ“‹ èª¬æ˜: {task.get('description')[:50]}...")
        logger.info(f"ğŸ“‹ ãƒ­ãƒ¼ãƒ«: {task.get('required_role', 'N/A')}")

    def _build_prompt(self, task: Dict) -> str:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        return f"""{self.DESIGN_SYSTEM_PROMPT}

ã€ã‚¿ã‚¹ã‚¯ã€‘
{task['description']}

ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦ã€è©³ç´°ãªè¨­è¨ˆã‚’è¡Œã£ã¦ãã ã•ã„ã€‚
å®Ÿè£…å¯èƒ½ã§å…·ä½“çš„ãªè¨­è¨ˆæ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚"""

    async def _pre_browser_validation(self) -> bool:
        """ãƒ–ãƒ©ã‚¦ã‚¶æ“ä½œå‰ã®æ¤œè¨¼"""
        logger.info("ğŸ” ãƒ–ãƒ©ã‚¦ã‚¶æ“ä½œå‰æ¤œè¨¼")
        
        if self.browser is None:
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
            return False
        
        # ãƒ–ãƒ©ã‚¦ã‚¶ã®çŠ¶æ…‹ç¢ºèª
        if hasattr(self.browser, 'is_ready'):
            is_ready = await self.browser.is_ready()
            if not is_ready:
                logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒæº–å‚™ã§ãã¦ã„ã¾ã›ã‚“")
                return False
        
        logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶æ¤œè¨¼: OK")
        return True

    async def _save_results(self, task: Dict, response_text: str) -> Dict:
        """çµæœã‚’ä¿å­˜"""
        logger.info("ğŸ” çµæœä¿å­˜å‡¦ç†")
        
        filename = f"design_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        output_path = self.output_folder / filename
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# è¨­è¨ˆæ›¸: {task['description']}\n\n")
                f.write(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
            
            logger.info(f"âœ… è¨­è¨ˆæ›¸ä¿å­˜: {output_path}")
            logger.info(f"è¨­è¨ˆæ›¸ã‚’ä¿å­˜: {output_path}")
            
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆï¼ˆæœ€åˆã®500æ–‡å­—ï¼‰
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
            
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            raise

    def _analyze_exception(self, e: Exception, task: Dict) -> str:
        """ä¾‹å¤–ã‚’è©³ç´°ã«åˆ†æ"""
        error_type = type(e).__name__
        task_id = task.get('task_id', 'UNKNOWN')
        
        logger.info(f"ğŸ” ä¾‹å¤–åˆ†æ: {error_type}")
        logger.info(f"ğŸ” ä¾‹å¤–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {str(e)}")
        
        # åŸå› ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        if "browser" in str(e).lower() or "send_prompt" in str(e):
            return f"ãƒ–ãƒ©ã‚¦ã‚¶æ“ä½œã‚¨ãƒ©ãƒ¼: {str(e)}"
        elif "timeout" in str(e).lower():
            return f"ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼: {str(e)}"
        elif "file" in str(e).lower() or "write" in str(e):
            return f"ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¨ãƒ©ãƒ¼: {str(e)}"
        elif "import" in str(e).lower():
            return f"ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: {str(e)}"
        else:
            return f"è¨­è¨ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ ({error_type}): {str(e)}"

    # ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ¡ã‚½ãƒƒãƒ‰
    def get_status(self) -> Dict:
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®çŠ¶æ…‹ã‚’å–å¾—"""
        return {
            'browser_available': self.browser is not None,
            'output_folder': str(self.output_folder),
            'config_utils_available': CONFIG_UTILS_AVAILABLE,
            'browser_controller_available': BROWSER_CONTROLLER_AVAILABLE,
            'output_folder_writable': self._check_folder_writable()
        }

    def _check_folder_writable(self) -> bool:
        """ãƒ•ã‚©ãƒ«ãƒ€æ›¸ãè¾¼ã¿å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯"""
        try:
            test_file = self.output_folder / "test_write.tmp"
            test_file.write_text("test")
            test_file.unlink()
            return True
        except:
            return False


# ãƒ†ã‚¹ãƒˆç”¨ã‚³ãƒ¼ãƒ‰
async def test_design_agent():
    """DesignAgentã®ãƒ†ã‚¹ãƒˆ"""
    print("ğŸ§ª DesignAgent ãƒ†ã‚¹ãƒˆé–‹å§‹")
    
    # ãƒ¢ãƒƒã‚¯ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆå®Ÿéš›ã®ç’°å¢ƒã«åˆã‚ã›ã¦èª¿æ•´ï¼‰
    class MockBrowser:
        async def send_prompt(self, prompt):
            print(f"ğŸ“¤ ãƒ¢ãƒƒã‚¯é€ä¿¡: {len(prompt)}æ–‡å­—")
            return True
        
        async def wait_for_text_generation(self, max_wait=180):
            await asyncio.sleep(1)
            return True
        
        async def extract_latest_text_response(self):
            return "ã“ã‚Œã¯ãƒ¢ãƒƒã‚¯å¿œç­”ã§ã™ã€‚è¨­è¨ˆå†…å®¹: ..."
    
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    try:
        browser = MockBrowser()
        agent = DesignAgent(browser_controller=browser)
        
        test_task = {
            'task_id': 'TEST_001',
            'description': 'ãƒ†ã‚¹ãƒˆè¨­è¨ˆã‚¿ã‚¹ã‚¯',
            'required_role': 'design'
        }
        
        result = await agent.process_task(test_task)
        print(f"ğŸ§ª ãƒ†ã‚¹ãƒˆçµæœ: {result}")
        
    except Exception as e:
        print(f"âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: {e}")


if __name__ == "__main__":
    # å˜ä½“ãƒ†ã‚¹ãƒˆ
    asyncio.run(test_design_agent())

#dev_agent.py
# dev_agent.py
"""é–‹ç™ºAI - ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã€WordPresså°‚ç”¨æ©Ÿèƒ½ã®ä½œæˆï¼ˆå¼•æ•°è¨ºæ–­å¼·åŒ–ç‰ˆï¼‰"""
import asyncio
import logging
import inspect
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)


class DevAgent:
    """é–‹ç™ºAI - ã‚³ãƒ¼ãƒ‰ç”Ÿæˆã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã€WordPresså°‚ç”¨æ©Ÿèƒ½ã®ä½œæˆ"""

    def __init__(self, browser: BrowserController = None, browser_controller: BrowserController = None, output_folder: Path = None):
        """
        åˆæœŸåŒ–ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆè¤‡æ•°å¼•æ•°åå¯¾å¿œç‰ˆï¼‰
    
        Args:
            browser: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆäº’æ›æ€§ç”¨ï¼‰
            output_folder: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹
        """
        # å¼•æ•°è¨ºæ–­ãƒ­ã‚°
        logger.info("ğŸ” DevAgent åˆæœŸåŒ–è¨ºæ–­:")
        logger.info(f"   - browser: {browser is not None}")
        logger.info(f"   - browser_controller: {browser_controller is not None}")
        logger.info(f"   - output_folder: {output_folder}")
    
        # browser_controller ã‚’å„ªå…ˆã—ã€æ¬¡ã« browser ã‚’ä½¿ç”¨
        if browser_controller is not None:
            self.browser = browser_controller
            logger.info("âœ… browser_controller ã‚’ä½¿ç”¨")
        elif browser is not None:
            self.browser = browser
            logger.info("âœ… browser ã‚’ä½¿ç”¨")
        else:
            logger.error("âŒ browser_controller ã‚‚ browser ã‚‚æä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            self.browser = None
    
        # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š
        if output_folder is None:
            from config_utils import config
            if config.AGENT_OUTPUT_FOLDER:
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"Agentå‡ºåŠ›å…ˆï¼ˆB14ã‹ã‚‰å–å¾—ï¼‰: {self.output_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ã‚¹
                self.output_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.warning(f"B14ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.output_folder}")
        else:
            self.output_folder = output_folder
    
        self.design_docs = {}  # è¨­è¨ˆæ›¸ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
    
        # åˆæœŸåŒ–å®Œäº†ãƒ­ã‚°
        logger.info(f"âœ… DevAgent åˆæœŸåŒ–å®Œäº†:")
        logger.info(f"   - browser: {self.browser is not None}")
        logger.info(f"   - output_folder: {self.output_folder}")

    # æ—¢å­˜ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©ã¯å¤‰æ›´ãªã—...
    DEV_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚..."""

    WORDPRESS_CPT_PROMPT = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚..."""

    async def process_task(self, task: Dict) -> Dict:
        """é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆå¼•æ•°è¨ºæ–­å¼·åŒ–ç‰ˆï¼‰"""
        try:
            # å¼•æ•°çŠ¶æ…‹ã®è¨ºæ–­
            self._diagnose_agent_state(task)
        
            logger.info(f"é–‹ç™ºAI: ã‚¿ã‚¹ã‚¯å‡¦ç†é–‹å§‹ - {task['description']}")
        
            # WordPress ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š
            if self._is_wordpress_cpt_task(task):
                return await self._process_wordpress_cpt_task(task)
        
            # WordPress ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š
            if self._is_wordpress_taxonomy_task(task):
                return await self._process_wordpress_taxonomy_task(task)
        
            # é€šå¸¸ã®é–‹ç™ºã‚¿ã‚¹ã‚¯
            return await self._process_general_task(task)
        
        except Exception as e:
            ErrorHandler.log_error(e, "é–‹ç™ºAIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }

    def _diagnose_agent_state(self, task: Dict):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçŠ¶æ…‹ã®è¨ºæ–­"""
        logger.info("ğŸ” DevAgent çŠ¶æ…‹è¨ºæ–­:")
        logger.info(f"   - ã‚¿ã‚¹ã‚¯ID: {task.get('task_id', 'N/A')}")
        logger.info(f"   - ã‚¿ã‚¹ã‚¯èª¬æ˜: {task.get('description', 'N/A')[:100]}...")
        logger.info(f"   - browser ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹: {self.browser is not None}")
        logger.info(f"   - output_folder å­˜åœ¨: {self.output_folder.exists() if self.output_folder else False}")
    
        # é‡è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ç¢ºèª
        required_methods = ['send_prompt', 'wait_for_text_generation', 'extract_latest_text_response']
        if self.browser:
            for method in required_methods:
                has_method = hasattr(self.browser, method) and callable(getattr(self.browser, method))
                logger.info(f"   - browser.{method}: {'âœ…' if has_method else 'âŒ'}")
    
        # å¼•æ•°ã‚·ã‚°ãƒãƒãƒ£ã®è¨ºæ–­
        try:
            init_signature = inspect.signature(self.__init__)
            params = list(init_signature.parameters.keys())
            logger.info(f"   - __init__ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: {params}")
        except Exception as e:
            logger.warning(f"   - ã‚·ã‚°ãƒãƒãƒ£è¨ºæ–­ã‚¨ãƒ©ãƒ¼: {e}")

    def _is_wordpress_cpt_task(self, task: Dict) -> bool:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š"""
        description = task.get('description', '').lower()
        keywords = [
            'custom post type',
            'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—',
            'cpt',
            'register_post_type',
            'æŠ•ç¨¿ã‚¿ã‚¤ãƒ—'
        ]
        return any(kw in description for kw in keywords)

    def _is_wordpress_taxonomy_task(self, task: Dict) -> bool:
        """WordPressã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š"""
        description = task.get('description', '').lower()
        keywords = [
            'taxonomy',
            'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼',
            'ã‚«ã‚¹ã‚¿ãƒ åˆ†é¡',
            'register_taxonomy'
        ]
        return any(kw in description for kw in keywords)

    async def _process_wordpress_cpt_task(self, task: Dict) -> Dict:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            # ãƒ–ãƒ©ã‚¦ã‚¶çŠ¶æ…‹ã®ç¢ºèª
            if not self.browser:
                return {
                    'success': False,
                    'error': 'DevAgent: browser_controller ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
        
            logger.info("="*60)
            logger.info("WordPress ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯")
            logger.info("="*60)
        
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡º
            cpt_info = self._extract_cpt_info(task)
        
            logger.info(f"æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚¹ãƒ©ãƒƒã‚°: {cpt_info['slug']}")
            logger.info(f"è¡¨ç¤ºåï¼ˆå˜æ•°ï¼‰: {cpt_info['singular_name']}")
            logger.info(f"è¡¨ç¤ºåï¼ˆè¤‡æ•°ï¼‰: {cpt_info['plural_name']}")
        
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = self._build_wordpress_cpt_prompt(task, cpt_info)
        
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«è¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)

            # å¿œç­”å¾…æ©Ÿï¼ˆè¦ä»¶å®šç¾©æ›¸ã¯é•·ã„ã®ã§300ç§’ï¼‰
            logger.info("â±ï¸ å¾…æ©Ÿæ™‚é–“: 300ç§’ï¼ˆè¦ä»¶å®šç¾©æ›¸ä½œæˆï¼‰")
        
            # ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¡ã‚½ãƒƒãƒ‰ã®äº’æ›æ€§å¯¾å¿œ
            if hasattr(self.browser, 'wait_for_text_generation'):
                success = await self.browser.wait_for_text_generation(max_wait=300)
            elif hasattr(self.browser, '_wait_for_generation_complete'):
                success = await self.browser._wait_for_generation_complete()
            else:
                logger.error("âŒ åˆ©ç”¨å¯èƒ½ãªå¾…æ©Ÿãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'åˆ©ç”¨å¯èƒ½ãªå¾…æ©Ÿãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
                }

            if not success:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆè¦ä»¶å®šç¾©æ›¸ä½œæˆ: 300ç§’ï¼‰'
                }
        
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
        
            if not response_text:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: å¿œç­”å–å¾—å¤±æ•—'
                }
        
            logger.info(f"é–‹ç™ºAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
        
            # çµæœã‚’ä¿å­˜
            output_files = self._save_wordpress_cpt_code(response_text, task, cpt_info)
        
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ
            summary = f"""âœ… WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆå®Œäº†

ã€æŠ•ç¨¿ã‚¿ã‚¤ãƒ—æƒ…å ±ã€‘
- ã‚¹ãƒ©ãƒƒã‚°: {cpt_info['slug']}
- è¡¨ç¤ºå: {cpt_info['singular_name']} / {cpt_info['plural_name']}
- ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½: {', '.join(cpt_info['supports'])}

ã€ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã€‘
"""
            for file_info in output_files:
                summary += f"- {file_info['type']}: {file_info['path'].name}\n"
        
            summary += f"\nã€æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã€‘\n"
            summary += f"1. functions.php ã¾ãŸã¯å°‚ç”¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã«è¿½åŠ \n"
            summary += f"2. ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šã‚’ä¿å­˜ï¼ˆè¨­å®š > ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®šï¼‰\n"
            summary += f"3. ç®¡ç†ç”»é¢ã§ã€Œ{cpt_info['menu_name']}ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç¢ºèª\n"
        
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'cpt_slug': cpt_info['slug']
            }
        
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆ")
            return {
                'success': False,
                'error': str(e)
            }

    # æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤‰æ›´ãªã—...
    def _extract_cpt_info(self, task: Dict) -> Dict:
        """ã‚¿ã‚¹ã‚¯ã‹ã‚‰ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®æƒ…å ±ã‚’æŠ½å‡º"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...
        pass

    def _build_wordpress_cpt_prompt(self, task: Dict, cpt_info: Dict) -> str:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...
        pass

    def _save_wordpress_cpt_code(self, text: str, task: Dict, cpt_info: Dict) -> list:
        """WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...
        pass

    def _extract_php_code(self, text: str) -> Optional[str]:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...
        pass

    async def _process_wordpress_taxonomy_task(self, task: Dict) -> Dict:
        """WordPressã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...
        pass

    async def _process_general_task(self, task: Dict) -> Dict:
        """é€šå¸¸ã®é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            # ãƒ–ãƒ©ã‚¦ã‚¶çŠ¶æ…‹ã®ç¢ºèª
            if not self.browser:
                return {
                    'success': False,
                    'error': 'DevAgent: browser_controller ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
        
            logger.info("é€šå¸¸ã®é–‹ç™ºã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
        
            # å¯¾å¿œã™ã‚‹è¨­è¨ˆæ›¸ãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€
            design_context = self._load_design_context(task)
        
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"""{self.DEV_SYSTEM_PROMPT}

ã€ã‚¿ã‚¹ã‚¯ã€‘
{task['description']}"""

            if design_context:
                full_prompt += f"""

ã€è¨­è¨ˆæ›¸ï¼ˆå‚è€ƒï¼‰ã€‘
{design_context}"""
        
            full_prompt += """

ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯ã«ã¤ã„ã¦ã€å®Œå…¨ã«å‹•ä½œã™ã‚‹ã‚³ãƒ¼ãƒ‰ã‚’å®Ÿè£…ã—ã¦ãã ã•ã„ã€‚
ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ã‚³ãƒ¡ãƒ³ãƒˆã‚’å«ã‚ã¦ãã ã•ã„ã€‚"""
        
            # Geminiã«é€ä¿¡
            logger.info("Geminiã«é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
        
            # ã‚¿ã‚¹ã‚¯ã®ç¨®é¡ã«ã‚ˆã£ã¦å¾…æ©Ÿæ™‚é–“ã‚’èª¿æ•´
            description = task.get('description', '').lower()
    
            if any(word in description for word in ['è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£', 'ä»•æ§˜æ›¸']):
                max_wait = 300  # è¦ä»¶å®šç¾©æ›¸ãªã©ã¯5åˆ†
                logger.info("ğŸ“‹ è¦ä»¶å®šç¾©ãƒ»è¨­è¨ˆæ›¸ã‚¿ã‚¹ã‚¯ - å¾…æ©Ÿæ™‚é–“ã‚’300ç§’ã«å»¶é•·")
            else:
                max_wait = 180  # é€šå¸¸ã¯3åˆ†
        
            # ãƒ–ãƒ©ã‚¦ã‚¶ãƒ¡ã‚½ãƒƒãƒ‰ã®äº’æ›æ€§å¯¾å¿œ
            if hasattr(self.browser, 'wait_for_text_generation'):
                success = await self.browser.wait_for_text_generation(max_wait=max_wait)
            elif hasattr(self.browser, '_wait_for_generation_complete'):
                success = await self.browser._wait_for_generation_complete()
            else:
                logger.error("âŒ åˆ©ç”¨å¯èƒ½ãªå¾…æ©Ÿãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'åˆ©ç”¨å¯èƒ½ãªå¾…æ©Ÿãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
                }
        
            if not success:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
        
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
        
            if not response_text:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: å¿œç­”å–å¾—å¤±æ•—'
                }
        
            logger.info(f"é–‹ç™ºAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
        
            # ã‚³ãƒ¼ãƒ‰ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            filename = f"code_{task['task_id']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            output_path = self.output_folder / filename
        
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(f"# ã‚³ãƒ¼ãƒ‰: {task['description']}\n\n")
                f.write(f"ã‚¿ã‚¹ã‚¯ID: {task['task_id']}\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write("---\n\n")
                f.write(response_text)
        
            logger.info(f"ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜: {output_path}")
        
            # ã‚³ãƒ¼ãƒ‰éƒ¨åˆ†ã‚’æŠ½å‡ºã—ã¦å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            self._extract_and_save_code(response_text, task)
        
            # ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ
            summary = response_text[:500] + "..." if len(response_text) > 500 else response_text
        
            return {
                'success': True,
                'output_file': str(output_path),
                'summary': summary,
                'full_text': response_text
            }
        
        except Exception as e:
            ErrorHandler.log_error(e, "é–‹ç™ºAIå‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _load_design_context(self, task: Dict) -> str:
        """å¯¾å¿œã™ã‚‹è¨­è¨ˆæ›¸ãŒã‚ã‚Œã°èª­ã¿è¾¼ã‚€"""
        try:
            # design_*.md ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™
            design_files = list(self.output_folder.glob(f"design_{task['task_id']}_*.md"))
            
            if design_files:
                # æœ€æ–°ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
                latest_design = sorted(design_files)[-1]
                with open(latest_design, 'r', encoding='utf-8') as f:
                    content = f.read()
                logger.info(f"è¨­è¨ˆæ›¸ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {latest_design.name}")
                return content[:2000]  # æœ€åˆã®2000æ–‡å­—ã®ã¿
            
            return ""
        except Exception as e:
            logger.warning(f"è¨­è¨ˆæ›¸èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return ""
    
    def _extract_and_save_code(self, text: str, task: Dict):
        """ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡ºã—ã¦å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        try:
            # ```è¨€èª ... ``` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æŠ½å‡º
            code_blocks = re.findall(r'```(\w+)\n(.*?)```', text, re.DOTALL)
            
            for i, (lang, code) in enumerate(code_blocks):
                # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’æ±ºå®š
                ext_map = {
                    'python': '.py',
                    'javascript': '.js',
                    'typescript': '.ts',
                    'html': '.html',
                    'css': '.css',
                    'java': '.java',
                    'cpp': '.cpp',
                    'c': '.c',
                    'php': '.php',
                    'ruby': '.rb',
                    'go': '.go',
                    'rust': '.rs',
                }
                ext = ext_map.get(lang.lower(), '.txt')
                
                # ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
                code_filename = f"code_{task['task_id']}_{i+1}{ext}"
                code_path = self.output_folder / code_filename
                
                with open(code_path, 'w', encoding='utf-8') as f:
                    f.write(code)
                
                logger.info(f"ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜: {code_filename}")
                
        except Exception as e:
            logger.warning(f"ã‚³ãƒ¼ãƒ‰æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")

#dev_agent_acf.py
# dev_agent_acf.py
"""ACFï¼ˆAdvanced Custom Fieldsï¼‰å°‚ç”¨é–‹ç™ºãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«"""
import asyncio
import logging
from pathlib import Path
from typing import Dict, Optional
from datetime import datetime
import re
import json

from config_utils import ErrorHandler, PathManager, config

logger = logging.getLogger(__name__)


# =============================================================================
# ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—å°‚ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

ACF_FIELD_GROUP_PROMPT = """ã‚ãªãŸã¯ACF Proã¨WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆã€‘

ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å®Œå…¨ã«å‹•ä½œã™ã‚‹ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å®šç¾©ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚

ã€å¿…é ˆè¦ç´ ã€‘
1. ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®åŸºæœ¬è¨­å®š
   - ã‚¿ã‚¤ãƒˆãƒ«ã€ã‚­ãƒ¼ã€é…ç½®å ´æ‰€ï¼ˆæŠ•ç¨¿ã‚¿ã‚¤ãƒ—ï¼‰
2. å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è©³ç´°å®šç¾©
   - ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—ï¼ˆtext, number, select, relationship ãªã©ï¼‰
   - ãƒ©ãƒ™ãƒ«ã€åå‰ã€ã‚­ãƒ¼
   - æ¤œè¨¼ãƒ«ãƒ¼ãƒ«ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
3. æ¡ä»¶ä»˜ããƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
4. PHPç™»éŒ²ã‚³ãƒ¼ãƒ‰ï¼ˆ`acf_add_local_field_group`ï¼‰
5. JSONå½¢å¼ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆWP-CLIã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ï¼‰

ã€å‡ºåŠ›å½¢å¼ã€‘

## ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—: {group_title}

### æ¦‚è¦
ï¼ˆã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®ç›®çš„ã¨ç”¨é€”ï¼‰

### PHPç™»éŒ²ã‚³ãƒ¼ãƒ‰ï¼ˆfunctions.phpã«è¿½åŠ ï¼‰

```php
<?php
/**
 * ACF Field Group: {group_title}
 * æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {post_type}
 */

if (function_exists('acf_add_local_field_group')) {{
    acf_add_local_field_group(array(
        'key' => 'group_{unique_key}',
        'title' => '{group_title}',
        'fields' => array(
            // ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å®šç¾©
            array(
                'key' => 'field_{field_key}',
                'label' => '{field_label}',
                'name' => '{field_name}',
                'type' => '{field_type}',
                'required' => {{true|false}},
                'default_value' => '',
            ),
        ),
        'location' => array(
            array(
                array(
                    'param' => 'post_type',
                    'operator' => '==',
                    'value' => '{post_type}',
                ),
            ),
        ),
        'menu_order' => 0,
        'position' => 'normal',
        'style' => 'default',
        'label_placement' => 'top',
        'instruction_placement' => 'label',
        'active' => true,
        'show_in_rest' => 1,
    ));
}}
?>
```

### JSONå®šç¾©ï¼ˆWP-CLIã‚¤ãƒ³ãƒãƒ¼ãƒˆç”¨ï¼‰

```json
{{
  "key": "group_{unique_key}",
  "title": "{group_title}",
  "fields": [
    {{
      "key": "field_{field_key}",
      "label": "{field_label}",
      "name": "{field_name}",
      "type": "{field_type}",
      "required": {{true|false}}
    }}
  ],
  "location": [
    [
      {{
        "param": "post_type",
        "operator": "==",
        "value": "{post_type}"
      }}
    ]
  ]
}}
```

### ä½¿ç”¨æ–¹æ³•

#### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã®å–å¾—
```php
<?php
// å˜ä¸€å€¤ã®å–å¾—
$value = get_field('field_name', $post_id);

// æ¡ä»¶ä»˜ãè¡¨ç¤º
if (get_field('field_name')) :
    echo esc_html(get_field('field_name'));
endif;
?>
```

### æ³¨æ„äº‹é …
- ACF Pro 6.0ä»¥ä¸ŠãŒå¿…è¦ã§ã™
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¼ã¯ä¸€æ„ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
"""


# =============================================================================
# ACFDevAgentã‚¯ãƒ©ã‚¹ï¼ˆACFå°‚ç”¨æ©Ÿèƒ½ï¼‰
# =============================================================================

class ACFDevAgent:
    """ACFï¼ˆAdvanced Custom Fieldsï¼‰å°‚ç”¨é–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(self, browser, output_folder: Path):
        """
        åˆæœŸåŒ–
        
        Args:
            browser: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            output_folder: å‡ºåŠ›å…ˆãƒ•ã‚©ãƒ«ãƒ€
        """
        self.browser = browser
        self.output_folder = output_folder
        self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯åˆ¤å®šãƒ¡ã‚½ãƒƒãƒ‰
    # =========================================================================
    
    def is_acf_task(self, task: Dict) -> bool:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‹åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            bool: ACFã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        description = task.get('description', '').lower()
        keywords = [
            'acf',
            'advanced custom fields',
            'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰',
            'ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—',
            'field group'
        ]
        return any(kw in description for kw in keywords)
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ2: ACFã‚¿ã‚¹ã‚¯å‡¦ç†ãƒ¡ã‚¤ãƒ³
    # =========================================================================
    
    async def process_acf_task(self, task: Dict) -> Dict:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            Dict: å‡¦ç†çµæœ
        """
        try:
            logger.info("="*60)
            logger.info("ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆã‚¿ã‚¹ã‚¯")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-1: ã‚¿ã‚¹ã‚¯ã‹ã‚‰æƒ…å ±ã‚’æŠ½å‡º ===
            acf_info = self._extract_acf_info(task)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰ ===
            full_prompt = self._build_acf_prompt(task, acf_info)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-3: Geminiã«é€ä¿¡ ===
            logger.info("Geminiã«ã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-4: å¿œç­”å¾…æ©Ÿ ===
            success = await self.browser.wait_for_text_generation(
                max_wait=config.WP_DEV_TIMEOUT if hasattr(config, 'WP_DEV_TIMEOUT') else 300
            )
            
            if not success:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆï¼‰'
                }
            
            # === ãƒ‘ãƒ¼ãƒˆ2-5: å¿œç­”ã‚’å–å¾— ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                return {
                    'success': False,
                    'error': 'é–‹ç™ºAI: å¿œç­”å–å¾—å¤±æ•—'
                }
            
            logger.info(f"é–‹ç™ºAI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # === ãƒ‘ãƒ¼ãƒˆ2-6: ã‚³ãƒ¼ãƒ‰æ¤œè¨¼ ===
            validation_result = self._validate_acf_code(response_text)
            if not validation_result['is_valid']:
                logger.warning(f"âš ï¸ ACFã‚³ãƒ¼ãƒ‰æ¤œè¨¼ã§å•é¡Œæ¤œå‡º: {validation_result['issues']}")
            
            # === ãƒ‘ãƒ¼ãƒˆ2-7: çµæœã‚’ä¿å­˜ ===
            output_files = self._save_acf_code(response_text, task, acf_info)
            
            # === ãƒ‘ãƒ¼ãƒˆ2-8: ã‚µãƒãƒªãƒ¼ä½œæˆ ===
            summary = self._create_acf_summary(acf_info, output_files, validation_result)
            
            return {
                'success': True,
                'output_files': output_files,
                'summary': summary,
                'full_text': response_text,
                'validation': validation_result
            }
            
        except Exception as e:
            ErrorHandler.log_error(e, "ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ")
            return {
                'success': False,
                'error': str(e)
            }
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ3: ACFæƒ…å ±æŠ½å‡º
    # =========================================================================
    
    def _extract_acf_info(self, task: Dict) -> Dict:
        """
        ã‚¿ã‚¹ã‚¯ã‹ã‚‰ACFæƒ…å ±ã‚’æŠ½å‡º
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            Dict: ACFæƒ…å ±
        """
        description = task.get('description', '')
        parameters = task.get('parameters', {})
        
        if isinstance(parameters, str):
            try:
                parameters = json.loads(parameters)
            except:
                parameters = {}
        
        return {
            'group_title': parameters.get('group_title', 'M&Aæ¡ˆä»¶ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰'),
            'post_type': parameters.get('post_type', 'ma_case'),
            'field_count': parameters.get('field_count', 10),
            'unique_key': parameters.get('unique_key', 'ma_case_fields')
        }
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ4: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
    # =========================================================================
    
    def _build_acf_prompt(self, task: Dict, acf_info: Dict) -> str:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            acf_info: ACFæƒ…å ±
            
        Returns:
            str: å®Œå…¨ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        prompt = ACF_FIELD_GROUP_PROMPT.format(
            group_title=acf_info['group_title'],
            post_type=acf_info['post_type'],
            unique_key=acf_info['unique_key'],
            field_label='ä¾‹: ä¼æ¥­å',
            field_name='company_name',
            field_key='company_name',
            field_type='text'
        )
        
        prompt += f"""

ã€ã“ã®ã‚¿ã‚¹ã‚¯ã®å…·ä½“çš„ãªè¦ä»¶ã€‘
{task.get('description', '')}

ã€é‡è¦ãªæŒ‡ç¤ºã€‘
1. PHPã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ã«å‹•ä½œã™ã‚‹çŠ¶æ…‹ã§ç”Ÿæˆã—ã¦ãã ã•ã„
2. JSONå½¢å¼ã®å®šç¾©ã‚‚å¿…ãšå«ã‚ã¦ãã ã•ã„
3. ã™ã¹ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚­ãƒ¼ï¼ˆkeyï¼‰ã‚’è¨­å®šã—ã¦ãã ã•ã„
4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å‡¦ç†ï¼‰ã‚’è€ƒæ…®ã—ã¦ãã ã•ã„
5. å¤šè¨€èªå¯¾å¿œï¼ˆPolylangï¼‰ã‚’è€ƒæ…®ã—ã¦ãã ã•ã„

ä¸Šè¨˜ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å®Œå…¨ãªACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å®šç¾©ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
"""
        
        return prompt
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ5: ACFã‚³ãƒ¼ãƒ‰æ¤œè¨¼
    # =========================================================================
    
    def _validate_acf_code(self, text: str) -> Dict:
        """
        ACFã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼
        
        Args:
            text: æ¤œè¨¼å¯¾è±¡ã®ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: æ¤œè¨¼çµæœ
        """
        issues = []
        
        # === ãƒ‘ãƒ¼ãƒˆ5-1: å¿…é ˆé–¢æ•°ã®ãƒã‚§ãƒƒã‚¯ ===
        if 'acf_add_local_field_group' not in text:
            issues.append('acf_add_local_field_group() é–¢æ•°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
        
        # === ãƒ‘ãƒ¼ãƒˆ5-2: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¼ã®ä¸€æ„æ€§ãƒã‚§ãƒƒã‚¯ ===
        field_keys = re.findall(r"'key'\s*=>\s*'(field_[^']+)'", text)
        if len(field_keys) != len(set(field_keys)):
            issues.append('ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚­ãƒ¼ãŒé‡è¤‡ã—ã¦ã„ã¾ã™')
        
        # === ãƒ‘ãƒ¼ãƒˆ5-3: JSONã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ ===
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        for json_str in json_blocks:
            try:
                json.loads(json_str)
            except json.JSONDecodeError:
                issues.append('JSONå½¢å¼ãŒä¸æ­£ã§ã™')
        
        # === ãƒ‘ãƒ¼ãƒˆ5-4: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢æ•°ã®ãƒã‚§ãƒƒã‚¯ ===
        if 'get_field(' in text and 'esc_html' not in text and 'esc_attr' not in text:
            issues.append('å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼ˆesc_html, esc_attrï¼‰')
        
        return {
            'is_valid': len(issues) == 0,
            'issues': issues
        }
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ6: ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
    # =========================================================================
    
    def _save_acf_code(self, text: str, task: Dict, acf_info: Dict) -> list:
        """
        ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®ã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜
        
        Args:
            text: ä¿å­˜å¯¾è±¡ã®ãƒ†ã‚­ã‚¹ãƒˆ
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            acf_info: ACFæƒ…å ±
            
        Returns:
            list: ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã®ãƒªã‚¹ãƒˆ
        """
        output_files = []
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ6-1: å®Œå…¨ãªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ä¿å­˜ ===
            doc_filename = f"acf_{acf_info['unique_key']}_{timestamp}.md"
            doc_path = self.output_folder / doc_filename
            
            with open(doc_path, 'w', encoding='utf-8') as f:
                f.write(f"# ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—: {acf_info['group_title']}\n\n")
                f.write(f"ä½œæˆæ—¥æ™‚: {datetime.now().isoformat()}\n\n")
                f.write(text)
            
            output_files.append({
                'type': 'ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ',
                'path': doc_path
            })
            logger.info(f"ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä¿å­˜: {doc_filename}")
            
            # === ãƒ‘ãƒ¼ãƒˆ6-2: PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã—ã¦ä¿å­˜ ===
            php_code = self._extract_php_code(text)
            if php_code:
                php_filename = f"acf_{acf_info['unique_key']}_{timestamp}.php"
                php_path = self.output_folder / php_filename
                
                with open(php_path, 'w', encoding='utf-8') as f:
                    f.write("<?php\n")
                    f.write(f"/**\n * ACF Field Group: {acf_info['group_title']}\n */\n\n")
                    f.write(php_code)
                
                output_files.append({
                    'type': 'PHPã‚³ãƒ¼ãƒ‰',
                    'path': php_path
                })
                logger.info(f"PHPã‚³ãƒ¼ãƒ‰ä¿å­˜: {php_filename}")
            
            # === ãƒ‘ãƒ¼ãƒˆ6-3: JSONå®šç¾©ã‚’æŠ½å‡ºã—ã¦ä¿å­˜ ===
            json_data = self._extract_json_from_text(text)
            if json_data:
                json_filename = f"acf_{acf_info['unique_key']}_{timestamp}.json"
                json_path = self.output_folder / json_filename
                
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(json_data, f, ensure_ascii=False, indent=2)
                
                output_files.append({
                    'type': 'JSONå®šç¾©',
                    'path': json_path
                })
                logger.info(f"JSONå®šç¾©ä¿å­˜: {json_filename}")
            
            # === ãƒ‘ãƒ¼ãƒˆ6-4: READMEã‚’ç”Ÿæˆ ===
            readme_filename = f"README_acf_{acf_info['unique_key']}_{timestamp}.md"
            readme_path = self.output_folder / readme_filename
            
            with open(readme_path, 'w', encoding='utf-8') as f:
                f.write(f"# {acf_info['group_title']} - ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¬ã‚¤ãƒ‰\n\n")
                f.write(f"## æ¦‚è¦\n\n")
                f.write(f"æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {acf_info['post_type']}\n\n")
                f.write(f"## ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ–¹æ³•\n\n")
                f.write(f"### æ–¹æ³•1: PHPã‚³ãƒ¼ãƒ‰ã§ç™»éŒ²\n\n")
                f.write(f"1. `{php_filename}` ã®å†…å®¹ã‚’ `functions.php` ã«è¿½åŠ \n\n")
                f.write(f"### æ–¹æ³•2: WP-CLIçµŒç”±\n\n")
                f.write(f"```bash\nwp acf import {json_filename}\n```\n\n")
            
            output_files.append({
                'type': 'README',
                'path': readme_path
            })
            logger.info(f"READMEä¿å­˜: {readme_filename}")
            
            return output_files
            
        except Exception as e:
            logger.error(f"ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
            return output_files
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ7: ã‚³ãƒ¼ãƒ‰æŠ½å‡ºãƒ˜ãƒ«ãƒ‘ãƒ¼
    # =========================================================================
    
    def _extract_php_code(self, text: str) -> Optional[str]:
        """PHPã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        php_pattern = r'```php\s*(.*?)```'
        matches = re.findall(php_pattern, text, re.DOTALL)
        
        if matches:
            longest_code = max(matches, key=len)
            longest_code = re.sub(r'^\s*<\?php\s*', '', longest_code)
            return longest_code.strip()
        
        return None
    
    def _extract_json_from_text(self, text: str) -> Optional[Dict]:
        """JSONå®šç¾©ã‚’æŠ½å‡º"""
        json_pattern = r'```json\s*(.*?)```'
        matches = re.findall(json_pattern, text, re.DOTALL)
        
        if matches:
            try:
                return json.loads(matches[0])
            except json.JSONDecodeError:
                return None
        
        return None
    
    # =========================================================================
    # ãƒ‘ãƒ¼ãƒˆ8: ã‚µãƒãƒªãƒ¼ä½œæˆ
    # =========================================================================
    
    def _create_acf_summary(self, acf_info: Dict, output_files: list, 
                           validation_result: Dict) -> str:
        """ACFã‚¿ã‚¹ã‚¯ã®ã‚µãƒãƒªãƒ¼ã‚’ä½œæˆ"""
        summary = f"""âœ… ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆå®Œäº†

ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã€‘
- ã‚¿ã‚¤ãƒˆãƒ«: {acf_info['group_title']}
- æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {acf_info['post_type']}
- ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: {acf_info['field_count']}

ã€ç”Ÿæˆãƒ•ã‚¡ã‚¤ãƒ«ã€‘
"""
        for file_info in output_files:
            summary += f"- {file_info['type']}: {file_info['path'].name}\n"
        
        if not validation_result['is_valid']:
            summary += f"\nã€æ¤œè¨¼çµæœã€‘\n"
            for issue in validation_result['issues']:
                summary += f"âš ï¸ {issue}\n"
        
        return summary

#error_classifier.py
# error_classifier.py
"""
ã‚¨ãƒ©ãƒ¼åˆ†é¡å™¨
ã‚¨ãƒ©ãƒ¼ã®è¤‡é›‘åº¦ã¨ç¨®é¡ã‚’åˆ¤å®š
"""

import logging
import re
from typing import Dict, Any, Optional
from enum import Enum
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class ErrorContextModel:
    """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«"""
    error_type: str
    error_message: Optional[str] = None
    surrounding_code: Optional[str] = None
    full_traceback: Optional[str] = None


class ErrorComplexity(Enum):
    """ã‚¨ãƒ©ãƒ¼è¤‡é›‘åº¦"""
    SIMPLE = "simple"      # å˜ç´”ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§å¯¾å¿œå¯èƒ½ï¼‰
    MEDIUM = "medium"      # ä¸­ç¨‹åº¦ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«AIã§å¯¾å¿œå¯èƒ½ï¼‰
    COMPLEX = "complex"    # è¤‡é›‘ï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰AIæ¨å¥¨ï¼‰


class ErrorCategory(Enum):
    """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª"""
    SYNTAX = "syntax"                    # æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
    IMPORT = "import"                    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼
    RUNTIME = "runtime"                  # å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼
    LOGIC = "logic"                      # ãƒ­ã‚¸ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼
    DESIGN = "design"                    # è¨­è¨ˆãƒ¬ãƒ™ãƒ«ã®å•é¡Œ
    PERFORMANCE = "performance"          # ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ
    SECURITY = "security"                # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œ
    UNKNOWN = "unknown"                  # ä¸æ˜


class ErrorClassifier:
    """
    ã‚¨ãƒ©ãƒ¼åˆ†é¡å™¨
    
    æ©Ÿèƒ½:
    - ã‚¨ãƒ©ãƒ¼ã®è¤‡é›‘åº¦åˆ¤å®š
    - ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªã®åˆ†é¡
    - ä¿®æ­£æˆ¦ç•¥ã®æ¨å¥¨
    - ä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢ã®ç®—å‡º
    """
    
    def __init__(self):
        """åˆæœŸåŒ–"""
        self._init_classification_rules()
        logger.info("âœ… ErrorClassifier åˆæœŸåŒ–å®Œäº†")
    
    def _init_classification_rules(self):
        """åˆ†é¡ãƒ«ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–"""
        
        # å˜ç´”ãªã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§å¯¾å¿œå¯èƒ½ï¼‰
        self.simple_patterns = {
            "SyntaxError": ErrorCategory.SYNTAX,
            "IndentationError": ErrorCategory.SYNTAX,
            "ImportError": ErrorCategory.IMPORT,
            "ModuleNotFoundError": ErrorCategory.IMPORT,
        }
        
        # ä¸­ç¨‹åº¦ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
        self.medium_patterns = {
            "AttributeError": ErrorCategory.RUNTIME,
            "NameError": ErrorCategory.RUNTIME,
            "TypeError": ErrorCategory.RUNTIME,
            "ValueError": ErrorCategory.RUNTIME,
            "KeyError": ErrorCategory.RUNTIME,
            "IndexError": ErrorCategory.RUNTIME,
        }
        
        # è¤‡é›‘ãªã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
        self.complex_patterns = {
            "RecursionError": ErrorCategory.LOGIC,
            "MemoryError": ErrorCategory.PERFORMANCE,
            "RuntimeError": ErrorCategory.LOGIC,
            "AssertionError": ErrorCategory.LOGIC,
        }
        
        # è¤‡é›‘åº¦åˆ¤å®šã®é‡ã¿ä»˜ã‘è¦å› 
        self.complexity_factors = {
            "multi_file": 2.0,           # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¾ãŸãŒã‚‹
            "async_code": 1.5,           # éåŒæœŸã‚³ãƒ¼ãƒ‰
            "class_hierarchy": 1.8,      # ã‚¯ãƒ©ã‚¹éšå±¤ãŒè¤‡é›‘
            "external_dependency": 1.3,  # å¤–éƒ¨ä¾å­˜é–¢ä¿‚
            "database_operation": 1.6,   # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ
            "network_operation": 1.5,    # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ“ä½œ
            "file_operation": 1.2,       # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
            "concurrency": 2.0,          # ä¸¦è¡Œå‡¦ç†
        }
    
    def classify(self, error_context: ErrorContextModel) -> Dict[str, Any]:
        """
        ã‚¨ãƒ©ãƒ¼ã‚’åˆ†é¡
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: åˆ†é¡çµæœ
        """
        try:
            # åŸºæœ¬åˆ†é¡
            error_type = error_context.error_type
            category = self._classify_category(error_type)
            
            # è¤‡é›‘åº¦åˆ¤å®š
            complexity_score = self._calculate_complexity_score(error_context)
            complexity = self._determine_complexity(complexity_score)
            
            # ä¿¡é ¼åº¦è¨ˆç®—
            confidence = self._calculate_confidence(error_context, category, complexity)
            
            # æ¨å¥¨æˆ¦ç•¥
            recommended_strategy = self._recommend_strategy(complexity, confidence)
            
            result = {
                "error_type": error_type,
                "category": category.value,
                "complexity": complexity.value,
                "complexity_score": complexity_score,
                "confidence": confidence,
                "recommended_strategy": recommended_strategy,
                "factors": self._identify_complexity_factors(error_context)
            }
            
            logger.info(
                f"ğŸ“Š ã‚¨ãƒ©ãƒ¼åˆ†é¡: {error_type} â†’ "
                f"{category.value}/{complexity.value} "
                f"(ã‚¹ã‚³ã‚¢={complexity_score:.2f}, ä¿¡é ¼åº¦={confidence:.2f})"
            )
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼åˆ†é¡å¤±æ•—: {e}", exc_info=True)
            
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
            return {
                "error_type": error_context.error_type,
                "category": ErrorCategory.UNKNOWN.value,
                "complexity": ErrorComplexity.MEDIUM.value,
                "complexity_score": 1.0,
                "confidence": 0.5,
                "recommended_strategy": "cloud_first",
                "factors": []
            }
    
    def _classify_category(self, error_type: str) -> ErrorCategory:
        """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªã‚’åˆ†é¡"""
        
        # å˜ç´”ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        if error_type in self.simple_patterns:
            return self.simple_patterns[error_type]
        
        # ä¸­ç¨‹åº¦ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        if error_type in self.medium_patterns:
            return self.medium_patterns[error_type]
        
        # è¤‡é›‘ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        if error_type in self.complex_patterns:
            return self.complex_patterns[error_type]
        
        # ãã®ä»–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        if "Import" in error_type or "Module" in error_type:
            return ErrorCategory.IMPORT
        
        if "Syntax" in error_type or "Indent" in error_type:
            return ErrorCategory.SYNTAX
        
        if "Runtime" in error_type:
            return ErrorCategory.RUNTIME
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return ErrorCategory.UNKNOWN
    
    def _calculate_complexity_score(self, error_context: ErrorContextModel) -> float:
        """è¤‡é›‘åº¦ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—"""
        
        base_score = 1.0
        
        # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹åŸºæœ¬ã‚¹ã‚³ã‚¢
        if error_context.error_type in self.simple_patterns:
            base_score = 0.3
        elif error_context.error_type in self.medium_patterns:
            base_score = 1.0
        elif error_context.error_type in self.complex_patterns:
            base_score = 2.0
        
        # è¤‡é›‘åº¦è¦å› ã‚’é©ç”¨
        factors = self._identify_complexity_factors(error_context)
        
        for factor in factors:
            weight = self.complexity_factors.get(factor, 1.0)
            base_score *= weight
        
        return base_score
    
    def _identify_complexity_factors(self, error_context: ErrorContextModel) -> list:
        """è¤‡é›‘åº¦è¦å› ã‚’ç‰¹å®š"""
        factors = []
        
        # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‹ã‚‰åˆ¤å®š
        code = error_context.surrounding_code or ""
        traceback = error_context.full_traceback or ""
        
        # éåŒæœŸã‚³ãƒ¼ãƒ‰
        if "async " in code or "await " in code:
            factors.append("async_code")
        
        # ã‚¯ãƒ©ã‚¹éšå±¤
        if "class " in code and "super()" in code:
            factors.append("class_hierarchy")
        
        # å¤–éƒ¨ä¾å­˜é–¢ä¿‚
        if "import " in code or "from " in code:
            factors.append("external_dependency")
        
        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œ
        if any(db in code.lower() for db in ["sql", "database", "db.", "cursor", "query"]):
            factors.append("database_operation")
        
        # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ“ä½œ
        if any(net in code.lower() for net in ["http", "request", "socket", "api"]):
            factors.append("network_operation")
        
        # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
        if any(file_op in code.lower() for file_op in ["open(", "file", "read(", "write("]):
            factors.append("file_operation")
        
        # ä¸¦è¡Œå‡¦ç†
        if any(conc in code.lower() for conc in ["thread", "process", "lock", "queue"]):
            factors.append("concurrency")
        
        # è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‹ã‚‰åˆ¤å®šï¼‰
        if traceback:
            file_count = len(set(re.findall(r'File "(.*?)"', traceback)))
            if file_count > 1:
                factors.append("multi_file")
        
        return factors
    
    def _determine_complexity(self, complexity_score: float) -> ErrorComplexity:
        """ã‚¹ã‚³ã‚¢ã‹ã‚‰è¤‡é›‘åº¦ã‚’æ±ºå®š"""
        
        if complexity_score < 0.5:
            return ErrorComplexity.SIMPLE
        elif complexity_score < 1.5:
            return ErrorComplexity.MEDIUM
        else:
            return ErrorComplexity.COMPLEX
    
    def _calculate_confidence(
        self, 
        error_context: ErrorContextModel,
        category: ErrorCategory,
        complexity: ErrorComplexity
    ) -> float:
        """åˆ†é¡ã®ä¿¡é ¼åº¦ã‚’è¨ˆç®—"""
        
        confidence = 0.5  # åŸºæœ¬å€¤
        
        # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ãŒæ—¢çŸ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ä¸€è‡´ã™ã‚‹å ´åˆã¯é«˜ä¿¡é ¼åº¦
        if error_context.error_type in self.simple_patterns or \
           error_context.error_type in self.medium_patterns or \
           error_context.error_type in self.complex_patterns:
            confidence += 0.3
        
        # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ˜ç¢ºãªå ´åˆ
        if error_context.error_message and len(error_context.error_message) > 10:
            confidence += 0.1
        
        # å‘¨è¾ºã‚³ãƒ¼ãƒ‰ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
        if error_context.surrounding_code:
            confidence += 0.1
        
        # ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
        if error_context.full_traceback:
            confidence += 0.05
        
        # ä¿¡é ¼åº¦ã‚’0-1ã«æ­£è¦åŒ–
        return min(confidence, 1.0)
    
    def _recommend_strategy(self, complexity: ErrorComplexity, confidence: float) -> str:
        """æ¨å¥¨æˆ¦ç•¥ã‚’æ±ºå®š"""
        
        if complexity == ErrorComplexity.SIMPLE:
            if confidence > 0.8:
                return "local_only"
            else:
                return "local_first"
        
        elif complexity == ErrorComplexity.MEDIUM:
            if confidence > 0.7:
                return "local_first"
            else:
                return "cloud_first"
        
        else:  # COMPLEX
            if confidence > 0.6:
                return "cloud_first"
            else:
                return "cloud_only"
    
    def print_classification(self, classification: Dict[str, Any]):
        """åˆ†é¡çµæœã‚’è¡¨ç¤º"""
        print("\n" + "=" * 60)
        print("ğŸ“Š ã‚¨ãƒ©ãƒ¼åˆ†é¡çµæœ")
        print("=" * 60)
        print(f"ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: {classification['error_type']}")
        print(f"ã‚«ãƒ†ã‚´ãƒª: {classification['category']}")
        print(f"è¤‡é›‘åº¦: {classification['complexity']} (ã‚¹ã‚³ã‚¢={classification['complexity_score']:.2f})")
        print(f"ä¿¡é ¼åº¦: {classification['confidence']:.1%}")
        print(f"æ¨å¥¨æˆ¦ç•¥: {classification['recommended_strategy']}")
        
        if classification['factors']:
            print("\nè¤‡é›‘åº¦è¦å› :")
            for factor in classification['factors']:
                print(f"  - {factor}")
        
        print("=" * 60 + "\n")


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ†ã‚¹ãƒˆç”¨ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    test_context = ErrorContextModel(
        error_type="ImportError",
        error_message="No module named 'nonexistent_module'",
        surrounding_code="import nonexistent_module",
        full_traceback="Traceback (most recent call last):\n  File \"test.py\", line 1, in <module>\n    import nonexistent_module\nImportError: No module named 'nonexistent_module'"
    )
    
    classifier = ErrorClassifier()
    result = classifier.classify(test_context)
    classifier.print_classification(result)

#error_handler_enhanced.py
"""
error_handler_enhanced.py - è‡ªå¾‹ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©
ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹æ•æ‰ã€æ§‹é€ åŒ–ã€ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ç”Ÿæˆæ©Ÿèƒ½ã‚’æä¾›
"""

import logging
import traceback
import sys
import inspect
from typing import Optional, Dict, Any, List, Tuple
from datetime import datetime
from pathlib import Path
from enum import Enum
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


# ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®šç¾©
class ErrorSeverity(Enum):
    """ã‚¨ãƒ©ãƒ¼ã®æ·±åˆ»åº¦"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ErrorCategory(Enum):
    """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒª"""
    SYNTAX = "syntax"
    IMPORT = "import"
    RUNTIME = "runtime"
    LOGIC = "logic"
    DESIGN = "design"
    PERFORMANCE = "performance"
    SECURITY = "security"
    UNKNOWN = "unknown"


@dataclass
class CodeLocation:
    """ã‚³ãƒ¼ãƒ‰ä½ç½®æƒ…å ±"""
    file_path: str
    line_number: int
    function_name: Optional[str] = None
    class_name: Optional[str] = None


@dataclass
class StackTraceFrame:
    """ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ¬ãƒ¼ãƒ """
    file_path: str
    line_number: int
    function_name: str
    code_context: Optional[str] = None
    local_variables: Optional[Dict[str, Any]] = None


@dataclass
class ErrorContextModel:
    """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«"""
    error_id: str
    timestamp: datetime
    task_id: str
    agent_name: Optional[str] = None
    error_type: str = "UnknownError"
    error_message: Optional[str] = None
    full_traceback: Optional[str] = None
    stack_frames: List[StackTraceFrame] = field(default_factory=list)
    error_location: Optional[CodeLocation] = None
    problematic_code: Optional[str] = None
    surrounding_code: Optional[str] = None
    local_variables: Dict[str, Any] = field(default_factory=dict)
    severity: ErrorSeverity = ErrorSeverity.MEDIUM
    task_description: Optional[str] = None
    task_parameters: Optional[Dict[str, Any]] = None


@dataclass
class BugFixTask:
    """ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯"""
    task_id: str
    original_task_id: str
    error_context: ErrorContextModel
    priority: str = "medium"
    required_role: str = "quick_fix"
    target_files: List[str] = field(default_factory=list)
    status: str = "pending"
    created_at: datetime = field(default_factory=datetime.now)
    assigned_agent: Optional[str] = None


class EnhancedErrorHandler:
    """
    å¼·åŒ–ç‰ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ© - è‡ªå¾‹ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ç”¨
    
    æ©Ÿèƒ½:
    1. ã‚¨ãƒ©ãƒ¼æƒ…å ±ã®è©³ç´°ãªæ•æ‰
    2. ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã®æ§‹é€ åŒ–
    3. ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ§‹ç¯‰
    4. ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã®è‡ªå‹•ç”Ÿæˆ
    """
    
    def __init__(self):
        """åˆæœŸåŒ–"""
        # ãƒ¡ãƒ¢ãƒªãƒãƒƒãƒ•ã‚¡(æœ€æ–°100ä»¶ã®ã‚¨ãƒ©ãƒ¼ã‚’ä¿æŒ)
        self.error_buffer: List[ErrorContextModel] = []
        self.max_buffer_size = 100
        
        # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ã‚¿
        self.error_counter = 0
        
        logger.info("âœ… EnhancedErrorHandler åˆæœŸåŒ–å®Œäº†")
    
    def capture_error(
        self,
        exception: Exception,
        task_id: Optional[str] = None,
        agent_name: Optional[str] = None,
        task_context: Optional[Dict[str, Any]] = None
    ) -> ErrorContextModel:
        """
        ã‚¨ãƒ©ãƒ¼ã‚’æ•æ‰ã—ã¦æ§‹é€ åŒ–ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            exception: æ•æ‰ã•ã‚ŒãŸä¾‹å¤–
            task_id: å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ID
            agent_name: å®Ÿè¡Œä¸­ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå
            task_context: ã‚¿ã‚¹ã‚¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±
            
        Returns:
            ErrorContextModel: æ§‹é€ åŒ–ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
        """
        try:
            # ã‚¨ãƒ©ãƒ¼IDã‚’ç”Ÿæˆ
            self.error_counter += 1
            error_id = f"ERROR_{task_id or 'UNKNOWN'}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{self.error_counter}"
            
            # ã‚¨ãƒ©ãƒ¼å‹ã¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            error_type = type(exception).__name__
            error_message = str(exception)
            
            # ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã®å–å¾—
            exc_type, exc_value, exc_tb = sys.exc_info()
            full_traceback = ''.join(traceback.format_exception(exc_type, exc_value, exc_tb))
            
            # ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ§‹é€ åŒ–
            stack_frames = self._extract_stack_frames(exc_tb) if exc_tb else []
            
            # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿä½ç½®ã®ç‰¹å®š
            error_location = self._extract_error_location(exc_tb) if exc_tb else None
            
            # å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆã‚’å–å¾—
            problematic_code, surrounding_code = self._extract_code_snippets(
                error_location.file_path if error_location else None,
                error_location.line_number if error_location else None
            )
            
            # ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®å–å¾—
            local_vars = self._extract_local_variables(exc_tb) if exc_tb else {}
            
            # æ·±åˆ»åº¦ã‚’åˆ¤å®š
            severity = self._determine_severity(error_type, error_message)
            
            # ErrorContextModelã‚’æ§‹ç¯‰
            error_context = ErrorContextModel(
                error_id=error_id,
                timestamp=datetime.now(),
                task_id=task_id or "UNKNOWN",
                agent_name=agent_name,
                error_type=error_type,
                error_message=error_message,
                full_traceback=full_traceback,
                stack_frames=stack_frames,
                error_location=error_location,
                problematic_code=problematic_code,
                surrounding_code=surrounding_code,
                local_variables=local_vars,
                severity=severity,
                task_description=task_context.get('description') if task_context else None,
                task_parameters=task_context.get('parameters') if task_context else None
            )
            
            # ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ 
            self._add_to_buffer(error_context)
            
            # ãƒ­ã‚°å‡ºåŠ›
            logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼æ•æ‰: {error_id}")
            logger.error(f"   ã‚¿ã‚¤ãƒ—: {error_type}")
            logger.error(f"   ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_message}")
            logger.error(f"   æ·±åˆ»åº¦: {severity.value}")
            
            if error_location:
                logger.error(f"   å ´æ‰€: {error_location.file_path}:{error_location.line_number}")
            
            return error_context
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚¨ãƒ©ãƒ¼æ•æ‰ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å°é™ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            return self._create_minimal_error_context(exception, task_id, agent_name)
    
    def _extract_stack_frames(self, traceback_obj) -> List[StackTraceFrame]:
        """ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ æƒ…å ±ã‚’æŠ½å‡º"""
        frames = []
        
        try:
            tb_list = traceback.extract_tb(traceback_obj)
            
            for frame_summary in tb_list:
                # ã‚³ãƒ¼ãƒ‰æ–‡è„ˆã‚’å–å¾—(å‰å¾Œ1è¡Œ)
                code_context = self._get_code_context(
                    frame_summary.filename,
                    frame_summary.lineno,
                    context_lines=1
                )
                
                frame = StackTraceFrame(
                    file_path=frame_summary.filename,
                    line_number=frame_summary.lineno,
                    function_name=frame_summary.name,
                    code_context=code_context
                )
                frames.append(frame)
        
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¹ã‚¿ãƒƒã‚¯ãƒ•ãƒ¬ãƒ¼ãƒ æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
        
        return frames
    
    def _extract_error_location(self, traceback_obj) -> Optional[CodeLocation]:
        """ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿä½ç½®ã‚’æŠ½å‡º"""
        try:
            tb_list = traceback.extract_tb(traceback_obj)
            
            if not tb_list:
                return None
            
            # æœ€å¾Œã®ãƒ•ãƒ¬ãƒ¼ãƒ (ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿç®‡æ‰€)ã‚’å–å¾—
            last_frame = tb_list[-1]
            
            return CodeLocation(
                file_path=last_frame.filename,
                line_number=last_frame.lineno,
                function_name=last_frame.name
            )
        
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¨ãƒ©ãƒ¼ä½ç½®æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _extract_code_snippets(
        self, 
        file_path: Optional[str], 
        line_number: Optional[int]
    ) -> Tuple[Optional[str], Optional[str]]:
        """å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰ã¨å‘¨è¾ºã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        if not file_path or not line_number:
            return None, None
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            # å•é¡Œã®ã‚ã‚‹è¡Œ(1è¡Œ)
            if 1 <= line_number <= len(lines):
                problematic_code = lines[line_number - 1].rstrip()
            else:
                problematic_code = None
            
            # å‘¨è¾ºã‚³ãƒ¼ãƒ‰(å‰å¾Œ10è¡Œ)
            start_line = max(0, line_number - 11)
            end_line = min(len(lines), line_number + 10)
            surrounding_lines = lines[start_line:end_line]
            
            # è¡Œç•ªå·ä»˜ãã§æ•´å½¢
            surrounding_code = '\n'.join([
                f"{start_line + i + 1:4d} | {line.rstrip()}"
                for i, line in enumerate(surrounding_lines)
            ])
            
            return problematic_code, surrounding_code
        
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚³ãƒ¼ãƒ‰ã‚¹ãƒ‹ãƒšãƒƒãƒˆæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None, None
    
    def _get_code_context(
        self, 
        file_path: str, 
        line_number: int, 
        context_lines: int = 1
    ) -> Optional[str]:
        """æŒ‡å®šè¡Œã®å‰å¾Œã®ã‚³ãƒ¼ãƒ‰ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            start = max(0, line_number - context_lines - 1)
            end = min(len(lines), line_number + context_lines)
            
            context = ''.join(lines[start:end])
            return context.strip()
        
        except:
            return None
    
    def _extract_local_variables(self, traceback_obj) -> Dict[str, Any]:
        """ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®çŠ¶æ…‹ã‚’æŠ½å‡º(å®‰å…¨ã«)"""
        local_vars = {}
        
        try:
            frame = traceback_obj.tb_frame
            
            for var_name, var_value in frame.f_locals.items():
                try:
                    # ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºå¯èƒ½ãªå€¤ã®ã¿ä¿å­˜
                    if isinstance(var_value, (str, int, float, bool, type(None))):
                        local_vars[var_name] = var_value
                    elif isinstance(var_value, (list, tuple, dict)):
                        # è¤‡é›‘ãªæ§‹é€ ã¯æ–‡å­—åˆ—è¡¨ç¾ã«å¤‰æ›
                        local_vars[var_name] = str(var_value)[:200]  # æœ€å¤§200æ–‡å­—
                    else:
                        local_vars[var_name] = f"<{type(var_value).__name__} object>"
                except:
                    local_vars[var_name] = "<unprintable>"
        
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
        
        return local_vars
    
    def _determine_severity(self, error_type: str, error_message: str) -> ErrorSeverity:
        """ã‚¨ãƒ©ãƒ¼ã®æ·±åˆ»åº¦ã‚’åˆ¤å®š"""
        error_lower = (error_type + error_message).lower()
        
        # CRITICAL: ã‚·ã‚¹ãƒ†ãƒ åœæ­¢ãƒ¬ãƒ™ãƒ«
        if any(kw in error_lower for kw in [
            'systemerror', 'memoryerror', 'recursionerror',
            'keyboardinterrupt', 'syntaxerror'
        ]):
            return ErrorSeverity.CRITICAL
        
        # HIGH: æ©Ÿèƒ½ä¸å…¨
        if any(kw in error_lower for kw in [
            'attributeerror', 'importerror', 'modulenotfound',
            'typeerror', 'valueerror'
        ]):
            return ErrorSeverity.HIGH
        
        # MEDIUM: éƒ¨åˆ†çš„ãªå•é¡Œ
        if any(kw in error_lower for kw in [
            'keyerror', 'indexerror', 'filenotfounderror'
        ]):
            return ErrorSeverity.MEDIUM
        
        # LOW: è»½å¾®ãªå•é¡Œ
        return ErrorSeverity.LOW
    
    def _add_to_buffer(self, error_context: ErrorContextModel):
        """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ """
        self.error_buffer.append(error_context)
        
        # ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºåˆ¶é™
        if len(self.error_buffer) > self.max_buffer_size:
            self.error_buffer.pop(0)  # æœ€å¤ã®ã‚¨ãƒ©ãƒ¼ã‚’å‰Šé™¤
    
    def _create_minimal_error_context(
        self,
        exception: Exception,
        task_id: Optional[str],
        agent_name: Optional[str]
    ) -> ErrorContextModel:
        """æœ€å°é™ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)"""
        return ErrorContextModel(
            error_id=f"ERROR_MINIMAL_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            timestamp=datetime.now(),
            task_id=task_id or "UNKNOWN",
            agent_name=agent_name,
            error_type=type(exception).__name__,
            error_message=str(exception),
            full_traceback=traceback.format_exc(),
            severity=ErrorSeverity.MEDIUM
        )
    
    def get_recent_errors(self, count: int = 10) -> List[ErrorContextModel]:
        """æœ€è¿‘ã®ã‚¨ãƒ©ãƒ¼ã‚’å–å¾—"""
        return self.error_buffer[-count:]
    
    def get_error_by_id(self, error_id: str) -> Optional[ErrorContextModel]:
        """IDã§ã‚¨ãƒ©ãƒ¼ã‚’æ¤œç´¢"""
        for error in reversed(self.error_buffer):
            if error.error_id == error_id:
                return error
        return None
    
    def clear_buffer(self):
        """ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢"""
        self.error_buffer.clear()
        logger.info("ğŸ§¹ ã‚¨ãƒ©ãƒ¼ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ")


class TaskErrorHandler:
    """
    ã‚¿ã‚¹ã‚¯å®Ÿè¡Œç”¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ© - ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ç”Ÿæˆæ©Ÿèƒ½ä»˜ã
    """
    
    def __init__(self, error_handler: EnhancedErrorHandler):
        """
        åˆæœŸåŒ–
        
        Args:
            error_handler: EnhancedErrorHandlerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.error_handler = error_handler
        self.bug_fix_tasks: List[BugFixTask] = []
        
        logger.info("âœ… TaskErrorHandler åˆæœŸåŒ–å®Œäº†")
    
    def handle_task_error(
        self,
        exception: Exception,
        task: Dict[str, Any],
        agent_name: Optional[str] = None,
        auto_generate_fix_task: bool = True
    ) -> Optional[BugFixTask]:
        """
        ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã—ã€å¿…è¦ã«å¿œã˜ã¦ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ
        
        Args:
            exception: æ•æ‰ã•ã‚ŒãŸä¾‹å¤–
            task: å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯æƒ…å ±
            agent_name: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå
            auto_generate_fix_task: ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯è‡ªå‹•ç”Ÿæˆãƒ•ãƒ©ã‚°
            
        Returns:
            BugFixTask: ç”Ÿæˆã•ã‚ŒãŸãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯(ç”Ÿæˆã—ãªã„å ´åˆã¯None)
        """
        try:
            task_id = task.get('task_id', 'UNKNOWN')
            
            # ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æ•æ‰
            error_context = self.error_handler.capture_error(
                exception=exception,
                task_id=task_id,
                agent_name=agent_name,
                task_context=task
            )
            
            # è‡ªå‹•ä¿®æ­£ãŒä¸è¦ãªå ´åˆã¯çµ‚äº†
            if not auto_generate_fix_task:
                return None
            
            # è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼ã®ã¿ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ
            if error_context.severity in [ErrorSeverity.CRITICAL, ErrorSeverity.HIGH]:
                bug_fix_task = self._generate_bug_fix_task(error_context, task)
                self.bug_fix_tasks.append(bug_fix_task)
                
                logger.info(f"ğŸ”§ ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ç”Ÿæˆ: {bug_fix_task.task_id}")
                return bug_fix_task
            
            return None
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚¿ã‚¹ã‚¯ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    def _generate_bug_fix_task(
        self,
        error_context: ErrorContextModel,
        original_task: Dict[str, Any]
    ) -> BugFixTask:
        """ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ"""
        
        # ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯IDã‚’ç”Ÿæˆ
        fix_task_id = f"FIX_BUG_{error_context.task_id}_{datetime.now().strftime('%H%M%S')}"
        
        # ä¿®æ­£å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç‰¹å®š
        target_files = []
        if error_context.error_location:
            target_files.append(error_context.error_location.file_path)
        
        bug_fix_task = BugFixTask(
            task_id=fix_task_id,
            original_task_id=error_context.task_id,
            error_context=error_context,
            priority="critical" if error_context.severity == ErrorSeverity.CRITICAL else "high",
            required_role="quick_fix",
            target_files=target_files,
            status="pending"
        )
        
        return bug_fix_task
    
    def get_pending_fix_tasks(self) -> List[BugFixTask]:
        """æœªå‡¦ç†ã®ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å–å¾—"""
        return [task for task in self.bug_fix_tasks if task.status == "pending"]
    
    def get_all_fix_tasks(self) -> List[BugFixTask]:
        """å…¨ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å–å¾—"""
        return self.bug_fix_tasks.copy()


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    # ãƒ†ã‚¹ãƒˆç”¨ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©
    error_handler = EnhancedErrorHandler()
    task_handler = TaskErrorHandler(error_handler)
    
    # ãƒ†ã‚¹ãƒˆç”¨ã®ä¾‹å¤–
    try:
        # æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿ
        result = 1 / 0
    except Exception as e:
        # ã‚¨ãƒ©ãƒ¼ã‚’æ•æ‰
        error_context = error_handler.capture_error(
            exception=e,
            task_id="TEST_TASK_001",
            agent_name="TestAgent",
            task_context={
                "description": "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯",
                "parameters": {"param1": "value1"}
            }
        )
        
        print(f"æ•æ‰ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼: {error_context.error_type}")
        print(f"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_context.error_message}")
        print(f"æ·±åˆ»åº¦: {error_context.severity.value}")
        
        # ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ç”Ÿæˆ
        bug_task = task_handler.handle_task_error(
            exception=e,
            task={"task_id": "TEST_TASK_001", "description": "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯"},
            agent_name="TestAgent"
        )
        
        if bug_task:
            print(f"ç”Ÿæˆã•ã‚ŒãŸä¿®æ­£ã‚¿ã‚¹ã‚¯: {bug_task.task_id}")

#example_usage.py
# example_usage.py
"""
ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹è‡ªå¾‹ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã®ä½¿ç”¨ä¾‹
"""

import asyncio
import logging
from pathlib import Path

# ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from hybrid_fix_orchestrator import HybridFixOrchestrator, FixStrategy
from local_fix_agent import LocalFixAgent
from cloud_fix_agent import CloudFixAgent
from error_classifier import ErrorClassifier
from wp_tester_agent import WPTesterAgent
from github_agent import GitHubAgent
from patch_manager import PatchManager
from cloud_storage_manager import CloudStorageManager

# ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
from data_models import (
    BugFixTask,
    ErrorContextModel,
    ErrorSeverity,
    ErrorCategory,
    create_bug_fix_task_from_exception
)

# ãƒ­ã‚°è¨­å®š
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)


# ========================================
# ä¾‹1: åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•
# ========================================

async def example_1_basic_usage():
    """åŸºæœ¬çš„ãªè‡ªå‹•ä¿®æ­£ã®ä¾‹"""
    
    logger.info("=" * 80)
    logger.info("ä¾‹1: åŸºæœ¬çš„ãªè‡ªå‹•ä¿®æ­£")
    logger.info("=" * 80)
    
    # ã‚³ãƒãƒ³ãƒ‰ãƒ¢ãƒ‹ã‚¿ãƒ¼ï¼ˆä»®ï¼‰
    class DummyCommandMonitor:
        async def execute_command(self, cmd):
            return {"success": True, "stdout": ""}
    
    cmd_monitor = DummyCommandMonitor()
    
    # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
    local_agent = LocalFixAgent(
        command_monitor=cmd_monitor,
        use_local_ai=False  # ã¾ãšã¯ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ã¿
    )
    
    cloud_agent = CloudFixAgent(
        command_monitor=cmd_monitor,
        api_provider="openai",
        model_name="gpt-4o"
    )
    
    classifier = ErrorClassifier()
    
    # ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼åˆæœŸåŒ–
    orchestrator = HybridFixOrchestrator(
        local_agent=local_agent,
        cloud_agent=cloud_agent,
        error_classifier=classifier,
        default_strategy=FixStrategy.ADAPTIVE
    )
    
    # ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½œæˆ
    error_context = ErrorContextModel(
        error_type="AttributeError",
        error_message="'NoneType' object has no attribute 'get'",
        severity=ErrorSeverity.HIGH,
        error_category=ErrorCategory.RUNTIME,
        file_path="wp_agent.py",
        line_number=42,
        surrounding_code="""
def process_data(self, data):
    result = self.fetch_config()
    value = result.get('key')  # â† ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿç®‡æ‰€
    return value
""",
        full_traceback="""
Traceback (most recent call last):
  File "wp_agent.py", line 42, in process_data
    value = result.get('key')
AttributeError: 'NoneType' object has no attribute 'get'
"""
    )
    
    # ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ä½œæˆ
    task = BugFixTask(
        task_id="Example-1-AttributeError-Fix",
        error_context=error_context,
        target_files=["wp_agent.py"],
        priority=8,
        run_tests=False,  # ã“ã®ä¾‹ã§ã¯ãƒ†ã‚¹ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
        create_pr=False
    )
    
    # ä¿®æ­£å®Ÿè¡Œ
    result = await orchestrator.execute_fix_task(task)
    
    # çµæœè¡¨ç¤º
    print("\n" + "=" * 80)
    print("ğŸ”§ ä¿®æ­£çµæœ")
    print("=" * 80)
    print(f"æˆåŠŸ: {result.success}")
    print(f"ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«: {result.modified_files}")
    print(f"ä¿¡é ¼åº¦: {result.confidence_score:.1%}")
    print(f"å®Ÿè¡Œæ™‚é–“: {result.execution_time:.2f}ç§’")
    print(f"ä½¿ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {result.agent_used}")
    
    if result.success:
        print(f"\nğŸ“ ä¿®æ­£ç†ç”±:\n{result.reasoning}")
    else:
        print(f"\nâŒ ã‚¨ãƒ©ãƒ¼: {result.error_message}")
    
    # çµ±è¨ˆè¡¨ç¤º
    orchestrator.print_stats()


# ========================================
# ä¾‹2: ä¾‹å¤–ã‹ã‚‰ã®è‡ªå‹•ä¿®æ­£
# ========================================

async def example_2_exception_handling():
    """å®Ÿè¡Œæ™‚ä¾‹å¤–ã‹ã‚‰ã®è‡ªå‹•ä¿®æ­£"""
    
    logger.info("=" * 80)
    logger.info("ä¾‹2: ä¾‹å¤–ã‹ã‚‰ã®è‡ªå‹•ä¿®æ­£")
    logger.info("=" * 80)
    
    # æ“¬ä¼¼çš„ãªã‚³ãƒ¼ãƒ‰å®Ÿè¡Œ
    try:
        # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã‚³ãƒ¼ãƒ‰
        data = None
        result = data.get('key')  # AttributeErrorç™ºç”Ÿ
    
    except Exception as e:
        logger.info(f"ä¾‹å¤–ã‚’æ•æ‰: {type(e).__name__}: {e}")
        
        # ä¾‹å¤–ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•ç”Ÿæˆ
        task = create_bug_fix_task_from_exception(
            task_id="Example-2-Auto-Generated",
            exception=e,
            file_path="example_code.py",
            line_number=10
        )
        
        # ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼åˆæœŸåŒ–ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        # ... (ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã¯çœç•¥)
        
        logger.info(f"âœ… ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯è‡ªå‹•ç”Ÿæˆ: {task.task_id}")
        logger.info(f"   ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: {task.error_context.error_type}")
        logger.info(f"   é‡è¦åº¦: {task.error_context.severity.value}")


# ========================================
# ä¾‹3: è¤‡æ•°æˆ¦ç•¥ã®æ¯”è¼ƒ
# ========================================

async def example_3_strategy_comparison():
    """ç•°ãªã‚‹æˆ¦ç•¥ã®æ¯”è¼ƒ"""
    
    logger.info("=" * 80)
    logger.info("ä¾‹3: è¤‡æ•°æˆ¦ç•¥ã®æ¯”è¼ƒ")
    logger.info("=" * 80)
    
    # ... (åˆæœŸåŒ–ã¯çœç•¥)
    
    strategies = [
        FixStrategy.LOCAL_ONLY,
        FixStrategy.CLOUD_ONLY,
        FixStrategy.LOCAL_FIRST,
        FixStrategy.PARALLEL
    ]
    
    results = {}
    
    for strategy in strategies:
        logger.info(f"\nğŸ“Š æˆ¦ç•¥ãƒ†ã‚¹ãƒˆ: {strategy.value}")
        
        # ã‚¿ã‚¹ã‚¯ä½œæˆï¼ˆåŒã˜ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼‰
        # task = ... (çœç•¥)
        
        # æˆ¦ç•¥ã‚’æŒ‡å®šã—ã¦å®Ÿè¡Œ
        # result = await orchestrator.execute_fix_task(task, strategy=strategy)
        
        # results[strategy.value] = result
    
    # çµæœæ¯”è¼ƒ
    print("\n" + "=" * 80)
    print("ğŸ“Š æˆ¦ç•¥åˆ¥æ¯”è¼ƒ")
    print("=" * 80)
    print(f"{'æˆ¦ç•¥':<20} {'æˆåŠŸ':<10} {'å®Ÿè¡Œæ™‚é–“':<15} {'ä¿¡é ¼åº¦':<10}")
    print("-" * 80)
    
    for strategy_name, result in results.items():
        print(
            f"{strategy_name:<20} "
            f"{'âœ…' if result.success else 'âŒ':<10} "
            f"{result.execution_time:.2f}ç§’{'':<8} "
            f"{result.confidence_score:.1%}"
        )


# ========================================
# ä¾‹4: GitHubé€£æºä»˜ãå®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
# ========================================

async def example_4_full_workflow_with_github():
    """GitHubé€£æºã‚’å«ã‚€å®Œå…¨ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼"""
    
    logger.info("=" * 80)
    logger.info("ä¾‹4: GitHubé€£æºä»˜ãå®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼")
    logger.info("=" * 80)
    
    # ... (ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–)
    
    # GitHubã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¿½åŠ 
    github_agent = GitHubAgent(
        repo_path=".",
        repo_owner="your-org",
        repo_name="your-repo"
    )
    
    # ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¿½åŠ 
    wp_tester = WPTesterAgent(
        command_monitor=None,  # ä»®
        wp_path="/var/www/html"
    )
    
    # ã‚¿ã‚¹ã‚¯ä½œæˆï¼ˆãƒ†ã‚¹ãƒˆ & PRä½œæˆã‚’æœ‰åŠ¹åŒ–ï¼‰
    # task = BugFixTask(
    #     task_id="Example-4-Full-Workflow",
    #     error_context=...,
    #     target_files=["wp_agent.py"],
    #     run_tests=True,
    #     create_pr=True
    # )
    
    # ä¿®æ­£å®Ÿè¡Œ
    # result = await orchestrator.execute_fix_task(task)
    
    # if result.success:
    #     # GitHub PRä½œæˆ
    #     pr_result = await github_agent.create_full_fix_workflow(
    #         task_id=task.task_id,
    #         modified_files=result.modified_files,
    #         fix_description=result.reasoning
    #     )
    #     
    #     if pr_result["success"]:
    #         logger.info(f"âœ… PRä½œæˆæˆåŠŸ: {pr_result['pr_url']}")


# ========================================
# ä¾‹5: ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸é€£æº
# ========================================

async def example_5_cloud_storage():
    """ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã¨ã®é€£æº"""
    
    logger.info("=" * 80)
    logger.info("ä¾‹5: ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸é€£æº")
    logger.info("=" * 80)
    
    # ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
    storage = CloudStorageManager(
        provider="gcs",  # or "s3", "azure"
        bucket_name="your-bucket",
        auto_sync=True
    )
    
    # ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰ã‹ã‚‰ï¼‰
    try:
        cookies = await storage.read_file("session/cookies.json")
        logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿æˆåŠŸï¼ˆ{len(cookies)}ãƒã‚¤ãƒˆï¼‰")
    except Exception as e:
        logger.error(f"âŒ ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿å¤±æ•—: {e}")
    
    # ä¿®æ­£çµæœã®ä¿å­˜ï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰ã¸ï¼‰
    fix_result_json = '{"success": true, "modified_files": ["wp_agent.py"]}'
    
    try:
        await storage.write_file(
            "fix_results/example_5.json",
            fix_result_json
        )
        logger.info("âœ… ä¿®æ­£çµæœã‚’ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜")
    except Exception as e:
        logger.error(f"âŒ ä¿å­˜å¤±æ•—: {e}")
    
    # çµ±è¨ˆè¡¨ç¤º
    stats = storage.get_stats()
    print(f"\nğŸ“Š ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸çµ±è¨ˆ:")
    print(f"   ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰: {stats['uploads']}å›")
    print(f"   ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰: {stats['downloads']}å›")
    print(f"   ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡: {stats['cache_hit_rate']:.1%}")


# ========================================
# ä¾‹6: ãƒ‘ãƒƒãƒç®¡ç†ã®é«˜åº¦ãªä½¿ç”¨
# ========================================

async def example_6_advanced_patching():
    """ãƒ‘ãƒƒãƒç®¡ç†ã®é«˜åº¦ãªä½¿ç”¨ä¾‹"""
    
    logger.info("=" * 80)
    logger.info("ä¾‹6: é«˜åº¦ãªãƒ‘ãƒƒãƒç®¡ç†")
    logger.info("=" * 80)
    
    patch_manager = PatchManager(
        backup_dir="./backups/patches",
        max_backups=10
    )
    
    # å®‰å…¨ãªä¿®æ­£é©ç”¨
    original_code = """
def fetch_config(self):
    return self.config_data
"""
    
    fixed_code = """
def fetch_config(self):
    if self.config_data is None:
        self.config_data = self._load_config()
    return self.config_data
"""
    
    # æ¤œè¨¼ä»˜ããƒ‘ãƒƒãƒé©ç”¨
    result = await patch_manager.apply_patch(
        file_path="wp_agent.py",
        new_content=fixed_code,
        strategy=PatchStrategy.REPLACE,
        verify=True  # æ§‹æ–‡ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ
    )
    
    if result["success"]:
        logger.info("âœ… ãƒ‘ãƒƒãƒé©ç”¨æˆåŠŸ")
        logger.info(f"   ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—: {result['backup_path']}")
        
        # å·®åˆ†è¡¨ç¤º
        if result.get("diff"):
            print("\nğŸ“‹ å¤‰æ›´å†…å®¹:")
            print(result["diff"])
    
    # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ
    # rollback_result = await patch_manager.rollback("wp_agent.py")
    
    # çµ±è¨ˆ
    stats = patch_manager.get_stats()
    print(f"\nğŸ“Š ãƒ‘ãƒƒãƒçµ±è¨ˆ:")
    print(f"   æˆåŠŸç‡: {stats['success_rate']:.1%}")
    print(f"   ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯: {stats['rollbacks']}å›")


# ========================================
# ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
# ========================================

async def main():
    """ã™ã¹ã¦ã®ä¾‹ã‚’å®Ÿè¡Œ"""
    
    print("\n" + "ğŸš€ " * 20)
    print("   ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹è‡ªå¾‹ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  - ä½¿ç”¨ä¾‹")
    print("ğŸš€ " * 20 + "\n")
    
    # ä¾‹1: åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•
    await example_1_basic_usage()
    
    # ä¾‹2: ä¾‹å¤–ã‹ã‚‰ã®è‡ªå‹•ä¿®æ­£
    await example_2_exception_handling()
    
    # ä¾‹3: è¤‡æ•°æˆ¦ç•¥ã®æ¯”è¼ƒ
    # await example_3_strategy_comparison()
    
    # ä¾‹4: GitHubé€£æºä»˜ãå®Œå…¨ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
    # await example_4_full_workflow_with_github()
    
    # ä¾‹5: ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸é€£æº
    # await example_5_cloud_storage()
    
    # ä¾‹6: ãƒ‘ãƒƒãƒç®¡ç†ã®é«˜åº¦ãªä½¿ç”¨
    # await example_6_advanced_patching()
    
    print("\n" + "âœ… " * 20)
    print("   ã™ã¹ã¦ã®ä¾‹ãŒå®Œäº†ã—ã¾ã—ãŸ")
    print("âœ… " * 20 + "\n")


if __name__ == "__main__":
    # Windowsç’°å¢ƒã®å ´åˆ
    import sys
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    # å®Ÿè¡Œ
    asyncio.run(main())

#fix_agent.py
# fix_agents/fix_agent.py
"""
ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹
"""

import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class BaseFixAgent(ABC):
    """
    ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åŸºåº•ã‚¯ãƒ©ã‚¹
    
    ã™ã¹ã¦ã®ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆLocal, Cloudï¼‰ã®å…±é€šã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
    """
    
    def __init__(
        self,
        command_monitor=None,
        wp_tester=None,
        **kwargs
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_tester: WordPressTester
            **kwargs: ãã®ä»–ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³
        """
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0
        }
        
        self.agent_name = self.__class__.__name__
        logger.info(f"âœ… {self.agent_name} åˆæœŸåŒ–")
    
    @abstractmethod
    async def execute_bug_fix_task(self, bug_fix_task):
        """
        ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰
        
        Args:
            bug_fix_task: BugFixTask
            
        Returns:
            FixResult: ä¿®æ­£çµæœ
        """
        pass
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_fixes"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_fixes"]
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "agent_name": self.agent_name
        }
    
    def _create_failed_result(
        self,
        task_id: str,
        error_message: str,
        start_time: datetime
    ):
        """å¤±æ•—çµæœã‚’ä½œæˆ"""
        from data_models import FixResult
        
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return FixResult(
            task_id=task_id,
            success=False,
            modified_files=[],
            generated_code="",
            test_passed=False,
            execution_time=execution_time,
            error_message=error_message,
            confidence_score=0.0
        )


# ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
LocalFixAgent = BaseFixAgent
CloudFixAgent = BaseFixAgent

#github_agent.py
# github_agent.py
"""
GitHubé€£æºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
Gitæ“ä½œã¨ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®è‡ªå‹•ä½œæˆ
"""

import asyncio
import logging
import os
import subprocess
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class GitHubAgent:
    """
    GitHubé€£æºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    æ©Ÿèƒ½:
    - Gitæ“ä½œï¼ˆãƒ–ãƒ©ãƒ³ãƒä½œæˆã€ã‚³ãƒŸãƒƒãƒˆã€ãƒ—ãƒƒã‚·ãƒ¥ï¼‰
    - ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®è‡ªå‹•ä½œæˆ
    - ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è‡ªå‹•ç”Ÿæˆ
    - GitHub APIé€£æº
    """
    
    def __init__(
        self,
        repo_path: str = ".",
        github_token: Optional[str] = None,
        repo_owner: Optional[str] = None,
        repo_name: Optional[str] = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            repo_path: ãƒªãƒã‚¸ãƒˆãƒªã®ãƒ‘ã‚¹
            github_token: GitHub Personal Access Token
            repo_owner: ãƒªãƒã‚¸ãƒˆãƒªã‚ªãƒ¼ãƒŠãƒ¼
            repo_name: ãƒªãƒã‚¸ãƒˆãƒªå
        """
        self.repo_path = Path(repo_path)
        self.github_token = github_token or os.getenv("GITHUB_TOKEN")
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        
        # GitHub APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        self.github_api = None
        if self.github_token:
            self._init_github_api()
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_commits": 0,
            "total_prs": 0,
            "successful_prs": 0,
            "failed_prs": 0
        }
        
        logger.info(f"âœ… GitHubAgent åˆæœŸåŒ–å®Œäº† (repo={repo_path})")
    
    def _init_github_api(self):
        """GitHub APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–"""
        try:
            from github import Github
            self.github_api = Github(self.github_token)
            logger.info("âœ… GitHub API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        except ImportError:
            logger.warning("âš ï¸ PyGithub ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚APIæ©Ÿèƒ½ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚")
            self.github_api = None
    
    async def create_fix_branch_and_commit(
        self,
        task_id: str,
        modified_files: List[str],
        commit_message: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        ä¿®æ­£ç”¨ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆã—ã¦ã‚³ãƒŸãƒƒãƒˆ
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            modified_files: ä¿®æ­£ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆ
            commit_message: ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆçœç•¥æ™‚ã¯è‡ªå‹•ç”Ÿæˆï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸŒ¿ ä¿®æ­£ãƒ–ãƒ©ãƒ³ãƒä½œæˆ & ã‚³ãƒŸãƒƒãƒˆ: {task_id}")
            logger.info("=" * 60)
            
            # ãƒ–ãƒ©ãƒ³ãƒåã‚’ç”Ÿæˆ
            branch_name = self._generate_branch_name(task_id)
            
            # ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã‚’ä¿å­˜
            current_branch = await self._get_current_branch()
            logger.info(f"ğŸ“ ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒ: {current_branch}")
            
            # æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ
            create_result = await self._create_branch(branch_name)
            if not create_result["success"]:
                return create_result
            
            logger.info(f"ğŸŒ¿ ãƒ–ãƒ©ãƒ³ãƒä½œæˆæˆåŠŸ: {branch_name}")
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
            stage_result = await self._stage_files(modified_files)
            if not stage_result["success"]:
                await self._checkout_branch(current_branch)
                return stage_result
            
            # ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
            if not commit_message:
                commit_message = self._generate_commit_message(task_id, modified_files)
            
            # ã‚³ãƒŸãƒƒãƒˆ
            commit_result = await self._commit(commit_message)
            if not commit_result["success"]:
                await self._checkout_branch(current_branch)
                return commit_result
            
            self.stats["total_commits"] += 1
            logger.info(f"âœ… ã‚³ãƒŸãƒƒãƒˆæˆåŠŸ: {commit_result['commit_hash']}")
            
            return {
                "success": True,
                "branch_name": branch_name,
                "commit_hash": commit_result["commit_hash"],
                "original_branch": current_branch,
                "commit_message": commit_message
            }
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ–ãƒ©ãƒ³ãƒä½œæˆ/ã‚³ãƒŸãƒƒãƒˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    async def push_and_create_pr(
        self,
        branch_name: str,
        pr_title: Optional[str] = None,
        pr_body: Optional[str] = None,
        base_branch: str = "main"
    ) -> Dict[str, Any]:
        """
        ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒ—ãƒƒã‚·ãƒ¥ã—ã¦ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ
        
        Args:
            branch_name: ãƒ–ãƒ©ãƒ³ãƒå
            pr_title: PRã‚¿ã‚¤ãƒˆãƒ«ï¼ˆçœç•¥æ™‚ã¯è‡ªå‹•ç”Ÿæˆï¼‰
            pr_body: PRæœ¬æ–‡ï¼ˆçœç•¥æ™‚ã¯è‡ªå‹•ç”Ÿæˆï¼‰
            base_branch: ãƒãƒ¼ã‚¸å…ˆãƒ–ãƒ©ãƒ³ãƒ
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸš€ ãƒ—ãƒƒã‚·ãƒ¥ & PRä½œæˆ: {branch_name}")
            logger.info("=" * 60)
            
            self.stats["total_prs"] += 1
            
            # ãƒ—ãƒƒã‚·ãƒ¥
            push_result = await self._push_branch(branch_name)
            if not push_result["success"]:
                self.stats["failed_prs"] += 1
                return push_result
            
            logger.info(f"âœ… ãƒ—ãƒƒã‚·ãƒ¥æˆåŠŸ: {branch_name}")
            
            # ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆä½œæˆ
            if self.github_api and self.repo_owner and self.repo_name:
                # GitHub APIçµŒç”±
                pr_result = await self._create_pr_via_api(
                    branch_name,
                    pr_title,
                    pr_body,
                    base_branch
                )
            else:
                # GitHub CLIçµŒç”±
                pr_result = await self._create_pr_via_cli(
                    branch_name,
                    pr_title,
                    pr_body,
                    base_branch
                )
            
            if pr_result["success"]:
                self.stats["successful_prs"] += 1
                logger.info(f"âœ… PRä½œæˆæˆåŠŸ: {pr_result['pr_url']}")
            else:
                self.stats["failed_prs"] += 1
            
            return pr_result
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ—ãƒƒã‚·ãƒ¥/PRä½œæˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_prs"] += 1
            return {
                "success": False,
                "error": str(e)
            }
    
    async def create_full_fix_workflow(
        self,
        task_id: str,
        modified_files: List[str],
        fix_description: str,
        base_branch: str = "main"
    ) -> Dict[str, Any]:
        """
        å®Œå…¨ãªä¿®æ­£ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œ
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            modified_files: ä¿®æ­£ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«
            fix_description: ä¿®æ­£å†…å®¹ã®èª¬æ˜
            base_branch: ãƒãƒ¼ã‚¸å…ˆãƒ–ãƒ©ãƒ³ãƒ
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ”„ å®Œå…¨ãªä¿®æ­£ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼é–‹å§‹")
            
            # 1. ãƒ–ãƒ©ãƒ³ãƒä½œæˆ & ã‚³ãƒŸãƒƒãƒˆ
            commit_result = await self.create_fix_branch_and_commit(
                task_id,
                modified_files
            )
            
            if not commit_result["success"]:
                return commit_result
            
            branch_name = commit_result["branch_name"]
            
            # 2. ãƒ—ãƒƒã‚·ãƒ¥ & PRä½œæˆ
            pr_title = f"ğŸ”§ Fix: {task_id}"
            pr_body = self._generate_pr_body(
                task_id,
                modified_files,
                fix_description,
                commit_result["commit_hash"]
            )
            
            pr_result = await self.push_and_create_pr(
                branch_name,
                pr_title,
                pr_body,
                base_branch
            )
            
            if pr_result["success"]:
                logger.info("=" * 60)
                logger.info("âœ… å®Œå…¨ãªä¿®æ­£ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æˆåŠŸ")
                logger.info(f"ğŸ“‹ PR URL: {pr_result['pr_url']}")
                logger.info("=" * 60)
            
            return {
                **pr_result,
                "branch_name": branch_name,
                "commit_hash": commit_result["commit_hash"],
                "original_branch": commit_result["original_branch"]
            }
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # Gitæ“ä½œé–¢æ•°
    # ========================================
    
    async def _run_git_command(self, *args) -> Dict[str, Any]:
        """Gitã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ"""
        try:
            cmd = ["git", "-C", str(self.repo_path)] + list(args)
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            stdout_text = stdout.decode('utf-8').strip()
            stderr_text = stderr.decode('utf-8').strip()
            
            success = process.returncode == 0
            
            if not success:
                logger.error(f"âŒ Git ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ©ãƒ¼: {' '.join(args)}")
                logger.error(f"   stderr: {stderr_text}")
            
            return {
                "success": success,
                "stdout": stdout_text,
                "stderr": stderr_text,
                "returncode": process.returncode
            }
            
        except Exception as e:
            logger.error(f"âŒ Git ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _get_current_branch(self) -> str:
        """ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒåã‚’å–å¾—"""
        result = await self._run_git_command("branch", "--show-current")
        return result.get("stdout", "main")
    
    async def _create_branch(self, branch_name: str) -> Dict[str, Any]:
        """æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆã—ã¦ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ"""
        result = await self._run_git_command("checkout", "-b", branch_name)
        return result
    
    async def _checkout_branch(self, branch_name: str) -> Dict[str, Any]:
        """ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ"""
        result = await self._run_git_command("checkout", branch_name)
        return result
    
    async def _stage_files(self, files: List[str]) -> Dict[str, Any]:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°"""
        for file in files:
            result = await self._run_git_command("add", file)
            if not result["success"]:
                return result
        
        return {"success": True}
    
    async def _commit(self, message: str) -> Dict[str, Any]:
        """ã‚³ãƒŸãƒƒãƒˆã‚’ä½œæˆ"""
        result = await self._run_git_command("commit", "-m", message)
        
        if result["success"]:
            # ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ã‚’å–å¾—
            hash_result = await self._run_git_command("rev-parse", "HEAD")
            result["commit_hash"] = hash_result.get("stdout", "")[:8]
        
        return result
    
    async def _push_branch(self, branch_name: str) -> Dict[str, Any]:
        """ãƒ–ãƒ©ãƒ³ãƒã‚’ãƒªãƒ¢ãƒ¼ãƒˆã«ãƒ—ãƒƒã‚·ãƒ¥"""
        result = await self._run_git_command(
            "push",
            "-u",
            "origin",
            branch_name
        )
        return result
    
    # ========================================
    # PRä½œæˆé–¢æ•°
    # ========================================
    
    async def _create_pr_via_api(
        self,
        branch_name: str,
        pr_title: Optional[str],
        pr_body: Optional[str],
        base_branch: str
    ) -> Dict[str, Any]:
        """GitHub APIçµŒç”±ã§PRã‚’ä½œæˆ"""
        try:
            if not self.github_api:
                return {
                    "success": False,
                    "error": "GitHub API client not initialized"
                }
            
            repo = self.github_api.get_repo(f"{self.repo_owner}/{self.repo_name}")
            
            pr = await asyncio.to_thread(
                repo.create_pull,
                title=pr_title or f"Auto-fix: {branch_name}",
                body=pr_body or "Automated bug fix",
                head=branch_name,
                base=base_branch
            )
            
            return {
                "success": True,
                "pr_number": pr.number,
                "pr_url": pr.html_url
            }
            
        except Exception as e:
            logger.error(f"âŒ GitHub API PRä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _create_pr_via_cli(
        self,
        branch_name: str,
        pr_title: Optional[str],
        pr_body: Optional[str],
        base_branch: str
    ) -> Dict[str, Any]:
        """GitHub CLIçµŒç”±ã§PRã‚’ä½œæˆ"""
        try:
            cmd = [
                "gh", "pr", "create",
                "--base", base_branch,
                "--head", branch_name,
                "--title", pr_title or f"Auto-fix: {branch_name}",
                "--body", pr_body or "Automated bug fix"
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.repo_path
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                pr_url = stdout.decode('utf-8').strip()
                return {
                    "success": True,
                    "pr_url": pr_url
                }
            else:
                return {
                    "success": False,
                    "error": stderr.decode('utf-8').strip()
                }
                
        except Exception as e:
            logger.error(f"âŒ GitHub CLI PRä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    # ========================================
    
    def _generate_branch_name(self, task_id: str) -> str:
        """ãƒ–ãƒ©ãƒ³ãƒåã‚’ç”Ÿæˆ"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_task_id = task_id.replace(" ", "_").replace("/", "-")
        return f"auto-fix/{safe_task_id}_{timestamp}"
    
    def _generate_commit_message(
        self,
        task_id: str,
        modified_files: List[str]
    ) -> str:
        """ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è‡ªå‹•ç”Ÿæˆ"""
        file_list = "\n".join(f"  - {f}" for f in modified_files[:5])
        
        if len(modified_files) > 5:
            file_list += f"\n  ... and {len(modified_files) - 5} more files"
        
        return f"""ğŸ”§ Auto-fix: {task_id}

Modified files:
{file_list}

Generated by: HybridFixOrchestrator
Timestamp: {datetime.now().isoformat()}
"""
    
    def _generate_pr_body(
        self,
        task_id: str,
        modified_files: List[str],
        fix_description: str,
        commit_hash: str
    ) -> str:
        """PRæœ¬æ–‡ã‚’è‡ªå‹•ç”Ÿæˆ"""
        file_list = "\n".join(f"- `{f}`" for f in modified_files)
        
        return f"""## ğŸ”§ è‡ªå‹•ä¿®æ­£: {task_id}

### ğŸ“ ä¿®æ­£å†…å®¹
{fix_description}

### ğŸ“‚ å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«
{file_list}

### ğŸ¤– è‡ªå‹•ç”Ÿæˆæƒ…å ±
- **ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥**: `{commit_hash}`
- **ç”Ÿæˆæ—¥æ™‚**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
- **ç”Ÿæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ**: HybridFixOrchestrator

### âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç¢ºèª
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°ï¼ˆå¿…è¦ãªå ´åˆï¼‰

---
*ã“ã®PRã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚ãƒãƒ¼ã‚¸å‰ã«å¿…ãšãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ãã ã•ã„ã€‚*
"""
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        pr_success_rate = 0.0
        if self.stats["total_prs"] > 0:
            pr_success_rate = self.stats["successful_prs"] / self.stats["total_prs"]
        
        return {
            **self.stats,
            "pr_success_rate": pr_success_rate
        }

#hybrid_fix_orchestrator.py
# hybrid_fix_orchestrator.py
"""
ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼
ãƒ­ãƒ¼ã‚«ãƒ«ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚’çµ±æ‹¬ç®¡ç†
"""

import asyncio
import logging
from typing import Dict, Any, Optional
from datetime import datetime
from enum import Enum

from data_models import BugFixTask, FixResult, ErrorContextModel
from local_fix_agent import LocalFixAgent
from cloud_fix_agent import CloudFixAgent
from error_classifier import ErrorClassifier

logger = logging.getLogger(__name__)


class FixStrategy(Enum):
    """ä¿®æ­£æˆ¦ç•¥"""
    LOCAL_ONLY = "local_only"          # ãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿
    CLOUD_ONLY = "cloud_only"          # ã‚¯ãƒ©ã‚¦ãƒ‰ã®ã¿
    LOCAL_FIRST = "local_first"        # ãƒ­ãƒ¼ã‚«ãƒ«å„ªå…ˆ
    CLOUD_FIRST = "cloud_first"        # ã‚¯ãƒ©ã‚¦ãƒ‰å„ªå…ˆ
    PARALLEL = "parallel"              # ä¸¦åˆ—å®Ÿè¡Œ
    ADAPTIVE = "adaptive"              # é©å¿œçš„é¸æŠ


class HybridFixOrchestrator:
    """
    ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼
    
    æ©Ÿèƒ½:
    - ã‚¨ãƒ©ãƒ¼åˆ†é¡ã¨ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
    - ãƒ­ãƒ¼ã‚«ãƒ«/ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã®é¸æŠ
    - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆ¦ç•¥
    - ä¸¦åˆ—å®Ÿè¡Œç®¡ç†
    - çµ±è¨ˆæƒ…å ±ã®åé›†
    """
    
    def __init__(
        self,
        local_agent: LocalFixAgent,
        cloud_agent: CloudFixAgent,
        error_classifier: Optional[ErrorClassifier] = None,
        default_strategy: FixStrategy = FixStrategy.ADAPTIVE
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            local_agent: ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
            cloud_agent: ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
            error_classifier: ã‚¨ãƒ©ãƒ¼åˆ†é¡å™¨
            default_strategy: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæˆ¦ç•¥
        """
        self.local_agent = local_agent
        self.cloud_agent = cloud_agent
        self.error_classifier = error_classifier or ErrorClassifier()
        self.default_strategy = default_strategy
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_tasks": 0,
            "local_fixes": 0,
            "cloud_fixes": 0,
            "hybrid_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0,
            "avg_execution_time": 0.0,
            "strategy_usage": {strategy.value: 0 for strategy in FixStrategy}
        }
        
        # ä¿®æ­£å±¥æ­´
        self.fix_history = []
        
        logger.info(f"âœ… HybridFixOrchestrator åˆæœŸåŒ–å®Œäº† (æˆ¦ç•¥={default_strategy.value})")
    
    async def execute_fix_task(
        self, 
        bug_fix_task: BugFixTask,
        strategy: Optional[FixStrategy] = None
    ) -> FixResult:
        """
        ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            bug_fix_task: ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯
            strategy: ä¿®æ­£æˆ¦ç•¥ï¼ˆçœç•¥æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
            
        Returns:
            FixResult: ä¿®æ­£çµæœ
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        self.stats["total_tasks"] += 1
        
        # æˆ¦ç•¥ã®æ±ºå®š
        selected_strategy = strategy or self.default_strategy
        
        # é©å¿œçš„æˆ¦ç•¥ã®å ´åˆã€ã‚¨ãƒ©ãƒ¼åˆ†æã«åŸºã¥ã„ã¦æ±ºå®š
        if selected_strategy == FixStrategy.ADAPTIVE:
            selected_strategy = await self._select_adaptive_strategy(bug_fix_task.error_context)
        
        self.stats["strategy_usage"][selected_strategy.value] += 1
        
        logger.info("=" * 80)
        logger.info(f"ğŸ¯ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£é–‹å§‹: {task_id}")
        logger.info(f"ğŸ“Š é¸æŠæˆ¦ç•¥: {selected_strategy.value}")
        logger.info("=" * 80)
        
        try:
            # æˆ¦ç•¥ã«å¿œã˜ãŸå®Ÿè¡Œ
            if selected_strategy == FixStrategy.LOCAL_ONLY:
                result = await self._execute_local_only(bug_fix_task)
                
            elif selected_strategy == FixStrategy.CLOUD_ONLY:
                result = await self._execute_cloud_only(bug_fix_task)
                
            elif selected_strategy == FixStrategy.LOCAL_FIRST:
                result = await self._execute_local_first(bug_fix_task)
                
            elif selected_strategy == FixStrategy.CLOUD_FIRST:
                result = await self._execute_cloud_first(bug_fix_task)
                
            elif selected_strategy == FixStrategy.PARALLEL:
                result = await self._execute_parallel(bug_fix_task)
                
            else:
                result = await self._execute_local_first(bug_fix_task)
            
            # çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
            if result.success:
                self.stats["successful_fixes"] += 1
            else:
                self.stats["failed_fixes"] += 1
            
            execution_time = (datetime.now() - start_time).total_seconds()
            self._update_avg_execution_time(execution_time)
            
            # å±¥æ­´ã«è¿½åŠ 
            self.fix_history.append({
                "task_id": task_id,
                "timestamp": datetime.now().isoformat(),
                "strategy": selected_strategy.value,
                "success": result.success,
                "execution_time": execution_time,
                "agent_used": result.agent_used if hasattr(result, 'agent_used') else "unknown"
            })
            
            logger.info(f"{'âœ…' if result.success else 'âŒ'} ä¿®æ­£{'æˆåŠŸ' if result.success else 'å¤±æ•—'}: {task_id} ({execution_time:.2f}ç§’)")
            
            return result
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ä¿®æ­£å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_fixes"] += 1
            
            return FixResult(
                task_id=task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=(datetime.now() - start_time).total_seconds(),
                error_message=str(e)
            )
    
    async def _select_adaptive_strategy(self, error_context: ErrorContextModel) -> FixStrategy:
        """
        ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«åŸºã¥ã„ã¦é©å¿œçš„ã«æˆ¦ç•¥ã‚’é¸æŠ
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            FixStrategy: é¸æŠã•ã‚ŒãŸæˆ¦ç•¥
        """
        # ã‚¨ãƒ©ãƒ¼åˆ†é¡
        classification = self.error_classifier.classify(error_context)
        
        complexity = classification.get("complexity", "medium")
        error_type = classification.get("error_type", "unknown")
        confidence = classification.get("confidence", 0.5)
        
        logger.info(f"ğŸ“Š ã‚¨ãƒ©ãƒ¼åˆ†é¡: è¤‡é›‘åº¦={complexity}, ã‚¿ã‚¤ãƒ—={error_type}, ä¿¡é ¼åº¦={confidence:.2f}")
        
        # è¤‡é›‘åº¦ã«åŸºã¥ãæˆ¦ç•¥é¸æŠ
        if complexity == "simple":
            # å˜ç´”ãªã‚¨ãƒ©ãƒ¼ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã§è¿…é€Ÿã«å‡¦ç†
            return FixStrategy.LOCAL_FIRST
            
        elif complexity == "medium":
            # ä¸­ç¨‹åº¦ã®è¤‡é›‘ã•ã¯ãƒ­ãƒ¼ã‚«ãƒ«å„ªå…ˆã€å¤±æ•—æ™‚ã‚¯ãƒ©ã‚¦ãƒ‰
            if confidence > 0.7:
                return FixStrategy.LOCAL_FIRST
            else:
                return FixStrategy.CLOUD_FIRST
                
        else:  # complex
            # è¤‡é›‘ãªã‚¨ãƒ©ãƒ¼ã¯æœ€åˆã‹ã‚‰ã‚¯ãƒ©ã‚¦ãƒ‰
            if error_type in ["design_flaw", "architectural", "multi_file"]:
                return FixStrategy.CLOUD_ONLY
            else:
                return FixStrategy.CLOUD_FIRST
    
    async def _execute_local_only(self, bug_fix_task: BugFixTask) -> FixResult:
        """ãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿ã§å®Ÿè¡Œ"""
        logger.info("ğŸ’» ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£å®Ÿè¡Œ")
        self.stats["local_fixes"] += 1
        result = await self.local_agent.execute_bug_fix_task(bug_fix_task)
        result.agent_used = "local"
        return result
    
    async def _execute_cloud_only(self, bug_fix_task: BugFixTask) -> FixResult:
        """ã‚¯ãƒ©ã‚¦ãƒ‰ã®ã¿ã§å®Ÿè¡Œ"""
        logger.info("â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£å®Ÿè¡Œ")
        self.stats["cloud_fixes"] += 1
        result = await self.cloud_agent.execute_bug_fix_task(bug_fix_task)
        result.agent_used = "cloud"
        return result
    
    async def _execute_local_first(self, bug_fix_task: BugFixTask) -> FixResult:
        """ãƒ­ãƒ¼ã‚«ãƒ«å„ªå…ˆã€å¤±æ•—æ™‚ã‚¯ãƒ©ã‚¦ãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        logger.info("ğŸ’» ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚’è©¦è¡Œ")
        self.stats["local_fixes"] += 1
        
        local_result = await self.local_agent.execute_bug_fix_task(bug_fix_task)
        
        if local_result.success and local_result.confidence_score >= 0.7:
            logger.info("âœ… ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£æˆåŠŸ")
            local_result.agent_used = "local"
            return local_result
        
        logger.warning("âš ï¸ ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ä¸ååˆ†ã€ã‚¯ãƒ©ã‚¦ãƒ‰ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
        logger.info("â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£å®Ÿè¡Œ")
        self.stats["cloud_fixes"] += 1
        self.stats["hybrid_fixes"] += 1
        
        cloud_result = await self.cloud_agent.execute_bug_fix_task(bug_fix_task)
        cloud_result.agent_used = "hybrid_local_then_cloud"
        
        return cloud_result
    
    async def _execute_cloud_first(self, bug_fix_task: BugFixTask) -> FixResult:
        """ã‚¯ãƒ©ã‚¦ãƒ‰å„ªå…ˆã€å¤±æ•—æ™‚ãƒ­ãƒ¼ã‚«ãƒ«ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯"""
        logger.info("â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚’è©¦è¡Œ")
        self.stats["cloud_fixes"] += 1
        
        cloud_result = await self.cloud_agent.execute_bug_fix_task(bug_fix_task)
        
        if cloud_result.success:
            logger.info("âœ… ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£æˆåŠŸ")
            cloud_result.agent_used = "cloud"
            return cloud_result
        
        logger.warning("âš ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£å¤±æ•—ã€ãƒ­ãƒ¼ã‚«ãƒ«ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯")
        logger.info("ğŸ’» ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£å®Ÿè¡Œ")
        self.stats["local_fixes"] += 1
        self.stats["hybrid_fixes"] += 1
        
        local_result = await self.local_agent.execute_bug_fix_task(bug_fix_task)
        local_result.agent_used = "hybrid_cloud_then_local"
        
        return local_result
    
    async def _execute_parallel(self, bug_fix_task: BugFixTask) -> FixResult:
        """ãƒ­ãƒ¼ã‚«ãƒ«ã¨ã‚¯ãƒ©ã‚¦ãƒ‰ã‚’ä¸¦åˆ—å®Ÿè¡Œã—ã€æœ€è‰¯ã®çµæœã‚’é¸æŠ"""
        logger.info("ğŸ”€ ä¸¦åˆ—ä¿®æ­£å®Ÿè¡Œï¼ˆãƒ­ãƒ¼ã‚«ãƒ« & ã‚¯ãƒ©ã‚¦ãƒ‰ï¼‰")
        self.stats["local_fixes"] += 1
        self.stats["cloud_fixes"] += 1
        self.stats["hybrid_fixes"] += 1
        
        # ä¸¦åˆ—å®Ÿè¡Œ
        results = await asyncio.gather(
            self.local_agent.execute_bug_fix_task(bug_fix_task),
            self.cloud_agent.execute_bug_fix_task(bug_fix_task),
            return_exceptions=True
        )
        
        local_result, cloud_result = results
        
        # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        if isinstance(local_result, Exception):
            logger.error(f"âŒ ãƒ­ãƒ¼ã‚«ãƒ«ä¸¦åˆ—å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {local_result}")
            local_result = None
        
        if isinstance(cloud_result, Exception):
            logger.error(f"âŒ ã‚¯ãƒ©ã‚¦ãƒ‰ä¸¦åˆ—å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {cloud_result}")
            cloud_result = None
        
        # æœ€è‰¯ã®çµæœã‚’é¸æŠ
        best_result = self._select_best_result(local_result, cloud_result)
        
        if best_result:
            best_result.agent_used = "parallel"
            logger.info(f"âœ… ä¸¦åˆ—å®Ÿè¡Œå®Œäº†ã€æœ€è‰¯çµæœã‚’é¸æŠï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ={best_result.agent_used}ï¼‰")
            return best_result
        else:
            # ä¸¡æ–¹å¤±æ•—
            logger.error("âŒ ä¸¦åˆ—å®Ÿè¡Œå¤±æ•—ï¼ˆä¸¡ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå¤±æ•—ï¼‰")
            return FixResult(
                task_id=bug_fix_task.task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=0.0,
                error_message="Both local and cloud agents failed",
                agent_used="parallel_failed"
            )
    
    def _select_best_result(
        self, 
        local_result: Optional[FixResult], 
        cloud_result: Optional[FixResult]
    ) -> Optional[FixResult]:
        """
        2ã¤ã®çµæœã‹ã‚‰æœ€è‰¯ã®ã‚‚ã®ã‚’é¸æŠ
        
        Args:
            local_result: ãƒ­ãƒ¼ã‚«ãƒ«çµæœ
            cloud_result: ã‚¯ãƒ©ã‚¦ãƒ‰çµæœ
            
        Returns:
            Optional[FixResult]: æœ€è‰¯ã®çµæœ
        """
        # ã©ã¡ã‚‰ã‹ãŒNoneã®å ´åˆ
        if local_result is None:
            return cloud_result
        if cloud_result is None:
            return local_result
        
        # ä¸¡æ–¹æˆåŠŸã®å ´åˆã€ä¿¡é ¼åº¦ã§æ¯”è¼ƒ
        if local_result.success and cloud_result.success:
            local_score = local_result.confidence_score or 0.5
            cloud_score = cloud_result.confidence_score or 0.5
            
            if cloud_score > local_score:
                logger.info(f"â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰çµæœã‚’é¸æŠï¼ˆä¿¡é ¼åº¦: {cloud_score:.2f} > {local_score:.2f}ï¼‰")
                return cloud_result
            else:
                logger.info(f"ğŸ’» ãƒ­ãƒ¼ã‚«ãƒ«çµæœã‚’é¸æŠï¼ˆä¿¡é ¼åº¦: {local_score:.2f} >= {cloud_score:.2f}ï¼‰")
                return local_result
        
        # ã©ã¡ã‚‰ã‹ä¸€æ–¹ã®ã¿æˆåŠŸ
        if local_result.success:
            logger.info("ğŸ’» ãƒ­ãƒ¼ã‚«ãƒ«çµæœã‚’é¸æŠï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿æˆåŠŸï¼‰")
            return local_result
        if cloud_result.success:
            logger.info("â˜ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰çµæœã‚’é¸æŠï¼ˆã‚¯ãƒ©ã‚¦ãƒ‰ã®ã¿æˆåŠŸï¼‰")
            return cloud_result
        
        # ä¸¡æ–¹å¤±æ•—ã®å ´åˆã€ä¿¡é ¼åº¦ãŒé«˜ã„æ–¹
        local_score = local_result.confidence_score or 0.0
        cloud_score = cloud_result.confidence_score or 0.0
        
        return cloud_result if cloud_score > local_score else local_result
    
    def _update_avg_execution_time(self, execution_time: float):
        """å¹³å‡å®Ÿè¡Œæ™‚é–“ã‚’æ›´æ–°"""
        total = self.stats["total_tasks"]
        current_avg = self.stats["avg_execution_time"]
        self.stats["avg_execution_time"] = (current_avg * (total - 1) + execution_time) / total
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_tasks"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_tasks"]
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "local_agent_stats": self.local_agent.get_stats(),
            "cloud_agent_stats": self.cloud_agent.get_stats()
        }
    
    def print_stats(self):
        """çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("ğŸ“Š ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ çµ±è¨ˆæƒ…å ±")
        print("=" * 80)
        print(f"ç·ã‚¿ã‚¹ã‚¯æ•°: {stats['total_tasks']}")
        print(f"æˆåŠŸæ•°: {stats['successful_fixes']} ({stats['success_rate']:.1%})")
        print(f"å¤±æ•—æ•°: {stats['failed_fixes']}")
        print(f"å¹³å‡å®Ÿè¡Œæ™‚é–“: {stats['avg_execution_time']:.2f}ç§’")
        print(f"\nãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£: {stats['local_fixes']}å›")
        print(f"ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£: {stats['cloud_fixes']}å›")
        print(f"ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£: {stats['hybrid_fixes']}å›")
        print("\næˆ¦ç•¥ä½¿ç”¨çŠ¶æ³:")
        for strategy, count in stats['strategy_usage'].items():
            print(f"  - {strategy}: {count}å›")
        print("=" * 80 + "\n")

#local_fix_agent.py
# local_fix_agent.py
"""
ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
ãƒ­ãƒ¼ã‚«ãƒ«AIã¾ãŸã¯ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã§è¿…é€Ÿãªä¿®æ­£ã‚’å®Ÿè¡Œ
"""

import asyncio
import logging
import re
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

from data_models import BugFixTask, FixResult, ErrorContextModel

logger = logging.getLogger(__name__)


class LocalFixAgent:
    """
    ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ç‰¹å¾´:
    - è¿…é€Ÿãªå‡¦ç†ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«AI or ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼‰
    - ç°¡æ˜“ã‚¨ãƒ©ãƒ¼ã«ç‰¹åŒ–
    - ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å‹•ä½œå¯èƒ½
    - ã‚³ã‚¹ãƒˆåŠ¹ç‡ãŒé«˜ã„
    """
    
    def __init__(
        self,
        command_monitor,
        wp_tester=None,
        use_local_ai: bool = True,
        ai_chat_agent=None  # browser_ai_chat_agentçµŒç”±ã§Gemini/DeepSeek
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_tester: WordPressTester
            use_local_ai: ãƒ­ãƒ¼ã‚«ãƒ«AIä½¿ç”¨ãƒ•ãƒ©ã‚°
            ai_chat_agent: AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        """
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        self.use_local_ai = use_local_ai
        self.ai_chat = ai_chat_agent
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        self.backup_dir = Path("./backups/local_fix")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_fixes": 0,
            "successful_fixes": 0,
            "failed_fixes": 0,
            "rule_based_fixes": 0,
            "ai_based_fixes": 0
        }
        
        # ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³
        self._init_fix_patterns()
        
        logger.info(f"âœ… LocalFixAgent åˆæœŸåŒ–å®Œäº† (AIä½¿ç”¨={'æœ‰åŠ¹' if use_local_ai else 'ç„¡åŠ¹'})")
    
    def _init_fix_patterns(self):
        """ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–"""
        self.fix_patterns = {
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼
            "ImportError": self._fix_import_error,
            "ModuleNotFoundError": self._fix_module_not_found,
            
            # æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
            "SyntaxError": self._fix_syntax_error,
            "IndentationError": self._fix_indentation_error,
            
            # å±æ€§ã‚¨ãƒ©ãƒ¼
            "AttributeError": self._fix_attribute_error,
            
            # åå‰ã‚¨ãƒ©ãƒ¼
            "NameError": self._fix_name_error,
            
            # ã‚¿ã‚¤ãƒ—ã‚¨ãƒ©ãƒ¼
            "TypeError": self._fix_type_error,
            
            # ã‚­ãƒ¼ã‚¨ãƒ©ãƒ¼
            "KeyError": self._fix_key_error,
        }
    
    async def execute_bug_fix_task(self, bug_fix_task: BugFixTask) -> FixResult:
        """
        ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å‡¦ç†ï¼‰
        
        Args:
            bug_fix_task: ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯
            
        Returns:
            FixResult: ä¿®æ­£çµæœ
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ’» ãƒ­ãƒ¼ã‚«ãƒ«ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_id}")
            logger.info("=" * 60)
            
            self.stats["total_fixes"] += 1
            
            error_context = bug_fix_task.error_context
            error_type = error_context.error_type
            
            # 1. ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£ã‚’è©¦è¡Œ
            if error_type in self.fix_patterns:
                logger.info(f"ğŸ”§ ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£ã‚’è©¦è¡Œ: {error_type}")
                rule_result = await self._try_rule_based_fix(bug_fix_task)
                
                if rule_result['success']:
                    self.stats["successful_fixes"] += 1
                    self.stats["rule_based_fixes"] += 1
                    
                    execution_time = (datetime.now() - start_time).total_seconds()
                    logger.info(f"âœ… ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£æˆåŠŸ: {task_id} ({execution_time:.2f}ç§’)")
                    
                    return FixResult(
                        task_id=task_id,
                        success=True,
                        modified_files=bug_fix_task.target_files,
                        generated_code=rule_result['code'],
                        test_passed=True,
                        execution_time=execution_time,
                        confidence_score=0.9,
                        reasoning="Rule-based fix applied successfully"
                    )
            
            # 2. ãƒ­ãƒ¼ã‚«ãƒ«AIä¿®æ­£ã‚’è©¦è¡Œ
            if self.use_local_ai and self.ai_chat:
                logger.info("ğŸ¤– ãƒ­ãƒ¼ã‚«ãƒ«AIä¿®æ­£ã‚’è©¦è¡Œ")
                ai_result = await self._try_ai_based_fix(bug_fix_task)
                
                if ai_result['success']:
                    self.stats["successful_fixes"] += 1
                    self.stats["ai_based_fixes"] += 1
                    
                    execution_time = (datetime.now() - start_time).total_seconds()
                    logger.info(f"âœ… AIä¿®æ­£æˆåŠŸ: {task_id} ({execution_time:.2f}ç§’)")
                    
                    return FixResult(
                        task_id=task_id,
                        success=True,
                        modified_files=bug_fix_task.target_files,
                        generated_code=ai_result['code'],
                        test_passed=ai_result.get('test_passed', False),
                        execution_time=execution_time,
                        confidence_score=ai_result.get('confidence', 0.7),
                        reasoning=ai_result.get('reasoning', '')
                    )
            
            # 3. ä¿®æ­£å¤±æ•—
            self.stats["failed_fixes"] += 1
            execution_time = (datetime.now() - start_time).total_seconds()
            
            logger.warning(f"âš ï¸ ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£å¤±æ•—: {task_id}")
            
            return FixResult(
                task_id=task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=execution_time,
                confidence_score=0.0,
                error_message="No applicable fix found locally"
            )
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_fixes"] += 1
            
            return FixResult(
                task_id=task_id,
                success=False,
                modified_files=[],
                generated_code="",
                test_passed=False,
                execution_time=(datetime.now() - start_time).total_seconds(),
                error_message=str(e)
            )
    
    async def _try_rule_based_fix(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£ã‚’è©¦è¡Œ"""
        error_context = bug_fix_task.error_context
        error_type = error_context.error_type
        
        fix_function = self.fix_patterns.get(error_type)
        if not fix_function:
            return {"success": False, "error": "No fix pattern available"}
        
        try:
            fixed_code = await fix_function(error_context)
            
            if fixed_code:
                # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
                await self._create_backup(bug_fix_task.target_files)
                
                # ä¿®æ­£é©ç”¨
                await self._apply_fix(bug_fix_task.target_files[0], fixed_code)
                
                return {
                    "success": True,
                    "code": fixed_code
                }
            else:
                return {"success": False, "error": "Fix generation failed"}
                
        except Exception as e:
            logger.error(f"âŒ ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _try_ai_based_fix(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """AIä¿®æ­£ã‚’è©¦è¡Œï¼ˆãƒ­ãƒ¼ã‚«ãƒ«AIçµŒç”±ï¼‰"""
        if not self.ai_chat:
            return {"success": False, "error": "AI agent not available"}
        
        try:
            # ä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self._build_fix_prompt(bug_fix_task.error_context)
            
            # AIã«é€ä¿¡
            ai_response = await self.ai_chat.send_prompt_and_wait(prompt)
            
            if not ai_response or "error" in ai_response:
                return {"success": False, "error": "AI response error"}
            
            # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯æŠ½å‡º
            code = self._extract_code_block(ai_response.get("content", ""))
            
            if code:
                # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
                await self._create_backup(bug_fix_task.target_files)
                
                # ä¿®æ­£é©ç”¨
                await self._apply_fix(bug_fix_task.target_files[0], code)
                
                return {
                    "success": True,
                    "code": code,
                    "confidence": 0.7,
                    "reasoning": "AI-generated fix"
                }
            else:
                return {"success": False, "error": "No code block found in AI response"}
                
        except Exception as e:
            logger.error(f"âŒ AIä¿®æ­£ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    def _build_fix_prompt(self, error_context: ErrorContextModel) -> str:
        """ä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        return f"""ä»¥ä¸‹ã®Pythonã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: {error_context.error_type}
ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_context.error_message}
ãƒ•ã‚¡ã‚¤ãƒ«: {error_context.file_path}:{error_context.line_number}

å‘¨è¾ºã‚³ãƒ¼ãƒ‰:
```python
{error_context.surrounding_code}
```

ä¿®æ­£å¾Œã®å®Œå…¨ãªã‚³ãƒ¼ãƒ‰ã‚’Pythonã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã§è¿”ã—ã¦ãã ã•ã„ã€‚"""
    
    def _extract_code_block(self, text: str) -> Optional[str]:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º"""
        pattern = r'```python\n(.*?)\n```'
        match = re.search(pattern, text, re.DOTALL)
        return match.group(1) if match else None
    
    # ========================================
    # ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ä¿®æ­£é–¢æ•°ç¾¤
    # ========================================
    
    async def _fix_import_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        error_msg = error_context.error_message
        
        # "cannot import name 'X' from 'Y'"ãƒ‘ã‚¿ãƒ¼ãƒ³
        match = re.search(r"cannot import name '(\w+)' from '([\w.]+)'", error_msg)
        if match:
            name, module = match.groups()
            
            # ã‚³ãƒ¼ãƒ‰å–å¾—
            code = error_context.surrounding_code or ""
            
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’ä¿®æ­£
            fixed_code = re.sub(
                rf'from {module} import .*{name}.*',
                f'# Fixed: {name} not available in {module}\n# from {module} import {name}',
                code
            )
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_module_not_found(self, error_context: ErrorContextModel) -> Optional[str]:
        """ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æœªæ¤œå‡ºã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        error_msg = error_context.error_message
        
        # "No module named 'X'"ãƒ‘ã‚¿ãƒ¼ãƒ³
        match = re.search(r"No module named '([\w.]+)'", error_msg)
        if match:
            module = match.group(1)
            
            code = error_context.surrounding_code or ""
            
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
            fixed_code = re.sub(
                rf'import {module}',
                f'# import {module}  # Module not found',
                code
            )
            fixed_code = re.sub(
                rf'from {module} import',
                f'# from {module} import  # Module not found',
                fixed_code
            )
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_syntax_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        code = error_context.surrounding_code or ""
        line_no = error_context.line_number
        
        lines = code.split('\n')
        if line_no and 0 < line_no <= len(lines):
            error_line = lines[line_no - 1]
            
            # ã‚ˆãã‚ã‚‹æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³
            fixes = [
                (r':\s*$', ':  # Fixed missing colon'),
                (r'\)\s*$', ')  # Fixed missing parenthesis'),
                (r']\s*$', ']  # Fixed missing bracket'),
            ]
            
            for pattern, replacement in fixes:
                if re.search(pattern, error_line):
                    lines[line_no - 1] = re.sub(pattern, replacement, error_line)
                    return '\n'.join(lines)
        
        return None
    
    async def _fix_indentation_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        code = error_context.surrounding_code or ""
        
        # ã‚¿ãƒ–ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«çµ±ä¸€
        fixed_code = code.replace('\t', '    ')
        
        return fixed_code if fixed_code != code else None
    
    async def _fix_attribute_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """å±æ€§ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        error_msg = error_context.error_message
        
        # "'X' object has no attribute 'Y'"ãƒ‘ã‚¿ãƒ¼ãƒ³
        match = re.search(r"'(\w+)' object has no attribute '(\w+)'", error_msg)
        if match:
            obj_type, attr = match.groups()
            
            code = error_context.surrounding_code or ""
            
            # å±æ€§ã‚¢ã‚¯ã‚»ã‚¹ã‚’hasattr()ã§ãƒ©ãƒƒãƒ—
            pattern = rf'(\w+)\.{attr}'
            replacement = rf"getattr(\1, '{attr}', None)  # Fixed: safe attribute access"
            
            fixed_code = re.sub(pattern, replacement, code)
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_name_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """åå‰ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        error_msg = error_context.error_message
        
        # "name 'X' is not defined"ãƒ‘ã‚¿ãƒ¼ãƒ³
        match = re.search(r"name '(\w+)' is not defined", error_msg)
        if match:
            var_name = match.group(1)
            
            code = error_context.surrounding_code or ""
            
            # å¤‰æ•°ã‚’å®šç¾©
            lines = code.split('\n')
            lines.insert(0, f"{var_name} = None  # Fixed: undefined variable")
            
            return '\n'.join(lines)
        
        return None
    
    async def _fix_type_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """ã‚¿ã‚¤ãƒ—ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        # ç°¡æ˜“çš„ãªå¯¾å¿œ: Noneãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
        code = error_context.surrounding_code or ""
        
        # NoneTypeã‚¨ãƒ©ãƒ¼ã®å ´åˆ
        if "NoneType" in error_context.error_message:
            # æœ€åˆã®é–¢æ•°/ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ã«Noneãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
            pattern = r'(\w+)\('
            replacement = r'(\1 if \1 is not None else lambda *a, **k: None)('
            
            fixed_code = re.sub(pattern, replacement, code, count=1)
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    async def _fix_key_error(self, error_context: ErrorContextModel) -> Optional[str]:
        """ã‚­ãƒ¼ã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
        error_msg = error_context.error_message
        
        # KeyError: 'X'ãƒ‘ã‚¿ãƒ¼ãƒ³
        match = re.search(r"KeyError: '(\w+)'", error_msg)
        if match:
            key = match.group(1)
            
            code = error_context.surrounding_code or ""
            
            # è¾æ›¸ã‚¢ã‚¯ã‚»ã‚¹ã‚’.get()ã«å¤‰æ›´
            pattern = rf'\[[\'"]{key}[\'"]\]'
            replacement = rf".get('{key}', None)  # Fixed: safe key access"
            
            fixed_code = re.sub(pattern, replacement, code)
            
            return fixed_code if fixed_code != code else None
        
        return None
    
    # ========================================
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    # ========================================
    
    async def _create_backup(self, target_files: List[str]) -> Path:
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_subdir = self.backup_dir / timestamp
        backup_subdir.mkdir(parents=True, exist_ok=True)
        
        for file_path in target_files:
            src = Path(file_path)
            if src.exists():
                dst = backup_subdir / src.name
                await asyncio.to_thread(dst.write_text, src.read_text(encoding='utf-8'))
        
        return backup_subdir
    
    async def _apply_fix(self, file_path: str, code: str):
        """ä¿®æ­£ã‚’é©ç”¨"""
        target = Path(file_path)
        await asyncio.to_thread(target.write_text, code, encoding='utf-8')
        logger.info(f"âœ… ä¿®æ­£é©ç”¨: {file_path}")
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_fixes"] > 0:
            success_rate = self.stats["successful_fixes"] / self.stats["total_fixes"]
        
        return {
            **self.stats,
            "success_rate": success_rate
        }

#log_analyzer.py
"""
LogAnalyzer - ãƒ­ã‚°åˆ†æã¨ç•°å¸¸æ¤œçŸ¥ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ãƒ­ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æã€ç•°å¸¸ãªãƒ­ã‚°ã®æ¤œå‡ºã€ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› åˆ†æã€
ãƒ­ã‚°é›†ç´„ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã€ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æã‚’æä¾›ã™ã‚‹ã€‚
"""

import re
import json
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from collections import Counter, deque
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class LogLevel(Enum):
    """ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«"""
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50


@dataclass
class LogEntry:
    """ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒª"""
    timestamp: datetime
    level: LogLevel
    message: str
    source: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "timestamp": self.timestamp.isoformat(),
            "level": self.level.name,
            "message": self.message,
            "source": self.source,
            "metadata": self.metadata
        }


@dataclass
class LogPattern:
    """ãƒ­ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³"""
    pattern: str
    regex: re.Pattern
    level: LogLevel
    frequency: int = 0
    first_seen: datetime = field(default_factory=datetime.now)
    last_seen: datetime = field(default_factory=datetime.now)
    examples: List[str] = field(default_factory=list)
    
    def matches(self, message: str) -> bool:
        return self.regex.search(message) is not None


@dataclass
class Anomaly:
    """ç•°å¸¸æ¤œçŸ¥çµæœ"""
    anomaly_type: str
    severity: str  # low, medium, high, critical
    description: str
    timestamp: datetime
    affected_logs: List[LogEntry]
    recommendation: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "anomaly_type": self.anomaly_type,
            "severity": self.severity,
            "description": self.description,
            "timestamp": self.timestamp.isoformat(),
            "affected_logs_count": len(self.affected_logs),
            "recommendation": self.recommendation
        }


class LogAnalyzerAgent:
    """
    ãƒ­ã‚°åˆ†æã¨ç•°å¸¸æ¤œçŸ¥ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ä¸»ãªæ©Ÿèƒ½:
    1. ãƒ­ã‚°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å­¦ç¿’ã¨åˆ†æ
    2. ç•°å¸¸ãªãƒ­ã‚°ã®è‡ªå‹•æ¤œå‡º
    3. ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› åˆ†æ
    4. ãƒ­ã‚°é›†ç´„ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    5. ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æã¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    """
    
    def __init__(self, 
                 max_log_entries: int = 10000,
                 anomaly_threshold: float = 3.0):
        self.max_log_entries = max_log_entries
        self.anomaly_threshold = anomaly_threshold  # æ¨™æº–åå·®ã®å€æ•°
        
        # ãƒ­ã‚°ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
        self.log_entries: deque = deque(maxlen=max_log_entries)
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ç®¡ç†
        self.known_patterns: List[LogPattern] = []
        self.error_patterns: Dict[str, LogPattern] = {}
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_logs": 0,
            "by_level": Counter(),
            "by_source": Counter(),
            "anomalies_detected": 0
        }
        
        # ç•°å¸¸æ¤œçŸ¥
        self.detected_anomalies: List[Anomaly] = []
        
        # ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆæœŸåŒ–
        self._initialize_error_patterns()
        
        logger.info("LogAnalyzerAgent initialized")
    
    def _initialize_error_patterns(self):
        """ä¸€èˆ¬çš„ãªã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–"""
        patterns = [
            (r"(?i)connection.*(?:refused|timeout|failed)", LogLevel.ERROR, "Connection issues"),
            (r"(?i)out of memory|memory.*overflow", LogLevel.CRITICAL, "Memory issues"),
            (r"(?i)permission denied|access denied", LogLevel.ERROR, "Permission issues"),
            (r"(?i)file not found|no such file", LogLevel.ERROR, "File not found"),
            (r"(?i)syntax error|parse error", LogLevel.ERROR, "Syntax errors"),
            (r"(?i)null pointer|null reference", LogLevel.ERROR, "Null pointer errors"),
            (r"(?i)deadlock|race condition", LogLevel.CRITICAL, "Concurrency issues"),
            (r"(?i)stack overflow|recursion", LogLevel.CRITICAL, "Stack issues"),
            (r"(?i)database.*error|sql.*error", LogLevel.ERROR, "Database errors"),
            (r"(?i)authentication failed|unauthorized", LogLevel.WARNING, "Auth issues")
        ]
        
        for pattern_str, level, description in patterns:
            pattern = LogPattern(
                pattern=description,
                regex=re.compile(pattern_str),
                level=level
            )
            self.error_patterns[description] = pattern
    
    def parse_log_line(self, line: str, source: str = "unknown") -> Optional[LogEntry]:
        """
        ãƒ­ã‚°è¡Œã‚’ãƒ‘ãƒ¼ã‚¹
        
        æ¨™æº–çš„ãªãƒ­ã‚°ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¯¾å¿œ:
        - [YYYY-MM-DD HH:MM:SS] LEVEL: message
        - YYYY-MM-DD HH:MM:SS - LEVEL - message
        - 2024-01-01T12:00:00Z [LEVEL] message
        """
        # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‘ã‚¿ãƒ¼ãƒ³
        timestamp_patterns = [
            r'\[(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})\]',
            r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2})',
            r'(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)'
        ]
        
        timestamp = None
        for pattern in timestamp_patterns:
            match = re.search(pattern, line)
            if match:
                try:
                    timestamp_str = match.group(1)
                    # ISOå½¢å¼ã‚’è©¦ã™
                    if 'T' in timestamp_str:
                        timestamp = datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
                    else:
                        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S')
                    break
                except:
                    continue
        
        if timestamp is None:
            timestamp = datetime.now()
        
        # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®æŠ½å‡º
        level = LogLevel.INFO
        level_match = re.search(r'\b(DEBUG|INFO|WARNING|WARN|ERROR|CRITICAL|FATAL)\b', line, re.IGNORECASE)
        if level_match:
            level_str = level_match.group(1).upper()
            if level_str == 'WARN':
                level_str = 'WARNING'
            elif level_str == 'FATAL':
                level_str = 'CRITICAL'
            level = LogLevel[level_str]
        
        # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æŠ½å‡ºï¼ˆãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®å¾Œã‚ã®éƒ¨åˆ†ï¼‰
        if level_match:
            message = line[level_match.end():].strip()
            # ã‚³ãƒ­ãƒ³ã‚„ãƒã‚¤ãƒ•ãƒ³ã®å¾Œã‚ã‚’å–å¾—
            message = re.sub(r'^[\s:\-]+', '', message)
        else:
            message = line.strip()
        
        return LogEntry(
            timestamp=timestamp,
            level=level,
            message=message,
            source=source
        )
    
    def ingest_log(self, log_entry: LogEntry):
        """ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒªã‚’å–ã‚Šè¾¼ã‚€"""
        self.log_entries.append(log_entry)
        
        # çµ±è¨ˆã‚’æ›´æ–°
        self.stats["total_logs"] += 1
        self.stats["by_level"][log_entry.level.name] += 1
        self.stats["by_source"][log_entry.source] += 1
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        self._match_patterns(log_entry)
        
        # ç•°å¸¸æ¤œçŸ¥
        if log_entry.level in [LogLevel.ERROR, LogLevel.CRITICAL]:
            self._detect_anomalies()
    
    def ingest_log_file(self, filepath: str, source: Optional[str] = None):
        """ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€"""
        if source is None:
            source = Path(filepath).name
        
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                for line in f:
                    line = line.strip()
                    if line:
                        log_entry = self.parse_log_line(line, source)
                        if log_entry:
                            self.ingest_log(log_entry)
            
            logger.info(f"Ingested log file: {filepath} ({self.stats['total_logs']} total logs)")
        except Exception as e:
            logger.error(f"Failed to ingest log file {filepath}: {e}")
    
    def _match_patterns(self, log_entry: LogEntry):
        """ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒªã‚’ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒãƒƒãƒãƒ³ã‚°"""
        for pattern_name, pattern in self.error_patterns.items():
            if pattern.matches(log_entry.message):
                pattern.frequency += 1
                pattern.last_seen = log_entry.timestamp
                
                # ã‚µãƒ³ãƒ—ãƒ«ã‚’ä¿å­˜ï¼ˆæœ€å¤§5ä»¶ï¼‰
                if len(pattern.examples) < 5:
                    pattern.examples.append(log_entry.message[:100])
    
    def _detect_anomalies(self):
        """ç•°å¸¸ã‚’æ¤œå‡º"""
        recent_window = timedelta(minutes=5)
        recent_cutoff = datetime.now() - recent_window
        
        # æœ€è¿‘ã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã‚’å–å¾—
        recent_errors = [
            entry for entry in self.log_entries
            if entry.timestamp >= recent_cutoff and entry.level >= LogLevel.ERROR
        ]
        
        if len(recent_errors) >= 10:  # 5åˆ†é–“ã«10ä»¶ä»¥ä¸Šã®ã‚¨ãƒ©ãƒ¼
            anomaly = Anomaly(
                anomaly_type="high_error_rate",
                severity="high",
                description=f"High error rate detected: {len(recent_errors)} errors in 5 minutes",
                timestamp=datetime.now(),
                affected_logs=recent_errors[-10:],
                recommendation="Investigate recent changes or system issues"
            )
            self.detected_anomalies.append(anomaly)
            self.stats["anomalies_detected"] += 1
            logger.warning(f"Anomaly detected: {anomaly.description}")
    
    def analyze_root_cause(self, error_message: str) -> Dict[str, Any]:
        """
        ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› ã‚’åˆ†æ
        
        Args:
            error_message: ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        
        Returns:
            æ ¹æœ¬åŸå› åˆ†æçµæœ
        """
        # é¡ä¼¼ã‚¨ãƒ©ãƒ¼ã‚’æ¤œç´¢
        similar_errors = []
        for entry in self.log_entries:
            if entry.level >= LogLevel.ERROR:
                similarity = self._calculate_similarity(error_message, entry.message)
                if similarity > 0.7:
                    similar_errors.append((similarity, entry))
        
        # æ™‚ç³»åˆ—åˆ†æï¼ˆã‚¨ãƒ©ãƒ¼ã®å‰ã«ä½•ãŒèµ·ããŸã‹ï¼‰
        context_logs = []
        if similar_errors:
            # æœ€ã‚‚é¡ä¼¼ã—ãŸã‚¨ãƒ©ãƒ¼ã®å‰å¾Œã®ãƒ­ã‚°ã‚’å–å¾—
            _, target_error = max(similar_errors, key=lambda x: x[0])
            target_idx = None
            
            for i, entry in enumerate(self.log_entries):
                if entry == target_error:
                    target_idx = i
                    break
            
            if target_idx is not None:
                # å‰å¾Œ5ä»¶ã®ãƒ­ã‚°ã‚’å–å¾—
                start_idx = max(0, target_idx - 5)
                end_idx = min(len(self.log_entries), target_idx + 1)
                context_logs = list(self.log_entries)[start_idx:end_idx]
        
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        matched_pattern = None
        for pattern_name, pattern in self.error_patterns.items():
            if pattern.matches(error_message):
                matched_pattern = pattern_name
                break
        
        return {
            "error_message": error_message,
            "matched_pattern": matched_pattern,
            "similar_errors_count": len(similar_errors),
            "context_logs": [log.to_dict() for log in context_logs],
            "recommendations": self._generate_recommendations(error_message, matched_pattern)
        }
    
    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """ãƒ†ã‚­ã‚¹ãƒˆã®é¡ä¼¼åº¦ã‚’è¨ˆç®—"""
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())
        
        if not words1 or not words2:
            return 0.0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)
    
    def _generate_recommendations(self, 
                                 error_message: str,
                                 pattern: Optional[str]) -> List[str]:
        """ã‚¨ãƒ©ãƒ¼ã«å¯¾ã™ã‚‹æ¨å¥¨äº‹é …ã‚’ç”Ÿæˆ"""
        recommendations = []
        
        if pattern == "Connection issues":
            recommendations.extend([
                "Check network connectivity",
                "Verify firewall settings",
                "Check if the remote service is running"
            ])
        elif pattern == "Memory issues":
            recommendations.extend([
                "Increase available memory",
                "Check for memory leaks",
                "Optimize resource usage"
            ])
        elif pattern == "Permission issues":
            recommendations.extend([
                "Check file/directory permissions",
                "Verify user has required access rights",
                "Check SELinux or AppArmor policies"
            ])
        elif pattern == "File not found":
            recommendations.extend([
                "Verify file path is correct",
                "Check if file exists",
                "Check file permissions"
            ])
        elif pattern == "Database errors":
            recommendations.extend([
                "Check database connection",
                "Verify SQL syntax",
                "Check database credentials"
            ])
        else:
            recommendations.append("Review the error message and stack trace")
        
        return recommendations
    
    def filter_logs(self,
                   level: Optional[LogLevel] = None,
                   source: Optional[str] = None,
                   time_range: Optional[Tuple[datetime, datetime]] = None,
                   pattern: Optional[str] = None) -> List[LogEntry]:
        """
        ãƒ­ã‚°ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        
        Args:
            level: ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã§ãƒ•ã‚£ãƒ«ã‚¿
            source: ã‚½ãƒ¼ã‚¹ã§ãƒ•ã‚£ãƒ«ã‚¿
            time_range: æ™‚é–“ç¯„å›²ã§ãƒ•ã‚£ãƒ«ã‚¿ (start, end)
            pattern: æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ãƒ•ã‚£ãƒ«ã‚¿
        
        Returns:
            ãƒ•ã‚£ãƒ«ã‚¿ã•ã‚ŒãŸãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒª
        """
        filtered = list(self.log_entries)
        
        if level is not None:
            filtered = [log for log in filtered if log.level == level]
        
        if source is not None:
            filtered = [log for log in filtered if log.source == source]
        
        if time_range is not None:
            start, end = time_range
            filtered = [log for log in filtered if start <= log.timestamp <= end]
        
        if pattern is not None:
            regex = re.compile(pattern, re.IGNORECASE)
            filtered = [log for log in filtered if regex.search(log.message)]
        
        return filtered
    
    def get_error_trend(self, hours: int = 24) -> Dict[str, List[Tuple[datetime, int]]]:
        """
        ã‚¨ãƒ©ãƒ¼ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’å–å¾—
        
        Args:
            hours: éå»ä½•æ™‚é–“åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã‹
        
        Returns:
            æ™‚é–“ã”ã¨ã®ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆ
        """
        cutoff = datetime.now() - timedelta(hours=hours)
        
        # 1æ™‚é–“ã”ã¨ã®ãƒã‚±ãƒƒãƒˆ
        buckets = {}
        for level in [LogLevel.ERROR, LogLevel.CRITICAL]:
            buckets[level.name] = {}
        
        for entry in self.log_entries:
            if entry.timestamp < cutoff:
                continue
            
            if entry.level not in [LogLevel.ERROR, LogLevel.CRITICAL]:
                continue
            
            # æ™‚é–“ã‚’1æ™‚é–“å˜ä½ã«ä¸¸ã‚ã‚‹
            hour_key = entry.timestamp.replace(minute=0, second=0, microsecond=0)
            
            level_buckets = buckets[entry.level.name]
            level_buckets[hour_key] = level_buckets.get(hour_key, 0) + 1
        
        # ã‚½ãƒ¼ãƒˆæ¸ˆã¿ãƒªã‚¹ãƒˆã«å¤‰æ›
        result = {}
        for level_name, level_buckets in buckets.items():
            result[level_name] = sorted(level_buckets.items())
        
        return result
    
    def get_top_errors(self, limit: int = 10) -> List[Tuple[str, int]]:
        """
        é »ç¹ã«ç™ºç”Ÿã™ã‚‹ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å–å¾—
        
        Args:
            limit: å–å¾—ã™ã‚‹ä»¶æ•°
        
        Returns:
            (ãƒ‘ã‚¿ãƒ¼ãƒ³å, é »åº¦) ã®ãƒªã‚¹ãƒˆ
        """
        patterns_with_freq = [
            (name, pattern.frequency)
            for name, pattern in self.error_patterns.items()
            if pattern.frequency > 0
        ]
        
        patterns_with_freq.sort(key=lambda x: x[1], reverse=True)
        
        return patterns_with_freq[:limit]
    
    def generate_summary_report(self) -> Dict[str, Any]:
        """ã‚µãƒãƒªãƒ¼ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ"""
        total = self.stats["total_logs"]
        
        # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«åˆ¥ã®å‰²åˆ
        level_distribution = {}
        for level_name, count in self.stats["by_level"].items():
            level_distribution[level_name] = {
                "count": count,
                "percentage": round(count / total * 100, 2) if total > 0 else 0
            }
        
        # æœ€è¿‘ã®ç•°å¸¸
        recent_anomalies = [
            anomaly.to_dict()
            for anomaly in self.detected_anomalies[-5:]
        ]
        
        # ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³çµ±è¨ˆ
        top_errors = self.get_top_errors(5)
        
        return {
            "summary": {
                "total_logs": total,
                "time_range": {
                    "start": min(log.timestamp for log in self.log_entries).isoformat() if self.log_entries else None,
                    "end": max(log.timestamp for log in self.log_entries).isoformat() if self.log_entries else None
                },
                "anomalies_detected": self.stats["anomalies_detected"]
            },
            "level_distribution": level_distribution,
            "top_errors": [
                {"pattern": name, "frequency": freq}
                for name, freq in top_errors
            ],
            "recent_anomalies": recent_anomalies,
            "sources": dict(self.stats["by_source"])
        }
    
    def export_analysis(self, filepath: str):
        """åˆ†æçµæœã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        report = self.generate_summary_report()
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Analysis exported to {filepath}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        return {
            **self.stats,
            "unique_sources": len(self.stats["by_source"]),
            "patterns_matched": sum(1 for p in self.error_patterns.values() if p.frequency > 0),
            "avg_logs_per_source": self.stats["total_logs"] / len(self.stats["by_source"]) if self.stats["by_source"] else 0
        }


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    analyzer = LogAnalyzerAgent()
    
    # ã‚µãƒ³ãƒ—ãƒ«ãƒ­ã‚°ã‚’ç”Ÿæˆ
    sample_logs = [
        "[2024-01-01 10:00:00] INFO: Application started",
        "[2024-01-01 10:01:00] DEBUG: Processing request",
        "[2024-01-01 10:02:00] ERROR: Connection timeout to database",
        "[2024-01-01 10:03:00] WARNING: Retry attempt 1",
        "[2024-01-01 10:04:00] ERROR: Connection timeout to database",
        "[2024-01-01 10:05:00] CRITICAL: Database connection failed after 3 retries",
        "[2024-01-01 10:06:00] INFO: Switching to backup database",
        "[2024-01-01 10:07:00] ERROR: File not found: /tmp/data.csv",
        "[2024-01-01 10:08:00] ERROR: Permission denied for /var/log/app.log",
    ]
    
    # ãƒ­ã‚°ã‚’å–ã‚Šè¾¼ã‚€
    for log_line in sample_logs:
        entry = analyzer.parse_log_line(log_line, "test_app")
        analyzer.ingest_log(entry)
    
    # ã‚µãƒãƒªãƒ¼ãƒ¬ãƒãƒ¼ãƒˆ
    print("\n=== Summary Report ===")
    report = analyzer.generate_summary_report()
    print(json.dumps(report, indent=2))
    
    # ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› åˆ†æ
    print("\n=== Root Cause Analysis ===")
    root_cause = analyzer.analyze_root_cause("Connection timeout to database")
    print(json.dumps(root_cause, indent=2))
    
    # çµ±è¨ˆæƒ…å ±
    print("\n=== Statistics ===")
    stats = analyzer.get_statistics()
    print(json.dumps(stats, indent=2))
    
    # ãƒˆãƒƒãƒ—ã‚¨ãƒ©ãƒ¼
    print("\n=== Top Errors ===")
    for pattern, freq in analyzer.get_top_errors():
        print(f"{pattern}: {freq} occurrences")


#main_automator.py
import asyncio
import time
import json
from pathlib import Path
from typing import List, Dict, Optional
import logging
from datetime import datetime

# ===== æœ€å„ªå…ˆ: ãƒ­ã‚°è¨­å®šã‚’ä»–ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚ˆã‚Šå‰ã«å®Ÿè¡Œ =====
# config_utilsã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ã¨è‡ªå‹•çš„ã«ãƒ­ã‚°è¨­å®šãŒå®Ÿè¡Œã•ã‚Œã‚‹
from config_utils import config, ErrorHandler, FileNameGenerator, PathManager

# ã“ã‚Œã§ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

logger = logging.getLogger(__name__)

class GeminiAutomator:
    """ãƒ¡ã‚¤ãƒ³ã®Geminiè‡ªå‹•åŒ–ã‚¯ãƒ©ã‚¹ï¼ˆæ‹¡å¼µç‰ˆ:ç”»åƒãƒ»ãƒ†ã‚­ã‚¹ãƒˆä¸¡å¯¾å¿œãƒ»ãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ãƒ»DeepSeekå¯¾å¿œï¼‰"""
    
    def __init__(self, pc_id: int = None, auto_detect_pc_id: bool = True):
        """
        åˆæœŸåŒ–
        
        Args:
            pc_id: æ˜ç¤ºçš„ã«æŒ‡å®šã™ã‚‹PC_IDï¼ˆNoneã®å ´åˆã¯è‡ªå‹•æ¤œå‡ºï¼‰
            auto_detect_pc_id: Trueã®å ´åˆã€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰PC_IDã‚’èª­ã¿å–ã‚‹
        """
        # ã¾ãšã€ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
        default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
        service_account_file = default_service_account if Path(default_service_account).exists() else None
        
        self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
        # PC_IDã®æ±ºå®šï¼ˆå„ªå…ˆé †ä½ï¼‰
        # 1. æ˜ç¤ºçš„ã«æŒ‡å®šã•ã‚ŒãŸpc_id
        # 2. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰èª­ã¿å–ã‚Šï¼ˆauto_detect_pc_id=Trueã®å ´åˆï¼‰
        # 3. ç’°å¢ƒå¤‰æ•°
        # 4. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤(1)
        if pc_id is not None:
            self.pc_id = pc_id
            logger.info(f"PC_IDã‚’æ˜ç¤ºçš„æŒ‡å®šã‹ã‚‰å–å¾—: {self.pc_id}")
        elif auto_detect_pc_id:
            try:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_IDã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ(B12)ã‹ã‚‰å–å¾—: {self.pc_id}")
            except Exception as e:
                logger.warning(f"ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ã®PC_IDå–å¾—ã«å¤±æ•—: {e}")
                import os
                self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
                logger.info(f"PC_IDã‚’ç’°å¢ƒå¤‰æ•°/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰å–å¾—: {self.pc_id}")
        else:
            import os
            self.pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
            logger.info(f"PC_IDã‚’ç’°å¢ƒå¤‰æ•°/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰å–å¾—: {self.pc_id}")
        
        # PCå›ºæœ‰ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
        self.load_pc_configuration()
        self.mode = config.GENERATION_MODE or "image"
        self.service = config.SERVICE_TYPE or "google"
        
        # ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®šï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆB5/B6ã‹ã‚‰å–å¾—ï¼‰
        if self.mode == "text":
            # ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯B6ã®è¨­å®šã‚’ä½¿ç”¨
            if config.DOWNLOAD_TEXT_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_TEXT_FOLDER)
                logger.info(f"ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜å…ˆï¼ˆB6ã‹ã‚‰å–å¾—ï¼‰: {self.download_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_texts"))
                logger.warning(f"B6ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.download_folder}")
        else:
            # ç”»åƒãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯B5ã®è¨­å®šã‚’ä½¿ç”¨
            if config.DOWNLOAD_IMAGE_FOLDER:
                self.download_folder = PathManager.get_safe_path(config.DOWNLOAD_IMAGE_FOLDER)
                logger.info(f"ç”»åƒä¿å­˜å…ˆï¼ˆB5ã‹ã‚‰å–å¾—ï¼‰: {self.download_folder}")
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ­ãƒ¼ã‚«ãƒ«ä¸€æ™‚ãƒ•ã‚©ãƒ«ãƒ€
                base_temp_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate")
                self.download_folder = PathManager.get_safe_path(str(base_temp_folder / "temp_images"))
                logger.warning(f"B5ãŒç©ºã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨: {self.download_folder}")
        
        self.browser_controller = BrowserController(self.download_folder, self.mode, self.service)
        self.credentials: Optional[Dict[str, str]] = None
        self.prompts: List[str] = []
        self.results: List[Dict] = []
        self.generate_unique_filename = lambda idx: FileNameGenerator.generate_unique_filename(idx, mode=self.mode)
    
    def load_pc_configuration(self) -> None:
        """PCå›ºæœ‰ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿"""
        try:
            logger.info(f"PC_ID={self.pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ä¸­...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.SERVICE_ACCOUNT_FILE = settings.get('service_account_file')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = settings.get('generation_mode', 'image')
            config.TEXT_FORMAT = settings.get('text_format', 'txt')
            config.DOWNLOAD_IMAGE_FOLDER = settings.get('download_image_folder')
            config.DOWNLOAD_TEXT_FOLDER = settings.get('download_text_folder')
            config.AGENT_OUTPUT_FOLDER = settings.get('agent_output_folder')
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            # ã‚µãƒ¼ãƒ“ã‚¹ã‚¿ã‚¤ãƒ—ã®å–å¾—
            service_type = settings.get('service_type', '').strip().lower()
            if service_type in ['deepseek', 'google', 'gemini']:
                if service_type == 'gemini':
                    service_type = 'google'
                config.SERVICE_TYPE = service_type
            else:
                config.SERVICE_TYPE = 'google'
        
            logger.info(f"PC_ID={self.pc_id} ã®è¨­å®šèª­ã¿è¾¼ã¿å®Œäº†")
            logger.info(f"  ã‚µãƒ¼ãƒ“ã‚¹: {config.SERVICE_TYPE}")
            logger.info(f"  ãƒ¢ãƒ¼ãƒ‰: {config.GENERATION_MODE}")
            logger.info(f"  ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼: {config.TEXT_FORMAT}")
            logger.info(f"  Browser Data: {config.BROWSER_DATA_DIR}")
            logger.info(f"  ç”»åƒãƒ•ã‚©ãƒ«ãƒ€ (B5): {config.DOWNLOAD_IMAGE_FOLDER}")
            logger.info(f"  ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚©ãƒ«ãƒ€ (B6): {config.DOWNLOAD_TEXT_FOLDER}")
            logger.info(f"  Agentå‡ºåŠ›å…ˆ (B14): {config.AGENT_OUTPUT_FOLDER}")
            logger.info(f"  æœ€å¤§åå¾©å›æ•° (B15): {config.MAX_ITERATIONS}")
            if config.SERVICE_ACCOUNT_FILE and Path(config.SERVICE_ACCOUNT_FILE).exists():
                self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, config.SERVICE_ACCOUNT_FILE)
        except Exception as e:
            ErrorHandler.log_error(e, "PCè¨­å®šèª­ã¿è¾¼ã¿")
            raise
    
    async def initialize(self) -> None:
        """åˆæœŸåŒ–å‡¦ç†"""
        try:
            logger.info("åˆæœŸåŒ–å‡¦ç†é–‹å§‹...")
            if not self.sheets_manager.validate_sheet_structure():
                raise Exception("Google Sheetsã®æ§‹é€ ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“")
            self.credentials = self.sheets_manager.load_credentials_from_sheet(self.pc_id)
            
            # credentialsã‚’browser_controllerã«æ¸¡ã™
            self.browser_controller.credentials = self.credentials
            
            prompt_sheet_name = "prompt_text" if self.mode == "text" else "prompt_text"
            self.prompts = self.sheets_manager.load_prompts_from_sheet(prompt_sheet_name)
            if not self.prompts:
                raise Exception("å‡¦ç†ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒã‚ã‚Šã¾ã›ã‚“")
            await self.browser_controller.setup_browser()
            logger.info("åˆæœŸåŒ–å‡¦ç†å®Œäº†")
        except Exception as e:
            ErrorHandler.log_error(e, "åˆæœŸåŒ–å‡¦ç†")
            raise
    
    async def login_process(self) -> None:
        """ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ï¼ˆã‚µãƒ¼ãƒ“ã‚¹åˆ¥ï¼‰"""
        try:
            logger.info("ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†é–‹å§‹...")
            
            if self.service == "deepseek":
                # DeepSeekã¯Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ãƒ­ã‚°ã‚¤ãƒ³
                logger.info("DeepSeekã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ï¼ˆDeepSeekç”¨ï¼‰")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("Googleãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ãƒ­ã‚°ã‚¤ãƒ³ãŒç¢ºèªã§ãã¾ã›ã‚“ãŒã€å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™")
                else:
                    logger.info("æ—¢ã«Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã§ã™")
                
                await self.browser_controller.navigate_to_deepseek()
            else:
                # Google/Geminiã®å ´åˆ
                logger.info("Geminiã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™")
                is_logged_in = await self.browser_controller.check_google_login_status()
                if not is_logged_in:
                    logger.info("Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
                    logger.info(f"ID: {self.credentials.get('email', 'N/A')}")
                    input("ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    is_logged_in = await self.browser_controller.check_google_login_status()
                    if not is_logged_in:
                        logger.warning("ãƒ­ã‚°ã‚¤ãƒ³ãŒç¢ºèªã§ãã¾ã›ã‚“ãŒã€å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™")
                else:
                    logger.info("æ—¢ã«Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã§ã™")
                
                await self.browser_controller.navigate_to_gemini()
            
            logger.info("ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†å®Œäº†")
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†")
            raise
    
    async def process_single_prompt_image(self, prompt: str, index: int) -> bool:
        """ç”»åƒãƒ¢ãƒ¼ãƒ‰ã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å‡¦ç†"""
        try:
            logger.info(f"\n--- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index}/{len(self.prompts)} ã‚’å‡¦ç†ä¸­ï¼ˆç”»åƒãƒ¢ãƒ¼ãƒ‰ï¼‰---")
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'image'
            }
            try:
                await self.browser_controller.send_prompt(prompt)
                if await self.browser_controller.wait_for_image_generation():
                    filename = await self.browser_controller.download_latest_image(index)
                    if filename:
                        result['status'] = 'success'
                        result['filename'] = filename
                        save_path = self.download_folder / filename
                        logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} ã®å‡¦ç†ã«æˆåŠŸ")
                        logger.info(f"ä¿å­˜å…ˆ: {save_path}")
                        return True
                    else:
                        result['status'] = 'download_failed'
                        result['error'] = 'ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—'
                else:
                    result['status'] = 'generation_failed'
                    result['error'] = 'ç”»åƒç”Ÿæˆã«å¤±æ•—ã¾ãŸã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
            except Exception as e:
                result['status'] = 'error'
                result['error'] = str(e)
                ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†")
            return False
        finally:
            self.results.append(result)
    
    async def process_single_prompt_text(self, prompt: str, index: int, max_retries: int = 2) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å‡¦ç†"""
        try:
            logger.info(f"\n--- ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index}/{len(self.prompts)} ã‚’å‡¦ç†ä¸­ï¼ˆãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼‰---")
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
            result = {
                'index': index, 'prompt': prompt, 'status': 'processing',
                'filename': None, 'timestamp': datetime.now().isoformat(),
                'error': None, 'mode': 'text'
            }
            for attempt in range(1, max_retries + 1):
                try:
                    logger.info(f"è©¦è¡Œ {attempt}/{max_retries}")
                    await self.browser_controller.send_prompt(prompt)
                    if await self.browser_controller.wait_for_text_generation():
                        response_text = await self.browser_controller.extract_latest_text_response()
                        if response_text:
                            # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¿œã˜ã¦ãƒ•ã‚¡ã‚¤ãƒ«åã¨ä¿å­˜å½¢å¼ã‚’å¤‰æ›´
                            text_format = config.TEXT_FORMAT or 'txt'
                            
                            if text_format == 'json':
                                # JSONå½¢å¼
                                filename = self.generate_unique_filename(index)
                                filename = filename.replace('.txt', '.json')
                                json_data = {"response": response_text}
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        json.dump(json_data, f, ensure_ascii=False, indent=2)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"âœ… JSONä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                                        logger.info(f"ä¿å­˜å…ˆ: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {str(e)}'
                                    logger.error(f"JSONä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
                            else:
                                # TXTå½¢å¼ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                                filename = self.generate_unique_filename(index)
                                save_path = self.download_folder / filename
                                try:
                                    with open(save_path, 'w', encoding='utf-8') as f:
                                        f.write(response_text)
                                    if save_path.exists():
                                        file_size = save_path.stat().st_size
                                        result['status'] = 'success'
                                        result['filename'] = filename
                                        logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                                        logger.info(f"ä¿å­˜å…ˆ: {save_path}")
                                        return True
                                except Exception as e:
                                    result['status'] = 'save_failed'
                                    result['error'] = f'ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: {str(e)}'
                                    logger.error(f"ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
                        else:
                            result['status'] = 'extraction_failed'
                            result['error'] = 'ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºã«å¤±æ•—'
                    else:
                        result['status'] = 'generation_failed'
                        result['error'] = 'ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã«å¤±æ•—ã¾ãŸã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                    if attempt < max_retries:
                        logger.info(f"5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await asyncio.sleep(5)
                    else:
                        break
                except Exception as e:
                    result['status'] = 'error'
                    result['error'] = str(e)
                    ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†ï¼ˆè©¦è¡Œ {attempt}ï¼‰")
                    if attempt < max_retries:
                        await asyncio.sleep(5)
                    else:
                        break
            return False
        except Exception as e:
            ErrorHandler.log_error(e, f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {index} å‡¦ç†")
            return False
        finally:
            self.results.append(result)
    
    async def run_automation(self) -> None:
        """è‡ªå‹•åŒ–å‡¦ç†ã®å®Ÿè¡Œ"""
        try:
            logger.info("=== Geminiè‡ªå‹•åŒ–å‡¦ç†ã‚’é–‹å§‹ ===")
            logger.info(f"PC_ID: {self.pc_id}")
            logger.info(f"ãƒ¢ãƒ¼ãƒ‰: {self.mode.upper()}")
            logger.info(f"ä¿å­˜å…ˆ: ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚©ãƒ«ãƒ€")
            logger.info(f"ä¿å­˜ãƒ‘ã‚¹: {self.download_folder.absolute()}")
            await self.initialize()
            await self.login_process()
            if self.browser_controller.page:
                await self.browser_controller.page.screenshot(path="gemini_initial.png")
            successful_count = 0
            failed_prompts = []
            for i, prompt in enumerate(self.prompts, 1):
                try:
                    if self.mode == "text":
                        success = await self.process_single_prompt_text(prompt, i)
                    else:
                        success = await self.process_single_prompt_image(prompt, i)
                    if success:
                        successful_count += 1
                    else:
                        failed_prompts.append(f"{i}: {prompt[:50]}...")
                    if i < len(self.prompts):
                        await asyncio.sleep(8)
                except Exception as e:
                    logger.error(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ {i} ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
                    failed_prompts.append(f"{i}: {prompt[:50]}... (ã‚¨ãƒ©ãƒ¼)")
                    continue
            try:
                self.sheets_manager.save_result_to_sheet(self.results, self.mode)
            except Exception as e:
                logger.warning(f"çµæœã®ã‚·ãƒ¼ãƒˆä¿å­˜ã«å¤±æ•—: {e}")
            self.generate_final_report(successful_count, failed_prompts)
        except Exception as e:
            ErrorHandler.log_error(e, "è‡ªå‹•åŒ–å‡¦ç†ã®é‡å¤§ãªã‚¨ãƒ©ãƒ¼")
            try:
                if self.browser_controller.page:
                    await self.browser_controller.page.screenshot(path="final_error.png")
            except:
                pass
            raise
        finally:
            await self.browser_controller.cleanup()
    
    def generate_final_report(self, successful: int, failed_prompts: list):
        """æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        logger.info(f"\n{'='*50}")
        logger.info("å‡¦ç†å®Œäº†ãƒ¬ãƒãƒ¼ãƒˆ")
        logger.info(f"{'='*50}")
        logger.info(f"PC_ID: {self.pc_id}")
        logger.info(f"ãƒ¢ãƒ¼ãƒ‰: {self.mode.upper()}")
        logger.info(f"æˆåŠŸ: {successful}/{len(self.prompts)} ä»¶")
        logger.info(f"å¤±æ•—: {len(failed_prompts)} ä»¶")
        logger.info(f"æˆåŠŸç‡: {successful/len(self.prompts)*100:.1f}%")
        logger.info(f"ä¿å­˜å…ˆ: {self.download_folder.absolute()}")
        if failed_prompts:
            logger.info("\nå¤±æ•—ã—ãŸãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:")
            for failed in failed_prompts:
                logger.info(f"  - {failed}")

async def main():
    import argparse
    import os
    
    parser = argparse.ArgumentParser(description='Geminiè‡ªå‹•ç”Ÿæˆï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ç‰ˆï¼‰')
    parser.add_argument('--pc-id', type=int, default=None, help='PC_IDã‚’æ˜ç¤ºçš„ã«æŒ‡å®šï¼ˆæŒ‡å®šã—ãªã„å ´åˆã¯ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰è‡ªå‹•å–å¾—ï¼‰')
    parser.add_argument('--no-auto-detect', action='store_true', help='ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰ã®PC_IDè‡ªå‹•å–å¾—ã‚’ç„¡åŠ¹åŒ–')
    args = parser.parse_args()
    
    print("=== Gemini è‡ªå‹•ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¿å­˜ç‰ˆï¼‰===")
    if args.pc_id is not None:
        print(f"PC_ID: {args.pc_id} (æ˜ç¤ºçš„æŒ‡å®š)")
        automator = GeminiAutomator(pc_id=args.pc_id, auto_detect_pc_id=False)
    elif args.no_auto_detect:
        default_pc_id = int(os.getenv('GEMINI_PC_ID', '1'))
        print(f"PC_ID: {default_pc_id} (ç’°å¢ƒå¤‰æ•°/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)")
        automator = GeminiAutomator(pc_id=default_pc_id, auto_detect_pc_id=False)
    else:
        print("PC_ID: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ(B12ã‚»ãƒ«)ã‹ã‚‰è‡ªå‹•å–å¾—")
        automator = GeminiAutomator(auto_detect_pc_id=True)
    
    try:
        await automator.run_automation()
        print("\nå‡¦ç†ãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
    except KeyboardInterrupt:
        print("\nå‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã—ãŸ")
    except Exception as e:
        print(f"\nã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        logger.error(f"ãƒ¡ã‚¤ãƒ³å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")

if __name__ == "__main__":
    asyncio.run(main())

#main_hybrid_fix.py
# main_hybrid_fix.py
"""
ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å‹è‡ªå¾‹ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  - ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ•ã‚¡ã‚¤ãƒ«
æ—¢å­˜ã®MATaskExecutorã¨çµ±åˆ
"""
import sys
from pathlib import Path

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‚’ãƒ‘ã‚¹ã«è¿½åŠ 
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))
import asyncio
import logging
import sys
from typing import Optional, Dict, Any
from pathlib import Path

# æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from task_executor.task_executor_ma import MATaskExecutor
from command_monitor_agent import CommandMonitorAgent
from browser_ai_chat_agent import AIChatAgent
from browser_controller import BrowserController

# æ–°ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from fix_agents.hybrid_fix_orchestrator import HybridFixOrchestrator, FixStrategy
from fix_agents.cloud_fix_agent import CloudFixAgent
from fix_agents.error_classifier import ErrorClassifier
from fix_agents.fix_agent import BaseFixAgent
from wp_tester_agent import WPTesterAgent
from github_agent import GitHubAgent
from fix_agents.patch_manager import PatchManager
from cloud_storage_manager import CloudStorageManager

# ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
from data_models import BugFixTask, ErrorContextModel, ErrorSeverity, ErrorCategory

# è¨­å®š
from config_hybrid import HybridFixConfig

logger = logging.getLogger(__name__)


class HybridFixSystem:
    """
    ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚¯ãƒ©ã‚¹
    
    æ—¢å­˜ã®MATaskExecutorã¨æ–°ã—ã„è‡ªå¾‹ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã‚’çµ±åˆ
    """
    
    def __init__(
        self,
        config: Optional[HybridFixConfig] = None,
        ma_task_executor: Optional[MATaskExecutor] = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            config: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£è¨­å®š
            ma_task_executor: æ—¢å­˜ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
        """
        self.config = config or HybridFixConfig()
        self.ma_executor = ma_task_executor
        
        # å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        self.cmd_monitor = None
        self.browser_controller = None
        self.ai_chat_agent = None
        
        self.local_agent = None
        self.cloud_agent = None
        self.orchestrator = None
        self.wp_tester = None
        self.github_agent = None
        self.patch_manager = None
        self.storage_manager = None
        
        # çµ±è¨ˆæƒ…å ±
        self.system_stats = {
            "start_time": None,
            "total_errors_detected": 0,
            "auto_fixed_errors": 0,
            "manual_intervention_required": 0
        }
        
        logger.info("ğŸš€ HybridFixSystem åˆæœŸåŒ–é–‹å§‹")
    
    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–"""
        try:
            logger.info("=" * 80)
            logger.info("ğŸ”§ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  åˆæœŸåŒ–")
            logger.info("=" * 80)
            
            # 1. æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å–å¾—
            if self.ma_executor:
                self.cmd_monitor = getattr(self.ma_executor, 'cmd_monitor', None)
                self.browser_controller = getattr(self.ma_executor, 'browser_controller', None)
            
            # CommandMonitorãŒãªã„å ´åˆã¯æ–°è¦ä½œæˆ
            if not self.cmd_monitor:
                self.cmd_monitor = CommandMonitorAgent()
                logger.info("âœ… CommandMonitorAgent æ–°è¦ä½œæˆ")
            
            # 2. ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
            self.storage_manager = CloudStorageManager(
                provider=self.config.storage_provider,
                bucket_name=self.config.storage_bucket,
                auto_sync=self.config.auto_sync_storage
            )
            logger.info(f"âœ… CloudStorageManager åˆæœŸåŒ–å®Œäº† (provider={self.config.storage_provider})")
            
            # 3. ãƒ‘ãƒƒãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ–
            self.patch_manager = PatchManager(
                backup_dir=self.config.backup_dir,
                max_backups=self.config.max_backups
            )
            logger.info("âœ… PatchManager åˆæœŸåŒ–å®Œäº†")
            
            # 4. ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            if self.config.enable_auto_tests:
                self.wp_tester = WPTesterAgent(
                    command_monitor=self.cmd_monitor,
                    wp_path=self.config.wp_path
                )
                logger.info("âœ… WPTesterAgent åˆæœŸåŒ–å®Œäº†")
            
            # 5. GitHubã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            if self.config.enable_auto_pr:
                self.github_agent = GitHubAgent(
                    repo_path=self.config.repo_path,
                    repo_owner=self.config.repo_owner,
                    repo_name=self.config.repo_name
                )
                logger.info("âœ… GitHubAgent åˆæœŸåŒ–å®Œäº†")
            
            # 6. AIãƒãƒ£ãƒƒãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«AIç”¨ï¼‰
            if self.browser_controller:
                self.ai_chat_agent = getattr(
                    self.browser_controller, 
                    'ai_chat', 
                    None
                )
            
            # 7. ãƒ­ãƒ¼ã‚«ãƒ«ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            self.local_agent = LocalFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                use_local_ai=self.config.use_local_ai,
                ai_chat_agent=self.ai_chat_agent
            )
            logger.info("âœ… LocalFixAgent åˆæœŸåŒ–å®Œäº†")
            
            # 8. ã‚¯ãƒ©ã‚¦ãƒ‰ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            self.cloud_agent = CloudFixAgent(
                command_monitor=self.cmd_monitor,
                wp_tester=self.wp_tester,
                api_provider=self.config.cloud_provider,
                model_name=self.config.cloud_model
            )
            logger.info(f"âœ… CloudFixAgent åˆæœŸåŒ–å®Œäº† (provider={self.config.cloud_provider})")
            
            # 9. ã‚¨ãƒ©ãƒ¼åˆ†é¡å™¨åˆæœŸåŒ–
            error_classifier = ErrorClassifier()
            logger.info("âœ… ErrorClassifier åˆæœŸåŒ–å®Œäº†")
            
            # 10. ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼åˆæœŸåŒ–
            self.orchestrator = HybridFixOrchestrator(
                local_agent=self.local_agent,
                cloud_agent=self.cloud_agent,
                error_classifier=error_classifier,
                default_strategy=FixStrategy[self.config.default_strategy]
            )
            logger.info(f"âœ… HybridFixOrchestrator åˆæœŸåŒ–å®Œäº† (æˆ¦ç•¥={self.config.default_strategy})")
            
            # ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•æ™‚åˆ»ã‚’è¨˜éŒ²
            from datetime import datetime
            self.system_stats["start_time"] = datetime.now()
            
            logger.info("=" * 80)
            logger.info("âœ… ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  åˆæœŸåŒ–å®Œäº†")
            logger.info("=" * 80)
            
            return True
            
        except Exception as e:
            logger.error(f"ğŸ’¥ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return False
    
    async def handle_error(
        self,
        error: Exception,
        task_id: str,
        file_path: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã—ã¦è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œ
        
        Args:
            error: ç™ºç”Ÿã—ãŸä¾‹å¤–
            task_id: ã‚¿ã‚¹ã‚¯ID
            file_path: ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿãƒ•ã‚¡ã‚¤ãƒ«
            context: è¿½åŠ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: å‡¦ç†çµæœ
        """
        try:
            self.system_stats["total_errors_detected"] += 1
            
            logger.info("=" * 80)
            logger.info(f"ğŸ” ã‚¨ãƒ©ãƒ¼æ¤œå‡º: {task_id}")
            logger.info(f"   ã‚¿ã‚¤ãƒ—: {type(error).__name__}")
            logger.info(f"   ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {str(error)}")
            logger.info("=" * 80)
            
            # 1. ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ
            error_context = self._create_error_context(
                error,
                file_path,
                context
            )
            
            # 2. ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
            bug_fix_task = BugFixTask(
                task_id=f"{task_id}-AutoFix",
                error_context=error_context,
                target_files=[file_path],
                priority=self._calculate_priority(error_context),
                run_tests=self.config.enable_auto_tests,
                create_pr=self.config.enable_auto_pr
            )
            
            logger.info(f"ğŸ“‹ ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ä½œæˆ: {bug_fix_task.task_id}")
            logger.info(f"   å„ªå…ˆåº¦: {bug_fix_task.priority}")
            logger.info(f"   æ·±åˆ»åº¦: {error_context.severity.value}")
            
            # 3. è‡ªå‹•ä¿®æ­£ã‚’å®Ÿè¡Œ
            fix_result = await self.orchestrator.execute_fix_task(bug_fix_task)
            
            # 4. çµæœã‚’è¨˜éŒ²
            if fix_result.success:
                self.system_stats["auto_fixed_errors"] += 1
                logger.info(f"âœ… è‡ªå‹•ä¿®æ­£æˆåŠŸ: {bug_fix_task.task_id}")
                
                # GitHub PRä½œæˆï¼ˆæœ‰åŠ¹ãªå ´åˆï¼‰
                if self.config.enable_auto_pr and self.github_agent:
                    await self._create_fix_pr(bug_fix_task, fix_result)
            
            else:
                self.system_stats["manual_intervention_required"] += 1
                logger.warning(f"âš ï¸ è‡ªå‹•ä¿®æ­£å¤±æ•—ï¼ˆæ‰‹å‹•ä»‹å…¥ãŒå¿…è¦ï¼‰: {bug_fix_task.task_id}")
            
            return {
                "success": fix_result.success,
                "task_id": bug_fix_task.task_id,
                "fix_result": fix_result,
                "requires_manual_intervention": not fix_result.success
            }
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ã‚¨ãƒ©ãƒ¼å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.system_stats["manual_intervention_required"] += 1
            
            return {
                "success": False,
                "error": str(e),
                "requires_manual_intervention": True
            }
    
    def _create_error_context(
        self,
        error: Exception,
        file_path: str,
        context: Optional[Dict[str, Any]]
    ) -> ErrorContextModel:
        """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä½œæˆ"""
        import traceback
        import inspect
        
        # ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’å–å¾—
        tb = traceback.extract_tb(error.__traceback__)
        
        # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿè¡Œç•ªå·
        line_number = None
        if tb:
            line_number = tb[-1].lineno
        
        # å‘¨è¾ºã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆå¯èƒ½ãªå ´åˆï¼‰
        surrounding_code = None
        try:
            if Path(file_path).exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    if line_number:
                        start = max(0, line_number - 6)
                        end = min(len(lines), line_number + 5)
                        surrounding_code = ''.join(lines[start:end])
        except:
            pass
        
        # ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªã‚’æ¨å®š
        error_category = self._infer_error_category(error)
        
        # æ·±åˆ»åº¦ã‚’æ¨å®š
        severity = self._infer_severity(error, error_category)
        
        return ErrorContextModel(
            error_type=type(error).__name__,
            error_message=str(error),
            severity=severity,
            error_category=error_category,
            file_path=file_path,
            line_number=line_number,
            full_traceback=traceback.format_exc(),
            surrounding_code=surrounding_code,
            context_info=context or {}
        )
    
    def _infer_error_category(self, error: Exception) -> ErrorCategory:
        """ã‚¨ãƒ©ãƒ¼ã‚«ãƒ†ã‚´ãƒªã‚’æ¨å®š"""
        error_type = type(error).__name__
        
        if "Import" in error_type or "Module" in error_type:
            return ErrorCategory.IMPORT
        elif "Syntax" in error_type or "Indent" in error_type:
            return ErrorCategory.SYNTAX
        elif error_type in ["AttributeError", "NameError", "TypeError", "KeyError"]:
            return ErrorCategory.RUNTIME
        elif "Recursion" in error_type or "Memory" in error_type:
            return ErrorCategory.PERFORMANCE
        else:
            return ErrorCategory.UNKNOWN
    
    def _infer_severity(
        self,
        error: Exception,
        category: ErrorCategory
    ) -> ErrorSeverity:
        """æ·±åˆ»åº¦ã‚’æ¨å®š"""
        error_type = type(error).__name__
        
        # è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼
        if error_type in ["MemoryError", "RecursionError", "SystemError"]:
            return ErrorSeverity.CRITICAL
        
        # é«˜å„ªå…ˆåº¦
        if category == ErrorCategory.LOGIC or "Runtime" in error_type:
            return ErrorSeverity.HIGH
        
        # ä¸­å„ªå…ˆåº¦
        if category in [ErrorCategory.RUNTIME, ErrorCategory.IMPORT]:
            return ErrorSeverity.MEDIUM
        
        # ä½å„ªå…ˆåº¦
        return ErrorSeverity.LOW
    
    def _calculate_priority(self, error_context: ErrorContextModel) -> int:
        """å„ªå…ˆåº¦ã‚’è¨ˆç®—ï¼ˆ1-10ï¼‰"""
        severity_scores = {
            ErrorSeverity.CRITICAL: 10,
            ErrorSeverity.HIGH: 8,
            ErrorSeverity.MEDIUM: 5,
            ErrorSeverity.LOW: 3
        }
        
        return severity_scores.get(error_context.severity, 5)
    
    async def _create_fix_pr(
        self,
        bug_fix_task: BugFixTask,
        fix_result
    ):
        """ä¿®æ­£ã®PRã‚’ä½œæˆ"""
        try:
            if not self.github_agent:
                return
            
            logger.info("ğŸŒ¿ GitHub PRä½œæˆé–‹å§‹")
            
            pr_result = await self.github_agent.create_full_fix_workflow(
                task_id=bug_fix_task.task_id,
                modified_files=fix_result.modified_files,
                fix_description=fix_result.reasoning or "Automated bug fix"
            )
            
            if pr_result["success"]:
                logger.info(f"âœ… PRä½œæˆæˆåŠŸ: {pr_result['pr_url']}")
                fix_result.pr_url = pr_result["pr_url"]
            else:
                logger.warning(f"âš ï¸ PRä½œæˆå¤±æ•—: {pr_result.get('error')}")
                
        except Exception as e:
            logger.error(f"âŒ PRä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
    
    def get_system_stats(self) -> Dict[str, Any]:
        """ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã‚’å–å¾—"""
        from datetime import datetime
        
        uptime = 0.0
        if self.system_stats["start_time"]:
            uptime = (datetime.now() - self.system_stats["start_time"]).total_seconds()
        
        auto_fix_rate = 0.0
        if self.system_stats["total_errors_detected"] > 0:
            auto_fix_rate = (
                self.system_stats["auto_fixed_errors"] / 
                self.system_stats["total_errors_detected"]
            )
        
        return {
            **self.system_stats,
            "uptime_seconds": uptime,
            "auto_fix_rate": auto_fix_rate,
            "orchestrator_stats": self.orchestrator.get_stats() if self.orchestrator else {},
            "local_agent_stats": self.local_agent.get_stats() if self.local_agent else {},
            "cloud_agent_stats": self.cloud_agent.get_stats() if self.cloud_agent else {}
        }
    
    def print_system_stats(self):
        """ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆã‚’è¡¨ç¤º"""
        stats = self.get_system_stats()
        
        print("\n" + "=" * 80)
        print("ğŸ“Š ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ  çµ±è¨ˆæƒ…å ±")
        print("=" * 80)
        print(f"ç¨¼åƒæ™‚é–“: {stats['uptime_seconds'] / 3600:.1f}æ™‚é–“")
        print(f"\næ¤œå‡ºã‚¨ãƒ©ãƒ¼ç·æ•°: {stats['total_errors_detected']}")
        print(f"è‡ªå‹•ä¿®æ­£æˆåŠŸ: {stats['auto_fixed_errors']}")
        print(f"æ‰‹å‹•ä»‹å…¥å¿…è¦: {stats['manual_intervention_required']}")
        print(f"è‡ªå‹•ä¿®æ­£ç‡: {stats['auto_fix_rate']:.1%}")
        
        if self.orchestrator:
            print("\n" + "-" * 80)
            self.orchestrator.print_stats()
        
        print("=" * 80 + "\n")


async def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    
    # ãƒ­ã‚°è¨­å®š
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # è¨­å®šèª­ã¿è¾¼ã¿
    config = HybridFixConfig()
    
    # ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
    system = HybridFixSystem(config=config)
    
    success = await system.initialize()
    
    if not success:
        logger.error("âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—")
        return 1
    
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    logger.info("\nğŸ§ª ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ç”Ÿæˆã—ã¦è‡ªå‹•ä¿®æ­£ã‚’ãƒ†ã‚¹ãƒˆ")
    
    try:
        # æ„å›³çš„ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã‚‹
        test_data = None
        result = test_data.get('key')  # AttributeError
    
    except Exception as e:
        # ã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã«é€ä¿¡
        handle_result = await system.handle_error(
            error=e,
            task_id="Test-AutoFix-Demo",
            file_path="main_hybrid_fix.py",
            context={"test": True}
        )
        
        logger.info(f"\nå‡¦ç†çµæœ: {handle_result}")
    
    # ã‚·ã‚¹ãƒ†ãƒ çµ±è¨ˆè¡¨ç¤º
    system.print_system_stats()
    
    return 0


if __name__ == "__main__":
    # Windowsç’°å¢ƒå¯¾å¿œ
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    # å®Ÿè¡Œ
    exit_code = asyncio.run(main())
    sys.exit(exit_code)

#metrics_collector.py
"""
MetricsCollector - ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ä¿®æ­£æˆåŠŸç‡ã€å¹³å‡ä¿®æ­£æ™‚é–“ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æã€
æ—¥æ¬¡/é€±æ¬¡/æœˆæ¬¡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆã‚’æä¾›ã™ã‚‹ã€‚
"""

import json
import statistics
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from collections import defaultdict, Counter
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class MetricType(Enum):
    """ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚¿ã‚¤ãƒ—"""
    COUNTER = "counter"  # ç´¯ç©ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
    GAUGE = "gauge"  # ç¾åœ¨å€¤
    HISTOGRAM = "histogram"  # åˆ†å¸ƒ
    TIMER = "timer"  # æ™‚é–“è¨ˆæ¸¬


class ReportPeriod(Enum):
    """ãƒ¬ãƒãƒ¼ãƒˆæœŸé–“"""
    HOURLY = "hourly"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


@dataclass
class MetricEntry:
    """ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚¨ãƒ³ãƒˆãƒª"""
    name: str
    value: float
    type: MetricType
    timestamp: datetime
    tags: Dict[str, str] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "value": self.value,
            "type": self.type.value,
            "timestamp": self.timestamp.isoformat(),
            "tags": self.tags
        }


@dataclass
class PerformanceStats:
    """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ"""
    total_count: int = 0
    success_count: int = 0
    failure_count: int = 0
    avg_duration: float = 0.0
    min_duration: float = float('inf')
    max_duration: float = 0.0
    percentile_50: float = 0.0
    percentile_95: float = 0.0
    percentile_99: float = 0.0
    
    @property
    def success_rate(self) -> float:
        return self.success_count / self.total_count if self.total_count > 0 else 0.0
    
    @property
    def failure_rate(self) -> float:
        return self.failure_count / self.total_count if self.total_count > 0 else 0.0


class MetricsCollectorAgent:
    """
    ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ä¸»ãªæ©Ÿèƒ½:
    1. ä¿®æ­£æˆåŠŸç‡ã®è¿½è·¡
    2. å¹³å‡ä¿®æ­£æ™‚é–“ã®è¨ˆç®—
    3. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
    4. æ—¥æ¬¡/é€±æ¬¡/æœˆæ¬¡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    5. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    """
    
    def __init__(self, storage_dir: str = ".metrics"):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        
        # ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
        self.metrics: List[MetricEntry] = []
        
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥çµ±è¨ˆ
        self.agent_stats: Dict[str, Dict[str, Any]] = defaultdict(
            lambda: {
                "tasks_processed": 0,
                "tasks_succeeded": 0,
                "tasks_failed": 0,
                "total_duration": 0.0,
                "durations": []
            }
        )
        
        # ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ
        self.error_stats: Dict[str, int] = Counter()
        
        # ä¿®æ­£ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ
        self.fix_stats: Dict[str, Dict[str, int]] = defaultdict(
            lambda: {"attempted": 0, "succeeded": 0, "failed": 0}
        )
        
        # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œä¸­ã®ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
        self.active_tasks: Dict[str, datetime] = {}
        
        logger.info(f"MetricsCollectorAgent initialized (storage_dir={storage_dir})")
    
    def record_metric(self, 
                     name: str,
                     value: float,
                     metric_type: MetricType = MetricType.GAUGE,
                     tags: Dict[str, str] = None):
        """
        ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¨˜éŒ²
        
        Args:
            name: ãƒ¡ãƒˆãƒªã‚¯ã‚¹å
            value: å€¤
            metric_type: ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚¿ã‚¤ãƒ—
            tags: ã‚¿ã‚°
        """
        entry = MetricEntry(
            name=name,
            value=value,
            type=metric_type,
            timestamp=datetime.now(),
            tags=tags or {}
        )
        
        self.metrics.append(entry)
        logger.debug(f"Recorded metric: {name}={value} {tags}")
    
    def start_task(self, task_id: str, agent_name: str):
        """ã‚¿ã‚¹ã‚¯é–‹å§‹ã‚’è¨˜éŒ²"""
        self.active_tasks[task_id] = datetime.now()
        self.agent_stats[agent_name]["tasks_processed"] += 1
        
        self.record_metric(
            name="task_started",
            value=1,
            metric_type=MetricType.COUNTER,
            tags={"agent": agent_name, "task_id": task_id}
        )
        
        logger.debug(f"Task started: {task_id} by {agent_name}")
    
    def end_task(self, 
                task_id: str,
                agent_name: str,
                success: bool,
                error_type: Optional[str] = None):
        """ã‚¿ã‚¹ã‚¯çµ‚äº†ã‚’è¨˜éŒ²"""
        if task_id not in self.active_tasks:
            logger.warning(f"Task {task_id} was not tracked")
            return
        
        # å®Ÿè¡Œæ™‚é–“ã‚’è¨ˆç®—
        start_time = self.active_tasks.pop(task_id)
        duration = (datetime.now() - start_time).total_seconds()
        
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆçµ±è¨ˆã‚’æ›´æ–°
        stats = self.agent_stats[agent_name]
        if success:
            stats["tasks_succeeded"] += 1
        else:
            stats["tasks_failed"] += 1
        
        stats["total_duration"] += duration
        stats["durations"].append(duration)
        
        # ã‚¨ãƒ©ãƒ¼çµ±è¨ˆã‚’æ›´æ–°
        if error_type:
            self.error_stats[error_type] += 1
        
        # ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’è¨˜éŒ²
        self.record_metric(
            name="task_duration",
            value=duration,
            metric_type=MetricType.TIMER,
            tags={
                "agent": agent_name,
                "task_id": task_id,
                "success": str(success),
                "error_type": error_type or "none"
            }
        )
        
        self.record_metric(
            name="task_completed",
            value=1,
            metric_type=MetricType.COUNTER,
            tags={
                "agent": agent_name,
                "success": str(success)
            }
        )
        
        logger.debug(f"Task ended: {task_id} (success={success}, duration={duration:.2f}s)")
    
    def record_fix_attempt(self,
                          fix_type: str,
                          success: bool,
                          duration: float,
                          error_type: str):
        """ä¿®æ­£è©¦è¡Œã‚’è¨˜éŒ²"""
        self.fix_stats[fix_type]["attempted"] += 1
        
        if success:
            self.fix_stats[fix_type]["succeeded"] += 1
        else:
            self.fix_stats[fix_type]["failed"] += 1
        
        self.record_metric(
            name="fix_attempt",
            value=duration,
            metric_type=MetricType.TIMER,
            tags={
                "fix_type": fix_type,
                "success": str(success),
                "error_type": error_type
            }
        )
        
        logger.debug(f"Fix attempt recorded: {fix_type} (success={success})")
    
    def get_agent_performance(self, agent_name: str) -> PerformanceStats:
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆã‚’å–å¾—"""
        if agent_name not in self.agent_stats:
            return PerformanceStats()
        
        stats = self.agent_stats[agent_name]
        durations = stats["durations"]
        
        if not durations:
            return PerformanceStats(
                total_count=stats["tasks_processed"],
                success_count=stats["tasks_succeeded"],
                failure_count=stats["tasks_failed"]
            )
        
        # ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã‚’è¨ˆç®—
        sorted_durations = sorted(durations)
        
        return PerformanceStats(
            total_count=stats["tasks_processed"],
            success_count=stats["tasks_succeeded"],
            failure_count=stats["tasks_failed"],
            avg_duration=statistics.mean(durations),
            min_duration=min(durations),
            max_duration=max(durations),
            percentile_50=self._percentile(sorted_durations, 50),
            percentile_95=self._percentile(sorted_durations, 95),
            percentile_99=self._percentile(sorted_durations, 99)
        )
    
    def get_all_agents_performance(self) -> Dict[str, PerformanceStats]:
        """å…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆã‚’å–å¾—"""
        return {
            agent_name: self.get_agent_performance(agent_name)
            for agent_name in self.agent_stats.keys()
        }
    
    def get_fix_success_rate(self, fix_type: Optional[str] = None) -> float:
        """ä¿®æ­£æˆåŠŸç‡ã‚’å–å¾—"""
        if fix_type:
            stats = self.fix_stats.get(fix_type, {"attempted": 0, "succeeded": 0})
            if stats["attempted"] == 0:
                return 0.0
            return stats["succeeded"] / stats["attempted"]
        
        # å…¨ä½“ã®æˆåŠŸç‡
        total_attempted = sum(s["attempted"] for s in self.fix_stats.values())
        total_succeeded = sum(s["succeeded"] for s in self.fix_stats.values())
        
        if total_attempted == 0:
            return 0.0
        
        return total_succeeded / total_attempted
    
    def get_error_distribution(self) -> Dict[str, int]:
        """ã‚¨ãƒ©ãƒ¼åˆ†å¸ƒã‚’å–å¾—"""
        return dict(self.error_stats)
    
    def get_top_errors(self, limit: int = 10) -> List[Tuple[str, int]]:
        """é »åº¦ã®é«˜ã„ã‚¨ãƒ©ãƒ¼ã‚’å–å¾—"""
        return self.error_stats.most_common(limit)
    
    def generate_report(self, 
                       period: ReportPeriod = ReportPeriod.DAILY,
                       start_time: Optional[datetime] = None) -> Dict[str, Any]:
        """
        ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            period: ãƒ¬ãƒãƒ¼ãƒˆæœŸé–“
            start_time: é–‹å§‹æ™‚åˆ»ï¼ˆNoneã®å ´åˆã¯ç¾åœ¨æ™‚åˆ»ã‹ã‚‰æœŸé–“ã‚’é€†ç®—ï¼‰
        
        Returns:
            ãƒ¬ãƒãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿
        """
        if start_time is None:
            start_time = datetime.now()
        
        # æœŸé–“ã‚’è¨ˆç®—
        if period == ReportPeriod.HOURLY:
            cutoff = start_time - timedelta(hours=1)
        elif period == ReportPeriod.DAILY:
            cutoff = start_time - timedelta(days=1)
        elif period == ReportPeriod.WEEKLY:
            cutoff = start_time - timedelta(weeks=1)
        elif period == ReportPeriod.MONTHLY:
            cutoff = start_time - timedelta(days=30)
        else:
            cutoff = datetime.min
        
        # æœŸé–“å†…ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ãƒ•ã‚£ãƒ«ã‚¿
        period_metrics = [m for m in self.metrics if m.timestamp >= cutoff]
        
        # ã‚¿ã‚¹ã‚¯çµ±è¨ˆ
        task_started = sum(1 for m in period_metrics if m.name == "task_started")
        task_completed = sum(1 for m in period_metrics if m.name == "task_completed")
        task_succeeded = sum(
            1 for m in period_metrics 
            if m.name == "task_completed" and m.tags.get("success") == "True"
        )
        task_failed = task_completed - task_succeeded
        
        # ä¿®æ­£çµ±è¨ˆ
        fix_attempts = sum(1 for m in period_metrics if m.name == "fix_attempt")
        fix_succeeded = sum(
            1 for m in period_metrics
            if m.name == "fix_attempt" and m.tags.get("success") == "True"
        )
        
        # å¹³å‡å®Ÿè¡Œæ™‚é–“
        durations = [
            m.value for m in period_metrics
            if m.name == "task_duration"
        ]
        avg_duration = statistics.mean(durations) if durations else 0.0
        
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¥çµ±è¨ˆ
        agent_performance = {}
        for agent_name in self.agent_stats.keys():
            perf = self.get_agent_performance(agent_name)
            agent_performance[agent_name] = {
                "total_tasks": perf.total_count,
                "success_rate": perf.success_rate,
                "avg_duration": perf.avg_duration,
                "p95_duration": perf.percentile_95
            }
        
        # ã‚¨ãƒ©ãƒ¼åˆ†å¸ƒ
        error_dist = self.get_error_distribution()
        
        report = {
            "period": period.value,
            "start_time": cutoff.isoformat(),
            "end_time": start_time.isoformat(),
            "summary": {
                "tasks_started": task_started,
                "tasks_completed": task_completed,
                "tasks_succeeded": task_succeeded,
                "tasks_failed": task_failed,
                "success_rate": task_succeeded / task_completed if task_completed > 0 else 0.0,
                "avg_duration_seconds": avg_duration
            },
            "fixes": {
                "attempts": fix_attempts,
                "succeeded": fix_succeeded,
                "success_rate": fix_succeeded / fix_attempts if fix_attempts > 0 else 0.0
            },
            "agent_performance": agent_performance,
            "error_distribution": error_dist,
            "top_errors": dict(self.get_top_errors(5))
        }
        
        return report
    
    def generate_dashboard_data(self) -> Dict[str, Any]:
        """ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ"""
        now = datetime.now()
        
        # è¤‡æ•°æœŸé–“ã®ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        hourly_report = self.generate_report(ReportPeriod.HOURLY, now)
        daily_report = self.generate_report(ReportPeriod.DAILY, now)
        weekly_report = self.generate_report(ReportPeriod.WEEKLY, now)
        
        # æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ï¼ˆéå»24æ™‚é–“ï¼‰
        cutoff = now - timedelta(hours=24)
        recent_metrics = [m for m in self.metrics if m.timestamp >= cutoff]
        
        # 1æ™‚é–“ã”ã¨ã®é›†è¨ˆ
        hourly_buckets = defaultdict(lambda: {"tasks": 0, "errors": 0, "fixes": 0})
        
        for metric in recent_metrics:
            hour_key = metric.timestamp.replace(minute=0, second=0, microsecond=0)
            
            if metric.name == "task_completed":
                hourly_buckets[hour_key]["tasks"] += 1
            elif metric.name == "fix_attempt":
                hourly_buckets[hour_key]["fixes"] += 1
            elif "error" in metric.name:
                hourly_buckets[hour_key]["errors"] += 1
        
        # æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’æ•´å½¢
        time_series = []
        for hour in sorted(hourly_buckets.keys()):
            time_series.append({
                "timestamp": hour.isoformat(),
                "tasks": hourly_buckets[hour]["tasks"],
                "errors": hourly_buckets[hour]["errors"],
                "fixes": hourly_buckets[hour]["fixes"]
            })
        
        # å…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
        all_agents_perf = self.get_all_agents_performance()
        agent_summary = {}
        
        for agent_name, perf in all_agents_perf.items():
            agent_summary[agent_name] = {
                "total_tasks": perf.total_count,
                "success_rate": round(perf.success_rate * 100, 2),
                "avg_duration": round(perf.avg_duration, 2),
                "status": self._get_agent_status(perf)
            }
        
        return {
            "overview": {
                "hourly": hourly_report["summary"],
                "daily": daily_report["summary"],
                "weekly": weekly_report["summary"]
            },
            "time_series": time_series,
            "agents": agent_summary,
            "errors": {
                "distribution": self.get_error_distribution(),
                "top_5": dict(self.get_top_errors(5))
            },
            "fixes": {
                "overall_success_rate": round(self.get_fix_success_rate() * 100, 2),
                "by_type": {
                    fix_type: {
                        "attempted": stats["attempted"],
                        "success_rate": round(
                            (stats["succeeded"] / stats["attempted"] * 100) 
                            if stats["attempted"] > 0 else 0, 2
                        )
                    }
                    for fix_type, stats in self.fix_stats.items()
                }
            },
            "active_tasks": len(self.active_tasks),
            "generated_at": now.isoformat()
        }
    
    def export_metrics(self, filepath: Optional[str] = None) -> str:
        """
        ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        
        Args:
            filepath: å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ï¼ˆNoneã®å ´åˆã¯è‡ªå‹•ç”Ÿæˆï¼‰
        
        Returns:
            å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        """
        if filepath is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filepath = self.storage_dir / f"metrics_{timestamp}.json"
        
        data = {
            "metrics": [m.to_dict() for m in self.metrics],
            "agent_stats": dict(self.agent_stats),
            "error_stats": dict(self.error_stats),
            "fix_stats": dict(self.fix_stats),
            "exported_at": datetime.now().isoformat()
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"Metrics exported to {filepath}")
        
        return str(filepath)
    
    def import_metrics(self, filepath: str):
        """ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆ"""
        with open(filepath, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’å¾©å…ƒ
        for m_data in data.get("metrics", []):
            metric = MetricEntry(
                name=m_data["name"],
                value=m_data["value"],
                type=MetricType(m_data["type"]),
                timestamp=datetime.fromisoformat(m_data["timestamp"]),
                tags=m_data.get("tags", {})
            )
            self.metrics.append(metric)
        
        # çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
        self.agent_stats.update(data.get("agent_stats", {}))
        self.error_stats.update(data.get("error_stats", {}))
        self.fix_stats.update(data.get("fix_stats", {}))
        
        logger.info(f"Metrics imported from {filepath}")
    
    def _percentile(self, sorted_data: List[float], percentile: int) -> float:
        """ãƒ‘ãƒ¼ã‚»ãƒ³ã‚¿ã‚¤ãƒ«ã‚’è¨ˆç®—"""
        if not sorted_data:
            return 0.0
        
        index = (len(sorted_data) - 1) * percentile / 100
        lower = int(index)
        upper = lower + 1
        
        if upper >= len(sorted_data):
            return sorted_data[-1]
        
        weight = index - lower
        return sorted_data[lower] * (1 - weight) + sorted_data[upper] * weight
    
    def _get_agent_status(self, perf: PerformanceStats) -> str:
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆ¤å®š"""
        if perf.total_count == 0:
            return "idle"
        
        if perf.success_rate >= 0.95:
            return "excellent"
        elif perf.success_rate >= 0.80:
            return "good"
        elif perf.success_rate >= 0.60:
            return "fair"
        else:
            return "poor"
    
    def clear_old_metrics(self, days: int = 30):
        """å¤ã„ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’ã‚¯ãƒªã‚¢"""
        cutoff = datetime.now() - timedelta(days=days)
        
        original_count = len(self.metrics)
        self.metrics = [m for m in self.metrics if m.timestamp >= cutoff]
        
        cleared_count = original_count - len(self.metrics)
        logger.info(f"Cleared {cleared_count} old metrics (older than {days} days)")
    
    def get_summary(self) -> Dict[str, Any]:
        """ç°¡æ˜“ã‚µãƒãƒªãƒ¼ã‚’å–å¾—"""
        total_tasks = sum(stats["tasks_processed"] for stats in self.agent_stats.values())
        total_succeeded = sum(stats["tasks_succeeded"] for stats in self.agent_stats.values())
        total_failed = sum(stats["tasks_failed"] for stats in self.agent_stats.values())
        
        overall_success_rate = total_succeeded / total_tasks if total_tasks > 0 else 0.0
        
        return {
            "total_tasks": total_tasks,
            "total_succeeded": total_succeeded,
            "total_failed": total_failed,
            "overall_success_rate": round(overall_success_rate * 100, 2),
            "active_agents": len(self.agent_stats),
            "total_metrics": len(self.metrics),
            "unique_errors": len(self.error_stats),
            "fix_types": len(self.fix_stats)
        }


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    collector = MetricsCollectorAgent()
    
    # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    collector.start_task("task-1", "LocalFixAgent")
    import time
    time.sleep(0.5)
    collector.end_task("task-1", "LocalFixAgent", success=True)
    
    collector.start_task("task-2", "CloudFixAgent")
    time.sleep(1.0)
    collector.end_task("task-2", "CloudFixAgent", success=False, error_type="SyntaxError")
    
    # ä¿®æ­£è©¦è¡Œã‚’è¨˜éŒ²
    collector.record_fix_attempt("local", success=True, duration=2.5, error_type="ImportError")
    collector.record_fix_attempt("cloud", success=False, duration=5.0, error_type="AttributeError")
    
    # ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    daily_report = collector.generate_report(ReportPeriod.DAILY)
    print("\n=== Daily Report ===")
    print(json.dumps(daily_report, indent=2))
    
    # ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    dashboard = collector.generate_dashboard_data()
    print("\n=== Dashboard Data ===")
    print(json.dumps(dashboard, indent=2))
    
    # ã‚µãƒãƒªãƒ¼
    summary = collector.get_summary()
    print("\n=== Summary ===")
    print(json.dumps(summary, indent=2))
    
    # ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
    export_path = collector.export_metrics()
    print(f"\nMetrics exported to: {export_path}")


#monitoring_agent.py
# monitoring_agent.py
"""
ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
ã‚·ã‚¹ãƒ†ãƒ ç›£è¦–ã¨ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
"""

import asyncio
import logging
import psutil
import os
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from enum import Enum

logger = logging.getLogger(__name__)


class HealthStatus(Enum):
    """ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"""
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    UNKNOWN = "unknown"


class MonitoringAgent:
    """
    ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    æ©Ÿèƒ½:
    - ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ç›£è¦–
    - ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿç‡ã®è¿½è·¡
    - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
    - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    - ã‚¢ãƒ©ãƒ¼ãƒˆç™ºè¡Œ
    """
    
    def __init__(
        self,
        check_interval: int = 60,  # ç§’
        cpu_threshold: float = 80.0,  # %
        memory_threshold: float = 85.0,  # %
        disk_threshold: float = 90.0,  # %
        error_rate_threshold: float = 0.3  # 30%
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            check_interval: ãƒã‚§ãƒƒã‚¯é–“éš”ï¼ˆç§’ï¼‰
            cpu_threshold: CPUä½¿ç”¨ç‡é–¾å€¤
            memory_threshold: ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡é–¾å€¤
            disk_threshold: ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡é–¾å€¤
            error_rate_threshold: ã‚¨ãƒ©ãƒ¼ç‡é–¾å€¤
        """
        self.check_interval = check_interval
        self.cpu_threshold = cpu_threshold
        self.memory_threshold = memory_threshold
        self.disk_threshold = disk_threshold
        self.error_rate_threshold = error_rate_threshold
        
        # ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿
        self.metrics_history = []
        self.alerts = []
        
        # ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
        self.start_time = datetime.now()
        self.is_monitoring = False
        self.monitoring_task = None
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_checks": 0,
            "health_checks": 0,
            "warnings_issued": 0,
            "critical_alerts": 0,
            "avg_cpu_usage": 0.0,
            "avg_memory_usage": 0.0,
            "avg_response_time": 0.0
        }
        
        logger.info("âœ… MonitoringAgent åˆæœŸåŒ–å®Œäº†")
    
    async def start_monitoring(self):
        """ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹"""
        if self.is_monitoring:
            logger.warning("âš ï¸ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™")
            return
        
        self.is_monitoring = True
        self.monitoring_task = asyncio.create_task(self._monitoring_loop())
        
        logger.info(f"ğŸ” ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°é–‹å§‹ (é–“éš”={self.check_interval}ç§’)")
    
    async def stop_monitoring(self):
        """ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°åœæ­¢"""
        self.is_monitoring = False
        
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
        
        logger.info("â¹ï¸ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°åœæ­¢")
    
    async def _monitoring_loop(self):
        """ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—"""
        try:
            while self.is_monitoring:
                # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
                await self.perform_health_check()
                
                # æ¬¡ã®ãƒã‚§ãƒƒã‚¯ã¾ã§å¾…æ©Ÿ
                await asyncio.sleep(self.check_interval)
                
        except asyncio.CancelledError:
            logger.info("ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ")
        except Exception as e:
            logger.error(f"âŒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
    
    async def perform_health_check(self) -> Dict[str, Any]:
        """ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚’å®Ÿè¡Œ"""
        try:
            check_time = datetime.now()
            self.stats["health_checks"] += 1
            self.stats["total_checks"] += 1
            
            # ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
            metrics = {
                "timestamp": check_time.isoformat(),
                "system": await self._collect_system_metrics(),
                "process": await self._collect_process_metrics(),
                "application": await self._collect_application_metrics()
            }
            
            # ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¤å®š
            health_status = self._determine_health_status(metrics)
            metrics["health_status"] = health_status.value
            
            # å±¥æ­´ã«è¿½åŠ 
            self.metrics_history.append(metrics)
            
            # å¤ã„å±¥æ­´ã‚’å‰Šé™¤ï¼ˆç›´è¿‘100ä»¶ã®ã¿ä¿æŒï¼‰
            if len(self.metrics_history) > 100:
                self.metrics_history = self.metrics_history[-100:]
            
            # ã‚¢ãƒ©ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
            await self._check_and_issue_alerts(metrics, health_status)
            
            # çµ±è¨ˆæ›´æ–°
            self._update_statistics(metrics)
            
            logger.debug(
                f"âœ… ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å®Œäº†: {health_status.value} "
                f"(CPU={metrics['system']['cpu_percent']:.1f}%, "
                f"Memory={metrics['system']['memory_percent']:.1f}%)"
            )
            
            return {
                "success": True,
                "health_status": health_status.value,
                "metrics": metrics
            }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def _collect_system_metrics(self) -> Dict[str, Any]:
        """ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’åé›†"""
        try:
            # CPUä½¿ç”¨ç‡
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            
            # ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡
            memory = psutil.virtual_memory()
            
            # ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡
            disk = psutil.disk_usage('/')
            
            # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çµ±è¨ˆ
            net_io = psutil.net_io_counters()
            
            return {
                "cpu_percent": cpu_percent,
                "cpu_count": cpu_count,
                "memory_percent": memory.percent,
                "memory_used_gb": memory.used / (1024**3),
                "memory_total_gb": memory.total / (1024**3),
                "disk_percent": disk.percent,
                "disk_used_gb": disk.used / (1024**3),
                "disk_total_gb": disk.total / (1024**3),
                "network_bytes_sent": net_io.bytes_sent,
                "network_bytes_recv": net_io.bytes_recv
            }
            
        except Exception as e:
            logger.error(f"âŒ ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã‚¨ãƒ©ãƒ¼: {e}")
            return {}
    
    async def _collect_process_metrics(self) -> Dict[str, Any]:
        """ãƒ—ãƒ­ã‚»ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’åé›†"""
        try:
            process = psutil.Process(os.getpid())
            
            # ãƒ—ãƒ­ã‚»ã‚¹æƒ…å ±
            with process.oneshot():
                cpu_percent = process.cpu_percent()
                memory_info = process.memory_info()
                num_threads = process.num_threads()
                open_files = len(process.open_files())
                
            return {
                "pid": process.pid,
                "cpu_percent": cpu_percent,
                "memory_mb": memory_info.rss / (1024**2),
                "num_threads": num_threads,
                "open_files": open_files,
                "status": process.status()
            }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ­ã‚»ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã‚¨ãƒ©ãƒ¼: {e}")
            return {}
    
    async def _collect_application_metrics(self) -> Dict[str, Any]:
        """ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã‚’åé›†"""
        try:
            # ç¨¼åƒæ™‚é–“
            uptime = (datetime.now() - self.start_time).total_seconds()
            
            return {
                "uptime_seconds": uptime,
                "uptime_hours": uptime / 3600,
                "total_health_checks": self.stats["health_checks"],
                "warnings_issued": self.stats["warnings_issued"],
                "critical_alerts": self.stats["critical_alerts"]
            }
            
        except Exception as e:
            logger.error(f"âŒ ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ã‚¨ãƒ©ãƒ¼: {e}")
            return {}
    
    def _determine_health_status(self, metrics: Dict[str, Any]) -> HealthStatus:
        """ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’åˆ¤å®š"""
        try:
            system = metrics.get("system", {})
            
            # Criticalæ¡ä»¶ãƒã‚§ãƒƒã‚¯
            if (system.get("cpu_percent", 0) > 95 or
                system.get("memory_percent", 0) > 95 or
                system.get("disk_percent", 0) > 95):
                return HealthStatus.CRITICAL
            
            # Warningæ¡ä»¶ãƒã‚§ãƒƒã‚¯
            if (system.get("cpu_percent", 0) > self.cpu_threshold or
                system.get("memory_percent", 0) > self.memory_threshold or
                system.get("disk_percent", 0) > self.disk_threshold):
                return HealthStatus.WARNING
            
            # Healthy
            return HealthStatus.HEALTHY
            
        except Exception as e:
            logger.error(f"âŒ ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¤å®šã‚¨ãƒ©ãƒ¼: {e}")
            return HealthStatus.UNKNOWN
    
    async def _check_and_issue_alerts(
        self,
        metrics: Dict[str, Any],
        health_status: HealthStatus
    ):
        """ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ç™ºè¡Œ"""
        try:
            system = metrics.get("system", {})
            timestamp = metrics.get("timestamp")
            
            alerts = []
            
            # CPUè­¦å‘Š
            if system.get("cpu_percent", 0) > self.cpu_threshold:
                alerts.append({
                    "level": "warning" if health_status == HealthStatus.WARNING else "critical",
                    "type": "cpu_usage",
                    "message": f"CPUä½¿ç”¨ç‡ãŒé«˜ã„: {system['cpu_percent']:.1f}%",
                    "value": system['cpu_percent'],
                    "threshold": self.cpu_threshold,
                    "timestamp": timestamp
                })
            
            # ãƒ¡ãƒ¢ãƒªè­¦å‘Š
            if system.get("memory_percent", 0) > self.memory_threshold:
                alerts.append({
                    "level": "warning" if health_status == HealthStatus.WARNING else "critical",
                    "type": "memory_usage",
                    "message": f"ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡ãŒé«˜ã„: {system['memory_percent']:.1f}%",
                    "value": system['memory_percent'],
                    "threshold": self.memory_threshold,
                    "timestamp": timestamp
                })
            
            # ãƒ‡ã‚£ã‚¹ã‚¯è­¦å‘Š
            if system.get("disk_percent", 0) > self.disk_threshold:
                alerts.append({
                    "level": "warning" if health_status == HealthStatus.WARNING else "critical",
                    "type": "disk_usage",
                    "message": f"ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡ãŒé«˜ã„: {system['disk_percent']:.1f}%",
                    "value": system['disk_percent'],
                    "threshold": self.disk_threshold,
                    "timestamp": timestamp
                })
            
            # ã‚¢ãƒ©ãƒ¼ãƒˆã‚’è¨˜éŒ²
            for alert in alerts:
                self.alerts.append(alert)
                
                if alert["level"] == "critical":
                    self.stats["critical_alerts"] += 1
                    logger.critical(f"ğŸš¨ CRITICAL: {alert['message']}")
                else:
                    self.stats["warnings_issued"] += 1
                    logger.warning(f"âš ï¸ WARNING: {alert['message']}")
            
            # å¤ã„ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å‰Šé™¤ï¼ˆç›´è¿‘50ä»¶ã®ã¿ä¿æŒï¼‰
            if len(self.alerts) > 50:
                self.alerts = self.alerts[-50:]
            
        except Exception as e:
            logger.error(f"âŒ ã‚¢ãƒ©ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _update_statistics(self, metrics: Dict[str, Any]):
        """çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°"""
        try:
            system = metrics.get("system", {})
            
            # ç§»å‹•å¹³å‡ã‚’è¨ˆç®—
            n = self.stats["health_checks"]
            
            self.stats["avg_cpu_usage"] = (
                (self.stats["avg_cpu_usage"] * (n - 1) + system.get("cpu_percent", 0)) / n
            )
            
            self.stats["avg_memory_usage"] = (
                (self.stats["avg_memory_usage"] * (n - 1) + system.get("memory_percent", 0)) / n
            )
            
        except Exception as e:
            logger.error(f"âŒ çµ±è¨ˆæ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    def get_current_status(self) -> Dict[str, Any]:
        """ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—"""
        if not self.metrics_history:
            return {
                "status": "no_data",
                "message": "ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“"
            }
        
        latest_metrics = self.metrics_history[-1]
        
        return {
            "status": latest_metrics.get("health_status", "unknown"),
            "timestamp": latest_metrics.get("timestamp"),
            "system": latest_metrics.get("system", {}),
            "process": latest_metrics.get("process", {}),
            "application": latest_metrics.get("application", {}),
            "recent_alerts": self.alerts[-5:] if self.alerts else []
        }
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        uptime = (datetime.now() - self.start_time).total_seconds()
        
        return {
            **self.stats,
            "uptime_seconds": uptime,
            "uptime_hours": uptime / 3600,
            "is_monitoring": self.is_monitoring,
            "metrics_count": len(self.metrics_history),
            "alerts_count": len(self.alerts)
        }
    
    def print_status(self):
        """ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¡¨ç¤º"""
        status = self.get_current_status()
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("ğŸ” ã‚·ã‚¹ãƒ†ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚° ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹")
        print("=" * 80)
        print(f"ãƒ˜ãƒ«ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status.get('status', 'unknown').upper()}")
        print(f"ç¨¼åƒæ™‚é–“: {stats['uptime_hours']:.1f}æ™‚é–“")
        print(f"\nã€ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ã€‘")
        system = status.get("system", {})
        print(f"  CPUä½¿ç”¨ç‡: {system.get('cpu_percent', 0):.1f}%")
        print(f"  ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡: {system.get('memory_percent', 0):.1f}%")
        print(f"  ãƒ‡ã‚£ã‚¹ã‚¯ä½¿ç”¨ç‡: {system.get('disk_percent', 0):.1f}%")
        print(f"\nã€çµ±è¨ˆã€‘")
        print(f"  ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: {stats['health_checks']}å›")
        print(f"  è­¦å‘Šç™ºè¡Œ: {stats['warnings_issued']}å›")
        print(f"  é‡è¦ã‚¢ãƒ©ãƒ¼ãƒˆ: {stats['critical_alerts']}å›")
        print(f"  å¹³å‡CPU: {stats['avg_cpu_usage']:.1f}%")
        print(f"  å¹³å‡ãƒ¡ãƒ¢ãƒª: {stats['avg_memory_usage']:.1f}%")
        
        if status.get("recent_alerts"):
            print(f"\nã€æœ€è¿‘ã®ã‚¢ãƒ©ãƒ¼ãƒˆã€‘")
            for alert in status["recent_alerts"]:
                print(f"  - [{alert['level'].upper()}] {alert['message']}")
        
        print("=" * 80 + "\n")

#notification_agent.py
# notification_agent.py
"""
é€šçŸ¥ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
Slack/ãƒ¡ãƒ¼ãƒ«/ãã®ä»–ã®é€šçŸ¥ç®¡ç†
"""

import asyncio
import logging
import json
import smtplib
from typing import Dict, Any, List, Optional
from datetime import datetime
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from enum import Enum

import aiohttp

logger = logging.getLogger(__name__)


class NotificationLevel(Enum):
    """é€šçŸ¥ãƒ¬ãƒ™ãƒ«"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"
    SUCCESS = "success"


class NotificationChannel(Enum):
    """é€šçŸ¥ãƒãƒ£ãƒãƒ«"""
    SLACK = "slack"
    EMAIL = "email"
    DISCORD = "discord"
    WEBHOOK = "webhook"


class NotificationAgent:
    """
    é€šçŸ¥ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    æ©Ÿèƒ½:
    - Slacké€šçŸ¥
    - ãƒ¡ãƒ¼ãƒ«é€šçŸ¥
    - Discordé€šçŸ¥
    - Webhooké€šçŸ¥
    - é€šçŸ¥ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    - é€šçŸ¥ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç®¡ç†
    """
    
    def __init__(
        self,
        slack_webhook_url: Optional[str] = None,
        email_config: Optional[Dict[str, str]] = None,
        discord_webhook_url: Optional[str] = None,
        min_notification_level: NotificationLevel = NotificationLevel.WARNING
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            slack_webhook_url: Slack Webhook URL
            email_config: ãƒ¡ãƒ¼ãƒ«è¨­å®šï¼ˆsmtp_server, smtp_port, username, password, recipientsï¼‰
            discord_webhook_url: Discord Webhook URL
            min_notification_level: æœ€å°é€šçŸ¥ãƒ¬ãƒ™ãƒ«
        """
        self.slack_webhook_url = slack_webhook_url
        self.email_config = email_config or {}
        self.discord_webhook_url = discord_webhook_url
        self.min_notification_level = min_notification_level
        
        # é€šçŸ¥å±¥æ­´
        self.notification_history = []
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_notifications": 0,
            "slack_notifications": 0,
            "email_notifications": 0,
            "discord_notifications": 0,
            "failed_notifications": 0
        }
        
        # é€šçŸ¥ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
        self._init_templates()
        
        logger.info("âœ… NotificationAgent åˆæœŸåŒ–å®Œäº†")
    
    def _init_templates(self):
        """é€šçŸ¥ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’åˆæœŸåŒ–"""
        self.templates = {
            "fix_success": {
                "title": "âœ… è‡ªå‹•ä¿®æ­£æˆåŠŸ",
                "color": "#36a64f",
                "emoji": "âœ…"
            },
            "fix_failure": {
                "title": "âŒ è‡ªå‹•ä¿®æ­£å¤±æ•—",
                "color": "#ff0000",
                "emoji": "âŒ"
            },
            "error_detected": {
                "title": "ğŸ” ã‚¨ãƒ©ãƒ¼æ¤œå‡º",
                "color": "#ff9900",
                "emoji": "ğŸ”"
            },
            "system_warning": {
                "title": "âš ï¸ ã‚·ã‚¹ãƒ†ãƒ è­¦å‘Š",
                "color": "#ffcc00",
                "emoji": "âš ï¸"
            },
            "system_critical": {
                "title": "ğŸš¨ ã‚·ã‚¹ãƒ†ãƒ é‡å¤§",
                "color": "#cc0000",
                "emoji": "ğŸš¨"
            },
            "pr_created": {
                "title": "ğŸŒ¿ PRä½œæˆå®Œäº†",
                "color": "#0366d6",
                "emoji": "ğŸŒ¿"
            }
        }
    
    async def send_notification(
        self,
        message: str,
        level: NotificationLevel = NotificationLevel.INFO,
        channels: Optional[List[NotificationChannel]] = None,
        template_name: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        é€šçŸ¥ã‚’é€ä¿¡
        
        Args:
            message: é€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            level: é€šçŸ¥ãƒ¬ãƒ™ãƒ«
            channels: é€šçŸ¥ãƒãƒ£ãƒãƒ«ï¼ˆçœç•¥æ™‚ã¯å…¨ãƒãƒ£ãƒãƒ«ï¼‰
            template_name: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå
            metadata: è¿½åŠ ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
            
        Returns:
            Dict: é€ä¿¡çµæœ
        """
        try:
            # ãƒ¬ãƒ™ãƒ«ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            if not self._should_notify(level):
                logger.debug(f"é€šçŸ¥ã‚¹ã‚­ãƒƒãƒ—: ãƒ¬ãƒ™ãƒ«={level.value}")
                return {"success": True, "skipped": True}
            
            self.stats["total_notifications"] += 1
            
            # ãƒãƒ£ãƒãƒ«ã®æ±ºå®š
            if channels is None:
                channels = self._get_available_channels()
            
            # é€šçŸ¥å†…å®¹ã‚’æ§‹ç¯‰
            notification = self._build_notification(
                message=message,
                level=level,
                template_name=template_name,
                metadata=metadata
            )
            
            # å„ãƒãƒ£ãƒãƒ«ã«é€ä¿¡
            results = {}
            
            for channel in channels:
                try:
                    if channel == NotificationChannel.SLACK:
                        result = await self._send_slack_notification(notification)
                        results["slack"] = result
                        
                    elif channel == NotificationChannel.EMAIL:
                        result = await self._send_email_notification(notification)
                        results["email"] = result
                        
                    elif channel == NotificationChannel.DISCORD:
                        result = await self._send_discord_notification(notification)
                        results["discord"] = result
                        
                except Exception as e:
                    logger.error(f"âŒ {channel.value}é€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")
                    results[channel.value] = {"success": False, "error": str(e)}
                    self.stats["failed_notifications"] += 1
            
            # å±¥æ­´ã«è¿½åŠ 
            self.notification_history.append({
                "timestamp": datetime.now().isoformat(),
                "message": message,
                "level": level.value,
                "channels": [c.value for c in channels],
                "results": results
            })
            
            # å¤ã„å±¥æ­´ã‚’å‰Šé™¤ï¼ˆç›´è¿‘100ä»¶ã®ã¿ï¼‰
            if len(self.notification_history) > 100:
                self.notification_history = self.notification_history[-100:]
            
            logger.info(f"ğŸ“¤ é€šçŸ¥é€ä¿¡å®Œäº†: {message[:50]}...")
            
            return {
                "success": True,
                "channels": results
            }
            
        except Exception as e:
            logger.error(f"âŒ é€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_notifications"] += 1
            return {
                "success": False,
                "error": str(e)
            }
    
    async def notify_fix_success(
        self,
        task_id: str,
        modified_files: List[str],
        execution_time: float,
        confidence: float
    ):
        """ä¿®æ­£æˆåŠŸã®é€šçŸ¥"""
        message = (
            f"ã‚¿ã‚¹ã‚¯ {task_id} ã®è‡ªå‹•ä¿®æ­£ãŒæˆåŠŸã—ã¾ã—ãŸ\n"
            f"ä¿®æ­£ãƒ•ã‚¡ã‚¤ãƒ«: {', '.join(modified_files)}\n"
            f"å®Ÿè¡Œæ™‚é–“: {execution_time:.2f}ç§’\n"
            f"ä¿¡é ¼åº¦: {confidence:.1%}"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.SUCCESS,
            template_name="fix_success",
            metadata={
                "task_id": task_id,
                "modified_files": modified_files,
                "execution_time": execution_time,
                "confidence": confidence
            }
        )
    
    async def notify_fix_failure(
        self,
        task_id: str,
        error_message: str
    ):
        """ä¿®æ­£å¤±æ•—ã®é€šçŸ¥"""
        message = (
            f"ã‚¿ã‚¹ã‚¯ {task_id} ã®è‡ªå‹•ä¿®æ­£ãŒå¤±æ•—ã—ã¾ã—ãŸ\n"
            f"ã‚¨ãƒ©ãƒ¼: {error_message}\n"
            f"æ‰‹å‹•ä»‹å…¥ãŒå¿…è¦ã§ã™"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.ERROR,
            template_name="fix_failure",
            metadata={
                "task_id": task_id,
                "error_message": error_message
            }
        )
    
    async def notify_system_warning(
        self,
        warning_type: str,
        details: str
    ):
        """ã‚·ã‚¹ãƒ†ãƒ è­¦å‘Šã®é€šçŸ¥"""
        message = f"ã‚·ã‚¹ãƒ†ãƒ è­¦å‘Š: {warning_type}\nè©³ç´°: {details}"
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.WARNING,
            template_name="system_warning",
            metadata={
                "warning_type": warning_type,
                "details": details
            }
        )
    
    async def notify_pr_created(
        self,
        task_id: str,
        pr_url: str,
        branch_name: str
    ):
        """PRä½œæˆã®é€šçŸ¥"""
        message = (
            f"ã‚¿ã‚¹ã‚¯ {task_id} ã®ä¿®æ­£PRãŒä½œæˆã•ã‚Œã¾ã—ãŸ\n"
            f"ãƒ–ãƒ©ãƒ³ãƒ: {branch_name}\n"
            f"PR URL: {pr_url}"
        )
        
        await self.send_notification(
            message=message,
            level=NotificationLevel.INFO,
            template_name="pr_created",
            metadata={
                "task_id": task_id,
                "pr_url": pr_url,
                "branch_name": branch_name
            }
        )
    
    # ========================================
    # å†…éƒ¨ãƒ¡ã‚½ãƒƒãƒ‰
    # ========================================
    
    def _should_notify(self, level: NotificationLevel) -> bool:
        """é€šçŸ¥ã™ã¹ãã‹ãƒã‚§ãƒƒã‚¯"""
        level_priority = {
            NotificationLevel.INFO: 0,
            NotificationLevel.SUCCESS: 1,
            NotificationLevel.WARNING: 2,
            NotificationLevel.ERROR: 3,
            NotificationLevel.CRITICAL: 4
        }
        
        return level_priority.get(level, 0) >= level_priority.get(self.min_notification_level, 0)
    
    def _get_available_channels(self) -> List[NotificationChannel]:
        """åˆ©ç”¨å¯èƒ½ãªãƒãƒ£ãƒãƒ«ã‚’å–å¾—"""
        channels = []
        
        if self.slack_webhook_url:
            channels.append(NotificationChannel.SLACK)
        
        if self.email_config.get("smtp_server"):
            channels.append(NotificationChannel.EMAIL)
        
        if self.discord_webhook_url:
            channels.append(NotificationChannel.DISCORD)
        
        return channels
    
    def _build_notification(
        self,
        message: str,
        level: NotificationLevel,
        template_name: Optional[str],
        metadata: Optional[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """é€šçŸ¥å†…å®¹ã‚’æ§‹ç¯‰"""
        template = self.templates.get(template_name, {}) if template_name else {}
        
        return {
            "message": message,
            "level": level.value,
            "title": template.get("title", f"{level.value.upper()} Notification"),
            "color": template.get("color", "#cccccc"),
            "emoji": template.get("emoji", "ğŸ“¢"),
            "timestamp": datetime.now().isoformat(),
            "metadata": metadata or {}
        }
    
    async def _send_slack_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """Slacké€šçŸ¥ã‚’é€ä¿¡"""
        if not self.slack_webhook_url:
            return {"success": False, "error": "Slack webhook URL not configured"}
        
        try:
            # Slackãƒšã‚¤ãƒ­ãƒ¼ãƒ‰æ§‹ç¯‰
            payload = {
                "text": f"{notification['emoji']} {notification['title']}",
                "attachments": [{
                    "color": notification['color'],
                    "text": notification['message'],
                    "footer": "Hybrid Fix System",
                    "ts": int(datetime.now().timestamp())
                }]
            }
            
            # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            if notification.get('metadata'):
                fields = []
                for key, value in notification['metadata'].items():
                    fields.append({
                        "title": key,
                        "value": str(value),
                        "short": True
                    })
                payload["attachments"][0]["fields"] = fields
            
            # Webhooké€ä¿¡
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.slack_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status == 200:
                        self.stats["slack_notifications"] += 1
                        return {"success": True}
                    else:
                        error_text = await response.text()
                        return {"success": False, "error": f"HTTP {response.status}: {error_text}"}
            
        except Exception as e:
            logger.error(f"âŒ Slacké€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _send_email_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã‚’é€ä¿¡"""
        if not self.email_config.get("smtp_server"):
            return {"success": False, "error": "Email not configured"}
        
        try:
            # ãƒ¡ãƒ¼ãƒ«ä½œæˆ
            msg = MIMEMultipart()
            msg['From'] = self.email_config.get("username", "noreply@example.com")
            msg['To'] = self.email_config.get("recipients", "admin@example.com")
            msg['Subject'] = f"{notification['emoji']} {notification['title']}"
            
            # æœ¬æ–‡
            body = f"""
{notification['title']}

{notification['message']}

---
Timestamp: {notification['timestamp']}
System: Hybrid Fix System
"""
            
            if notification.get('metadata'):
                body += "\nDetails:\n"
                for key, value in notification['metadata'].items():
                    body += f"  {key}: {value}\n"
            
            msg.attach(MIMEText(body, 'plain'))
            
            # SMTPé€ä¿¡
            await asyncio.to_thread(self._send_smtp_email, msg)
            
            self.stats["email_notifications"] += 1
            return {"success": True}
            
        except Exception as e:
            logger.error(f"âŒ ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    def _send_smtp_email(self, msg: MIMEMultipart):
        """SMTPçµŒç”±ã§ãƒ¡ãƒ¼ãƒ«é€ä¿¡ï¼ˆåŒæœŸï¼‰"""
        server = smtplib.SMTP(
            self.email_config["smtp_server"],
            int(self.email_config.get("smtp_port", 587))
        )
        server.starttls()
        server.login(
            self.email_config["username"],
            self.email_config["password"]
        )
        server.send_message(msg)
        server.quit()
    
    async def _send_discord_notification(self, notification: Dict[str, Any]) -> Dict[str, Any]:
        """Discordé€šçŸ¥ã‚’é€ä¿¡"""
        if not self.discord_webhook_url:
            return {"success": False, "error": "Discord webhook URL not configured"}
        
        try:
            # Discordãƒšã‚¤ãƒ­ãƒ¼ãƒ‰æ§‹ç¯‰
            payload = {
                "content": f"{notification['emoji']} **{notification['title']}**",
                "embeds": [{
                    "description": notification['message'],
                    "color": int(notification['color'].replace('#', ''), 16),
                    "timestamp": notification['timestamp'],
                    "footer": {
                        "text": "Hybrid Fix System"
                    }
                }]
            }
            
            # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            if notification.get('metadata'):
                fields = []
                for key, value in notification['metadata'].items():
                    fields.append({
                        "name": key,
                        "value": str(value),
                        "inline": True
                    })
                payload["embeds"][0]["fields"] = fields
            
            # Webhooké€ä¿¡
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    self.discord_webhook_url,
                    json=payload,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    if response.status in [200, 204]:
                        self.stats["discord_notifications"] += 1
                        return {"success": True}
                    else:
                        error_text = await response.text()
                        return {"success": False, "error": f"HTTP {response.status}: {error_text}"}
            
        except Exception as e:
            logger.error(f"âŒ Discordé€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_notifications"] > 0:
            success_rate = (
                (self.stats["total_notifications"] - self.stats["failed_notifications"]) /
                self.stats["total_notifications"]
            )
        
        return {
            **self.stats,
            "success_rate": success_rate,
            "recent_notifications": self.notification_history[-10:]
        }
    
    def print_stats(self):
        """çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("ğŸ“¤ é€šçŸ¥ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ çµ±è¨ˆæƒ…å ±")
        print("=" * 80)
        print(f"ç·é€šçŸ¥æ•°: {stats['total_notifications']}")
        print(f"æˆåŠŸç‡: {stats['success_rate']:.1%}")
        print(f"\nãƒãƒ£ãƒãƒ«åˆ¥:")
        print(f"  Slack: {stats['slack_notifications']}å›")
        print(f"  ãƒ¡ãƒ¼ãƒ«: {stats['email_notifications']}å›")
        print(f"  Discord: {stats['discord_notifications']}å›")
        print(f"\nå¤±æ•—: {stats['failed_notifications']}å›")
        print("=" * 80 + "\n")

#patch_manager.py
# patch_manager.py
"""
ãƒ‘ãƒƒãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
ã‚³ãƒ¼ãƒ‰ãƒ‘ãƒƒãƒã®å®‰å…¨ãªé©ç”¨ã¨ç®¡ç†
"""

import asyncio
import logging
import difflib
import hashlib
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
from pathlib import Path
from enum import Enum

logger = logging.getLogger(__name__)


class PatchStrategy(Enum):
    """ãƒ‘ãƒƒãƒé©ç”¨æˆ¦ç•¥"""
    REPLACE = "replace"          # ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’ç½®æ›
    DIFF = "diff"                # å·®åˆ†ãƒ‘ãƒƒãƒã‚’é©ç”¨
    MERGE = "merge"              # ãƒãƒ¼ã‚¸
    SAFE_INSERT = "safe_insert"  # å®‰å…¨ãªæŒ¿å…¥


class PatchManager:
    """
    ãƒ‘ãƒƒãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
    
    æ©Ÿèƒ½:
    - å®‰å…¨ãªã‚³ãƒ¼ãƒ‰ãƒ‘ãƒƒãƒé©ç”¨
    - ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†
    - å·®åˆ†ç”Ÿæˆ
    - ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½
    - ãƒ‘ãƒƒãƒæ¤œè¨¼
    """
    
    def __init__(
        self,
        backup_dir: str = "./backups/patches",
        max_backups: int = 10
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            backup_dir: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            max_backups: ä¿æŒã™ã‚‹æœ€å¤§ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°
        """
        self.backup_dir = Path(backup_dir)
        self.max_backups = max_backups
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # ãƒ‘ãƒƒãƒå±¥æ­´
        self.patch_history = []
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_patches": 0,
            "successful_patches": 0,
            "failed_patches": 0,
            "rollbacks": 0
        }
        
        logger.info(f"âœ… PatchManager åˆæœŸåŒ–å®Œäº† (backup_dir={backup_dir})")
    
    async def apply_patch(
        self,
        file_path: str,
        new_content: str,
        strategy: PatchStrategy = PatchStrategy.REPLACE,
        verify: bool = True
    ) -> Dict[str, Any]:
        """
        ãƒ‘ãƒƒãƒã‚’é©ç”¨
        
        Args:
            file_path: å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            new_content: æ–°ã—ã„å†…å®¹
            strategy: é©ç”¨æˆ¦ç•¥
            verify: é©ç”¨å‰ã®æ¤œè¨¼ãƒ•ãƒ©ã‚°
            
        Returns:
            Dict: é©ç”¨çµæœ
        """
        start_time = datetime.now()
        file_path_obj = Path(file_path)
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ”§ ãƒ‘ãƒƒãƒé©ç”¨é–‹å§‹: {file_path}")
            logger.info(f"ğŸ“Š æˆ¦ç•¥: {strategy.value}")
            logger.info("=" * 60)
            
            self.stats["total_patches"] += 1
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆ
            if not file_path_obj.exists():
                logger.warning(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {file_path}")
                return await self._create_new_file(file_path, new_content)
            
            # ç¾åœ¨ã®å†…å®¹ã‚’èª­ã¿è¾¼ã¿
            old_content = await asyncio.to_thread(
                file_path_obj.read_text,
                encoding='utf-8'
            )
            
            # å¤‰æ›´ãŒãªã„å ´åˆ
            if old_content == new_content:
                logger.info("â„¹ï¸ å†…å®¹ã«å¤‰æ›´ã¯ã‚ã‚Šã¾ã›ã‚“")
                return {
                    "success": True,
                    "changed": False,
                    "message": "No changes"
                }
            
            # æ¤œè¨¼
            if verify:
                validation_result = await self._validate_patch(
                    old_content,
                    new_content
                )
                
                if not validation_result["valid"]:
                    self.stats["failed_patches"] += 1
                    return {
                        "success": False,
                        "error": f"Validation failed: {validation_result['reason']}"
                    }
            
            # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
            backup_path = await self._create_backup(file_path, old_content)
            logger.info(f"ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ: {backup_path}")
            
            # æˆ¦ç•¥ã«å¿œã˜ã¦ãƒ‘ãƒƒãƒé©ç”¨
            if strategy == PatchStrategy.REPLACE:
                apply_result = await self._apply_replace(file_path_obj, new_content)
            
            elif strategy == PatchStrategy.DIFF:
                apply_result = await self._apply_diff(
                    file_path_obj,
                    old_content,
                    new_content
                )
            
            elif strategy == PatchStrategy.MERGE:
                apply_result = await self._apply_merge(
                    file_path_obj,
                    old_content,
                    new_content
                )
            
            elif strategy == PatchStrategy.SAFE_INSERT:
                apply_result = await self._apply_safe_insert(
                    file_path_obj,
                    old_content,
                    new_content
                )
            
            else:
                self.stats["failed_patches"] += 1
                return {
                    "success": False,
                    "error": f"Unsupported strategy: {strategy}"
                }
            
            if apply_result["success"]:
                self.stats["successful_patches"] += 1
                
                # å·®åˆ†æƒ…å ±ã‚’ç”Ÿæˆ
                diff = self._generate_diff(old_content, new_content)
                
                # å±¥æ­´ã«è¿½åŠ 
                self.patch_history.append({
                    "file_path": file_path,
                    "timestamp": datetime.now().isoformat(),
                    "strategy": strategy.value,
                    "backup_path": str(backup_path),
                    "success": True
                })
                
                execution_time = (datetime.now() - start_time).total_seconds()
                
                logger.info(f"âœ… ãƒ‘ãƒƒãƒé©ç”¨æˆåŠŸ: {file_path} ({execution_time:.2f}ç§’)")
                
                return {
                    "success": True,
                    "changed": True,
                    "backup_path": str(backup_path),
                    "diff": diff,
                    "execution_time": execution_time
                }
            
            else:
                self.stats["failed_patches"] += 1
                
                # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
                await self._rollback_from_backup(file_path, backup_path)
                
                return apply_result
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ‘ãƒƒãƒé©ç”¨ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_patches"] += 1
            
            return {
                "success": False,
                "error": str(e)
            }
    
    async def rollback(
        self,
        file_path: str,
        backup_path: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        ãƒ‘ãƒƒãƒã‚’ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
        
        Args:
            file_path: å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«
            backup_path: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‘ã‚¹ï¼ˆçœç•¥æ™‚ã¯æœ€æ–°ï¼‰
            
        Returns:
            Dict: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœ
        """
        try:
            logger.info(f"â™»ï¸ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯é–‹å§‹: {file_path}")
            
            if not backup_path:
                # æœ€æ–°ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’æ¤œç´¢
                backup_path = await self._find_latest_backup(file_path)
            
            if not backup_path:
                return {
                    "success": False,
                    "error": "No backup found"
                }
            
            backup_path_obj = Path(backup_path)
            
            if not backup_path_obj.exists():
                return {
                    "success": False,
                    "error": f"Backup not found: {backup_path}"
                }
            
            # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ
            result = await self._rollback_from_backup(file_path, backup_path_obj)
            
            if result["success"]:
                self.stats["rollbacks"] += 1
                logger.info(f"âœ… ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æˆåŠŸ: {file_path}")
            
            return result
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # ãƒ‘ãƒƒãƒé©ç”¨æˆ¦ç•¥
    # ========================================
    
    async def _apply_replace(
        self,
        file_path: Path,
        new_content: str
    ) -> Dict[str, Any]:
        """ãƒ•ã‚¡ã‚¤ãƒ«å…¨ä½“ã‚’ç½®æ›"""
        try:
            await asyncio.to_thread(
                file_path.write_text,
                new_content,
                encoding='utf-8'
            )
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"âŒ ç½®æ›ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _apply_diff(
        self,
        file_path: Path,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """å·®åˆ†ãƒ‘ãƒƒãƒã‚’é©ç”¨"""
        try:
            # unified diffã‚’ç”Ÿæˆ
            diff = list(difflib.unified_diff(
                old_content.splitlines(keepends=True),
                new_content.splitlines(keepends=True),
                fromfile=str(file_path),
                tofile=str(file_path)
            ))
            
            if not diff:
                return {"success": True, "message": "No differences"}
            
            # æ–°ã—ã„å†…å®¹ã‚’é©ç”¨ï¼ˆå®Ÿéš›ã«ã¯unified diffã®é©ç”¨ãƒ­ã‚¸ãƒƒã‚¯ãŒå¿…è¦ï¼‰
            # ç°¡æ˜“ç‰ˆã¨ã—ã¦å…¨ç½®æ›
            await asyncio.to_thread(
                file_path.write_text,
                new_content,
                encoding='utf-8'
            )
            
            return {
                "success": True,
                "diff_lines": len(diff)
            }
            
        except Exception as e:
            logger.error(f"âŒ å·®åˆ†é©ç”¨ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _apply_merge(
        self,
        file_path: Path,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """ãƒãƒ¼ã‚¸é©ç”¨ï¼ˆ3-way mergeçš„ãªå‡¦ç†ï¼‰"""
        try:
            # ç°¡æ˜“ç‰ˆ: è¡Œå˜ä½ã§ãƒãƒ¼ã‚¸
            old_lines = old_content.splitlines()
            new_lines = new_content.splitlines()
            
            merged_lines = []
            
            # SequenceMatcherã§ãƒãƒƒãƒãƒ³ã‚°
            matcher = difflib.SequenceMatcher(None, old_lines, new_lines)
            
            for tag, i1, i2, j1, j2 in matcher.get_opcodes():
                if tag == 'equal':
                    merged_lines.extend(old_lines[i1:i2])
                elif tag == 'replace':
                    merged_lines.extend(new_lines[j1:j2])
                elif tag == 'delete':
                    pass  # å‰Šé™¤
                elif tag == 'insert':
                    merged_lines.extend(new_lines[j1:j2])
            
            merged_content = '\n'.join(merged_lines)
            
            await asyncio.to_thread(
                file_path.write_text,
                merged_content,
                encoding='utf-8'
            )
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"âŒ ãƒãƒ¼ã‚¸ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _apply_safe_insert(
        self,
        file_path: Path,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """å®‰å…¨ãªæŒ¿å…¥ï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰ã‚’ä¿è­·ï¼‰"""
        try:
            # æ—¢å­˜ã®å†…å®¹ã®çµ‚ã‚ã‚Šã«è¿½åŠ 
            combined_content = old_content + "\n\n# Auto-generated patch\n" + new_content
            
            await asyncio.to_thread(
                file_path.write_text,
                combined_content,
                encoding='utf-8'
            )
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"âŒ å®‰å…¨æŒ¿å…¥ã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    # ========================================
    # æ¤œè¨¼
    # ========================================
    
    async def _validate_patch(
        self,
        old_content: str,
        new_content: str
    ) -> Dict[str, Any]:
        """ãƒ‘ãƒƒãƒã‚’æ¤œè¨¼"""
        try:
            # åŸºæœ¬çš„ãªæ§‹æ–‡ãƒã‚§ãƒƒã‚¯ï¼ˆPythonã®å ´åˆï¼‰
            try:
                compile(new_content, '<string>', 'exec')
            except SyntaxError as e:
                return {
                    "valid": False,
                    "reason": f"Syntax error: {e}"
                }
            
            # ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
            size_diff = len(new_content) - len(old_content)
            if abs(size_diff) > len(old_content) * 2:  # 2å€ä»¥ä¸Šã®å¤‰æ›´
                logger.warning(f"âš ï¸ å¤§å¹…ãªã‚µã‚¤ã‚ºå¤‰æ›´: {size_diff}æ–‡å­—")
            
            # ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
            if '\t' in new_content and '    ' in new_content:
                logger.warning("âš ï¸ ã‚¿ãƒ–ã¨ã‚¹ãƒšãƒ¼ã‚¹ãŒæ··åœ¨ã—ã¦ã„ã¾ã™")
            
            return {"valid": True}
            
        except Exception as e:
            logger.error(f"âŒ æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                "valid": False,
                "reason": str(e)
            }
    
    # ========================================
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç®¡ç†
    # ========================================
    
    async def _create_backup(
        self,
        file_path: str,
        content: str
    ) -> Path:
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_name = Path(file_path).name
            
            # ãƒãƒƒã‚·ãƒ¥ã‚’ç”Ÿæˆï¼ˆãƒ•ã‚¡ã‚¤ãƒ«è­˜åˆ¥ç”¨ï¼‰
            content_hash = hashlib.md5(content.encode()).hexdigest()[:8]
            
            backup_filename = f"{file_name}_{timestamp}_{content_hash}.bak"
            backup_path = self.backup_dir / backup_filename
            
            await asyncio.to_thread(
                backup_path.write_text,
                content,
                encoding='utf-8'
            )
            
            # å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
            await self._cleanup_old_backups(file_name)
            
            return backup_path
            
        except Exception as e:
            logger.error(f"âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            raise
    
    async def _rollback_from_backup(
        self,
        file_path: str,
        backup_path: Path
    ) -> Dict[str, Any]:
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒ"""
        try:
            content = await asyncio.to_thread(
                backup_path.read_text,
                encoding='utf-8'
            )
            
            file_path_obj = Path(file_path)
            await asyncio.to_thread(
                file_path_obj.write_text,
                content,
                encoding='utf-8'
            )
            
            logger.info(f"â™»ï¸ å¾©å…ƒæˆåŠŸ: {file_path} â† {backup_path}")
            
            return {"success": True}
            
        except Exception as e:
            logger.error(f"âŒ å¾©å…ƒã‚¨ãƒ©ãƒ¼: {e}")
            return {"success": False, "error": str(e)}
    
    async def _find_latest_backup(self, file_path: str) -> Optional[str]:
        """æœ€æ–°ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’æ¤œç´¢"""
        try:
            file_name = Path(file_path).name
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            backups = list(self.backup_dir.glob(f"{file_name}_*.bak"))
            
            if not backups:
                return None
            
            # æœ€æ–°ã®ã‚‚ã®ã‚’å–å¾—ï¼ˆã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§ã‚½ãƒ¼ãƒˆï¼‰
            latest_backup = max(backups, key=lambda p: p.stat().st_mtime)
            
            return str(latest_backup)
            
        except Exception as e:
            logger.error(f"âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    async def _cleanup_old_backups(self, file_name: str):
        """å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤"""
        try:
            backups = sorted(
                self.backup_dir.glob(f"{file_name}_*.bak"),
                key=lambda p: p.stat().st_mtime,
                reverse=True
            )
            
            # ä¸Šé™ã‚’è¶…ãˆãŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤
            for backup in backups[self.max_backups:]:
                await asyncio.to_thread(backup.unlink)
                logger.debug(f"ğŸ—‘ï¸ å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å‰Šé™¤: {backup}")
                
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
    
    async def _create_new_file(
        self,
        file_path: str,
        content: str
    ) -> Dict[str, Any]:
        """æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ"""
        try:
            file_path_obj = Path(file_path)
            file_path_obj.parent.mkdir(parents=True, exist_ok=True)
            
            await asyncio.to_thread(
                file_path_obj.write_text,
                content,
                encoding='utf-8'
            )
            
            logger.info(f"âœ… æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ: {file_path}")
            
            self.stats["successful_patches"] += 1
            
            return {
                "success": True,
                "new_file": True
            }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            self.stats["failed_patches"] += 1
            
            return {
                "success": False,
                "error": str(e)
            }
    
    # ========================================
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    # ========================================
    
    def _generate_diff(
        self,
        old_content: str,
        new_content: str
    ) -> str:
        """å·®åˆ†ã‚’ç”Ÿæˆ"""
        diff = difflib.unified_diff(
            old_content.splitlines(keepends=True),
            new_content.splitlines(keepends=True),
            lineterm=''
        )
        
        return ''.join(diff)
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_patches"] > 0:
            success_rate = self.stats["successful_patches"] / self.stats["total_patches"]
        
        return {
            **self.stats,
            "success_rate": success_rate
        }

#pm_agent.py
import asyncio
import json
import logging
from pathlib import Path
from typing import List, Dict, Optional
from datetime import datetime

from config_utils import config, ErrorHandler
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_system_prompts import PM_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class PMAgent:
    """PM AI - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ã¨ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚’æ‹…å½“"""
    
    def __init__(self, sheets_manager: GoogleSheetsManager, browser_controller: BrowserController):
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.current_goal = None
        self.generated_tasks = []
        self.system_prompt = PM_SYSTEM_PROMPT
    
    async def load_project_goal(self) -> Optional[Dict]:
        """project_goalã‚·ãƒ¼ãƒˆã‹ã‚‰æœ€æ–°ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™ã‚’èª­ã¿è¾¼ã‚€"""
        try:
            logger.info("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            
            try:
                goal_sheet = sheet.worksheet("project_goal")
            except:
                logger.error("'project_goal'ã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
            
            all_values = goal_sheet.get_all_values()
            
            if len(all_values) <= 1:
                logger.warning("ç›®æ¨™ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return None
            
            for row in all_values[1:]:
                if len(row) >= 3 and row[2].lower() == 'active':
                    goal = {
                        'goal_id': row[0],
                        'description': row[1],
                        'status': row[2],
                        'created_at': row[3] if len(row) > 3 else ''
                    }
                    logger.info(f"ç›®æ¨™ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {goal['description']}")
                    self.current_goal = goal
                    return goal
            
            logger.warning("ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None
            
        except Exception as e:
            ErrorHandler.log_error(e, "ç›®æ¨™èª­ã¿è¾¼ã¿")
            raise
    async def analyze_and_create_tasks(self, goal_description: str) -> Dict:
        """ç›®æ¨™ã‚’åˆ†æã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: é–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
            logger.info("="*60)
            logger.info("PM AI: ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚’é–‹å§‹ã—ã¾ã™")
            logger.info("="*60)
    
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰ ===
            full_prompt = f"""{self.system_prompt}

    ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã€‘
    {goal_description}

    ã€é‡è¦ãªå‡ºåŠ›æŒ‡ç¤ºã€‘
    1. **å¿…ãšæœ‰åŠ¹ãªJSONå½¢å¼ã®ã¿ã§å‡ºåŠ›ã—ã¦ãã ã•ã„**
    2. èª¬æ˜æ–‡ã€ã‚³ãƒ¡ãƒ³ãƒˆã€æŒ¨æ‹¶ãªã©ã¯ä¸€åˆ‡ä¸è¦ã§ã™
    3. æœ€åˆã®æ–‡å­—ãŒ {{ ã§ã€æœ€å¾Œã®æ–‡å­—ãŒ }} ã®å®Œå…¨ãªJSONå½¢å¼ã®ã¿ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„
    4. **ã‚¿ã‚¹ã‚¯æ•°ã¯æœ€å¤§15å€‹ã¾ã§**ã¨ã—ã€JSONãŒé•·ããªã‚Šã™ããªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„
    5. ã™ã¹ã¦ã®æ–‡å­—åˆ—å€¤ã¯æ­£ã—ããƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§å›²ã‚“ã§ãã ã•ã„

    ä¸Šè¨˜ã®ç›®æ¨™ã‚’é”æˆã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã‚’ã€JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚"""
    
            # === ãƒ‘ãƒ¼ãƒˆ3: Geminiã¸ã®é€ä¿¡ ===
            logger.info("Geminiã«é€ä¿¡ä¸­...")
            await self.browser.send_prompt(full_prompt)
    
            # === ãƒ‘ãƒ¼ãƒˆ4: å¿œç­”å¾…æ©Ÿ ===
            logger.info("PM AIã®åˆ†æã‚’å¾…æ©Ÿä¸­...")
            success = await self.browser.wait_for_text_generation(max_wait=180)
    
            if not success:
                raise Exception("PM AIã®ã‚¿ã‚¹ã‚¯ç”ŸæˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
    
            # === ãƒ‘ãƒ¼ãƒˆ5: å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã®æŠ½å‡º ===
            response_text = await self.browser.extract_latest_text_response()
    
            if not response_text:
                raise Exception("PM AIã‹ã‚‰ã®å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
    
            logger.info(f"PM AIã®å¿œç­”ã‚’å–å¾—ã—ã¾ã—ãŸï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            logger.info(f"å¿œç­”ã®å…ˆé ­500æ–‡å­—:\n{response_text[:500]}")
            logger.info(f"å¿œç­”ã®æœ«å°¾500æ–‡å­—:\n{response_text[-500:]}")
    
            # === ãƒ‘ãƒ¼ãƒˆ6: JSONãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®è§£æ ===
            task_plan = self._parse_json_response(response_text)
    
            if task_plan:
                # === ãƒ‘ãƒ¼ãƒˆ7: æˆåŠŸæ™‚ã®å‡¦ç† ===
                logger.info("="*60)
                logger.info("PM AI: ã‚¿ã‚¹ã‚¯åˆ†è§£å®Œäº†")
                logger.info(f"ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯æ•°: {len(task_plan.get('tasks', []))}")
                logger.info("="*60)
                self.generated_tasks = task_plan.get('tasks', [])
                return task_plan
            else:
                # === ãƒ‘ãƒ¼ãƒˆ8: JSONè§£æå¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç† ===
                logger.error("JSONè§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚å¿œç­”å…¨ä½“ã‚’ä¿å­˜ã—ã¾ã™ã€‚")
                fallback_path = Path("pm_ai_response_error.txt")
                with open(fallback_path, 'w', encoding='utf-8') as f:
                    f.write(response_text)
                logger.info(f"å¿œç­”ã‚’ä¿å­˜ã—ã¾ã—ãŸ: {fallback_path}")
        
                logger.error("="*60)
                logger.error("âŒ è‡ªå‹•ä¿®å¾©ã‚‚å¤±æ•—ã—ã¾ã—ãŸ")
                logger.error("="*60)
        
                # === ãƒ‘ãƒ¼ãƒˆ9: ä¿®æ­£æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚§ãƒƒã‚¯ ===
                fixed_path = Path("pm_ai_response_fixed.json")
                if fixed_path.exists():
                    logger.info("ä¿®æ­£æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡ºã—ã¾ã—ãŸ!")
                    try:
                        with open(fixed_path, 'r', encoding='utf-8') as f:
                            task_plan = json.load(f)
                        logger.info(f"âœ… ä¿®æ­£æ¸ˆã¿JSONã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: ã‚¿ã‚¹ã‚¯æ•°={len(task_plan.get('tasks', []))}")
                        self.generated_tasks = task_plan.get('tasks', [])
                        return task_plan
                    except Exception as e:
                        logger.error(f"ä¿®æ­£æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: {e}")
        
                raise Exception("PM AIã®å¿œç­”ã‚’JSONå½¢å¼ã§ãƒ‘ãƒ¼ã‚¹ã§ãã¾ã›ã‚“ã§ã—ãŸ")
    
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ç”Ÿæˆ")
            raise
        
        
    def _parse_json_response(self, text: str) -> Optional[Dict]:
        """å¿œç­”ã‹ã‚‰JSONéƒ¨åˆ†ã‚’æŠ½å‡ºã—ã¦ãƒ‘ãƒ¼ã‚¹ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å…¥åŠ›æ¤œè¨¼ ===
            if not text:
                logger.warning("ç©ºã®å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆ")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ2: è§£æé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
            logger.info("="*60)
            logger.info("JSONè§£æé–‹å§‹")
            logger.info("="*60)
            logger.info(f"å¿œç­”å…¨ä½“ã®é•·ã•: {len(text)}æ–‡å­—")
            
            import re
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ‘ã‚¿ãƒ¼ãƒ³1 - ```json ... ``` å½¢å¼ã®æ¤œå‡º ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                logger.info("âœ… ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json...``` å½¢å¼ã‚’æ¤œå‡º")
                try:
                    result = json.loads(json_str)
                    logger.info(f"âœ… JSONè§£ææˆåŠŸï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³1ï¼‰: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                    return result
                except json.JSONDecodeError as e:
                    logger.warning(f"ãƒ‘ã‚¿ãƒ¼ãƒ³1ã§JSONè§£æå¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‘ã‚¿ãƒ¼ãƒ³2 - ä¸­æ‹¬å¼§ã®ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ã—ãŸæŠ½å‡º ===
            start_idx = text.find('{')
            if start_idx != -1:
                logger.info(f"âœ… '{{' ã‚’ä½ç½® {start_idx} ã§æ¤œå‡º")
                
                # === ãƒ‘ãƒ¼ãƒˆ5: ãƒãƒ©ãƒ³ã‚¹ã®å–ã‚ŒãŸJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¤œå‡º ===
                brace_count = 0
                in_string = False
                escape_next = False
                
                for i, char in enumerate(text[start_idx:], start=start_idx):
                    if escape_next:
                        escape_next = False
                        continue
                    
                    if char == '\\':
                        escape_next = True
                        continue
                    
                    if char == '"' and not escape_next:
                        in_string = not in_string
                        continue
                    
                    if not in_string:
                        if char == '{':
                            brace_count += 1
                        elif char == '}':
                            brace_count -= 1
                            if brace_count == 0:
                                # === ãƒ‘ãƒ¼ãƒˆ6: å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡ºã¨è§£æ ===
                                potential_json = text[start_idx:i+1]
                                logger.info(f"âœ… å®Œå…¨ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŠ½å‡º: {len(potential_json)}æ–‡å­—")
                                
                                try:
                                    result = json.loads(potential_json)
                                    logger.info(f"âœ… JSONè§£ææˆåŠŸ: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                                    return result
                                except json.JSONDecodeError as e:
                                    # === ãƒ‘ãƒ¼ãƒˆ7: è§£æã‚¨ãƒ©ãƒ¼ã®è©³ç´°ãƒ­ã‚° ===
                                    logger.error(f"âŒ JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
                                    logger.error(f"ã‚¨ãƒ©ãƒ¼ä½ç½®: line {e.lineno}, column {e.colno}")
                                    
                                    error_pos = e.pos if hasattr(e, 'pos') else 0
                                    context_start = max(0, error_pos - 100)
                                    context_end = min(len(potential_json), error_pos + 100)
                                    logger.error(f"ã‚¨ãƒ©ãƒ¼å‘¨è¾ºã®ãƒ†ã‚­ã‚¹ãƒˆ:\n{potential_json[context_start:context_end]}")
                                    
                                    # === ãƒ‘ãƒ¼ãƒˆ8: JSONä¿®å¾©ã®è©¦è¡Œ ===
                                    repaired_json = self._attempt_json_repair(potential_json, e)
                                    if repaired_json:
                                        return repaired_json
            
            # === ãƒ‘ãƒ¼ãƒˆ9: ãƒ‘ã‚¿ãƒ¼ãƒ³3 - ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’JSONã¨ã—ã¦è§£æ ===
            logger.info("ãƒ‘ã‚¿ãƒ¼ãƒ³3: ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’JSONã¨ã—ã¦è§£æ")
            try:
                result = json.loads(text)
                logger.info(f"âœ… JSONè§£ææˆåŠŸï¼ˆå…¨ä½“è§£æï¼‰: ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                return result
            except json.JSONDecodeError as e:
                logger.error(f"âŒ å…¨ä½“è§£æã‚‚å¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ10: å…¨ãƒ‘ã‚¿ãƒ¼ãƒ³å¤±æ•—æ™‚ã®ã‚¨ãƒ©ãƒ¼ãƒ­ã‚° ===
            logger.error("="*60)
            logger.error("âŒ ã™ã¹ã¦ã®JSONè§£æãƒ‘ã‚¿ãƒ¼ãƒ³ãŒå¤±æ•—")
            logger.error("="*60)
            logger.error(f"å¿œç­”ã®å…ˆé ­500æ–‡å­—:\n{text[:500]}")
            logger.error(f"å¿œç­”ã®æœ«å°¾500æ–‡å­—:\n{text[-500:]}")
            
            return None
            
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ11: äºˆæœŸã—ãªã„ä¾‹å¤–ã®å‡¦ç† ===
            logger.error(f"âŒ JSONè§£æã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def _attempt_json_repair(self, json_str: str, error: json.JSONDecodeError) -> Optional[Dict]:
        """å£Šã‚ŒãŸJSONã®ä¿®å¾©ã‚’è©¦ã¿ã‚‹"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ä¿®å¾©é–‹å§‹ ===
            logger.info("ğŸ”§ JSONä¿®å¾©ã‚’è©¦ã¿ã¾ã™...")
            
            error_pos = error.pos if hasattr(error, 'pos') else len(json_str)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ä¿®å¾©è©¦è¡Œ1 - ãƒ‡ãƒªãƒŸã‚¿ã‚¨ãƒ©ãƒ¼ã®ä¿®æ­£ ===
            if "Expecting ',' delimiter" in str(error) or "Expecting ':' delimiter" in str(error):
                last_complete_task = json_str.rfind('},', 0, error_pos)
                if last_complete_task > 0:
                    repaired = json_str[:last_complete_task + 1] + '], "risks": [], "success_criteria": []}'
                    logger.info(f"ä¿®å¾©è©¦è¡Œ1: ä½ç½®{last_complete_task}ã§åˆ‡ã‚Šæ¨ã¦")
                    try:
                        result = json.loads(repaired)
                        logger.info(f"âœ… ä¿®å¾©æˆåŠŸ! ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                        return result
                    except:
                        pass
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ä¿®å¾©è©¦è¡Œ2 - è¡Œãƒ™ãƒ¼ã‚¹ã®åˆ‡ã‚Šæ¨ã¦ ===
            lines = json_str.split('\n')
            error_line = error.lineno if hasattr(error, 'lineno') else len(lines)
            
            if error_line > 0 and error_line <= len(lines):
                truncated_lines = lines[:error_line-1]
                truncated = '\n'.join(truncated_lines)
                open_braces = truncated.count('{') - truncated.count('}')
                
                repaired = truncated
                if ',"tasks":[' in repaired and not repaired.rstrip().endswith(']'):
                    repaired += ']'
                
                # === ãƒ‘ãƒ¼ãƒˆ4: é–‹ã„ãŸä¸­æ‹¬å¼§ã‚’é–‰ã˜ã‚‹ ===
                for _ in range(open_braces):
                    repaired += '}'
                
                logger.info("ä¿®å¾©è©¦è¡Œ2: ä¸å®Œå…¨ãªéƒ¨åˆ†ã‚’å‰Šé™¤ã—ã¦é–‰ã˜ã‚‹")
                try:
                    result = json.loads(repaired)
                    logger.info(f"âœ… ä¿®å¾©æˆåŠŸ! ã‚¿ã‚¹ã‚¯æ•°={len(result.get('tasks', []))}")
                    return result
                except:
                    pass
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ä¿®å¾©å¤±æ•— ===
            logger.warning("âŒ JSONä¿®å¾©ã«å¤±æ•—")
            return None
            
        except Exception as e:
            logger.error(f"JSONä¿®å¾©ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")
            return None
        
    async def save_tasks_to_sheet(self, task_plan: Dict) -> bool:
        """ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ï¼ˆè¿½åŠ æ–¹å¼ï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ä¿å­˜é–‹å§‹ ===
            logger.info("ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ä¸­...")
        
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                # === ãƒ‘ãƒ¼ãƒˆ2: æ—¢å­˜ã‚·ãƒ¼ãƒˆã®èª­ã¿è¾¼ã¿ ===
                task_sheet = sheet.worksheet("pm_tasks")
                existing_data = task_sheet.get_all_values()
                start_row = len(existing_data) + 1
            
                if len(existing_data) == 0:
                    # === ãƒ‘ãƒ¼ãƒˆ3: æ–°è¦ã‚·ãƒ¼ãƒˆã®ãƒ˜ãƒƒãƒ€ãƒ¼ä½œæˆ ===
                    headers = [
                        "task_id", "parent_goal_id", "task_description", 
                        "required_role", "status", "priority", 
                        "estimated_time", "dependencies", "created_at", "batch_id"
                    ]
                    task_sheet.update('A1:J1', [headers])
                    start_row = 2
                
            except:
                # === ãƒ‘ãƒ¼ãƒˆ4: ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã®ä½œæˆ ===
                logger.info("'pm_tasks'ã‚·ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™")
                task_sheet = sheet.add_worksheet(title="pm_tasks", rows=1000, cols=10)
                headers = [
                    "task_id", "parent_goal_id", "task_description", 
                    "required_role", "status", "priority", 
                    "estimated_time", "dependencies", "created_at", "batch_id"
                ]
                task_sheet.update('A1:J1', [headers])
                start_row = 2
                existing_data = []
        
            # === ãƒ‘ãƒ¼ãƒˆ5: ãƒãƒƒãƒIDã®ç”Ÿæˆ ===
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            # === ãƒ‘ãƒ¼ãƒˆ6: æ—¢å­˜ã‚¿ã‚¹ã‚¯IDã®åé›† ===
            existing_task_ids = []
            if len(existing_data) > 1:
                for row in existing_data[1:]:
                    if row and row[0].isdigit():
                        existing_task_ids.append(int(row[0]))
        
            # === ãƒ‘ãƒ¼ãƒˆ7: æ¬¡ã®ã‚¿ã‚¹ã‚¯IDã®æ±ºå®š ===
            next_task_id = max(existing_task_ids) + 1 if existing_task_ids else 1
        
            # === ãƒ‘ãƒ¼ãƒˆ8: ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ ===
            tasks = task_plan.get('tasks', [])
            rows_data = []
        
            for i, task in enumerate(tasks):
                row = [
                    next_task_id + i,
                    self.current_goal['goal_id'] if self.current_goal else '',
                    task.get('description', ''),
                    task.get('required_role', 'dev'),
                    'pending',
                    task.get('priority', 'medium'),
                    task.get('estimated_time', ''),
                    ','.join(map(str, task.get('dependencies', []))),
                    datetime.now().isoformat(),
                    batch_id
                ]
                rows_data.append(row)
        
            # === ãƒ‘ãƒ¼ãƒˆ9: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã¸ã®æ›¸ãè¾¼ã¿ ===
            if rows_data:
                end_row = start_row + len(rows_data) - 1
                task_sheet.update(f'A{start_row}:J{end_row}', rows_data)
                logger.info(f"ã‚¿ã‚¹ã‚¯ {len(rows_data)} ä»¶ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼ˆãƒãƒƒãƒ: {batch_id}ï¼‰")
        
            # === ãƒ‘ãƒ¼ãƒˆ10: ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ ===
            self._save_project_metadata(task_plan)
        
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ä¿å­˜")
            return False
    
    def _save_project_metadata(self, task_plan: Dict):
        """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ¡ã‚¿æƒ…å ±ï¼ˆåˆ†æçµæœã€ãƒªã‚¹ã‚¯ã€æˆåŠŸåŸºæº–ï¼‰ã‚’ä¿å­˜ï¼ˆè¿½åŠ æ–¹å¼ï¼‰"""
        try:
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
        
            try:
                meta_sheet = sheet.worksheet("project_metadata")
                existing_data = meta_sheet.get_all_values()
                start_row = len(existing_data) + 2
            except:
                meta_sheet = sheet.add_worksheet(title="project_metadata", rows=100, cols=5)
                existing_data = []
                start_row = 1
        
            batch_id = f"batch_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
            data = [
                ["ãƒãƒƒãƒID", batch_id],
                ["ç›®æ¨™ID", self.current_goal['goal_id'] if self.current_goal else ''],
                ["åˆ†æçµæœ", task_plan.get('project_analysis', '')],
                ["", ""],
                ["ãƒªã‚¹ã‚¯", ""],
            ]
        
            for risk in task_plan.get('risks', []):
                data.append(["", risk])
        
            data.append(["", ""])
            data.append(["æˆåŠŸåŸºæº–", ""])
        
            for criteria in task_plan.get('success_criteria', []):
                data.append(["", criteria])
        
            if existing_data:
                data = [["", ""], ["="*50, "="*50]] + data
        
            end_row = start_row + len(data) - 1
            meta_sheet.update(f'A{start_row}:B{end_row}', data)
            logger.info("ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
        
        except Exception as e:
            logger.warning(f"ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã«å¤±æ•—: {e}")
    
    def display_task_summary(self, task_plan: Dict):
        """ã‚¿ã‚¹ã‚¯æ¦‚è¦ã‚’è¡¨ç¤º"""
        print("\n" + "="*60)
        print("PM AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯åˆ†è§£çµæœ")
        print("="*60)
        
        print(f"\nã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æã€‘")
        print(task_plan.get('project_analysis', ''))
        
        print(f"\nã€ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯: {len(task_plan.get('tasks', []))}ä»¶ã€‘")
        for i, task in enumerate(task_plan.get('tasks', []), 1):
            role_icon = {
                'design': 'ğŸ“',
                'dev': 'ğŸ’»',
                'ui': 'ğŸ¨',
                'review': 'âœ…'
            }.get(task.get('required_role', 'dev'), 'ğŸ“‹')
            
            priority_icon = {
                'high': 'ğŸ”´',
                'medium': 'ğŸŸ¡',
                'low': 'ğŸŸ¢'
            }.get(task.get('priority', 'medium'), 'âšª')
            
            print(f"{i}. {priority_icon} {role_icon} {task.get('description', '')}")
            print(f"   æ‹…å½“: {task.get('required_role', 'dev')} | å„ªå…ˆåº¦: {task.get('priority', 'medium')}")
            if task.get('dependencies'):
                print(f"   ä¾å­˜: ã‚¿ã‚¹ã‚¯ {task.get('dependencies')}")
            print()
        
        if task_plan.get('risks'):
            print(f"\nã€æƒ³å®šãƒªã‚¹ã‚¯ã€‘")
            for risk in task_plan.get('risks', []):
                print(f"- {risk}")
        
        if task_plan.get('success_criteria'):
            print(f"\nã€æˆåŠŸåŸºæº–ã€‘")
            for criteria in task_plan.get('success_criteria', []):
                print(f"- {criteria}")
        
        print("="*60)

async def main():
    """PM AIå˜ä½“ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    import argparse
        
    # === ãƒ‘ãƒ¼ãƒˆ1: å¼•æ•°è§£æ ===
    parser = argparse.ArgumentParser(description='PM AI - ã‚¿ã‚¹ã‚¯åˆ†è§£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ')
    parser.add_argument('--goal', type=str, help='ç›´æ¥ç›®æ¨™ã‚’æŒ‡å®šã™ã‚‹ï¼ˆã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’ä½¿ã‚ãªã„å ´åˆï¼‰')
    args = parser.parse_args()
        
    # === ãƒ‘ãƒ¼ãƒˆ2: èµ·å‹•ãƒ˜ãƒƒãƒ€ãƒ¼ ===
    print("="*60)
    print("PM AIèµ·å‹•ä¸­...")
    print("="*60)
        
    # === ãƒ‘ãƒ¼ãƒˆ3: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®š ===
    default_service_account = r"C:\Users\color\Documents\gemini_auto_generate\service_account.json"
    service_account_file = default_service_account if Path(default_service_account).exists() else None
        
    # === ãƒ‘ãƒ¼ãƒˆ4: ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼åˆæœŸåŒ– ===
    sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
    # === ãƒ‘ãƒ¼ãƒˆ5: PCè¨­å®šã®èª­ã¿è¾¼ã¿ ===
    pc_id = sheets_manager.get_current_pc_id()
    settings = sheets_manager.load_pc_settings(pc_id)
        
    config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
    config.COOKIES_FILE = settings.get('cookies_file')
    config.GENERATION_MODE = 'text'
    config.SERVICE_TYPE = 'google'
        
    # === ãƒ‘ãƒ¼ãƒˆ6: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š ===
    download_folder = Path(r"C:\Users\color\Documents\gemini_auto_generate\temp_texts")
    download_folder.mkdir(exist_ok=True, parents=True)
        
    # === ãƒ‘ãƒ¼ãƒˆ7: ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åˆæœŸåŒ– ===
    browser = BrowserController(download_folder, mode='text', service='google')
    await browser.setup_browser()
        
    logger.info("Geminiã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
    await browser.navigate_to_gemini()
        
    # === ãƒ‘ãƒ¼ãƒˆ8: PMã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
    pm_agent = PMAgent(sheets_manager, browser)
        
    # === ãƒ‘ãƒ¼ãƒˆ9: ç›®æ¨™ã®å–å¾—ï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ or ã‚·ãƒ¼ãƒˆï¼‰===
    if args.goal:
        goal_description = args.goal
        logger.info(f"ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã‹ã‚‰ç›®æ¨™ã‚’å–å¾—: {goal_description}")
    else:
        goal = await pm_agent.load_project_goal()
        if not goal:
            print("\nã‚¨ãƒ©ãƒ¼: ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªç›®æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            print("ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®'project_goal'ã‚·ãƒ¼ãƒˆã«statusãŒ'active'ã®ç›®æ¨™ã‚’è¨­å®šã—ã¦ãã ã•ã„")
            await browser.cleanup()
            return
        goal_description = goal['description']
        
    try:
        # === ãƒ‘ãƒ¼ãƒˆ10: ã‚¿ã‚¹ã‚¯è¨ˆç”»ã®ç”Ÿæˆ ===
        task_plan = await pm_agent.analyze_and_create_tasks(goal_description)
            
        # === ãƒ‘ãƒ¼ãƒˆ11: ã‚¿ã‚¹ã‚¯æ¦‚è¦ã®è¡¨ç¤º ===
        pm_agent.display_task_summary(task_plan)
            
        # === ãƒ‘ãƒ¼ãƒˆ12: ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªã¨ä¿å­˜ ===
        save = input("\nã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
        if save.lower() == 'y':
            success = await pm_agent.save_tasks_to_sheet(task_plan)
            if success:
                print("ã‚¿ã‚¹ã‚¯ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
            else:
                print("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ")
            
    except Exception as e:
        # === ãƒ‘ãƒ¼ãƒˆ13: ä¾‹å¤–å‡¦ç† ===
        logger.error(f"PM AIå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        traceback.print_exc()
        
    finally:
        # === ãƒ‘ãƒ¼ãƒˆ14: ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— ===
        await browser.cleanup()
        print("\nPM AIã‚’çµ‚äº†ã—ã¾ã—ãŸ")

if __name__ == "__main__":
    asyncio.run(main())


#pm_system_prompts.py
"""
PM AIã®ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©ï¼ˆå®Œå…¨ç‰ˆï¼‰
ACF & Custom Post Type UI å¯¾å¿œ
"""

PM_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼AIã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç›®æ¨™ã‚’åˆ†æã—ã€é”æˆã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã«åˆ†è§£ã™ã‚‹
- å„ã‚¿ã‚¹ã‚¯ã«é©åˆ‡ãªæ‹…å½“è€…ï¼ˆAI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼‰ã‚’å‰²ã‚Šå½“ã¦ã‚‹
- **å¤šè¨€èªå¯¾å¿œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã¯ã€å¿…ãšè¨€èªã¨Polylangè¨­å®šã‚’æ˜è¨˜ã™ã‚‹**
- **é–‹ç™ºã‚¿ã‚¹ã‚¯ã¯åŸå‰‡WordPressã§å®Ÿè£…å¯èƒ½ã‹æ¤œè¨ã™ã‚‹**
- ã‚¿ã‚¹ã‚¯ã®å„ªå…ˆé †ä½ã‚’æ±ºå®šã™ã‚‹
- å®Ÿç¾å¯èƒ½ã§å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã™ã‚‹

ã€é‡è¦: WordPresså„ªå…ˆé–‹ç™ºãƒãƒªã‚·ãƒ¼ã€‘
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ **WordPressä¸­å¿ƒã®é–‹ç™ºã‚¹ã‚¿ã‚¤ãƒ«** ã‚’æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚
ä»¥ä¸‹ã®å„ªå…ˆé †ä½ã§ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„:

**å„ªå…ˆåº¦1: WordPressæ¨™æº–æ©Ÿèƒ½ + ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®Ÿè£…**
- ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— â†’ **wordpress**: Custom Post Type UI ã§GUIè¨­å®š
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ â†’ **wordpress**: Advanced Custom Fields (ACF) ã§GUIè¨­å®š
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ â†’ **design**: ACFè¨­è¨ˆæ›¸ä½œæˆ â†’ **wordpress**: ACFè¨­å®š
- UI/ç”»é¢ãƒ‡ã‚¶ã‚¤ãƒ³ â†’ **ui**: ãƒ‡ã‚¶ã‚¤ãƒ³è¨­è¨ˆ â†’ **wordpress**: ãƒ†ãƒ¼ãƒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- æ¤œç´¢ãƒ»çµã‚Šè¾¼ã¿ â†’ **wordpress**: FacetWP / SearchWP / Relevanssiè¨­å®š
- ãƒ•ã‚©ãƒ¼ãƒ ä½œæˆ â†’ **wordpress**: ACFãƒ•ã‚©ãƒ¼ãƒ  / Contact Form 7è¨­å®š
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç† â†’ **wordpress**: User Role Editor / Membersè¨­å®š

**å„ªå…ˆåº¦2: è»½é‡ã‚«ã‚¹ã‚¿ãƒ é–‹ç™ºï¼ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ´»ç”¨å¾Œã®å¾®èª¿æ•´ï¼‰**
- ACFé€£æºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º â†’ **dev**: functions.phpè¿½è¨˜
- æ¤œç´¢ã‚¯ã‚¨ãƒªèª¿æ•´ â†’ **dev**: pre_get_posts ãƒ•ãƒƒã‚¯å®Ÿè£…
- è¡¨ç¤ºã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º â†’ **dev**: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ

**å„ªå…ˆåº¦3: é«˜åº¦ãªé–‹ç™ºï¼ˆWordPressæ¨™æº–ã§å®Ÿç¾å›°é›£ãªå ´åˆã®ã¿ï¼‰**
- è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ â†’ **dev**: ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™º
- å¤–éƒ¨APIé€£æº â†’ **dev**: REST APIçµ±åˆ
- ç‰¹æ®Šãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ â†’ **design**: ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆ â†’ **dev**: å®Ÿè£…

**åˆ¤æ–­åŸºæº–:**
ã€ŒWordPressã®æ¨™æº–æ©Ÿèƒ½ã‚„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã§å®Ÿç¾ã§ãã‚‹ã‹ï¼Ÿã€
â†’ YES: wordpress / plugin ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
â†’ NO: design â†’ dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ã€åˆ©ç”¨å¯èƒ½ãªAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã€‘

**é–‹ç™ºãƒ»è¨­è¨ˆç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **design** (è¨­è¨ˆAI): ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆã€è¦ä»¶å®šç¾©æ›¸ä½œæˆã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã€APIä»•æ§˜æ›¸ä½œæˆã€ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­è¨ˆæ›¸ä½œæˆ
- **dev** (é–‹ç™ºAI): ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä½œæˆã€å®Ÿè£…ã€è¤‡æ•°è¨€èªå¯¾å¿œï¼ˆPython, JavaScript, PHP ãªã©ï¼‰ã€functions.php ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **ui** (UI/UX AI): ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆã€ç”»é¢è¨­è¨ˆã€UXæœ€é©åŒ–ã€ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ä½œæˆ

**ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **writer** (æ±ç”¨ãƒ©ã‚¤ã‚¿ãƒ¼AI): ãƒ–ãƒ­ã‚°è¨˜äº‹ä½œæˆã€HTMLè¨˜äº‹åŸ·ç­†ã€SEOã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
- **writer_ja** (æ—¥æœ¬èªãƒ©ã‚¤ã‚¿ãƒ¼AI): æ—¥æœ¬èªè¨˜äº‹ä½œæˆã€å“è³ªé‡è¦–ã€æ—¥æœ¬ã®ãƒ“ã‚¸ãƒã‚¹ã‚ªãƒ¼ãƒŠãƒ¼å‘ã‘
- **writer_en** (è‹±èªãƒ©ã‚¤ã‚¿ãƒ¼AI): è‹±èªè¨˜äº‹ä½œæˆã€SEOæœ€é©åŒ–ã€å›½éš›æŠ•è³‡å®¶å‘ã‘
- **writer_ru** (ãƒ­ã‚·ã‚¢èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ãƒ­ã‚·ã‚¢èªè¨˜äº‹ä½œæˆã€ç¾åœ°ãƒ“ã‚¸ãƒã‚¹å‘ã‘
- **writer_uz** (ã‚¦ã‚ºãƒ™ã‚¯èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ã‚¦ã‚ºãƒ™ã‚¯èªè¨˜äº‹ä½œæˆã€ç¾åœ°ä¼æ¥­å‘ã‘
- **writer_zh** (ä¸­å›½èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ä¸­å›½èªè¨˜äº‹ä½œæˆã€ä¸­å›½æŠ•è³‡å®¶å‘ã‘
- **writer_ko** (éŸ“å›½èªãƒ©ã‚¤ã‚¿ãƒ¼AI): éŸ“å›½èªè¨˜äº‹ä½œæˆã€éŸ“å›½ãƒ“ã‚¸ãƒã‚¹å‘ã‘
- **writer_tr** (ãƒˆãƒ«ã‚³èªãƒ©ã‚¤ã‚¿ãƒ¼AI): ãƒˆãƒ«ã‚³èªè¨˜äº‹ä½œæˆã€ãƒˆãƒ«ã‚³ãƒ“ã‚¸ãƒã‚¹å‘ã‘
- **content** (ã‚³ãƒ³ãƒ†ãƒ³ãƒ„AI): writerã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ï¼ˆå¾Œæ–¹äº’æ›æ€§ï¼‰

**WordPressãƒ»ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **wordpress** (WordPressAI): WordPressæŠ•ç¨¿ã€è¨˜äº‹å…¬é–‹ã€è¨˜äº‹ç·¨é›†ã€Polylangè¨€èªè¨­å®šã€ä¸‹æ›¸ãä¿å­˜ã€ACFè¨­å®šã€Custom Post Type UIè¨­å®šã€ãƒ†ãƒ¼ãƒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- **plugin** (ãƒ—ãƒ©ã‚°ã‚¤ãƒ³AI): WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†ã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã€è¨­å®šå¤‰æ›´ã€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é¸å®š

**å“è³ªç®¡ç†ç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ:**
- **review** (ãƒ¬ãƒ“ãƒ¥ãƒ¼AI): å“è³ªãƒã‚§ãƒƒã‚¯ã€ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€è¨˜äº‹ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€å‡ºåŠ›ç‰©è©•ä¾¡

ã€é‡è¦: ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€‘
ä»¥ä¸‹ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯ã™ã§ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã§ã™ã€‚ã“ã‚Œã‚‰ã‚’æ´»ç”¨ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š
- Advanced Custom Fields (ACF) Pro
- Custom Post Type UI
- Polylang Pro
- FacetWPï¼ˆæ¤œç´¢æ©Ÿèƒ½å¼·åŒ–ï¼‰
- User Role Editorï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ç®¡ç†ï¼‰
- Wordfence Securityï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼‰
- WP Rocketï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼‰

ã€é‡è¦: ACF & Custom Post Type UI è¨­å®šã‚¿ã‚¹ã‚¯ã®ãƒ«ãƒ¼ãƒ«ã€‘

**ACFè¨­å®šã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€ACFè¨­å®šã€‘M&Aæ¡ˆä»¶ç”¨ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä½œæˆ",
  "acf_field_group_name": "M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±",
  "acf_fields": [
    {"name": "case_id", "type": "text", "label": "æ¡ˆä»¶ID", "required": true},
    {"name": "ma_scheme", "type": "select", "label": "M&Aã‚¹ã‚­ãƒ¼ãƒ ", "choices": ["æ ªå¼è­²æ¸¡", "äº‹æ¥­è­²æ¸¡"]},
    {"name": "desired_price", "type": "number", "label": "å¸Œæœ›ä¾¡æ ¼", "min": 0}
  ],
  "acf_location_rules": {
    "post_type": "ma_case"
  }
}
```

**ä½¿ç”¨å¯èƒ½ãªACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—:**
- ãƒ†ã‚­ã‚¹ãƒˆç³»: text, textarea, number, email, url, password
- é¸æŠç³»: select, checkbox, radio, true_false
- æ—¥ä»˜æ™‚åˆ»ç³»: date_picker, date_time_picker, time_picker
- ãƒ•ã‚¡ã‚¤ãƒ«ç³»: file, image, gallery
- ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç³»: post_object, relationship, taxonomy, user
- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç³»: repeater, flexible_content, group
- ãã®ä»–: wysiwyg, oembed, google_map, color_picker

**Custom Post Typeè¨­å®šã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€Custom Post Typeã€‘M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆ",
  "cpt_slug": "ma_case",
  "cpt_labels": {
    "singular": "M&Aæ¡ˆä»¶",
    "plural": "M&Aæ¡ˆä»¶ä¸€è¦§"
  },
  "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"],
  "cpt_settings": {
    "public": true,
    "has_archive": true,
    "show_in_rest": true,
    "menu_icon": "dashicons-portfolio"
  }
}
```

**ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼è¨­å®šã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã€‘æ¥­ç¨®ã‚«ãƒ†ã‚´ãƒªä½œæˆ",
  "taxonomy_slug": "industry_category",
  "taxonomy_labels": {
    "singular": "æ¥­ç¨®",
    "plural": "æ¥­ç¨®ä¸€è¦§"
  },
  "taxonomy_post_types": ["ma_case"],
  "taxonomy_hierarchical": true
}
```

**M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã«å¿…é ˆã®æƒ…å ±:**
```json
{
  "agent": "wordpress",
  "description": "ã€M&Aæ¡ˆä»¶ç™»éŒ²ã€‘è£½é€ æ¥­ã®äº‹æ¥­æ‰¿ç¶™æ¡ˆä»¶æŠ•ç¨¿",
  "post_title": "è£½é€ æ¥­ãƒ»å¹´å•†5å„„å††ãƒ»é»’å­—ä¼æ¥­ã®äº‹æ¥­æ‰¿ç¶™æ¡ˆä»¶",
  "post_content": "ä¼æ¥­æ¦‚è¦...",
  "acf_fields": {
    "case_id": "MA2025001",
    "ma_scheme": "æ ªå¼è­²æ¸¡",
    "desired_price": "100000000",
    "industry_category": "è£½é€ æ¥­",
    "region": "é–¢æ±",
    "established_year": "1995",
    "employees": "50"
  },
  "polylang_lang": "ja",
  "post_status": "draft"
}
```

ã€é‡è¦: è¨€èªæŒ‡å®šã®ãƒ«ãƒ¼ãƒ«ã€‘
1. **è¨˜äº‹ä½œæˆã‚¿ã‚¹ã‚¯**ã«ã¯å¿…ãšä»¥ä¸‹ã‚’å«ã‚ã‚‹:
   - `language`: å¯¾è±¡è¨€èªã‚³ãƒ¼ãƒ‰ (ja/en/ru/uz/zh/ko/tr)
   - `polylang_lang`: Polylangã®è¨€èªè¨­å®š (ja/en/ru/uz_UZ/zh_CN/ko_KR/tr_TR)
   - `target_url`: å‚ç…§å…ƒURLï¼ˆã‚ã‚‹å ´åˆï¼‰
   - `seo_keywords`: SEOã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
   - `target_audience`: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆèª­è€…

2. **WordPressæŠ•ç¨¿ã‚¿ã‚¹ã‚¯**ã«ã¯å¿…ãšä»¥ä¸‹ã‚’å«ã‚ã‚‹:
   - `language`: æŠ•ç¨¿å…ˆè¨€èª
   - `polylang_lang`: Polylangè¨€èªã‚³ãƒ¼ãƒ‰
   - `source_task_id`: å…ƒè¨˜äº‹ã®ã‚¿ã‚¹ã‚¯ID
   - `post_action`: "create" ã¾ãŸã¯ "edit"
   - `post_status`: "publish" / "draft" / "pending"

3. **ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯**ã«ã¯ä»¥ä¸‹ã‚’å«ã‚ã‚‹:
   - `review_language`: ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã®è¨€èª
   - `review_target_task_id`: ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚¿ã‚¹ã‚¯ID
   - `review_criteria`: è©•ä¾¡åŸºæº–

ã€ã‚¿ã‚¹ã‚¯åˆ†è§£ã®åŸºæœ¬ãƒ•ãƒ­ãƒ¼ã€‘

**ãƒ‘ã‚¿ãƒ¼ãƒ³1: å¤šè¨€èªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "writer_ja",
      "description": "ã€æ—¥æœ¬èªã€‘M&Aå¸‚å ´å‹•å‘è¨˜äº‹ä½œæˆ",
      "language": "ja",
      "polylang_lang": "ja",
      "seo_keywords": "M&A,ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³,å¸‚å ´å‹•å‘"
    },
    {
      "id": 2,
      "agent": "review",
      "description": "ã€æ—¥æœ¬èªã€‘è¨˜äº‹å“è³ªãƒã‚§ãƒƒã‚¯",
      "review_language": "ja",
      "review_target_task_id": 1
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "ã€æ—¥æœ¬èªã€‘WordPressæŠ•ç¨¿",
      "polylang_lang": "ja",
      "source_task_id": 1,
      "post_action": "create",
      "post_status": "publish"
    },
    {
      "id": 4,
      "agent": "writer_en",
      "description": "ã€è‹±èªã€‘M&A market trends article",
      "language": "en",
      "polylang_lang": "en",
      "target_url": "å‚ç…§å…ƒè¨˜äº‹URL"
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "ã€è‹±èªã€‘WordPressæŠ•ç¨¿",
      "polylang_lang": "en",
      "source_task_id": 4,
      "post_action": "create"
    }
  ]
}
```

**ãƒ‘ã‚¿ãƒ¼ãƒ³2: M&Aãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ãƒˆæ©Ÿèƒ½é–‹ç™ºãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**
```json
{
  "project_name": "M&Aãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ãƒˆæ§‹ç¯‰",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "ã€è¦ä»¶å®šç¾©ã€‘M&Aæ¡ˆä»¶ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®è¦ä»¶å®šç¾©æ›¸ä½œæˆ",
      "priority": "high",
      "deliverables": ["è¦ä»¶å®šç¾©æ›¸.md"]
    },
    {
      "id": 2,
      "agent": "design",
      "description": "ã€ACFè¨­è¨ˆã€‘M&Aæ¡ˆä»¶ç”¨ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­è¨ˆæ›¸ä½œæˆ",
      "priority": "high",
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "ã€Custom Post Typeã€‘M&Aæ¡ˆä»¶ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆ",
      "priority": "high",
      "dependencies": [2],
      "cpt_slug": "ma_case",
      "cpt_labels": {"singular": "M&Aæ¡ˆä»¶", "plural": "M&Aæ¡ˆä»¶ä¸€è¦§"},
      "cpt_supports": ["title", "editor", "thumbnail", "custom-fields"]
    },
    {
      "id": 4,
      "agent": "wordpress",
      "description": "ã€ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã€‘æ¥­ç¨®ã‚«ãƒ†ã‚´ãƒªä½œæˆ",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "industry_category",
      "taxonomy_labels": {"singular": "æ¥­ç¨®", "plural": "æ¥­ç¨®ä¸€è¦§"},
      "taxonomy_post_types": ["ma_case"],
      "taxonomy_hierarchical": true
    },
    {
      "id": 5,
      "agent": "wordpress",
      "description": "ã€ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã€‘åœ°åŸŸã‚«ãƒ†ã‚´ãƒªä½œæˆ",
      "priority": "high",
      "dependencies": [3],
      "taxonomy_slug": "region",
      "taxonomy_labels": {"singular": "åœ°åŸŸ", "plural": "åœ°åŸŸä¸€è¦§"}
    },
    {
      "id": 6,
      "agent": "wordpress",
      "description": "ã€ACFè¨­å®šã€‘M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ",
      "priority": "high",
      "dependencies": [3, 4, 5],
      "acf_field_group_name": "M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±",
      "acf_fields": [
        {"name": "case_id", "type": "text", "label": "æ¡ˆä»¶ID"},
        {"name": "ma_scheme", "type": "select", "label": "M&Aã‚¹ã‚­ãƒ¼ãƒ "},
        {"name": "desired_price", "type": "number", "label": "å¸Œæœ›ä¾¡æ ¼"},
        {"name": "industry_category", "type": "taxonomy", "label": "æ¥­ç¨®"},
        {"name": "region", "type": "taxonomy", "label": "åœ°åŸŸ"}
      ],
      "acf_location_rules": {"post_type": "ma_case"}
    },
    {
      "id": 7,
      "agent": "plugin",
      "description": "ã€FacetWPã€‘çµã‚Šè¾¼ã¿æ¤œç´¢è¨­å®š",
      "priority": "medium",
      "dependencies": [6],
      "plugin_name": "facetwp",
      "facets": [
        {"name": "æ¥­ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", "type": "checkboxes", "source": "tax/industry_category"},
        {"name": "ä¾¡æ ¼å¸¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", "type": "slider", "source": "cf/desired_price"},
        {"name": "åœ°åŸŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼", "type": "dropdown", "source": "tax/region"}
      ]
    },
    {
      "id": 8,
      "agent": "ui",
      "description": "ã€æ¤œç´¢UIè¨­è¨ˆã€‘æ¤œç´¢ãƒ•ã‚©ãƒ¼ãƒ ç”»é¢ãƒ‡ã‚¶ã‚¤ãƒ³ä½œæˆ",
      "priority": "medium",
      "dependencies": [7]
    },
    {
      "id": 9,
      "agent": "plugin",
      "description": "ã€User Roleã€‘ææºãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ãƒ­ãƒ¼ãƒ«ä½œæˆ",
      "priority": "medium",
      "dependencies": [3],
      "plugin_name": "user-role-editor",
      "role_slug": "ma_partner",
      "role_name": "ææºãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼",
      "capabilities": {"read": true, "edit_posts": true}
    },
    {
      "id": 10,
      "agent": "plugin",
      "description": "ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€‘WordfenceåŸºæœ¬è¨­å®š",
      "priority": "high",
      "plugin_name": "wordfence"
    },
    {
      "id": 11,
      "agent": "plugin",
      "description": "ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€‘WP Rocketè¨­å®š",
      "priority": "medium",
      "plugin_name": "wp-rocket"
    },
    {
      "id": 12,
      "agent": "review",
      "description": "ã€ç·åˆè©•ä¾¡ã€‘æ©Ÿèƒ½å…¨ä½“ã®å“è³ªãƒã‚§ãƒƒã‚¯",
      "priority": "high",
      "dependencies": [7, 8, 9, 10, 11]
    }
  ]
}
```

**ãƒ‘ã‚¿ãƒ¼ãƒ³3: æ—¢å­˜WordPressè¨˜äº‹ã®å¤šè¨€èªå±•é–‹**
```json
{
  "tasks": [
    {
      "id": 1,
      "agent": "wordpress",
      "description": "ã€è¨˜äº‹å–å¾—ã€‘æ—¢å­˜æŠ•ç¨¿ã®å†…å®¹å–å¾—",
      "post_id": 123
    },
    {
      "id": 2,
      "agent": "writer_en",
      "description": "ã€è‹±èªç¿»è¨³ã€‘è‹±èªç‰ˆè¨˜äº‹ä½œæˆ",
      "language": "en",
      "polylang_lang": "en",
      "source_post_id": 123,
      "dependencies": [1]
    },
    {
      "id": 3,
      "agent": "wordpress",
      "description": "ã€è‹±èªæŠ•ç¨¿ã€‘Polylangé€£æºã§è‹±èªç‰ˆå…¬é–‹",
      "polylang_lang": "en",
      "source_task_id": 2,
      "translation_of": 123,
      "dependencies": [2]
    }
  ]
}
```

ã€å‡ºåŠ›å½¢å¼ã€‘
å¿…ãšJSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚

**JSONå‡ºåŠ›ä¾‹:**
```json
{
  "project_name": "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå",
  "total_tasks": 10,
  "estimated_duration": "2é€±é–“",
  "tasks": [
    {
      "id": 1,
      "agent": "design",
      "description": "ã€è¦ä»¶å®šç¾©ã€‘ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶å®šç¾©æ›¸ä½œæˆ",
      "priority": "high",
      "dependencies": [],
      "parameters": {}
    }
  ]
}
```

ã€é‡è¦ãªæ³¨æ„äº‹é …ã€‘
- ã‚¿ã‚¹ã‚¯èª¬æ˜ã®å†’é ­ã«å¿…ãšã€æ©Ÿèƒ½åã€‘ã¾ãŸã¯ã€è¨€èªåã€‘ã‚’ä»˜ã‘ã‚‹
- WordPressæŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã«ã¯å¿…ãš`source_task_id`ã‚’æŒ‡å®šï¼ˆç¿»è¨³ã®å ´åˆï¼‰
- ACFè¨­å®šã‚¿ã‚¹ã‚¯ã«ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è©³ç´°ã‚’å¿…ãšè¨˜è¼‰
- Custom Post Typeè¨­å®šã‚¿ã‚¹ã‚¯ã«ã¯ã‚¹ãƒ©ãƒƒã‚°ã¨ãƒ©ãƒ™ãƒ«ã‚’å¿…ãšæŒ‡å®š
- å„è¨€èªå°‚ç”¨ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ­£ã—ãæŒ‡å®š
- Polylangè¨€èªã‚³ãƒ¼ãƒ‰ã‚’æ­£ç¢ºã«è¨˜è¼‰ã™ã‚‹
  - æ—¥æœ¬èª: ja
  - è‹±èª: en
  - ãƒ­ã‚·ã‚¢èª: ru
  - ã‚¦ã‚ºãƒ™ã‚¯èª: uz_UZ
  - ä¸­å›½èª: zh_CN
  - éŸ“å›½èª: ko_KR
  - ãƒˆãƒ«ã‚³èª: tr_TR
- ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚¿ã‚¹ã‚¯ã«ã¯å…·ä½“çš„ãªè¨­å®šå†…å®¹ã‚’è¨˜è¼‰
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¿ã‚¹ã‚¯ã¯å¿…ãšå«ã‚ã‚‹
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã‚¿ã‚¹ã‚¯ã‚’å¿˜ã‚Œãšã«è¿½åŠ 
- ä¾å­˜é–¢ä¿‚ï¼ˆdependenciesï¼‰ã‚’æ­£ç¢ºã«è¨­å®š

ã€ã‚¿ã‚¹ã‚¯åˆ†è§£æ™‚ã®ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã€‘
âœ… Custom Post Type ã¯ä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã¯ä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… æ¤œç´¢æ©Ÿèƒ½ã¯å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ã¯è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… Polylangè¨­å®šã¯å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯å°å…¥ã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã¯è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã¯å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
âœ… å„ã‚¿ã‚¹ã‚¯ã®ä¾å­˜é–¢ä¿‚ã¯æ­£ã—ã„ã‹ï¼Ÿ
âœ… ACF/CPT UIã®è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å…·ä½“çš„ã‹ï¼Ÿ
âœ… M&Aæ¡ˆä»¶æŠ•ç¨¿ã«ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å«ã¾ã‚Œã¦ã„ã‚‹ã‹ï¼Ÿ
"""

#quick_fix.py
#!/usr/bin/env python3
"""
ã‚¯ã‚¤ãƒƒã‚¯ä¿®æ­£ã‚¹ã‚¯ãƒªãƒ—ãƒˆ - ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’è‡ªå‹•ä¿®æ­£
ä½¿ã„æ–¹: python quick_fix.py
"""

import os
import re
from pathlib import Path
import shutil
from datetime import datetime


def create_backup(file_path: Path) -> Path:
    """ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = file_path.with_suffix(f'.backup_{timestamp}{file_path.suffix}')
    shutil.copy2(file_path, backup_path)
    print(f"âœ… ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ: {backup_path}")
    return backup_path


def fix_wp_plugin_manager(base_dir: Path) -> bool:
    """wp_plugin_manager.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
    file_path = base_dir / "wordpress" / "wp_plugin_manager.py"
    
    if not file_path.exists():
        print(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
        return False
    
    print(f"\nğŸ”§ ä¿®æ­£ä¸­: {file_path}")
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    create_backup(file_path)
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ—¢ã«ä¿®æ­£æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    if 'from typing import' in content and 'List' in content:
        print("âœ… æ—¢ã«ä¿®æ­£æ¸ˆã¿ã§ã™")
        return True
    
    # ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’æ¢ã™
    import_pattern = r'^(import logging\s*\n)'
    
    # æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡
    new_imports = '''import logging
import asyncio
from typing import Dict, List, Optional, Any
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

'''
    
    # ç½®æ›
    if re.search(import_pattern, content, re.MULTILINE):
        content = re.sub(import_pattern, new_imports, content, count=1, flags=re.MULTILINE)
        print("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
    else:
        # ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯å…ˆé ­ã«è¿½åŠ 
        lines = content.split('\n')
        # docstring ã®å¾Œã«æŒ¿å…¥
        insert_index = 0
        for i, line in enumerate(lines):
            if '"""' in line or "'''" in line:
                # docstringã®çµ‚ã‚ã‚Šã‚’æ¢ã™
                for j in range(i+1, len(lines)):
                    if '"""' in lines[j] or "'''" in lines[j]:
                        insert_index = j + 1
                        break
                break
        
        if insert_index == 0:
            insert_index = 1  # ãƒ•ã‚¡ã‚¤ãƒ«ã®æœ€åˆã®è¡Œã®å¾Œ
        
        lines.insert(insert_index, '\n' + new_imports.strip())
        content = '\n'.join(lines)
        print("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚’å…ˆé ­ã«è¿½åŠ ã—ã¾ã—ãŸ")
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("âœ… wp_plugin_manager.py ã®ä¿®æ­£å®Œäº†")
    return True


def fix_wordpress_init(base_dir: Path) -> bool:
    """wordpress/__init__.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
    file_path = base_dir / "wordpress" / "__init__.py"
    
    if not file_path.exists():
        print(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
        return False
    
    print(f"\nğŸ”§ ãƒã‚§ãƒƒã‚¯ä¸­: {file_path}")
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå¿…è¦ã‹ç¢ºèª
    needs_fix = False
    
    if 'from .wp_agent import WordPressAgent' in content:
        if 'try:' not in content:
            needs_fix = True
    
    if not needs_fix:
        print("âœ… ä¿®æ­£ä¸è¦ã§ã™")
        return True
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    create_backup(file_path)
    
    # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤‰æ›´
    new_content = '''"""
WordPress ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
"""

try:
    from .wp_agent import WordPressAgent
    from .wp_utils import WordPressConfig, task_router
    __all__ = ['WordPressAgent', 'WordPressConfig', 'task_router']
except ImportError as e:
    import logging
    logger = logging.getLogger(__name__)
    logger.warning(f"âš ï¸ WordPress ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
    WordPressAgent = None
    WordPressConfig = None
    task_router = None
    __all__ = []
'''
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("âœ… wordpress/__init__.py ã®ä¿®æ­£å®Œäº†")
    return True


def check_all_typing_imports(base_dir: Path) -> list:
    """å…¨Pythonãƒ•ã‚¡ã‚¤ãƒ«ã® typing ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’ãƒã‚§ãƒƒã‚¯"""
    print("\nğŸ” å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚§ãƒƒã‚¯ä¸­...")
    
    issues = []
    
    for py_file in base_dir.rglob("*.py"):
        if 'venv' in str(py_file) or '__pycache__' in str(py_file):
            continue
        
        try:
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # List, Dict ãªã©ã‚’ä½¿ã£ã¦ã„ã‚‹ãŒã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¦ã„ãªã„
            if ('List[' in content or 'Dict[' in content or 
                'Optional[' in content or 'Tuple[' in content):
                if 'from typing import' not in content:
                    issues.append(str(py_file))
        except Exception as e:
            print(f"âš ï¸ {py_file} ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
    
    return issues


def fix_task_executor_imports(base_dir: Path) -> bool:
    """task_executor.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã‚’ä¿®æ­£"""
    file_path = base_dir / "task_executor.py"
    
    if not file_path.exists():
        print(f"âš ï¸ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {file_path}")
        return False
    
    print(f"\nğŸ”§ ä¿®æ­£ä¸­: {file_path}")
    
    # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
    create_backup(file_path)
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿
    with open(file_path, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # æ—¢ã«ä¿®æ­£æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
    if 'from sheets_manager import GoogleSheetsManager' in content:
        print("âœ… æ—¢ã«ä¿®æ­£æ¸ˆã¿ã§ã™")
        return True
    
    # æ­£ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆé †åº
    correct_imports = '''"""
Task Executor - ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
from config_utils import ErrorHandler, config

# ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====
from sheets_manager import GoogleSheetsManager

# ===== ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    import warnings
    warnings.warn("âš ï¸ error_handler_enhancedæœªæ¤œå‡ºï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")

# ===== åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    import warnings
    warnings.warn("âš ï¸ task_executor_content/ma ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

# ===== WordPressé€£æºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None
    import warnings
    warnings.warn("âš ï¸ wordpress.wp_utils.task_router ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

logger = logging.getLogger(__name__)


'''
    
    # æ—¢å­˜ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆéƒ¨åˆ†ã‚’æ¢ã—ã¦ç½®ãæ›ãˆ
    # ã‚¯ãƒ©ã‚¹å®šç¾©ã®å‰ã¾ã§ã‚’ç½®ãæ›ãˆã‚‹
    class_pattern = r'class TaskExecutor:'
    class_match = re.search(class_pattern, content)
    
    if class_match:
        # ã‚¯ãƒ©ã‚¹å®šç¾©ä»¥é™ã‚’ä¿æŒ
        class_and_rest = content[class_match.start():]
        # æ–°ã—ã„ã‚¤ãƒ³ãƒãƒ¼ãƒˆ + ã‚¯ãƒ©ã‚¹å®šç¾©ä»¥é™
        new_content = correct_imports + class_and_rest
    else:
        print("âš ï¸ TaskExecutor ã‚¯ãƒ©ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return False
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
    with open(file_path, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print("âœ… task_executor.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¿®æ­£å®Œäº†")
    return True


def main():
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    print("="*60)
    print("ğŸ”§ ã‚¯ã‚¤ãƒƒã‚¯ä¿®æ­£ã‚¹ã‚¯ãƒªãƒ—ãƒˆ v2")
    print("="*60)
    
    # ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’å–å¾—
    base_dir = Path.cwd()
    print(f"\nğŸ“ ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {base_dir}")
    
    # ä¿®æ­£å®Ÿè¡Œ
    success_count = 0
    
    # 1. wp_plugin_manager.py ã®ä¿®æ­£
    if fix_wp_plugin_manager(base_dir):
        success_count += 1
    
    # 2. wordpress/__init__.py ã®ä¿®æ­£
    if fix_wordpress_init(base_dir):
        success_count += 1
    
    # 3. task_executor.py ã®ä¿®æ­£ï¼ˆæ–°è¦è¿½åŠ ï¼‰
    if fix_task_executor_imports(base_dir):
        success_count += 1
    
    # 4. ãã®ä»–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
    issues = check_all_typing_imports(base_dir)
    
    if issues:
        print(f"\nâš ï¸ è¿½åŠ ã§ä¿®æ­£ãŒå¿…è¦ãªå¯èƒ½æ€§ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«: {len(issues)}ä»¶")
        for issue_file in issues[:10]:  # æœ€åˆã®10ä»¶ã®ã¿è¡¨ç¤º
            print(f"  - {issue_file}")
        
        if len(issues) > 10:
            print(f"  ... ä»– {len(issues) - 10} ä»¶")
    
    # çµæœã‚µãƒãƒªãƒ¼
    print("\n" + "="*60)
    print("ğŸ“Š ä¿®æ­£å®Œäº†")
    print("="*60)
    print(f"âœ… ä¿®æ­£æˆåŠŸ: {success_count} ãƒ•ã‚¡ã‚¤ãƒ«")
    
    if issues:
        print(f"âš ï¸ è¦ç¢ºèª: {len(issues)} ãƒ•ã‚¡ã‚¤ãƒ«")
        print("\nğŸ’¡ ãƒ’ãƒ³ãƒˆ: å„ãƒ•ã‚¡ã‚¤ãƒ«ã§ä»¥ä¸‹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„:")
        print("   from typing import Dict, List, Optional, Any")
    
    print("\nğŸ‰ ä¿®æ­£å®Œäº†ï¼")
    print("æ¬¡ã®ã‚³ãƒãƒ³ãƒ‰ã§å®Ÿè¡Œã—ã¦ãã ã•ã„:")
    print("   python run_multi_agent.py --auto")


if __name__ == "__main__":
    main()

#quick_fix_agent.py
"""
quick_fix_agent.py - è‡ªå¾‹å‹ã‚³ãƒ¼ãƒ‰ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
AIã‹ã‚‰ã®ä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’å—ã‘å–ã‚Šã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ‘ãƒƒãƒã‚’é©ç”¨ã—ã€ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
"""

import asyncio
import logging
import re
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any

from data_models import (
    BugFixTask,
    ErrorContextModel,
    FixResult,
    ErrorSeverity
)

logger = logging.getLogger(__name__)


class QuickFixAgent:
    """
    è‡ªå¾‹å‹ä¿®æ­£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ - ã‚»ãƒ«ãƒ•ãƒ’ãƒ¼ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®ä¸­æ ¸
    
    è²¬å‹™:
    1. AIã«ä¿®æ­£ã‚’ä¾é ¼ã™ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
    2. AIã‹ã‚‰ã®ä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
    3. ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ‘ãƒƒãƒã‚’é©ç”¨
    4. è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦æ¤œè¨¼
    5. GitHubé€£æº(å°†æ¥å®Ÿè£…)
    """
    
    def __init__(
        self,
        browser_controller,
        command_monitor,
        wp_tester=None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController (AIå¯¾è©±ç”¨)
            command_monitor: CommandMonitorAgent (ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œç”¨)
            wp_tester: WordPressTester (WordPressé–¢é€£ãƒ†ã‚¹ãƒˆç”¨)
        """
        self.browser = browser_controller
        self.cmd_monitor = command_monitor
        self.wp_tester = wp_tester
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        self.backup_dir = Path("./backups/auto_fix")
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # ä¿®æ­£å±¥æ­´
        self.fix_history: List[FixResult] = []
        
        logger.info("âœ… QuickFixAgent åˆæœŸåŒ–å®Œäº†")
    
    async def execute_bug_fix_task(self, bug_fix_task: BugFixTask) -> FixResult:
        """
        ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            bug_fix_task: ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯
            
        Returns:
            FixResult: ä¿®æ­£çµæœ
        """
        start_time = datetime.now()
        task_id = bug_fix_task.task_id
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ”§ ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info("=" * 60)
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            bug_fix_task.status = "in_progress"
            
            # 1. AIä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            fix_prompt = self._build_bug_fix_prompt(bug_fix_task.error_context)
            bug_fix_task.fix_prompt = fix_prompt
            
            logger.info(f"ğŸ“ ä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰å®Œäº† ({len(fix_prompt)}æ–‡å­—)")
            
            # 2. AIã«ä¿®æ­£ã‚’ä¾é ¼
            ai_result = await self._request_ai_fix(fix_prompt)
            
            if not ai_result['success']:
                return self._create_failed_result(
                    task_id,
                    f"AIä¿®æ­£ä¾é ¼å¤±æ•—: {ai_result.get('error')}",
                    start_time
                )
            
            generated_code = ai_result['generated_code']
            logger.info(f"ğŸ¤– AIä¿®æ­£ã‚³ãƒ¼ãƒ‰å–å¾—å®Œäº† ({len(generated_code)}æ–‡å­—)")
            
            # 3. ä¿®æ­£ã‚³ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
            validation_result = self._validate_generated_code(
                generated_code,
                bug_fix_task.error_context
            )
            
            if not validation_result['valid']:
                return self._create_failed_result(
                    task_id,
                    f"AIä¿®æ­£ã‚³ãƒ¼ãƒ‰æ¤œè¨¼å¤±æ•—: {validation_result['reason']}",
                    start_time
                )
            
            logger.info("âœ… AIä¿®æ­£ã‚³ãƒ¼ãƒ‰æ¤œè¨¼åˆæ ¼")
            
            # 4. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
            backup_paths = self._create_backups(bug_fix_task.target_files)
            logger.info(f"ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆå®Œäº†: {len(backup_paths)}ãƒ•ã‚¡ã‚¤ãƒ«")
            
            # 5. ãƒ‘ãƒƒãƒé©ç”¨
            apply_result = await self._apply_patch(
                bug_fix_task.target_files[0] if bug_fix_task.target_files else None,
                generated_code,
                bug_fix_task.error_context
            )
            
            if not apply_result['success']:
                self._restore_backups(backup_paths)
                return self._create_failed_result(
                    task_id,
                    f"ãƒ‘ãƒƒãƒé©ç”¨å¤±æ•—: {apply_result.get('error')}",
                    start_time
                )
            
            logger.info("âœ… ãƒ‘ãƒƒãƒé©ç”¨å®Œäº†")
            
            # 6. è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
            bug_fix_task.status = "testing"
            test_result = await self._run_automated_tests(bug_fix_task)
            
            if not test_result['success']:
                logger.warning("âš ï¸ ãƒ†ã‚¹ãƒˆå¤±æ•— - ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯")
                self._restore_backups(backup_paths)
                return self._create_failed_result(
                    task_id,
                    f"ãƒ†ã‚¹ãƒˆå¤±æ•—: {test_result.get('error')}",
                    start_time,
                    test_output=test_result.get('output'),
                    test_errors=test_result.get('errors', [])
                )
            
            logger.info("âœ… å…¨ãƒ†ã‚¹ãƒˆåˆæ ¼")
            
            # 7. æˆåŠŸçµæœã‚’ä½œæˆ
            bug_fix_task.status = "success"
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            fix_result = FixResult(
                task_id=task_id,
                success=True,
                modified_files=bug_fix_task.target_files,
                generated_code=generated_code,
                patch_content=apply_result.get('patch_content'),
                test_passed=True,
                test_output=test_result.get('output'),
                execution_time=execution_time
            )
            
            self.fix_history.append(fix_result)
            
            logger.info("=" * 60)
            logger.info(f"ğŸ‰ ãƒã‚°ä¿®æ­£å®Œäº†: {task_id} ({execution_time:.2f}ç§’)")
            logger.info("=" * 60)
            
            return fix_result
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            bug_fix_task.status = "failed"
            
            execution_time = (datetime.now() - start_time).total_seconds()
            return self._create_failed_result(
                task_id,
                f"å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}",
                start_time
            )
    
    def _build_bug_fix_prompt(self, error_context: ErrorContextModel) -> str:
        """
        AIä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            str: AIä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
        """
        prompt_parts = []
        
        # ãƒ˜ãƒƒãƒ€ãƒ¼
        prompt_parts.append("ä»¥ä¸‹ã®Pythonã‚³ãƒ¼ãƒ‰ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚ä¿®æ­£ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚")
        prompt_parts.append("")
        
        # ã‚¨ãƒ©ãƒ¼æƒ…å ±
        prompt_parts.append("ã€ã‚¨ãƒ©ãƒ¼æƒ…å ±ã€‘")
        prompt_parts.append(f"ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—: {error_context.error_type}")
        prompt_parts.append(f"ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_context.error_message}")
        prompt_parts.append(f"æ·±åˆ»åº¦: {error_context.severity.value}")
        prompt_parts.append("")
        
        # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿä½ç½®
        if error_context.error_location:
            prompt_parts.append("ã€ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿä½ç½®ã€‘")
            prompt_parts.append(f"ãƒ•ã‚¡ã‚¤ãƒ«: {error_context.error_location.file_path}")
            prompt_parts.append(f"è¡Œç•ªå·: {error_context.error_location.line_number}")
            if error_context.error_location.function_name:
                prompt_parts.append(f"é–¢æ•°: {error_context.error_location.function_name}")
            prompt_parts.append("")
        
        # å•é¡Œã®ã‚ã‚‹ã‚³ãƒ¼ãƒ‰
        if error_context.problematic_code:
            prompt_parts.append("ã€å•é¡Œã®ã‚ã‚‹è¡Œã€‘")
            prompt_parts.append(f"```python")
            prompt_parts.append(error_context.problematic_code)
            prompt_parts.append(f"```")
            prompt_parts.append("")
        
        # å‘¨è¾ºã‚³ãƒ¼ãƒ‰
        if error_context.surrounding_code:
            prompt_parts.append("ã€å‘¨è¾ºã‚³ãƒ¼ãƒ‰(å‰å¾Œ10è¡Œ)ã€‘")
            prompt_parts.append(f"```python")
            prompt_parts.append(error_context.surrounding_code)
            prompt_parts.append(f"```")
            prompt_parts.append("")
        
        # ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹(é‡è¦éƒ¨åˆ†ã®ã¿)
        if error_context.stack_frames:
            prompt_parts.append("ã€ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã€‘")
            for i, frame in enumerate(error_context.stack_frames[-3:], 1):  # æœ€å¾Œã®3ãƒ•ãƒ¬ãƒ¼ãƒ 
                prompt_parts.append(f"{i}. {frame.file_path}:{frame.line_number} in {frame.function_name}")
            prompt_parts.append("")
        
        # ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°(é‡è¦ãªã‚‚ã®ã®ã¿)
        if error_context.local_variables:
            prompt_parts.append("ã€ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã®çŠ¶æ…‹ã€‘")
            for var_name, var_value in list(error_context.local_variables.items())[:5]:
                prompt_parts.append(f"  {var_name} = {var_value}")
            prompt_parts.append("")
        
        # ã‚¿ã‚¹ã‚¯æƒ…å ±
        if error_context.task_description:
            prompt_parts.append("ã€å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã€‘")
            prompt_parts.append(error_context.task_description)
            prompt_parts.append("")
        
        # ä¿®æ­£è¦ä»¶
        prompt_parts.append("ã€ä¿®æ­£è¦ä»¶ã€‘")
        prompt_parts.append("1. ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› ã‚’ç‰¹å®šã—ã¦ãã ã•ã„")
        prompt_parts.append("2. æœ€å°é™ã®å¤‰æ›´ã§ä¿®æ­£ã—ã¦ãã ã•ã„")
        prompt_parts.append("3. ä¿®æ­£å¾Œã®ã‚³ãƒ¼ãƒ‰ã¯å®Œå…¨ã§ã€å®Ÿè¡Œå¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™")
        prompt_parts.append("4. ã‚³ãƒ¡ãƒ³ãƒˆã§ä¿®æ­£å†…å®¹ã‚’èª¬æ˜ã—ã¦ãã ã•ã„")
        prompt_parts.append("")
        
        # å‡ºåŠ›å½¢å¼
        prompt_parts.append("ã€å‡ºåŠ›å½¢å¼ã€‘")
        prompt_parts.append("ä»¥ä¸‹ã®å½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„:")
        prompt_parts.append("")
        prompt_parts.append("```python")
        prompt_parts.append("# ä¿®æ­£ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰å…¨ä½“ã‚’ã“ã“ã«è¨˜è¿°")
        prompt_parts.append("# (å‘¨è¾ºã‚³ãƒ¼ãƒ‰ã‚‚å«ã‚ã¦ã€ç½®ãæ›ãˆå¯èƒ½ãªå®Œå…¨ãªã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›)")
        prompt_parts.append("```")
        prompt_parts.append("")
        prompt_parts.append("ã€é‡è¦ã€‘")
        prompt_parts.append("- ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯å¿…ãš ```python ... ``` ã§å›²ã‚“ã§ãã ã•ã„")
        prompt_parts.append("- ä¸å®Œå…¨ãªã‚³ãƒ¼ãƒ‰ã‚„çœç•¥ã¯é¿ã‘ã¦ãã ã•ã„")
        prompt_parts.append("- ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ã‚‚å«ã‚ã¦ãã ã•ã„")
        
        return "\n".join(prompt_parts)
    
    async def _request_ai_fix(self, fix_prompt: str) -> Dict[str, Any]:
        """
        AIã«ä¿®æ­£ã‚’ä¾é ¼
        
        Args:
            fix_prompt: ä¿®æ­£ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
            
        Returns:
            Dict: AIå¿œç­”çµæœ
        """
        try:
            # AIã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡
            if not hasattr(self.browser, 'send_prompt_and_wait'):
                return {
                    'success': False,
                    'error': 'BrowserControllerã«send_prompt_and_waitãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“'
                }
            
            success = await self.browser.send_prompt_and_wait(
                fix_prompt,
                max_wait=180  # 3åˆ†
            )
            
            if not success:
                return {
                    'success': False,
                    'error': 'AIãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã¾ãŸã¯å¿œç­”å¾…æ©Ÿå¤±æ•—'
                }
            
            # AIå¿œç­”ã‚’æŠ½å‡º
            if not hasattr(self.browser, 'extract_latest_text_response'):
                return {
                    'success': False,
                    'error': 'BrowserControllerã«extract_latest_text_responseãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“'
                }
            
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text or len(response_text) < 50:
                return {
                    'success': False,
                    'error': 'AIå¿œç­”ãŒç©ºã¾ãŸã¯çŸ­ã™ãã¾ã™'
                }
            
            # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
            code_blocks = re.findall(r'```python\s*\n(.*?)```', response_text, re.DOTALL)
            
            if not code_blocks:
                return {
                    'success': False,
                    'error': 'AIå¿œç­”ã«Pythonã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
                }
            
            # æœ€å¤§ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¡ç”¨
            generated_code = max(code_blocks, key=len)
            
            return {
                'success': True,
                'generated_code': generated_code,
                'full_response': response_text
            }
            
        except Exception as e:
            logger.error(f"âŒ AIä¿®æ­£ä¾é ¼ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _validate_generated_code(
        self,
        generated_code: str,
        error_context: ErrorContextModel
    ) -> Dict[str, Any]:
        """
        AIç”Ÿæˆã‚³ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
        
        Args:
            generated_code: AIç”Ÿæˆã‚³ãƒ¼ãƒ‰
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: æ¤œè¨¼çµæœ
        """
        # 1. æœ€å°é•·ãƒã‚§ãƒƒã‚¯
        if len(generated_code.strip()) < 20:
            return {
                'valid': False,
                'reason': 'ã‚³ãƒ¼ãƒ‰ãŒçŸ­ã™ãã¾ã™'
            }
        
        # 2. Pythonã‚³ãƒ¼ãƒ‰ã®åŸºæœ¬æ§‹é€ ãƒã‚§ãƒƒã‚¯
        if not any(kw in generated_code for kw in ['def ', 'class ', 'import ', 'from ']):
            return {
                'valid': False,
                'reason': 'Pythonã‚³ãƒ¼ãƒ‰ã®åŸºæœ¬æ§‹é€ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
            }
        
        # 3. ã‚¨ãƒ©ãƒ¼é–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒãªã„ã‹ãƒã‚§ãƒƒã‚¯
        if error_context.error_type == "ImportError" or error_context.error_type == "ModuleNotFoundError":
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã®å ´åˆã€é©åˆ‡ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚‹ã‹
            if 'import ' not in generated_code and 'from ' not in generated_code:
                return {
                    'valid': False,
                    'reason': 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼ã®ä¿®æ­£ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚Šã¾ã›ã‚“'
                }
        
        # 4. ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®é–‰ã˜å¿˜ã‚Œãƒã‚§ãƒƒã‚¯
        open_braces = generated_code.count('{')
        close_braces = generated_code.count('}')
        open_parens = generated_code.count('(')
        close_parens = generated_code.count(')')
        open_brackets = generated_code.count('[')
        close_brackets = generated_code.count(']')
        
        if (open_braces != close_braces or 
            open_parens != close_parens or 
            open_brackets != close_brackets):
            return {
                'valid': False,
                'reason': 'æ‹¬å¼§ã®å¯¾å¿œãŒä¸æ­£ã§ã™'
            }
        
        # 5. æ§‹æ–‡ãƒã‚§ãƒƒã‚¯(ç°¡æ˜“)
        try:
            compile(generated_code, '<string>', 'exec')
        except SyntaxError as e:
            return {
                'valid': False,
                'reason': f'æ§‹æ–‡ã‚¨ãƒ©ãƒ¼: {e}'
            }
        
        return {
            'valid': True,
            'reason': 'æ¤œè¨¼åˆæ ¼'
        }
    
    def _create_backups(self, file_paths: List[str]) -> Dict[str, str]:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ
        
        Args:
            file_paths: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            
        Returns:
            Dict: {å…ƒãƒ•ã‚¡ã‚¤ãƒ«: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ‘ã‚¹}
        """
        backup_paths = {}
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        for file_path in file_paths:
            try:
                src = Path(file_path)
                if not src.exists():
                    logger.warning(f"âš ï¸ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¯¾è±¡ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {file_path}")
                    continue
                
                # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
                backup_name = f"{src.stem}_backup_{timestamp}{src.suffix}"
                backup_path = self.backup_dir / backup_name
                
                # ã‚³ãƒ”ãƒ¼
                shutil.copy2(src, backup_path)
                backup_paths[file_path] = str(backup_path)
                
                logger.info(f"ğŸ’¾ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—: {file_path} â†’ {backup_path}")
                
            except Exception as e:
                logger.error(f"âŒ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¤±æ•—: {file_path} - {e}")
        
        return backup_paths
    
    def _restore_backups(self, backup_paths: Dict[str, str]):
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒ"""
        for original_path, backup_path in backup_paths.items():
            try:
                shutil.copy2(backup_path, original_path)
                logger.info(f"â™»ï¸ å¾©å…ƒ: {backup_path} â†’ {original_path}")
            except Exception as e:
                logger.error(f"âŒ å¾©å…ƒå¤±æ•—: {original_path} - {e}")
    
    async def _apply_patch(
        self,
        target_file: Optional[str],
        generated_code: str,
        error_context: ErrorContextModel
    ) -> Dict[str, Any]:
        """
        ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«é©ç”¨
        
        Args:
            target_file: å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            generated_code: ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            Dict: é©ç”¨çµæœ
        """
        try:
            if not target_file:
                # ã‚¨ãƒ©ãƒ¼ä½ç½®ã‹ã‚‰å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç‰¹å®š
                if error_context.error_location:
                    target_file = error_context.error_location.file_path
                else:
                    return {
                        'success': False,
                        'error': 'å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒç‰¹å®šã§ãã¾ã›ã‚“'
                    }
            
            target_path = Path(target_file)
            
            if not target_path.exists():
                return {
                    'success': False,
                    'error': f'å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“: {target_file}'
                }
            
            # å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’èª­ã¿è¾¼ã¿
            with open(target_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            # æ–°ã—ã„å†…å®¹ã‚’æ›¸ãè¾¼ã¿
            with open(target_path, 'w', encoding='utf-8') as f:
                f.write(generated_code)
            
            logger.info(f"âœ… ãƒ‘ãƒƒãƒé©ç”¨å®Œäº†: {target_file}")
            
            # Diffå½¢å¼ã®ãƒ‘ãƒƒãƒå†…å®¹ã‚’ç”Ÿæˆ(ç°¡æ˜“ç‰ˆ)
            patch_content = self._generate_simple_diff(
                original_content,
                generated_code,
                target_file
            )
            
            return {
                'success': True,
                'target_file': target_file,
                'patch_content': patch_content
            }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ‘ãƒƒãƒé©ç”¨ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _generate_simple_diff(
        self,
        original: str,
        modified: str,
        filename: str
    ) -> str:
        """ç°¡æ˜“Diffå½¢å¼ã®ãƒ‘ãƒƒãƒå†…å®¹ã‚’ç”Ÿæˆ"""
        lines = []
        lines.append(f"--- {filename} (original)")
        lines.append(f"+++ {filename} (modified)")
        lines.append(f"@@ -{len(original.splitlines())},{len(modified.splitlines())} @@")
        
        # ç°¡æ˜“çš„ãªå·®åˆ†è¡¨ç¤º
        orig_lines = original.splitlines()
        mod_lines = modified.splitlines()
        
        max_lines = max(len(orig_lines), len(mod_lines))
        
        for i in range(min(10, max_lines)):  # æœ€åˆã®10è¡Œã®ã¿
            if i < len(orig_lines):
                lines.append(f"- {orig_lines[i]}")
            if i < len(mod_lines):
                lines.append(f"+ {mod_lines[i]}")
        
        if max_lines > 10:
            lines.append(f"... ({max_lines - 10} more lines)")
        
        return "\n".join(lines)
    
    async def _run_automated_tests(self, bug_fix_task: BugFixTask) -> Dict[str, Any]:
        """
        è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
        
        Args:
            bug_fix_task: ãƒã‚°ä¿®æ­£ã‚¿ã‚¹ã‚¯
            
        Returns:
            Dict: ãƒ†ã‚¹ãƒˆçµæœ
        """
        try:
            error_context = bug_fix_task.error_context
            
            # ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ã‚’æ±ºå®š
            test_command = self._determine_test_command(error_context)
            
            if not test_command:
                logger.warning("âš ï¸ ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ãŒç‰¹å®šã§ãã¾ã›ã‚“ - ã‚¹ã‚­ãƒƒãƒ—")
                return {
                    'success': True,
                    'output': 'ãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰æœªç‰¹å®šã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—',
                    'errors': []
                }
            
            logger.info(f"ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ: {test_command}")
            
            # ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ
            result = await self.cmd_monitor.execute_command(
                test_command,
                timeout=120
            )
            
            # ãƒ†ã‚¹ãƒˆçµæœã‚’è©•ä¾¡
            if result['return_code'] == 0 and not result['has_errors']:
                return {
                    'success': True,
                    'output': result['stdout'],
                    'errors': []
                }
            else:
                return {
                    'success': False,
                    'output': result['stdout'],
                    'errors': result['errors'],
                    'error': f"ãƒ†ã‚¹ãƒˆå¤±æ•— (return_code={result['return_code']})"
                }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e),
                'errors': [str(e)]
            }
    
    def _determine_test_command(self, error_context: ErrorContextModel) -> Optional[str]:
        """ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰é©åˆ‡ãªãƒ†ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ã‚’æ±ºå®š"""
        
        # WordPressé–¢é€£ã®ã‚¨ãƒ©ãƒ¼
        if error_context.wp_context or 'wordpress' in str(error_context.error_location).lower():
            return "wp plugin list"  # åŸºæœ¬çš„ãªå‹•ä½œç¢ºèª
        
        # Pythonãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼
        if error_context.error_category.value == "import_error":
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if error_context.error_location:
                module_name = Path(error_context.error_location.file_path).stem
                return f"python -c 'import {module_name}'"
        
        # ä¸€èˆ¬çš„ãªPythonã‚³ãƒ¼ãƒ‰
        if error_context.error_location:
            file_path = error_context.error_location.file_path
            if file_path.endswith('.py'):
                # æ§‹æ–‡ãƒã‚§ãƒƒã‚¯
                return f"python -m py_compile {file_path}"
        
        return None
    
    def _create_failed_result(
        self,
        task_id: str,
        error_message: str,
        start_time: datetime,
        test_output: Optional[str] = None,
        test_errors: List[str] = None
    ) -> FixResult:
        """å¤±æ•—çµæœã‚’ä½œæˆ"""
        execution_time = (datetime.now() - start_time).total_seconds()
        
        return FixResult(
            task_id=task_id,
            success=False,
            test_passed=False,
            test_output=test_output,
            test_errors=test_errors or [],
            execution_time=execution_time,
            error_message=error_message
        )
    
    def get_fix_history(self) -> List[FixResult]:
        """ä¿®æ­£å±¥æ­´ã‚’å–å¾—"""
        return self.fix_history.copy()
    
    def get_success_rate(self) -> float:
        """ä¿®æ­£æˆåŠŸç‡ã‚’è¨ˆç®—"""
        if not self.fix_history:
            return 0.0
        
        success_count = sum(1 for result in self.fix_history if result.success)
        return (success_count / len(self.fix_history)) * 100

#review_agent.py
# review_agent.py
"""ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController
from sheets_manager import GoogleSheetsManager
from review_agent_prompts import REVIEW_SYSTEM_PROMPT

logger = logging.getLogger(__name__)

class ReviewAgent:
    """ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
    
    def __init__(self):
        """ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ - å¾Œã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®šã™ã‚‹"""
        self.browser = None
        self.sheets_manager = None
        self.system_prompt = REVIEW_SYSTEM_PROMPT

    async def process_task(self, task: Dict) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰"""
        return await self.review_completed_task(task, task.get('output_content', ''))

    async def review_completed_task(self, task: Dict, output_content: str) -> Dict:
        """å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå¤±æ•—åŸå› åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹å‡¦ç† ===
            logger.info("="*60)
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¹ã‚¯ {task['task_id']} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹")
            logger.info("="*60)
            
            # ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç¢ºèª
            task_status = task.get('status', 'unknown')
            is_failed_task = task_status in ['failed', 'error', 'timeout']
            
            # äº‹å‰ãƒã‚§ãƒƒã‚¯ï¼šå‡ºåŠ›å†…å®¹ã®æ§‹é€ ã‚’æ¤œè¨¼
            pre_check_result = self._pre_check_content(output_content, task['required_role'])
            if pre_check_result:
                logger.info(f"äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœ: {pre_check_result}")
            
            # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’å–å¾—
            error_info = task.get('error', '')
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰ã¨Geminié€ä¿¡ ===
            full_prompt = self._build_review_prompt(
                task, task_status, is_failed_task, 
                output_content, error_info, pre_check_result
            )
            
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’Geminiã«ä¾é ¼ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
                return self._create_default_review(task, is_failed_task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: å¿œç­”å–å¾—ã¨çµæœè§£æ ===
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
            
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            review_result = self._parse_review_json(response_text)
            
            if review_result:
                # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
                validated_review = self._validate_review_result(review_result, output_content)
                self._display_review_summary(validated_review, is_failed_task)
                return {
                    'success': True,
                    'review': validated_review,
                    'summary': validated_review.get('evaluation', {}).get('overall_assessment', ''),
                    'full_text': response_text
                }
            else:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONè§£æã«å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ¬ãƒ“ãƒ¥ãƒ¼AIå‡¦ç†")
            return self._create_default_review(task, False)

    def _build_review_prompt(self, task: Dict, task_status: str, is_failed_task: bool,
                           output_content: str, error_info: str, pre_check_result: str) -> str:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰(ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£æƒ…å ±ä»˜ã)"""
    
        # === ğŸ†• æ–°è¦è¿½åŠ : ãƒˆãƒ¬ãƒ¼ã‚µãƒ“ãƒªãƒ†ã‚£æƒ…å ±ã®æŠ½å‡º ===
        traceability = task.get('_traceability', {})
        executed_by = traceability.get('executed_by_agent', 'ä¸æ˜')
        agent_class = traceability.get('agent_class', 'ä¸æ˜')
    
        return f"""{self.system_prompt}

    ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚¿ã‚¹ã‚¯ã€‘
    ã‚¿ã‚¹ã‚¯ID: {task['task_id']}
    å†…å®¹: {task['description']}
    æ‹…å½“: {task['required_role']}
    ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task_status}
    å‡ºåŠ›æ–‡å­—æ•°: {len(output_content)}æ–‡å­—

    ğŸ†•ã€å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæƒ…å ±ã€‘(åŸå› åˆ‡ã‚Šåˆ†ã‘ç”¨)
    å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {executed_by}
    ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹: {agent_class}
    å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—: {traceability.get('execution_timestamp', 'N/A')}

    ã€ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ã€‘
    {'âŒ ã“ã®ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸ' if is_failed_task else 'âœ… ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã—ã¾ã—ãŸ'}
    {f'ã‚¨ãƒ©ãƒ¼æƒ…å ±: {error_info}' if error_info else ''}

    ã€äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœã€‘
    {pre_check_result if pre_check_result else 'ç‰¹è¨˜äº‹é …ãªã—'}

    ã€ã‚¿ã‚¹ã‚¯ã®å‡ºåŠ›ã€‘
    {output_content[:4000] if output_content else '(å‡ºåŠ›ãªã—)'}

    ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã€æŒ‡å®šã•ã‚ŒãŸJSONå½¢å¼ã§è©•ä¾¡ã¨æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚
    {'ç‰¹ã«å¤±æ•—åŸå› ã‚’è©³ç´°ã«åˆ†æã—ã€é©åˆ‡ãªæ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚' if is_failed_task else 'ç‰¹ã«ã€æ§‹é€ çš„ã«å®Œçµã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’é‡ç‚¹çš„ã«ç¢ºèªã—ã¦ãã ã•ã„ã€‚'}

    ğŸ†•ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã®æ³¨æ„ã€‘
    - ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒé€”ä¸­ã§é€”åˆ‡ã‚Œã¦ã„ã‚‹å ´åˆã¯å¿…ãšæŒ‡æ‘˜ã—ã¦ãã ã•ã„
    - å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ({executed_by})ã®å‡ºåŠ›å“è³ªã«å•é¡ŒãŒã‚ã‚‹å ´åˆã€ãã®æ—¨ã‚’æ˜è¨˜ã—ã¦ãã ã•ã„
    - æ‰‹å‹•ä½œæ¥­ãŒå¿…è¦ãªæ‰‹é †ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã€è‡ªå‹•åŒ–ã®ææ¡ˆã‚‚å«ã‚ã¦ãã ã•ã„
    """


    def _pre_check_content(self, content: str, role: str) -> str:
        """å‡ºåŠ›å†…å®¹ã®äº‹å‰ãƒã‚§ãƒƒã‚¯"""
        checks = []
        
        # === ãƒ‘ãƒ¼ãƒˆ1: æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯ ===
        if len(content) < 100:
            checks.append("âš ï¸ æ–‡å­—æ•°ãŒå°‘ãªã™ãã¾ã™ï¼ˆ100æ–‡å­—æœªæº€ï¼‰")
        elif len(content) > 5000:
            checks.append("âœ… æ–‡å­—æ•°ãŒååˆ†ã§ã™")
        
        # === ãƒ‘ãƒ¼ãƒˆ2: è¨˜äº‹ãƒ»æ–‡æ›¸ç³»ã‚¿ã‚¹ã‚¯ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯ ===
        if role in ['writer', 'content', 'wordpress', 'writer_ja', 'writer_en', 'writer_ru']:
            if '<h1' in content or '<h2' in content or '# ' in content:
                checks.append("âœ… è¦‹å‡ºã—æ§‹é€ ãŒã‚ã‚Šã¾ã™")
            
            if any(phrase in content for phrase in ['ã¾ã¨ã‚', 'çµè«–', 'çµ‚ã‚ã‚Š', 'ä»¥ä¸Š', 'æœ€å¾Œã«', 'Conclusion', 'Summary']):
                checks.append("âœ… çµè«–ãƒ»ã¾ã¨ã‚ãŒã‚ã‚Šã¾ã™")
            else:
                checks.append("âš ï¸ æ˜ç¤ºçš„ãªçµè«–ãƒ»ã¾ã¨ã‚ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®é–‰ã˜å¿˜ã‚Œãƒã‚§ãƒƒã‚¯
            if content.count('<div') > content.count('</div'):
                checks.append("âš ï¸ HTMLã®divã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
            if content.count('<p>') > content.count('</p>'):
                checks.append("âš ï¸ HTMLã®pã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚³ãƒ¼ãƒ‰ç³»ã‚¿ã‚¹ã‚¯ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯ ===
        if role in ['dev', 'programming']:
            if 'def ' in content or 'function ' in content or 'class ' in content:
                checks.append("âœ… é–¢æ•°/ã‚¯ãƒ©ã‚¹å®šç¾©ãŒã‚ã‚Šã¾ã™")
            if 'import ' in content or 'require ' in content:
                checks.append("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚Šã¾ã™")
        
        return " | ".join(checks) if checks else "âœ… åŸºæœ¬çš„ãªæ§‹é€ ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“"

    def _validate_review_result(self, review: Dict, original_content: str) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼"""
        evaluation = review.get('evaluation', {})
        next_actions = review.get('next_actions', {})
        
        # === ãƒ‘ãƒ¼ãƒˆ1: ã€Œéƒ¨åˆ†çš„ã€åˆ¤å®šã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ ===
        if evaluation.get('completeness') == 'éƒ¨åˆ†çš„':
            issues = evaluation.get('issues', [])
            new_issues = []
            
            for issue in issues:
                # æ–‡å­—æ•°é–¢é€£ã®æŒ‡æ‘˜ã‚’æ¤œè¨¼
                if any(word in issue for word in ['æ–‡å­—æ•°', 'æ–‡å­—', 'çŸ­ã„', 'å°‘ãªã„']):
                    if len(original_content) > 1000:  # 1000æ–‡å­—ä»¥ä¸Šã‚ã‚Œã°æ–‡å­—æ•°ä¸è¶³ã§ã¯ãªã„
                        continue
                # æ§‹é€ çš„ãªæŒ‡æ‘˜ã‚’æ¤œè¨¼
                elif 'åˆ‡ã‚Œã¦' in issue or 'é€”åˆ‡ã‚Œ' in issue:
                    # å®Ÿéš›ã«æ–‡ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if self._is_content_properly_ended(original_content):
                        continue
                
                new_issues.append(issue)
            
            # å•é¡Œç‚¹ã‚’æ›´æ–°
            evaluation['issues'] = new_issues
            
            # å•é¡Œç‚¹ãŒãªããªã£ãŸå ´åˆã¯ã€Œå®Œäº†ã€ã«å¤‰æ›´
            if not new_issues and len(original_content) > 500:
                evaluation['completeness'] = 'å®Œäº†'
                evaluation['overall_assessment'] = 'å†è©•ä¾¡: å†…å®¹ã¯å®Œçµã—ã¦ãŠã‚Šã€æ–‡å­—æ•°ã‚‚ååˆ†ã§ã™'
                next_actions['required'] = False
                next_actions['suggested_tasks'] = []
        
        return review

    def _is_content_properly_ended(self, content: str) -> bool:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒé©åˆ‡ã«çµ‚äº†ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        # === ãƒ‘ãƒ¼ãƒˆ1: æ–‡ã®çµ‚äº†ãƒã‚§ãƒƒã‚¯ ===
        sentences = re.split(r'[ã€‚ï¼ï¼Ÿ!?\.]', content.strip())
        if sentences and sentences[-1].strip():
            return False  # æœ€å¾Œã®æ–‡ãŒçµ‚äº†è¨˜å·ã§çµ‚ã‚ã£ã¦ã„ãªã„
        
        # === ãƒ‘ãƒ¼ãƒˆ2: HTMLã‚¿ã‚°ã®é–‰ã˜ãƒã‚§ãƒƒã‚¯ ===
        if content.count('<') > 0 and content.count('>') > 0:
            open_tags = len(re.findall(r'<(?!\/)[^>]+>', content))
            close_tags = len(re.findall(r'<\/[^>]+>', content))
            if open_tags != close_tags:
                return False
        
        return True

    def _parse_review_json(self, text: str) -> Optional[Dict]:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONã‚’ãƒ‘ãƒ¼ã‚¹"""
        try:
            import re
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ```json ... ``` å½¢å¼ã®æŠ½å‡º ===
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡º ===
            json_match = re.search(r'(\{.*\})', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            logger.warning("JSONå½¢å¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None
            
        except json.JSONDecodeError as e:
            logger.error(f"JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def _create_default_review(self, task: Dict, is_failed: bool = False) -> Dict:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœï¼ˆå¤±æ•—æ™‚ï¼‰"""
        if is_failed:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å¤±æ•—',
                        'quality_score': 3,
                        'issues': ['ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ'],
                        'good_points': [],
                        'overall_assessment': 'ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸãŒã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚‚å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ',
                        'failure_analysis': {
                            'is_failed': True,
                            'failure_category': 'ç’°å¢ƒå•é¡Œ',
                            'root_cause': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—',
                            'impact': 'å¤±æ•—åŸå› ã®è©³ç´°ãŒä¸æ˜',
                            'recommended_action': 'immediate_retry',
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': True,
                        'reasoning': 'ã‚¿ã‚¹ã‚¯ã®å†å®Ÿè¡Œã¾ãŸã¯ä¿®æ­£ãŒå¿…è¦',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ã‚¿ã‚¹ã‚¯å¤±æ•—',
                'full_text': ''
            }
        else:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å®Œäº†',
                        'quality_score': 7,
                        'issues': [],
                        'good_points': ['ã‚¿ã‚¹ã‚¯å®Œäº†'],
                        'overall_assessment': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸãŒã€ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã¨ã¿ãªã—ã¾ã™',
                        'failure_analysis': {
                            'is_failed': False,
                            'failure_category': None,
                            'root_cause': None,
                            'impact': None,
                            'recommended_action': None,
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': False,
                        'reasoning': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—ã—ãŸãŸã‚ã€è¿½åŠ ã‚¿ã‚¹ã‚¯ãªã—',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè©•ä¾¡',
                'full_text': ''
            }

    def _display_review_summary(self, review: Dict, is_failed_task: bool = False):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’è¡¨ç¤ºï¼ˆå¤±æ•—åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        
        print("\n" + "ğŸ¯" * 30)
        print("ğŸ“‹ ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ")
        print("ğŸ¯" * 30)
        
        evaluation = review.get('evaluation', {})
        
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬æƒ…å ±è¡¨ç¤º ===
        completeness = evaluation.get('completeness', 'N/A')
        completeness_icon = {
            'å®Œäº†': 'âœ…',
            'éƒ¨åˆ†çš„': 'âš ï¸',
            'ä¸å®Œå…¨': 'âŒ',
            'å¤±æ•—': 'ğŸ’¥'
        }.get(completeness, 'â“')
        
        print(f"\n{completeness_icon} å®Œæˆåº¦: {completeness}")
        print(f"â­ å“è³ªã‚¹ã‚³ã‚¢: {evaluation.get('quality_score', 'N/A')}/10")
        
        # === ãƒ‘ãƒ¼ãƒˆ2: å¤±æ•—åˆ†æè¡¨ç¤º ===
        failure_analysis = evaluation.get('failure_analysis', {})
        if failure_analysis.get('is_failed'):
            print("\n" + "ğŸ’¥" * 30)
            print("ğŸ” å¤±æ•—åŸå› åˆ†æ")
            print("ğŸ’¥" * 30)
            
            category = failure_analysis.get('failure_category', 'N/A')
            category_icon = {
                'è¦ä»¶ä¸æ˜ç­': 'ğŸ“',
                'æŠ€è¡“çš„å•é¡Œ': 'âš™ï¸',
                'ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³': 'ğŸ“¦',
                'ä¾å­˜é–¢ä¿‚': 'ğŸ”—',
                'ç’°å¢ƒå•é¡Œ': 'ğŸŒ',
                'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ': 'â±ï¸',
                'å‡ºåŠ›ä¸å®Œå…¨': 'âœ‚ï¸',
                'å“è³ªä¸è¶³': 'ğŸ“‰'
            }.get(category, 'â“')
            
            print(f"\n{category_icon} å¤±æ•—ã‚«ãƒ†ã‚´ãƒª: {category}")
            print(f"ğŸ” æ ¹æœ¬åŸå› : {failure_analysis.get('root_cause', 'N/A')}")
            print(f"ğŸ’¡ å½±éŸ¿: {failure_analysis.get('impact', 'N/A')}")
            
            action = failure_analysis.get('recommended_action', 'N/A')
            action_map = {
                'immediate_retry': 'ğŸ”„ å³åº§ã«å†å®Ÿè¡Œ',
                'modify_task': 'âœï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¿®æ­£',
                'add_prerequisite': 'â• å‰æã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ',
                'escalate': 'ğŸš¨ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆäººé–“ã®åˆ¤æ–­ãŒå¿…è¦ï¼‰',
                'skip': 'â­ï¸ ã‚¹ã‚­ãƒƒãƒ—ã¾ãŸã¯å¾Œå›ã—'
            }
            print(f"ğŸ“Œ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_map.get(action, action)}")
            
            prereqs = failure_analysis.get('prerequisites', [])
            if prereqs:
                print(f"\nğŸ“‹ å‰ææ¡ä»¶:")
                for prereq in prereqs:
                    print(f"   â€¢ {prereq}")
            
            print("ğŸ’¥" * 30)
        
        # === ãƒ‘ãƒ¼ãƒˆ3: è‰¯ã„ç‚¹ãƒ»å•é¡Œç‚¹è¡¨ç¤º ===
        good_points = evaluation.get('good_points', [])
        if good_points:
            print(f"\nâœ¨ è‰¯ã„ç‚¹:")
            for point in good_points:
                print(f"   âœ… {point}")
        
        issues = evaluation.get('issues', [])
        if issues:
            print(f"\nâš ï¸ å•é¡Œç‚¹:")
            for issue in issues:
                print(f"   âŒ {issue}")
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ç·åˆè©•ä¾¡è¡¨ç¤º ===
        overall = evaluation.get('overall_assessment', '')
        if overall:
            print(f"\nğŸ’ ç·åˆè©•ä¾¡:")
            print(f"   {overall}")
        
        # === ãƒ‘ãƒ¼ãƒˆ5: æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¡¨ç¤º ===
        next_actions = review.get('next_actions', {})
        required = next_actions.get('required', False)
        
        action_icon = 'ğŸ”´' if required else 'ğŸŸ¢'
        print(f"\nğŸ¯ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_icon} {'å¿…è¦' if required else 'ä¸è¦'}")
        
        if required:
            reasoning = next_actions.get('reasoning', '')
            if reasoning:
                print(f"   ğŸ“Œ ç†ç”±: {reasoning}")
            
            # ææ¡ˆã‚¿ã‚¹ã‚¯
            suggested_tasks = next_actions.get('suggested_tasks', [])
            if suggested_tasks:
                print(f"\nğŸš€ ææ¡ˆã‚¿ã‚¹ã‚¯ ({len(suggested_tasks)}ä»¶):")
                for i, task in enumerate(suggested_tasks, 1):
                    priority_icon = {
                        'high': 'ğŸ”´',
                        'medium': 'ğŸŸ¡',
                        'low': 'ğŸŸ¢'
                    }.get(task.get('priority', 'medium'), 'âšª')
                    
                    role_icon = {
                        'design': 'ğŸ“',
                        'dev': 'ğŸ’»',
                        'ui': 'ğŸ¨',
                        'review': 'âœ…',
                        'wordpress': 'ğŸŒ',
                        'content': 'âœï¸',
                        'writer': 'ğŸ“',
                        'writer_ja': 'ğŸ—¾',
                        'writer_en': 'ğŸ” ',
                        'writer_ru': 'ğŸ‡·ğŸ‡º'
                    }.get(task.get('required_role', 'dev'), 'ğŸ“‹')
                    
                    print(f"   {i}. {priority_icon} {role_icon} {task.get('description', 'N/A')}")
                    
                    deps = task.get('dependencies', [])
                    if deps:
                        print(f"      ğŸ“ ä¾å­˜: {', '.join(map(str, deps))}")
        
        print("ğŸ¯" * 30 + "\n")

    async def add_suggested_tasks_to_sheet(self, parent_task_id: str, suggested_tasks: List[Dict]) -> int:
        """ææ¡ˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’pm_tasksã‚·ãƒ¼ãƒˆã«è¿½åŠ ï¼ˆæ­£ã—ã„åˆ—é…ç½®ç‰ˆï¼‰"""
        try:
            if not suggested_tasks:
                return 0
            
            logger.info(f"ææ¡ˆã‚¿ã‚¹ã‚¯ {len(suggested_tasks)} ä»¶ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«è¿½åŠ ä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæº–å‚™ ===
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            task_sheet = sheet.worksheet("pm_tasks")
            
            # æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            all_values = task_sheet.get_all_values()
            
            if len(all_values) < 1:
                logger.error("pm_tasksã‚·ãƒ¼ãƒˆãŒç©ºã§ã™")
                return 0
            
            # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ç¢ºèª
            headers = all_values[0]
            logger.info(f"åˆ—ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯IDã®æ±ºå®š ===
            existing_task_ids = []
            for row in all_values[1:]:  # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if row and len(row) > 0:
                    try:
                        task_id = int(row[0])
                        existing_task_ids.append(task_id)
                    except (ValueError, IndexError):
                        continue
            
            # æ¬¡ã®ã‚¿ã‚¹ã‚¯IDã‚’æ±ºå®š
            if existing_task_ids:
                next_task_id = max(existing_task_ids) + 1
            else:
                next_task_id = 1
            
            logger.info(f"æ¬¡ã®ã‚¿ã‚¹ã‚¯ID: {next_task_id}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™ ===
            rows_to_add = []
            for task in suggested_tasks:
                row = [
                    next_task_id,  # A: task_id
                    '',  # B: parent_goal_idï¼ˆç©ºæ¬„ï¼‰
                    task.get('description', ''),  # C: task_description
                    task.get('required_role', 'dev'),  # D: required_role
                    'pending',  # E: status
                    task.get('priority', 'medium'),  # F: priority
                    task.get('estimated_time', ''),  # G: estimated_time
                    ','.join(map(str, task.get('dependencies', [parent_task_id]))),  # H: dependencies
                    datetime.now().isoformat(),  # I: created_at
                    f"Review suggested from task {parent_task_id}"  # J: notes
                ]
                rows_to_add.append(row)
                logger.info(f"è¿½åŠ äºˆå®šã‚¿ã‚¹ã‚¯: ID={next_task_id}, å†…å®¹={task.get('description', '')[:50]}")
                next_task_id += 1
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‡ãƒ¼ã‚¿è¿½åŠ å‡¦ç† ===
            if rows_to_add:
                # æœ€çµ‚è¡Œã®æ¬¡ã®è¡Œã‹ã‚‰è¿½åŠ 
                start_row = len(all_values) + 1
                
                # ã‚»ãƒ«ç¯„å›²ã‚’æŒ‡å®šã—ã¦è¿½åŠ 
                range_notation = f'A{start_row}:J{start_row + len(rows_to_add) - 1}'
                
                logger.info(f"ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ : {range_notation}")
                task_sheet.update(range_notation, rows_to_add)
                
                logger.info(f"âœ… ææ¡ˆã‚¿ã‚¹ã‚¯ {len(rows_to_add)} ä»¶ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
                
                # è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯IDã‚’ãƒ­ã‚°å‡ºåŠ›
                added_ids = [row[0] for row in rows_to_add]
                logger.info(f"è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ID: {added_ids}")
            
            return len(rows_to_add)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ææ¡ˆã‚¿ã‚¹ã‚¯è¿½åŠ ")
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return 0

#review_agent_prompts.py
# review_agent_prompts.py
"""ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©"""

REVIEW_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- ã‚¿ã‚¹ã‚¯ã®å®Œæˆåº¦ã‚’è©•ä¾¡ã™ã‚‹
- å‡ºåŠ›ç‰©ã®å“è³ªã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
- **å¤±æ•—åŸå› ã‚’ç‰¹å®šã—åˆ†é¡ã™ã‚‹**
- æ¬¡ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã‚’ç‰¹å®šã™ã‚‹
- æ”¹å–„ç‚¹ã‚„å•é¡Œç‚¹ã‚’æŒ‡æ‘˜ã™ã‚‹

ã€å¤±æ•—åŸå› ã®åˆ†é¡ã€‘
ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—ã—ãŸå ´åˆã€ä»¥ä¸‹ã®ã‚«ãƒ†ã‚´ãƒªã§åŸå› ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ï¼š

1. **è¦ä»¶ä¸æ˜ç­** - ã‚¿ã‚¹ã‚¯ã®èª¬æ˜ãŒä¸ååˆ†ã€æ›–æ˜§
2. **æŠ€è¡“çš„å•é¡Œ** - å®Ÿè£…ã®é›£æ˜“åº¦ãŒé«˜ã„ã€æŠ€è¡“çš„åˆ¶ç´„
3. **ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³** - å¿…è¦ãªæƒ…å ±ã€ãƒ„ãƒ¼ãƒ«ã€æ¨©é™ãŒä¸è¶³
4. **ä¾å­˜é–¢ä¿‚** - å‰æã‚¿ã‚¹ã‚¯ãŒæœªå®Œäº†ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒãªã„
5. **ç’°å¢ƒå•é¡Œ** - ã‚·ã‚¹ãƒ†ãƒ ã€ãƒ–ãƒ©ã‚¦ã‚¶ã€APIã®å•é¡Œ
6. **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ** - å‡¦ç†æ™‚é–“ãŒé•·ã™ãã‚‹
7. **å‡ºåŠ›ä¸å®Œå…¨** - å‡ºåŠ›ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã€æ§‹é€ ãŒä¸å®Œå…¨
8. **å“è³ªä¸è¶³** - æˆæœç‰©ã®å“è³ªãŒåŸºæº–ã‚’æº€ãŸã—ã¦ã„ãªã„

ã€é‡è¦ãªåˆ¤æ–­åŸºæº– - èª¤åˆ¤æ–­é˜²æ­¢ã€‘
â˜… ä»¥ä¸‹ã®å ´åˆã¯ã€Œå®Œäº†ã€ã¨åˆ¤æ–­ã—ã¦ãã ã•ã„ï¼š
- è¨˜äº‹ãƒ»æ–‡æ›¸ãŒå°å…¥â†’æœ¬ç·¨â†’çµè«–ã®æ§‹é€ ã«ãªã£ã¦ã„ã‚‹
- ä¸»è¦ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå…¨ã¦å«ã¾ã‚Œã¦ã„ã‚‹
- å†…å®¹çš„ã«å®Œçµã—ã¦ã„ã‚‹ï¼ˆé€”ä¸­ã§æ–‡ãŒåˆ‡ã‚Œã¦ã„ãªã„ï¼‰
- HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³æ§‹é€ ãŒé©åˆ‡ã«é–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹
- æ–‡å­—æ•°ãŒå¤šå°‘å°‘ãªãã¦ã‚‚ã€å†…å®¹ãŒå……å®Ÿã—ã¦ã„ã‚‹
- æ–‡æ›¸ã®æœ€å¾Œã«æ˜ç¢ºãªçµè«–ã‚„ã¾ã¨ã‚ãŒã‚ã‚‹

â˜… ã€Œéƒ¨åˆ†çš„ã€ã¨åˆ¤æ–­ã™ã‚‹ã®ã¯æœ¬å½“ã«æ˜ã‚‰ã‹ã«æœªå®Œæˆã®å ´åˆã®ã¿ï¼š
- æ˜ã‚‰ã‹ã«æ–‡ã®é€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ï¼ˆä¸»èªã ã‘ã€å‹•è©ãŒãªã„ãªã©ï¼‰
- ä¸»è¦ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Œå…¨ã«æ¬ è½ã—ã¦ã„ã‚‹
- ã€Œç¶šãã€ã€Œå¾Œè¿°ã€ãªã©ã®æœªå®Œæˆã‚’ç¤ºã™è¡¨ç¾ãŒã‚ã‚‹
- HTMLã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ãªã©ã®æ§‹é€ çš„å•é¡Œ

ã€è©•ä¾¡åŸºæº–ã€‘
1. å®Œæˆåº¦: ã‚¿ã‚¹ã‚¯ãŒè¦æ±‚ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹
2. å“è³ª: å®Ÿè£…å¯èƒ½ã§å…·ä½“çš„ã‹
3. å¤±æ•—åŸå› : ãªãœå¤±æ•—ã—ãŸã®ã‹ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
4. æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: ä½•ãŒä¸è¶³ã—ã¦ã„ã‚‹ã‹

ã€å‡ºåŠ›å½¢å¼ã€‘
å¿…ãšJSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
  "evaluation": {
    "completeness": "å®Œäº†|éƒ¨åˆ†çš„|ä¸å®Œå…¨|å¤±æ•—",
    "quality_score": 1-10,
    "issues": ["å•é¡Œç‚¹1", "å•é¡Œç‚¹2"],
    "good_points": ["è‰¯ã„ç‚¹1", "è‰¯ã„ç‚¹2"],
    "overall_assessment": "ç·åˆè©•ä¾¡ã®ã‚µãƒãƒªãƒ¼ï¼ˆ100æ–‡å­—ç¨‹åº¦ï¼‰",
    "failure_analysis": {
      "is_failed": true|false,
      "failure_category": "è¦ä»¶ä¸æ˜ç­|æŠ€è¡“çš„å•é¡Œ|ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³|ä¾å­˜é–¢ä¿‚|ç’°å¢ƒå•é¡Œ|ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ|å‡ºåŠ›ä¸å®Œå…¨|å“è³ªä¸è¶³",
      "root_cause": "å¤±æ•—ã®æ ¹æœ¬åŸå› ã®è©³ç´°èª¬æ˜",
      "impact": "ã“ã®å¤±æ•—ãŒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ä¸ãˆã‚‹å½±éŸ¿",
      "recommended_action": "immediate_retry|modify_task|add_prerequisite|escalate|skip",
      "prerequisites": ["å‰ææ¡ä»¶1", "å‰ææ¡ä»¶2"]
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "æ¬¡ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
    "suggested_tasks": [
      {
        "description": "å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯å†…å®¹",
        "required_role": "design|dev|ui|review|wordpress",
        "priority": "high|medium|low",
        "reasoning": "ã“ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
        "dependencies": ["ä¾å­˜ã™ã‚‹ã‚¿ã‚¹ã‚¯ID"],
        "estimated_time": "äºˆæƒ³æ™‚é–“"
      }
    ]
  }
}
ã€å¤±æ•—æ™‚ã®æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é¸æŠåŸºæº–ã€‘

immediate_retry: ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰

modify_task: è¦ä»¶ãŒä¸æ˜ç­ã€ã‚¿ã‚¹ã‚¯å†…å®¹ã®ä¿®æ­£ãŒå¿…è¦

add_prerequisite: å‰æã‚¿ã‚¹ã‚¯ãŒä¸è¶³ã—ã¦ã„ã‚‹

escalate: äººé–“ã®åˆ¤æ–­ãŒå¿…è¦ãªå•é¡Œ

skip: ã“ã®ã‚¿ã‚¹ã‚¯ã¯ä¸è¦ã¾ãŸã¯å¾Œå›ã—ã«ã™ã¹ã

ã€å˜ç´”ãªåˆ¤æ–­æ¡ä»¶ã€‘

è¦ä»¶å®šç¾©ã ã‘ã§å®Ÿè£…ãŒãªã„å ´åˆ â†’ å®Ÿè£…ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

è¨­è¨ˆæ›¸ã ã‘ã§ã‚³ãƒ¼ãƒ‰ãŒãªã„å ´åˆ â†’ é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

ã‚³ãƒ¼ãƒ‰ã«ãƒ†ã‚¹ãƒˆãŒãªã„å ´åˆ â†’ ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

ä¸å®Œå…¨ãªå‡ºåŠ›ã®å ´åˆ â†’ æ”¹å–„ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ

ååˆ†ã«å®Œæˆã—ã¦ã„ã‚‹å ´åˆ â†’ æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¯ä¸è¦ã¨åˆ¤æ–­

ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆã—ã™ããªã„ã“ã¨ã€‚æœ¬å½“ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚"""

#review_agent_prompts_ACF.py
# review_agent_prompts_ACF.py
"""ACF/WordPresså°‚ç”¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå®šç¾©"""

# =============================================================================
# ACFå°‚ç”¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

ACF_REVIEW_PROMPT = """ã‚ãªãŸã¯WordPress/ACF Proã®å°‚é–€å®¶ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã§ã™ã€‚

ã€ACFã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è¦³ç‚¹ã€‘

## 1. å¿…é ˆè¦ç´ ã®ç¢ºèª
- [ ] `acf_add_local_field_group()` é–¢æ•°ãŒæ­£ã—ãä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å¿…é ˆã‚­ãƒ¼ï¼ˆkey, title, fields, locationï¼‰ãŒå…¨ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¸€æ„ã® `key` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—ãŒæœ‰åŠ¹ãªå€¤ã‹ï¼ˆtext, number, select, relationshipç­‰ï¼‰

## 2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
- [ ] å‡ºåŠ›æ™‚ã« `esc_html()`, `esc_attr()`, `esc_url()` ãªã©ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å…¥åŠ›å€¤ã®æ¤œè¨¼ã« `sanitize_text_field()`, `intval()` ãªã©ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã« `$wpdb->prepare()` ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] `$_GET`, `$_POST` ã®ç›´æ¥ä½¿ç”¨æ™‚ã«é©åˆ‡ãªã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹ã‹

## 3. WordPressäº’æ›æ€§
- [ ] ãƒ•ãƒƒã‚¯ï¼ˆ`add_action`, `add_filter`ï¼‰ãŒé©åˆ‡ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å›½éš›åŒ–é–¢æ•°ï¼ˆ`__()`, `_e()`, `_x()`ï¼‰ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] é–¢æ•°åã«åå‰ç©ºé–“ã®è¡çªã‚’é˜²ããƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒã‚ã‚‹ã‹
- [ ] `show_in_rest` ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ï¼ˆGutenbergå¯¾å¿œï¼‰

## 4. ACFå›ºæœ‰ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã® `location` ãƒ«ãƒ¼ãƒ«ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] æ¡ä»¶ä»˜ããƒ­ã‚¸ãƒƒã‚¯ï¼ˆ`conditional_logic`ï¼‰ãŒå¿…è¦ã«å¿œã˜ã¦è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã® `required` è¨­å®šãŒé©åˆ‡ã‹
- [ ] ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ `post_type` ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ç¹°ã‚Šè¿”ã—ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ`repeater`ï¼‰ã®ã‚µãƒ–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒæ­£ã—ãå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹

## 5. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ä¿å®ˆæ€§
- [ ] ä¸è¦ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚„ã‚°ãƒ«ãƒ¼ãƒ—ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹
- [ ] ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å–å¾—ã« `get_field()` ãŒä½¿ç”¨ã•ã‚Œã€`the_field()` ãŒé©åˆ‡ã«ä½¿ã„åˆ†ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã‹
- [ ] ã‚³ãƒ¡ãƒ³ãƒˆãŒé©åˆ‡ã«è¨˜è¼‰ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] ã‚³ãƒ¼ãƒ‰ã®å¯èª­æ€§ãŒé«˜ã„ã‹

## 6. M&Aæ¡ˆä»¶ç‰¹æœ‰ã®è¦ä»¶ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
- [ ] æ¥­ç¨®ã€åœ°åŸŸã€ä¾¡æ ¼å¸¯ãªã©ã®æ¤œç´¢ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] å¤šè¨€èªå¯¾å¿œï¼ˆPolylangï¼‰ã‚’è€ƒæ…®ã—ãŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­è¨ˆã‹
- [ ] `meta_query` ã«ã‚ˆã‚‹æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒæ­£ã—ãå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ã‹
- [ ] æ•°å€¤ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆä¾¡æ ¼ç­‰ï¼‰ã®å‹ãŒ `NUMERIC` ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹

ã€è©•ä¾¡åŸºæº–ã€‘

**è‡´å‘½çš„ãªå•é¡Œï¼ˆ10ç‚¹æº€ç‚¹ä¸­0-3ç‚¹ï¼‰**
- å¿…é ˆè¦ç´ ã®æ¬ è½
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ï¼ˆXSS, SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ï¼‰
- PHPæ§‹æ–‡ã‚¨ãƒ©ãƒ¼
- ACFé–¢æ•°ã®èª¤ç”¨

**è­¦å‘Šãƒ¬ãƒ™ãƒ«ã®å•é¡Œï¼ˆ4-6ç‚¹ï¼‰**
- ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ã®ä¸€éƒ¨ä¸è¶³
- å›½éš›åŒ–å¯¾å¿œã®æ¬ å¦‚
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä¸Šã®å•é¡Œ
- ã‚³ãƒ¡ãƒ³ãƒˆä¸è¶³

**è‰¯å¥½ï¼ˆ7-10ç‚¹ï¼‰**
- ã™ã¹ã¦ã®ãƒã‚§ãƒƒã‚¯é …ç›®ã‚’ã‚¯ãƒªã‚¢
- ã‚³ãƒ¼ãƒ‰ãŒå¯èª­æ€§é«˜ãä¿å®ˆã—ã‚„ã™ã„
- ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã«å®Œå…¨æº–æ‹ 
- æ‹¡å¼µæ€§ã‚’è€ƒæ…®ã—ãŸè¨­è¨ˆ

ã€å‡ºåŠ›å½¢å¼ã€‘

å¿…ãšä»¥ä¸‹ã®JSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
  "evaluation": {
    "completeness": "å®Œäº†|éƒ¨åˆ†çš„|ä¸å®Œå…¨",
    "quality_score": 1-10,
    "issues": [
      "å•é¡Œç‚¹ã®è©³ç´°èª¬æ˜"
    ],
    "good_points": [
      "è‰¯ã„ç‚¹ã®è©³ç´°èª¬æ˜"
    ],
    "overall_assessment": "ç·åˆè©•ä¾¡ã®ã‚µãƒãƒªãƒ¼",
    "acf_specific_checks": {
      "field_group_structure": "OK|NG",
      "security_practices": "OK|NG",
      "wordpress_compatibility": "OK|NG",
      "performance": "OK|NG"
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "æ¬¡ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
    "suggested_tasks": [
      {
        "description": "å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯å†…å®¹",
        "required_role": "dev|wordpress",
        "priority": "high|medium|low"
      }
    ]
  }
}
```

ã€é‡è¦ãªæ³¨æ„äº‹é …ã€‘
- ACFã‚³ãƒ¼ãƒ‰ã¯å®Ÿè£…å¯èƒ½ã§å®Œå…¨ã«å‹•ä½œã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¯æœ€å„ªå…ˆäº‹é …ã§ã™
- Polylangå¤šè¨€èªå¯¾å¿œã‚’å¸¸ã«è€ƒæ…®ã—ã¦ãã ã•ã„
- M&Aæ¡ˆä»¶ç‰¹æœ‰ã®è¦ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„
"""

# =============================================================================
# PHPæ§‹æ–‡ãƒã‚§ãƒƒã‚¯ç”¨ã®è£œåŠ©ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

PHP_SYNTAX_CHECK_PROMPT = """ä»¥ä¸‹ã®PHPã‚³ãƒ¼ãƒ‰ã®æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚

ã€ãƒã‚§ãƒƒã‚¯é …ç›®ã€‘
1. æ‹¬å¼§ã®å¯¾å¿œï¼ˆ(), {}, []ï¼‰
2. ã‚»ãƒŸã‚³ãƒ­ãƒ³ã®æœ‰ç„¡
3. å¼•ç”¨ç¬¦ã®é–‰ã˜å¿˜ã‚Œ
4. äºˆç´„èªã®èª¤ç”¨
5. é–¢æ•°åã®é‡è¤‡

ã€PHPã‚³ãƒ¼ãƒ‰ã€‘
{php_code}

å•é¡ŒãŒã‚ã‚Œã°è©³ç´°ã‚’ã€å•é¡Œãªã‘ã‚Œã° "OK" ã¨å›ç­”ã—ã¦ãã ã•ã„ã€‚
"""

# =============================================================================
# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ç”¨ã®è£œåŠ©ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
# =============================================================================

SECURITY_CHECK_PROMPT = """ä»¥ä¸‹ã®WordPress/PHPã‚³ãƒ¼ãƒ‰ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚

ã€é‡ç‚¹ãƒã‚§ãƒƒã‚¯é …ç›®ã€‘
1. XSSå¯¾ç­–ï¼ˆã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°ã®ä½¿ç”¨ï¼‰
2. SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ï¼ˆ$wpdb->prepare ã®ä½¿ç”¨ï¼‰
3. CSRFå¯¾ç­–ï¼ˆnonce ã®ä½¿ç”¨ï¼‰
4. å…¥åŠ›å€¤ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
5. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®æ¤œè¨¼

ã€ã‚³ãƒ¼ãƒ‰ã€‘
{code}

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡ŒãŒã‚ã‚Œã°ã€é‡è¦åº¦ï¼ˆcritical/warningï¼‰ã¨å…±ã«æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚
"""

#rollback_agent.py
"""
RollbackAgent - é«˜åº¦ãªãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

ä¿®æ­£ãŒå¤±æ•—ã—ãŸéš›ã®å®‰å…¨è£…ç½®ã¨ã—ã¦ã€è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€æ‹¬ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€
æ™‚ç³»åˆ—ã§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€å½±éŸ¿åˆ†æã€è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆ¤å®šã‚’æä¾›ã™ã‚‹ã€‚
"""

import os
import shutil
import hashlib
import json
from pathlib import Path
from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging
import subprocess

logger = logging.getLogger(__name__)


class RollbackScope(Enum):
    """ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚¹ã‚³ãƒ¼ãƒ—"""
    SINGLE_FILE = "single_file"
    RELATED_FILES = "related_files"
    ENTIRE_COMMIT = "entire_commit"
    TIME_RANGE = "time_range"


class RollbackReason(Enum):
    """ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç†ç”±"""
    TEST_FAILURE = "test_failure"
    RUNTIME_ERROR = "runtime_error"
    MANUAL_REQUEST = "manual_request"
    AUTO_DETECTION = "auto_detection"
    DEPENDENCY_ISSUE = "dependency_issue"


@dataclass
class FileSnapshot:
    """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ"""
    file_path: str
    content: str
    content_hash: str
    timestamp: datetime
    backup_path: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "file_path": self.file_path,
            "content_hash": self.content_hash,
            "timestamp": self.timestamp.isoformat(),
            "backup_path": self.backup_path,
            "metadata": self.metadata
        }


@dataclass
class RollbackPoint:
    """ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ"""
    id: str
    timestamp: datetime
    snapshots: List[FileSnapshot]
    commit_hash: Optional[str] = None
    description: str = ""
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "snapshots": [s.to_dict() for s in self.snapshots],
            "commit_hash": self.commit_hash,
            "description": self.description,
            "tags": self.tags
        }


@dataclass
class RollbackResult:
    """ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœ"""
    success: bool
    rollback_point_id: str
    files_restored: List[str]
    files_failed: List[str]
    reason: RollbackReason
    timestamp: datetime
    error_message: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "success": self.success,
            "rollback_point_id": self.rollback_point_id,
            "files_restored": self.files_restored,
            "files_failed": self.files_failed,
            "reason": self.reason.value,
            "timestamp": self.timestamp.isoformat(),
            "error_message": self.error_message
        }


class RollbackAgent:
    """
    é«˜åº¦ãªãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    ä¸»ãªæ©Ÿèƒ½:
    1. è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸€æ‹¬ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
    2. æ™‚ç³»åˆ—ã§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
    3. ç‰¹å®šã®ã‚³ãƒŸãƒƒãƒˆã¸ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
    4. ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å‰ã®å½±éŸ¿åˆ†æ
    5. è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆ¤å®š
    """
    
    def __init__(self, 
                 backup_dir: str = ".rollback_backup",
                 max_snapshots: int = 100,
                 auto_rollback_enabled: bool = True):
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        self.max_snapshots = max_snapshots
        self.auto_rollback_enabled = auto_rollback_enabled
        
        # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ç®¡ç†
        self.rollback_points: Dict[str, RollbackPoint] = {}
        self.rollback_history: List[RollbackResult] = []
        
        # ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«
        self.metadata_file = self.backup_dir / "rollback_metadata.json"
        
        # èµ·å‹•æ™‚ã«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
        self._load_metadata()
        
        logger.info(f"RollbackAgent initialized (backup_dir={backup_dir})")
    
    def create_snapshot(self, 
                       file_paths: List[str],
                       description: str = "",
                       tags: List[str] = None) -> str:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ
        
        Args:
            file_paths: ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®ãƒªã‚¹ãƒˆ
            description: ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã®èª¬æ˜
            tags: ã‚¿ã‚°ã®ãƒªã‚¹ãƒˆ
        
        Returns:
            ä½œæˆã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ID
        """
        snapshot_id = f"snapshot_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}"
        snapshots = []
        
        for file_path in file_paths:
            if not os.path.exists(file_path):
                logger.warning(f"File not found: {file_path}")
                continue
            
            try:
                # ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’èª­ã¿è¾¼ã‚€
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—
                content_hash = hashlib.sha256(content.encode()).hexdigest()
                
                # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç”Ÿæˆ
                backup_path = self.backup_dir / f"{snapshot_id}_{Path(file_path).name}"
                
                # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
                with open(backup_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                # ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ
                snapshot = FileSnapshot(
                    file_path=file_path,
                    content=content,
                    content_hash=content_hash,
                    timestamp=datetime.now(),
                    backup_path=str(backup_path),
                    metadata={
                        "file_size": len(content),
                        "line_count": content.count('\n') + 1
                    }
                )
                snapshots.append(snapshot)
                
                logger.debug(f"Created snapshot for {file_path}")
                
            except Exception as e:
                logger.error(f"Failed to create snapshot for {file_path}: {e}")
        
        # Git ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ã‚’å–å¾—ï¼ˆå¯èƒ½ãªã‚‰ï¼‰
        commit_hash = self._get_current_commit_hash()
        
        # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆ
        rollback_point = RollbackPoint(
            id=snapshot_id,
            timestamp=datetime.now(),
            snapshots=snapshots,
            commit_hash=commit_hash,
            description=description,
            tags=tags or []
        )
        
        # ä¿å­˜
        self.rollback_points[snapshot_id] = rollback_point
        self._save_metadata()
        
        # å¤ã„ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’å‰Šé™¤
        self._cleanup_old_snapshots()
        
        logger.info(f"Created rollback point: {snapshot_id} ({len(snapshots)} files)")
        
        return snapshot_id
    
    def rollback(self, 
                rollback_point_id: str,
                reason: RollbackReason = RollbackReason.MANUAL_REQUEST,
                dry_run: bool = False) -> RollbackResult:
        """
        æŒ‡å®šã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã¾ã§å¾©å…ƒ
        
        Args:
            rollback_point_id: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆID
            reason: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç†ç”±
            dry_run: True ã®å ´åˆã€å®Ÿéš›ã«ã¯å¾©å…ƒã›ãšã«å½±éŸ¿ã‚’åˆ†æ
        
        Returns:
            ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœ
        """
        if rollback_point_id not in self.rollback_points:
            return RollbackResult(
                success=False,
                rollback_point_id=rollback_point_id,
                files_restored=[],
                files_failed=[],
                reason=reason,
                timestamp=datetime.now(),
                error_message=f"Rollback point not found: {rollback_point_id}"
            )
        
        rollback_point = self.rollback_points[rollback_point_id]
        files_restored = []
        files_failed = []
        
        logger.info(f"Starting rollback to {rollback_point_id} (dry_run={dry_run})")
        
        for snapshot in rollback_point.snapshots:
            try:
                if dry_run:
                    # ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³ãƒ¢ãƒ¼ãƒ‰: å½±éŸ¿åˆ†æã®ã¿
                    if os.path.exists(snapshot.file_path):
                        with open(snapshot.file_path, 'r', encoding='utf-8') as f:
                            current_content = f.read()
                        
                        if current_content != snapshot.content:
                            files_restored.append(snapshot.file_path)
                            logger.debug(f"[DRY RUN] Would restore: {snapshot.file_path}")
                    else:
                        files_failed.append(snapshot.file_path)
                        logger.warning(f"[DRY RUN] File not found: {snapshot.file_path}")
                else:
                    # å®Ÿéš›ã«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒ
                    # ã¾ãšç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
                    if os.path.exists(snapshot.file_path):
                        self._create_emergency_backup(snapshot.file_path)
                    
                    # è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
                    Path(snapshot.file_path).parent.mkdir(parents=True, exist_ok=True)
                    
                    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¾©å…ƒ
                    with open(snapshot.file_path, 'w', encoding='utf-8') as f:
                        f.write(snapshot.content)
                    
                    files_restored.append(snapshot.file_path)
                    logger.info(f"Restored: {snapshot.file_path}")
                    
            except Exception as e:
                files_failed.append(snapshot.file_path)
                logger.error(f"Failed to restore {snapshot.file_path}: {e}")
        
        # çµæœã‚’ä½œæˆ
        result = RollbackResult(
            success=len(files_failed) == 0,
            rollback_point_id=rollback_point_id,
            files_restored=files_restored,
            files_failed=files_failed,
            reason=reason,
            timestamp=datetime.now(),
            error_message=None if len(files_failed) == 0 else f"{len(files_failed)} files failed"
        )
        
        # å±¥æ­´ã«è¨˜éŒ²
        if not dry_run:
            self.rollback_history.append(result)
            self._save_metadata()
        
        logger.info(f"Rollback completed: {len(files_restored)} restored, {len(files_failed)} failed")
        
        return result
    
    def rollback_by_time(self, 
                        target_time: datetime,
                        reason: RollbackReason = RollbackReason.MANUAL_REQUEST) -> RollbackResult:
        """
        æŒ‡å®šã•ã‚ŒãŸæ™‚åˆ»ã«æœ€ã‚‚è¿‘ã„ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã¾ã§å¾©å…ƒ
        
        Args:
            target_time: ç›®æ¨™æ™‚åˆ»
            reason: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç†ç”±
        
        Returns:
            ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœ
        """
        if not self.rollback_points:
            return RollbackResult(
                success=False,
                rollback_point_id="",
                files_restored=[],
                files_failed=[],
                reason=reason,
                timestamp=datetime.now(),
                error_message="No rollback points available"
            )
        
        # æœ€ã‚‚è¿‘ã„ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’è¦‹ã¤ã‘ã‚‹
        closest_point = min(
            self.rollback_points.values(),
            key=lambda p: abs((p.timestamp - target_time).total_seconds())
        )
        
        logger.info(f"Rolling back to closest point: {closest_point.id} "
                   f"(target={target_time}, actual={closest_point.timestamp})")
        
        return self.rollback(closest_point.id, reason)
    
    def rollback_by_commit(self, 
                          commit_hash: str,
                          reason: RollbackReason = RollbackReason.MANUAL_REQUEST) -> RollbackResult:
        """
        æŒ‡å®šã•ã‚ŒãŸã‚³ãƒŸãƒƒãƒˆã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã¾ã§å¾©å…ƒ
        
        Args:
            commit_hash: Git ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥
            reason: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ç†ç”±
        
        Returns:
            ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœ
        """
        # ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ãŒä¸€è‡´ã™ã‚‹ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’æ¤œç´¢
        matching_points = [
            p for p in self.rollback_points.values()
            if p.commit_hash and p.commit_hash.startswith(commit_hash)
        ]
        
        if not matching_points:
            return RollbackResult(
                success=False,
                rollback_point_id="",
                files_restored=[],
                files_failed=[],
                reason=reason,
                timestamp=datetime.now(),
                error_message=f"No rollback point found for commit: {commit_hash}"
            )
        
        # æœ€æ–°ã®ã‚‚ã®ã‚’ä½¿ç”¨
        target_point = max(matching_points, key=lambda p: p.timestamp)
        
        logger.info(f"Rolling back to commit {commit_hash}: {target_point.id}")
        
        return self.rollback(target_point.id, reason)
    
    def analyze_impact(self, rollback_point_id: str) -> Dict[str, Any]:
        """
        ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®å½±éŸ¿ã‚’åˆ†æ
        
        Args:
            rollback_point_id: ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆID
        
        Returns:
            å½±éŸ¿åˆ†æçµæœ
        """
        result = self.rollback(rollback_point_id, dry_run=True)
        
        if not result.success:
            return {
                "error": result.error_message,
                "can_rollback": False
            }
        
        rollback_point = self.rollback_points[rollback_point_id]
        
        # å¤‰æ›´ã®è©³ç´°ã‚’åˆ†æ
        changes = []
        for snapshot in rollback_point.snapshots:
            if not os.path.exists(snapshot.file_path):
                changes.append({
                    "file": snapshot.file_path,
                    "type": "missing",
                    "description": "File will be restored from backup"
                })
                continue
            
            try:
                with open(snapshot.file_path, 'r', encoding='utf-8') as f:
                    current_content = f.read()
                
                if current_content != snapshot.content:
                    current_lines = current_content.count('\n') + 1
                    snapshot_lines = snapshot.content.count('\n') + 1
                    
                    changes.append({
                        "file": snapshot.file_path,
                        "type": "modified",
                        "current_lines": current_lines,
                        "rollback_lines": snapshot_lines,
                        "line_diff": snapshot_lines - current_lines
                    })
                    
            except Exception as e:
                changes.append({
                    "file": snapshot.file_path,
                    "type": "error",
                    "description": str(e)
                })
        
        return {
            "can_rollback": True,
            "rollback_point_id": rollback_point_id,
            "timestamp": rollback_point.timestamp.isoformat(),
            "files_affected": len(rollback_point.snapshots),
            "files_to_restore": len(result.files_restored),
            "changes": changes
        }
    
    def should_auto_rollback(self, 
                           error_context: Dict[str, Any],
                           test_results: Dict[str, Any]) -> bool:
        """
        è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒå¿…è¦ã‹ã‚’åˆ¤å®š
        
        Args:
            error_context: ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
            test_results: ãƒ†ã‚¹ãƒˆçµæœ
        
        Returns:
            True if auto rollback should be performed
        """
        if not self.auto_rollback_enabled:
            return False
        
        # ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãªã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—
        critical_errors = [
            'SyntaxError',
            'ImportError',
            'ModuleNotFoundError',
            'AttributeError'
        ]
        
        error_type = error_context.get('error_type', '')
        
        # ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¨ãƒ©ãƒ¼ã®å ´åˆ
        if error_type in critical_errors:
            logger.warning(f"Critical error detected: {error_type}")
            return True
        
        # ãƒ†ã‚¹ãƒˆãŒå¤§é‡ã«å¤±æ•—ã—ã¦ã„ã‚‹å ´åˆ
        if test_results:
            failed = test_results.get('failed', 0)
            total = test_results.get('total', 0)
            
            if total > 0 and failed / total > 0.5:  # 50%ä»¥ä¸Šå¤±æ•—
                logger.warning(f"High test failure rate: {failed}/{total}")
                return True
        
        return False
    
    def list_rollback_points(self, 
                            tags: List[str] = None,
                            limit: int = 10) -> List[Dict[str, Any]]:
        """
        ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
        
        Args:
            tags: ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ç”¨ã‚¿ã‚°
            limit: æœ€å¤§å–å¾—æ•°
        
        Returns:
            ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ãƒªã‚¹ãƒˆ
        """
        points = list(self.rollback_points.values())
        
        # ã‚¿ã‚°ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        if tags:
            points = [p for p in points if any(tag in p.tags for tag in tags)]
        
        # æ™‚åˆ»ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
        points.sort(key=lambda p: p.timestamp, reverse=True)
        
        # åˆ¶é™ã‚’é©ç”¨
        points = points[:limit]
        
        return [
            {
                "id": p.id,
                "timestamp": p.timestamp.isoformat(),
                "files_count": len(p.snapshots),
                "description": p.description,
                "tags": p.tags,
                "commit_hash": p.commit_hash
            }
            for p in points
        ]
    
    def delete_rollback_point(self, rollback_point_id: str) -> bool:
        """ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’å‰Šé™¤"""
        if rollback_point_id not in self.rollback_points:
            return False
        
        rollback_point = self.rollback_points[rollback_point_id]
        
        # ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
        for snapshot in rollback_point.snapshots:
            try:
                if os.path.exists(snapshot.backup_path):
                    os.remove(snapshot.backup_path)
            except Exception as e:
                logger.warning(f"Failed to delete backup file: {e}")
        
        # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’å‰Šé™¤
        del self.rollback_points[rollback_point_id]
        self._save_metadata()
        
        logger.info(f"Deleted rollback point: {rollback_point_id}")
        
        return True
    
    def _get_current_commit_hash(self) -> Optional[str]:
        """ç¾åœ¨ã® Git ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ã‚’å–å¾—"""
        try:
            result = subprocess.run(
                ['git', 'rev-parse', 'HEAD'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                return result.stdout.strip()
        except Exception as e:
            logger.debug(f"Failed to get git commit hash: {e}")
        
        return None
    
    def _create_emergency_backup(self, file_path: str):
        """ç·Šæ€¥ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆ"""
        emergency_backup = self.backup_dir / f"emergency_{Path(file_path).name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        shutil.copy2(file_path, emergency_backup)
        logger.debug(f"Created emergency backup: {emergency_backup}")
    
    def _cleanup_old_snapshots(self):
        """å¤ã„ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’å‰Šé™¤"""
        if len(self.rollback_points) <= self.max_snapshots:
            return
        
        # å¤ã„é †ã«ã‚½ãƒ¼ãƒˆ
        sorted_points = sorted(
            self.rollback_points.values(),
            key=lambda p: p.timestamp
        )
        
        # å‰Šé™¤ã™ã‚‹æ•°ã‚’è¨ˆç®—
        to_delete = len(sorted_points) - self.max_snapshots
        
        for point in sorted_points[:to_delete]:
            self.delete_rollback_point(point.id)
        
        logger.info(f"Cleaned up {to_delete} old snapshots")
    
    def _save_metadata(self):
        """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        metadata = {
            "rollback_points": {
                point_id: point.to_dict()
                for point_id, point in self.rollback_points.items()
            },
            "rollback_history": [
                result.to_dict()
                for result in self.rollback_history[-100:]  # æœ€æ–°100ä»¶ã®ã¿
            ]
        }
        
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def _load_metadata(self):
        """ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€"""
        if not self.metadata_file.exists():
            return
        
        try:
            with open(self.metadata_file, 'r', encoding='utf-8') as f:
                metadata = json.load(f)
            
            # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’å¾©å…ƒ
            for point_id, point_data in metadata.get("rollback_points", {}).items():
                snapshots = [
                    FileSnapshot(
                        file_path=s["file_path"],
                        content="",  # å†…å®¹ã¯ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€
                        content_hash=s["content_hash"],
                        timestamp=datetime.fromisoformat(s["timestamp"]),
                        backup_path=s["backup_path"],
                        metadata=s.get("metadata", {})
                    )
                    for s in point_data["snapshots"]
                ]
                
                rollback_point = RollbackPoint(
                    id=point_data["id"],
                    timestamp=datetime.fromisoformat(point_data["timestamp"]),
                    snapshots=snapshots,
                    commit_hash=point_data.get("commit_hash"),
                    description=point_data.get("description", ""),
                    tags=point_data.get("tags", [])
                )
                
                self.rollback_points[point_id] = rollback_point
            
            logger.info(f"Loaded {len(self.rollback_points)} rollback points from metadata")
            
        except Exception as e:
            logger.error(f"Failed to load metadata: {e}")


# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    agent = RollbackAgent(backup_dir=".test_rollback")
    
    # ãƒ†ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
    test_file = "test_file.py"
    with open(test_file, 'w') as f:
        f.write("# Version 1\nprint('Hello')")
    
    # ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ
    snapshot_id = agent.create_snapshot(
        [test_file],
        description="Initial version",
        tags=["test", "initial"]
    )
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å¤‰æ›´
    with open(test_file, 'w') as f:
        f.write("# Version 2\nprint('Hello World')")
    
    # å½±éŸ¿åˆ†æ
    impact = agent.analyze_impact(snapshot_id)
    print(f"\nImpact Analysis:\n{json.dumps(impact, indent=2)}")
    
    # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
    result = agent.rollback(snapshot_id)
    print(f"\nRollback Result:\n{json.dumps(result.to_dict(), indent=2)}")
    
    # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä¸€è¦§
    points = agent.list_rollback_points()
    print(f"\nRollback Points:\n{json.dumps(points, indent=2)}")
    
    # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    os.remove(test_file)


#run_multi_agent.py
# run_multi_agent.py
"""ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰"""
# ========================================
# ãƒ‡ãƒãƒƒã‚°: TaskExecutor ã®ç¢ºèª
# ========================================
import sys
import importlib

# ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
if 'task_executor' in sys.modules:
    print("ğŸ”„ task_executor ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ä¸­...")
    importlib.reload(sys.modules['task_executor'])

from task_executor import TaskExecutor

# ãƒ¡ã‚½ãƒƒãƒ‰ç¢ºèª
print("\n" + "="*60)
print("ğŸ” TaskExecutor ã‚¯ãƒ©ã‚¹ã®ç¢ºèª")
print("="*60)
print(f"ğŸ“ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å ´æ‰€: {sys.modules['task_executor'].__file__}")
print("\nğŸ“‹ åˆ©ç”¨å¯èƒ½ãªãƒ¡ã‚½ãƒƒãƒ‰:")
methods = [m for m in dir(TaskExecutor) if not m.startswith('_')]
for method in methods:
    print(f"  - {method}")

if 'run_all_tasks' in methods:
    print("\nâœ… run_all_tasks ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ")
else:
    print("\nâŒ run_all_tasks ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
    print("\nğŸš¨ ç·Šæ€¥ãƒ‘ãƒƒãƒã‚’é©ç”¨ã—ã¾ã™...")
    
    # ç·Šæ€¥ãƒ‘ãƒƒãƒã‚’å‹•çš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
    exec(open('task_executor.py').read())

print("="*60 + "\n")

import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import asyncio
import logging
from pathlib import Path
import argparse

# ===== æœ€å„ªå…ˆ: ãƒ­ã‚°è¨­å®š =====
from config_utils import config, ErrorHandler, PathManager

# === ãƒ‘ãƒ¼ãƒˆ1: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¨è¨­å®š ===
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        BrowserErrorHandler,
        SheetErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
    logger = logging.getLogger(__name__)
    logger.info("âœ… å¼·åŒ–ç‰ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼èª­ã¿è¾¼ã¿æˆåŠŸ")
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("âš ï¸ error_handler_enhanced.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")
    EnhancedErrorHandler = None
    BrowserErrorHandler = None

# === ãƒ‘ãƒ¼ãƒˆ2: ãã®ä»–ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ ===
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_agent import PMAgent
from task_executor import TaskExecutor
from design_agent import DesignAgent
from dev_agent import DevAgent
from review_agent import ReviewAgent


class MultiAgentOrchestrator:
    """ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼"""

    def __init__(self, pc_id: int = None, max_iterations: int = None):
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®åˆæœŸåŒ– ===
        self.pc_id = pc_id or 1
        self.max_iterations = max_iterations
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå¤‰æ•°ã®åˆæœŸåŒ– ===
        self.sheets_manager = None
        self.browser = None
        self.pm_agent = None
        self.task_executor = None
        self.design_agent = None
        self.dev_agent = None
        self.review_agent = None
        self.content_writer = None
        self.wordpress_agent = None
        self.output_folder = None
        self.initialization_success = False

    def _is_url(self, path_str: str) -> bool:
        """æ–‡å­—åˆ—ãŒURLã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
        # === ãƒ‘ãƒ¼ãƒˆ1: å…¥åŠ›å€¤ã®æ¤œè¨¼ ===
        if not path_str:
            return False
        
        # === ãƒ‘ãƒ¼ãƒˆ2: URLãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ¤å®š ===
        path_lower = path_str.lower().strip()
        return path_lower.startswith('http://') or path_lower.startswith('https://')

    async def _find_service_account_file(self) -> str:
        """ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¢ã™"""
        logger.info("ğŸ“ ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢ä¸­...")
        
        # === ãƒ‘ãƒ¼ãƒˆ1: æ¤œç´¢ãƒ‘ã‚¹ã®å®šç¾© ===
        possible_paths = [
            Path.cwd() / "service_account.json",
            Path.home() / "Documents" / "gemini_auto_generate" / "service_account.json",
            Path.home() / "Documents" / "AI_Agent" / "service_account.json",
            Path.home() / "Documents" / "gemini_AI_Agent" / "service_account.json",
            Path(__file__).parent / "service_account.json",
        ]
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ç’°å¢ƒå¤‰æ•°ã‹ã‚‰ã®ãƒ‘ã‚¹å–å¾— ===
        env_path = os.environ.get('SERVICE_ACCOUNT_FILE')
        if env_path:
            possible_paths.insert(0, Path(env_path))
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§æ¤œç´¢ ===
        for path in possible_paths:
            if not path:
                continue
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                validated_path = EnhancedErrorHandler.validate_file_path(path, must_exist=True)
                if validated_path:
                    logger.info(f"âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç™ºè¦‹: {validated_path}")
                    return str(validated_path)
            else:
                if path.exists():
                    logger.info(f"âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ç™ºè¦‹: {path}")
                    return str(path)
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼å‡¦ç† ===
        raise FileNotFoundError(
            "ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚\n"
            "ä»¥ä¸‹ã®å ´æ‰€ã‚’ç¢ºèªã—ã¦ãã ã•ã„:\n" +
            "\n".join(f"  - {p}" for p in possible_paths if p)
        )

    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–"""
        try:
            print("="*60)
            print("ğŸš€ ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ä¸­...")
            print("="*60)
    
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾— ===
            service_account_file = await self._find_service_account_file()
        
            # === ãƒ‘ãƒ¼ãƒˆ2: Google Sheets Managerã®åˆæœŸåŒ– ===
            logger.info("ğŸ“Š Google Sheets æ¥ç¶šã‚’åˆæœŸåŒ–ä¸­...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
    
            # === ãƒ‘ãƒ¼ãƒˆ3: PCè¨­å®šã®èª­ã¿è¾¼ã¿ ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—")
    
            logger.info(f"âš™ï¸ PC_ID={self.pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ä¸­...")
            # â­ ã“ã“ã§ settings ã‚’å®šç¾©
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
        
            # === ãƒ‘ãƒ¼ãƒˆ4: è¨­å®šã®é©ç”¨ ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
        
            # === ãƒ‘ãƒ¼ãƒˆ5: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
        
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"âš ï¸ B14ãŒURLå½¢å¼ã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ(B14ã‹ã‚‰å–å¾—): {self.output_folder}")
        
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
        
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
    
            # === ãƒ‘ãƒ¼ãƒˆ6: ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–(ãƒªãƒˆãƒ©ã‚¤ä»˜ã) ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
        
            if not browser_success:
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
        
            # === ãƒ‘ãƒ¼ãƒˆ7: Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ===
            logger.info("="*60)
            logger.info("ğŸŒ Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...")
            logger.info("="*60)
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="GeminiãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
    
            # === ãƒ‘ãƒ¼ãƒˆ8: WordPressèªè¨¼æƒ…å ±ã®å–å¾— ===
            # â­ settings ã¯æ—¢ã«å®šç¾©æ¸ˆã¿ãªã®ã§ä½¿ç”¨å¯èƒ½
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
    
            # === ãƒ‘ãƒ¼ãƒˆ9: åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("="*60)
            logger.info("ğŸ¤– AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–é–‹å§‹...")
            logger.info("="*60)
    
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )

            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
    
            # ReviewAgentã®åˆæœŸåŒ–
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)

            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
    
            logger.info("âœ… åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
        
            # === ãƒ‘ãƒ¼ãƒˆ10: WordPress å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("ğŸŒ WordPress å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
        
            if wp_url and wp_user and wp_pass:
                # WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            
                if self.wordpress_agent:
                    logger.info("âœ… WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–æˆåŠŸ")
                else:
                    logger.warning("âš ï¸ WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å¤±æ•—ï¼ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã«å½±éŸ¿ãªã—ï¼‰")
            else:
                logger.info("âš ï¸ WordPress èªè¨¼æƒ…å ±ãŒæœªè¨­å®šã§ã™ï¼ˆã‚¹ã‚­ãƒƒãƒ—ï¼‰")
                self.wordpress_agent = None
        
            # === ãƒ‘ãƒ¼ãƒˆ11: ãã®ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ– ===
            # ï¼ˆcontent_writers, MA ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãªã©ï¼‰
            # ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’ç¶­æŒ ...
        
            # === ãƒ‘ãƒ¼ãƒˆ12: åˆæœŸåŒ–å®Œäº† ===
            logger.info("="*60)
            logger.info("âœ… ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("="*60)
            logger.info(f"âš™ï¸ æœ€å¤§åå¾©å›æ•°: {self.max_iterations}")
            logger.info(f"ğŸ†” ä½¿ç”¨ä¸­ã® PC_ID: {self.pc_id}")
        
            self.initialization_success = True
        
        except Exception as e:
            logger.error("âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            else:
                ErrorHandler.log_error(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            raise

    async def validate_system_health(self) -> bool:
        """ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆè¿½åŠ ï¼‰"""
        try:
            logger.info("ğŸ” ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ä¸­...")
            
            # 1. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šç¢ºèª
            if not self.sheets_manager or not self.sheets_manager.gc:
                logger.error("âŒ Google Sheetsæ¥ç¶šãŒç¢ºç«‹ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # 2. ã‚·ãƒ¼ãƒˆæ§‹é€ æ¤œè¨¼
            if not self.sheets_manager.validate_sheet_structure():
                logger.error("âŒ ã‚·ãƒ¼ãƒˆæ§‹é€ ãŒä¸æ­£ã§ã™")
                return False
            
            # 3. ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã®åŸºæœ¬æ¤œè¨¼
            try:
                tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
                logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆèª­ã¿è¾¼ã¿: {len(tasks)}ä»¶")
                
                # ã‚¿ã‚¹ã‚¯IDã®é‡è¤‡ãƒã‚§ãƒƒã‚¯
                task_ids = [task.get('task_id') for task in tasks if task.get('task_id')]
                unique_ids = set(task_ids)
                if len(task_ids) != len(unique_ids):
                    logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯IDé‡è¤‡æ¤œå‡º: {len(task_ids)} -> {len(unique_ids)}ãƒ¦ãƒ‹ãƒ¼ã‚¯")
                
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆæ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            
            logger.info("âœ… ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯å®Œäº†")
            return True
            
        except Exception as e:
            logger.error(f"âŒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
            return False


    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """
        WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰
    
        ã‚·ãƒ¼ã‚±ãƒ³ã‚¹:
        1. WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
        2. WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆæ–°ã—ã„ã‚¿ãƒ–ã§ï¼‰
        3. ã‚¿ã‚¹ã‚¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ã¸ã®ç™»éŒ²
    
        Args:
            wp_url: WordPress ã‚µã‚¤ãƒˆURL
            wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
            wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        
        Returns:
            WordPressAgent or None
        """
        try:
            # WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("âš ï¸ WordPress ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # èªè¨¼æƒ…å ±ã®è¨­å®š
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("ğŸŒ WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        
            # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
            wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            wordpress_agent.sheets_manager = self.sheets_manager
        
            # ã‚¹ãƒ†ãƒƒãƒ—2: WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆæ–°ã—ã„ã‚¿ãƒ–ã§ï¼‰
            logger.info("ğŸ” WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
        
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0,
                    context="WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # ã‚¹ãƒ†ãƒƒãƒ—3: åˆæœŸåŒ–çµæœã®å‡¦ç†
            if wp_login_success:
                # ã‚¿ã‚¹ã‚¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ã«ç™»éŒ²
                self.task_executor.register_agent('wordpress', wordpress_agent)
                logger.info("âœ… WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            
                # ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file and wp_cookies_file.exists():
                    logger.info(f"ğŸª WordPress ã‚¯ãƒƒã‚­ãƒ¼: {wp_cookies_file}")
                else:
                    logger.info("ğŸª WordPress ã‚¯ãƒƒã‚­ãƒ¼: æ–°è¦ä½œæˆæ¸ˆã¿")
            
                return wordpress_agent
            else:
                logger.error("âŒ WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å¤±æ•—")
                return None
            
        except Exception as e:
            logger.error(f"WordPress ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress åˆæœŸåŒ–")
            return None

    def _print_browser_troubleshooting(self):
        """ãƒ–ãƒ©ã‚¦ã‚¶ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æƒ…å ±ã®è¡¨ç¤º ===
        logger.error("\nğŸ“‹ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°:")
        logger.error("1. âœ… æ—¢å­˜ã®Chromeãƒ—ãƒ­ã‚»ã‚¹ã‚’å…¨ã¦çµ‚äº†")
        logger.error("2. ğŸ“ ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®æ¨©é™ç¢ºèª")
        logger.error(f"     â†’ {config.BROWSER_DATA_DIR}")
        logger.error("3. ğŸ”§ Playwrightã®å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:")
        logger.error("     â†’ playwright install chromium")
        logger.error("4. ğŸ—‘ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ã‚¯ãƒªã‚¢:")
        logger.error(f"     â†’ {config.BROWSER_DATA_DIR} ã‚’å‰Šé™¤")
        logger.error("5. ğŸ”„ ã‚·ã‚¹ãƒ†ãƒ ã®å†èµ·å‹•")

    # === ä¿®æ­£é–‹å§‹: MultiAgentOrchestratorã®WordPressåˆæœŸåŒ–ã‚’å¼·åŒ– ===

    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆã‚¯ãƒƒã‚­ãƒ¼ç®¡ç†å¯¾å¿œç‰ˆï¼‰"""
        try:
            # ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("âš ï¸ WordPressãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return None
        
            from wordpress.wp_agent import WordPressAgent
        
            # èªè¨¼æƒ…å ±ã®è¨­å®š
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
        
            logger.info("ğŸŒ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
            self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            self.wordpress_agent.sheets_manager = self.sheets_manager
        
            # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆï¼‰
            logger.info("ğŸ” WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
        
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãåˆæœŸåŒ–
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0,  # 90ç§’ã«å»¶é•·
                    context="WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=90.0
                )
        
            # åˆæœŸåŒ–çµæœã®å‡¦ç†
            if wp_login_success:
                self.task_executor.register_agent('wordpress', self.wordpress_agent)
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            
                # ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
                wp_cookies_file = self.browser.wp_cookies_file
                if wp_cookies_file.exists():
                    logger.info(f"ğŸ“ WordPressã‚¯ãƒƒã‚­ãƒ¼: {wp_cookies_file}")
                else:
                    logger.info("ğŸ“ WordPressã‚¯ãƒƒã‚­ãƒ¼: æ–°è¦ä½œæˆæ¸ˆã¿")
                
                return self.wordpress_agent
            else:
                logger.error("âŒ WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å¤±æ•—")
                return None
            
        except Exception as e:
            logger.error(f"WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPressåˆæœŸåŒ–")
            return None


    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–"""
        try:
            print("="*60)
            print("ğŸš€ ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ èµ·å‹•ä¸­...")
            print("="*60)
        
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾— ===
            service_account_file = await self._find_service_account_file()
            
            # === ãƒ‘ãƒ¼ãƒˆ2: Google Sheets Managerã®åˆæœŸåŒ– ===
            logger.info("ğŸ“Š Google Sheets æ¥ç¶šã‚’åˆæœŸåŒ–ä¸­...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
            health_ok = await self.validate_system_health()
            if not health_ok:
                logger.warning("âš ï¸ ã‚·ã‚¹ãƒ†ãƒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã§è­¦å‘ŠãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ")
        
            # === ãƒ‘ãƒ¼ãƒˆ3: PCè¨­å®šã®èª­ã¿è¾¼ã¿ ===
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—")
        
            logger.info(f"âš™ï¸ PC_ID={self.pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ä¸­...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: è¨­å®šã®é©ç”¨ ===
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            # === ãƒ‘ãƒ¼ãƒˆ5: å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š ===
            agent_output_setting = settings.get('agent_output_folder', '').strip()
            
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"âš ï¸ B14ãŒURLå½¢å¼ã®ãŸã‚ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‚’ä½¿ç”¨")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"ğŸ“ Agentå‡ºåŠ›å…ˆ(B14ã‹ã‚‰å–å¾—): {self.output_folder}")
            
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
            
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
        
            # === ãƒ‘ãƒ¼ãƒˆ6: ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ï¼ˆãƒªãƒˆãƒ©ã‚¤ä»˜ãï¼‰ ===
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
            
            if not browser_success:
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
            
            # === ãƒ‘ãƒ¼ãƒˆ7: Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ ===
            logger.info("="*60)
            logger.info("ğŸŒ Geminiã‚µã‚¤ãƒˆã¸ã®ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹...")
            logger.info("="*60)
            
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="GeminiãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
        
            # === ãƒ‘ãƒ¼ãƒˆ8: WordPressèªè¨¼æƒ…å ±ã®å–å¾— ===
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
        
            # === ãƒ‘ãƒ¼ãƒˆ9: åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("="*60)
            logger.info("ğŸ¤– AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–é–‹å§‹...")
            logger.info("="*60)
        
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )
    
            self.design_agent = DesignAgent(self.browser, output_folder=self.output_folder)
            self.dev_agent = DevAgent(self.browser, output_folder=self.output_folder)
        
            # ReviewAgentã®åˆæœŸåŒ–
            self.review_agent = ReviewAgent(self.browser, self.sheets_manager)
    
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
        
            logger.info("âœ… åŸºæœ¬ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")

            # === ãƒ‘ãƒ¼ãƒˆ10: WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("ğŸŒ WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            # WordPressèªè¨¼æƒ…å ±ã®å–å¾—
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
            
            # === WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_design) ===
            try:
                from wordpress.wp_design import WordPressDesignAgent
                wp_design_agent = WordPressDesignAgent(
                    self.browser, 
                    output_folder=self.output_folder
                )
                wp_design_agent.sheets_manager = self.sheets_manager
                self.task_executor.register_agent('wp_design', wp_design_agent)
                logger.info("âœ… WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ wordpress/wp_design.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            except Exception as e:
                logger.warning(f"âš ï¸ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
            
            # === WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_dev) ===
            try:
                from wordpress.wp_dev import WordPressDevAgent
                
                # WordPressDevAgent ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
                wp_dev_agent = WordPressDevAgent(
                    self.browser,
                    wp_credentials=wp_credentials,
                    output_folder=self.output_folder
                )
                wp_dev_agent.sheets_manager = self.sheets_manager
                
                # ã‚¿ã‚¹ã‚¯ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ã«ç™»éŒ²
                self.task_executor.register_agent('wp_dev', wp_dev_agent)
                logger.info("âœ… WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ(wp_dev)ç™»éŒ²å®Œäº†")
                
                # æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç™»éŒ²ã‚‚ç¶­æŒ
                if self.dev_agent:
                    # æ—¢å­˜ã® dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ç¶­æŒï¼ˆè¦ä»¶å®šç¾©ç”¨ï¼‰
                    logger.info("âœ… æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚‚ç¶­æŒï¼ˆè¦ä»¶å®šç¾©ã‚¿ã‚¹ã‚¯ç”¨ï¼‰")
                
            except ImportError:
                logger.warning("âš ï¸ wordpress/wp_dev.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.info("ğŸ’¡ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã¯æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
                
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ã¨ã—ã¦ã‚‚ç™»éŒ²
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("ğŸ”„ æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ã¨ã—ã¦ã‚‚ç™»éŒ²ã—ã¾ã—ãŸ")
                    
            except Exception as e:
                logger.warning(f"âš ï¸ WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å¤±æ•—: {e}")
                
                # ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                if self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("ğŸ”„ ã‚¨ãƒ©ãƒ¼ã®ãŸã‚æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ä»£æ›¿")


            # === ãƒ‘ãƒ¼ãƒˆ11: M&Aå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("ğŸ“Š M&Aå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            try:
                from task_executor_ma import MATaskExecutor
                ma_task_executor = MATaskExecutor(self.task_executor.agents)
                self.task_executor.register_agent('ma', ma_task_executor)
                self.task_executor.register_agent('wordpress_ma', ma_task_executor)
                
                # â­ é‡è¦: dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ã¨ã—ã¦ã‚‚ç™»éŒ²ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
                # wp_dev å°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                if 'wp_dev' not in self.task_executor.agents and self.dev_agent:
                    self.task_executor.register_agent('wp_dev', self.dev_agent)
                    logger.info("âœ… dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ wp_dev ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦ç™»éŒ²")
                
                logger.info("âœ… M&Aå°‚ç”¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
            except ImportError:
                logger.warning("âš ï¸ task_executor_ma.py ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            except Exception as e:
                logger.warning(f"âš ï¸ M&Aå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ12: å¤šè¨€èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            logger.info("\n" + "="*60)
            logger.info("å¤šè¨€èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
            
            try:
                from content_writers import (
                    JapaneseWriterAgent,
                    EnglishWriterAgent,
                    RussianWriterAgent,
                    UzbekWriterAgent,
                    ChineseWriterAgent,
                    KoreanWriterAgent,
                    TurkishWriterAgent
                )
                
                # æ—¥æœ¬èªãƒ©ã‚¤ã‚¿ãƒ¼
                ja_writer = JapaneseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ja', ja_writer)
                logger.info("âœ… æ—¥æœ¬èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # è‹±èªãƒ©ã‚¤ã‚¿ãƒ¼
                en_writer = EnglishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_en', en_writer)
                logger.info("âœ… è‹±èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ãƒ­ã‚·ã‚¢èªãƒ©ã‚¤ã‚¿ãƒ¼
                ru_writer = RussianWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ru', ru_writer)
                logger.info("âœ… ãƒ­ã‚·ã‚¢èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ã‚¦ã‚ºãƒ™ã‚¯èªãƒ©ã‚¤ã‚¿ãƒ¼
                uz_writer = UzbekWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_uz', uz_writer)
                logger.info("âœ… ã‚¦ã‚ºãƒ™ã‚¯èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ä¸­å›½èªãƒ©ã‚¤ã‚¿ãƒ¼
                zh_writer = ChineseWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_zh', zh_writer)
                logger.info("âœ… ä¸­å›½èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # éŸ“å›½èªãƒ©ã‚¤ã‚¿ãƒ¼
                ko_writer = KoreanWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_ko', ko_writer)
                logger.info("âœ… éŸ“å›½èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
                # ãƒˆãƒ«ã‚³èªãƒ©ã‚¤ã‚¿ãƒ¼
                tr_writer = TurkishWriterAgent(self.browser, output_folder=self.output_folder)
                self.task_executor.register_agent('writer_tr', tr_writer)
                logger.info("âœ… ãƒˆãƒ«ã‚³èªãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
            
            # === ãƒ‘ãƒ¼ãƒˆ13: WordPressæŠ•ç¨¿ç®¡ç†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ– ===
            if wp_url and wp_user and wp_pass:
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            else:
                logger.info("âš ï¸ WordPressèªè¨¼æƒ…å ±ãŒæœªè¨­å®šã§ã™(ã‚¹ã‚­ãƒƒãƒ—)")
                self.wordpress_agent = None
        
            # === ãƒ‘ãƒ¼ãƒˆ14: åˆæœŸåŒ–å®Œäº†ã®ç¢ºèª ===
            logger.info("="*60)
            logger.info("âœ… ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("="*60)
            logger.info(f"âš™ï¸ æœ€å¤§åå¾©å›æ•°: {self.max_iterations}")
            logger.info(f"ğŸ†” ä½¿ç”¨ä¸­ã®PC_ID: {self.pc_id}")
            
            self.initialization_success = True
        
        except Exception as e:
            logger.error("âŒ ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å¤±æ•—")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            else:
                ErrorHandler.log_error(e, "ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            raise

    async def run_full_workflow(self, goal: str = None, auto_continue: bool = False, enable_review: bool = True):
        """å®Œå…¨ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œ"""
        # === ãƒ‘ãƒ¼ãƒˆ1: åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª ===
        if not self.initialization_success:
            raise Exception("ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ2: PM AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯åˆ†è§£ãƒ•ã‚§ãƒ¼ã‚º ===
            print("\n" + "="*60)
            print("ğŸ“‹ ãƒ•ã‚§ãƒ¼ã‚º1: PM AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯åˆ†è§£")
            print("="*60)
            
            if goal:
                goal_description = goal
                logger.info(f"ğŸ¯ æŒ‡å®šã•ã‚ŒãŸç›®æ¨™: {goal_description}")
            else:
                goal_data = await self.pm_agent.load_project_goal()
                if not goal_data:
                    print("\nâŒ ã‚¨ãƒ©ãƒ¼: ç›®æ¨™ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    print("--goal ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ç›®æ¨™ã‚’æŒ‡å®šã™ã‚‹ã‹ã€")
                    print("ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®'project_goal'ã‚·ãƒ¼ãƒˆã«ç›®æ¨™ã‚’è¨­å®šã—ã¦ãã ã•ã„")
                    return
                goal_description = goal_data['description']
            
            task_plan = await self.pm_agent.analyze_and_create_tasks(goal_description)
            self.pm_agent.display_task_summary(task_plan)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ä¿å­˜ã®ç¢ºèª ===
            if not auto_continue:
                save = input("\nğŸ’¾ ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜ã—ã¾ã™ã‹? (y/n): ")
                if save.lower() != 'y':
                    print("â¸ï¸ å®Ÿè¡Œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ")
                    return
            
            await self.pm_agent.save_tasks_to_sheet(task_plan)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ•ã‚§ãƒ¼ã‚º ===
            print("\n" + "="*60)
            print("âš™ï¸ ãƒ•ã‚§ãƒ¼ã‚º2: ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ")
            print("="*60)
            
            if enable_review:
                print("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: æœ‰åŠ¹")
            else:
                print("â­ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ç„¡åŠ¹")
            
            if not auto_continue:
                execute = input("\nâ–¶ï¸ ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™ã‹? (y/n): ")
                if execute.lower() != 'y':
                    print("â¸ï¸ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
                    return
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®å®Ÿè¡Œ ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === ãƒ‘ãƒ¼ãƒˆ6: å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º ===
            print("\n" + "="*60)
            print("ğŸ‰ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Œäº†")
            print("="*60)
            print(f"ğŸ“ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {self.output_folder}")
            print("ğŸ“Š ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã§çµæœã‚’ç¢ºèªã—ã¦ãã ã•ã„")
            
        except Exception as e:
            logger.error("ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            else:
                ErrorHandler.log_error(e, "ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            raise

    async def run_tasks_only(self, auto_continue: bool = False, enable_review: bool = True):
        """æ—¢å­˜ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’å®Ÿè¡Œ"""
        # === ãƒ‘ãƒ¼ãƒˆ1: åˆæœŸåŒ–çŠ¶æ…‹ã®ç¢ºèª ===
        if not self.initialization_success:
            raise Exception("ã‚·ã‚¹ãƒ†ãƒ ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ2: å®Ÿè¡Œé–‹å§‹ã®è¡¨ç¤º ===
            print("\n" + "="*60)
            print("âš™ï¸ æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œ")
            print("="*60)
            
            if enable_review:
                print("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: æœ‰åŠ¹")
            else:
                print("â­ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ç„¡åŠ¹")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®å®Ÿè¡Œ ===
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            # === ãƒ‘ãƒ¼ãƒˆ4: å®Œäº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤º ===
            print("\n" + "="*60)
            print("ğŸ‰ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            print("="*60)
            
        except Exception as e:
            logger.error("ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            if HAS_ENHANCED_HANDLER and EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            else:
                ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            raise

    async def cleanup(self):
        """ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        logger.info("ğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹...")
        
        cleanup_tasks = []
        
        # ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if self.browser:
            cleanup_tasks.append(self._safe_cleanup_browser())
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if self.wordpress_agent:
            cleanup_tasks.append(self._safe_cleanup_wordpress())
        
        # ãã®ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        if hasattr(self, 'dev_agent') and self.dev_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.dev_agent, "dev_agent"))
        
        if hasattr(self, 'design_agent') and self.design_agent:
            cleanup_tasks.append(self._safe_cleanup_agent(self.design_agent, "design_agent"))
        
        # ä¸¦è¡Œã—ã¦ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
        if cleanup_tasks:
            await asyncio.gather(*cleanup_tasks, return_exceptions=True)
        
        logger.info("âœ… å…¨ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")

    async def _safe_cleanup_browser(self):
        """å®‰å…¨ãªãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if self.browser:
                await self.browser.cleanup()
                logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")

    async def _safe_cleanup_wordpress(self):
        """å®‰å…¨ãªWordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if self.wordpress_agent and hasattr(self.wordpress_agent, 'cleanup'):
                await self.wordpress_agent.cleanup()
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            logger.warning(f"âš ï¸ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")

    async def _safe_cleanup_agent(self, agent, agent_name: str):
        """å®‰å…¨ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            if agent and hasattr(agent, 'cleanup'):
                await agent.cleanup()
                logger.info(f"âœ… {agent_name} ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
        except Exception as e:
            logger.warning(f"âš ï¸ {agent_name} ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å¤±æ•—: {e}")


async def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    # === ãƒ‘ãƒ¼ãƒˆ1: ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ ===
    parser = argparse.ArgumentParser(description='ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ')
    parser.add_argument('--goal', type=str, help='ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç›®æ¨™ã‚’ç›´æ¥æŒ‡å®š')
    parser.add_argument('--tasks-only', action='store_true', help='æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®ã¿å®Ÿè¡Œ(PM AIã‚¹ã‚­ãƒƒãƒ—)')
    parser.add_argument('--auto', action='store_true', help='è‡ªå‹•å®Ÿè¡Œ(ç¢ºèªãªã—)')
    parser.add_argument('--no-review', action='store_true', help='ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–')
    parser.add_argument('--max-iterations', type=int, default=3, help='æœ€å¤§åå¾©å›æ•°(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 3)')
    parser.add_argument('--pc-id', type=int, help='PC_IDã‚’æŒ‡å®š')
    
    args = parser.parse_args()
    
    # === ãƒ‘ãƒ¼ãƒˆ2: ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã®åˆæœŸåŒ– ===
    orchestrator = MultiAgentOrchestrator(
        pc_id=args.pc_id,
        max_iterations=args.max_iterations
    )
    
    try:
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ– ===
        await orchestrator.initialize()
        
        # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®å®Ÿè¡Œ ===
        if args.tasks_only:
            await orchestrator.run_tasks_only(
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        else:
            await orchestrator.run_full_workflow(
                goal=args.goal,
                auto_continue=args.auto,
                enable_review=not args.no_review
            )
        
    except KeyboardInterrupt:
        # === ãƒ‘ãƒ¼ãƒˆ5: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­æ–­ã®å‡¦ç† ===
        logger.warning("\nâ¸ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
    except Exception as e:
        # === ãƒ‘ãƒ¼ãƒˆ6: ã‚¨ãƒ©ãƒ¼å‡¦ç† ===
        logger.error(f"âŒ è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        # === ãƒ‘ãƒ¼ãƒˆ7: ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ— ===
        await orchestrator.cleanup()
        logger.info("\nğŸ‘‹ ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’çµ‚äº†ã—ã¾ã—ãŸ")


if __name__ == "__main__":
    asyncio.run(main())

#sheets_manager.py
# sheets_manager.py
"""Google Sheetsç®¡ç†ã‚¯ãƒ©ã‚¹(æ‹¡å¼µç‰ˆ: Google Driveå¯¾å¿œ)"""
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from google.auth import default
from google.auth.transport.requests import Request
from pathlib import Path
from typing import List, Dict, Optional
import logging
import re

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class GoogleSheetsManager:
    """Google Sheetsç®¡ç†ã‚¯ãƒ©ã‚¹(æ‹¡å¼µç‰ˆ: Google Driveå¯¾å¿œ)"""
    
    # Google API ã‚¹ã‚³ãƒ¼ãƒ—ã®å®šç¾©
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]
    
    def __init__(self, spreadsheet_id: str, service_account_file: Optional[str] = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.gc: Optional[gspread.Client] = None
        self.drive_service = None  # Google Drive APIç”¨
        self.setup_client()
    
    def setup_client(self) -> None:
        """Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®è¨­å®š"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼ã®è©¦è¡Œ ===
            logger.info("ğŸ” Google Sheetsã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®šä¸­...")
            
            if self.service_account_file and Path(self.service_account_file).exists():
                # ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.service_account_file, self.GOOGLE_SHEETS_SCOPE)
                self.gc = gspread.authorize(creds)
                
                # Google Drive APIç”¨ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚‚åˆæœŸåŒ–
                self._setup_drive_service(creds)
                
                logger.info("âœ… ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ Google Sheets ã«æ¥ç¶šã—ã¾ã—ãŸ")
            else:
                # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã¸ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ ===
                logger.info("ğŸ”„ ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãªã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã‚’è©¦è¡Œ...")
                
                try:
                    creds, project = default(scopes=self.GOOGLE_SHEETS_SCOPE)
                    if creds.expired and creds.refresh_token:
                        creds.refresh(Request())
                    self.gc = gspread.authorize(creds)
                    
                    # Google Drive APIç”¨
                    self._setup_drive_service(creds)
                    
                    logger.info("âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã§ Google Sheets ã«æ¥ç¶šã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆèªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                    logger.warning("ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒå¿…è¦ã§ã™")
                    self.gc = None
                    
        except Exception as e:
            ErrorHandler.log_error(e, "Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®š")
            self.gc = None
    
    def _setup_drive_service(self, creds):
        """Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆæœŸåŒ–"""
        try:
            from googleapiclient.discovery import build
            self.drive_service = build('drive', 'v3', credentials=creds)
            logger.info("âœ… Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—: {e}")
            self.drive_service = None
    
    def _ensure_client(self) -> None:
        """ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª"""
        if not self.gc:
            raise Exception("Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚")
    
    async def update_task_status(self, task_id: int, status: str, sheet_name: str = "pm_tasks") -> bool:
        """
        ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ï¼ˆãƒ­ãƒã‚¹ãƒˆæ€§å‘ä¸Šç‰ˆ + è¶…è©³ç´°ãƒ­ã‚°ï¼‰
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            status: æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
            sheet_name: ã‚·ãƒ¼ãƒˆå
            
        Returns:
            bool: æ›´æ–°æˆåŠŸãƒ•ãƒ©ã‚°
        """
        try:
            logger.info("=" * 70)
            logger.info(f"ğŸ”„ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å‡¦ç†é–‹å§‹")
            logger.info(f"   ã‚¿ã‚¹ã‚¯ID: {task_id}")
            logger.info(f"   æ–°ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}")
            logger.info(f"   å¯¾è±¡ã‚·ãƒ¼ãƒˆ: {sheet_name}")
            logger.info("=" * 70)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆã®æº–å‚™ ===
            logger.info("ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—1] Google Sheets ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¢ºèªä¸­...")
            self._ensure_client()
            logger.info("âœ… ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç¢ºèªå®Œäº†")
            
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—2] ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šä¸­ (ID: {self.spreadsheet_id[:20]}...)")
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            logger.info("âœ… ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šæˆåŠŸ")
            
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—3] ã‚·ãƒ¼ãƒˆ '{sheet_name}' ã‚’é–‹ã„ã¦ã„ã¾ã™...")
            task_sheet = sheet.worksheet(sheet_name)
            logger.info("âœ… ã‚·ãƒ¼ãƒˆã‚’é–‹ãã¾ã—ãŸ")
            
            # å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            logger.info("ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—4] ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­...")
            all_data = task_sheet.get_all_values()
            logger.info(f"âœ… ãƒ‡ãƒ¼ã‚¿å–å¾—å®Œäº†: {len(all_data)}è¡Œ")
            
            if len(all_data) <= 1:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆ '{sheet_name}' ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼ã®ã¿ï¼‰")
                return False
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ˜ãƒƒãƒ€ãƒ¼è§£æã¨åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ç‰¹å®š ===
            logger.info("ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—5] ãƒ˜ãƒƒãƒ€ãƒ¼è§£æä¸­...")
            headers = all_data[0]
            logger.info(f"   ãƒ˜ãƒƒãƒ€ãƒ¼å†…å®¹: {headers}")
            
            task_id_col = None
            status_col = None
            
            for i, header in enumerate(headers):
                header_lower = header.lower().strip()
                logger.debug(f"   åˆ—{i+1}: '{header}' (å°æ–‡å­—: '{header_lower}')")
                
                if 'task_id' in header_lower or header_lower == 'id':
                    task_id_col = i
                    logger.info(f"âœ… ã‚¿ã‚¹ã‚¯IDåˆ—ã‚’æ¤œå‡º: åˆ—{i+1} ('{header}')")
                elif 'status' in header_lower:
                    status_col = i
                    logger.info(f"âœ… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ã‚’æ¤œå‡º: åˆ—{i+1} ('{header}')")
            
            # ã‚¿ã‚¹ã‚¯IDåˆ—ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            if task_id_col is None:
                task_id_col = 0
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯IDåˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§åˆ—1ã‚’ä½¿ç”¨ã—ã¾ã™")
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯è¿½åŠ 
            if status_col is None:
                status_col = len(headers)
                logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚æ–°è¦è¿½åŠ ã—ã¾ã™: åˆ—{status_col + 1}")
                try:
                    task_sheet.update_cell(1, status_col + 1, 'status')
                    logger.info(f"âœ… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.error(f"âŒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
                    return False
            
            # === ãƒ‘ãƒ¼ãƒˆ3: å¼·åŒ–ç‰ˆã‚¿ã‚¹ã‚¯æ¤œç´¢ ===
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—6] ã‚¿ã‚¹ã‚¯ID '{task_id}' ã‚’æ¤œç´¢ä¸­...")
            logger.info(f"   æ¤œç´¢å¯¾è±¡åˆ—: åˆ—{task_id_col + 1}")
            logger.info(f"   æ¤œç´¢å¯¾è±¡è¡Œæ•°: {len(all_data) - 1}è¡Œï¼ˆãƒ˜ãƒƒãƒ€ãƒ¼é™¤ãï¼‰")
            
            task_id_str = str(task_id).strip()
            task_found = False
            row_index = None
            
            # è©³ç´°ãªæ¤œç´¢å®Ÿè¡Œ
            available_ids = []
            for row_idx, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    
                    logger.debug(f"   è¡Œ{row_idx}: ID='{cell_value}' (æ¯”è¼ƒå¯¾è±¡: '{task_id_str}')")
                    
                    if cell_value == task_id_str:
                        row_index = row_idx
                        task_found = True
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ã‚’ç™ºè¦‹: è¡Œ{row_idx}")
                        break
            
            if not task_found:
                # è©³ç´°ãªãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ID '{task_id_str}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.error(f"")
                logger.error(f"ğŸ” æ¤œç´¢è©³ç´°:")
                logger.error(f"   æ¤œç´¢ã—ãŸID: '{task_id_str}' (å‹: {type(task_id).__name__})")
                logger.error(f"   æ¤œç´¢ã—ãŸåˆ—: åˆ—{task_id_col + 1}")
                logger.error(f"   ç·ã‚¿ã‚¹ã‚¯æ•°: {len(all_data) - 1}")
                logger.error(f"")
                logger.error(f"ğŸ“‹ ã‚·ãƒ¼ãƒˆå†…ã®åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯ID:")
                for i, aid in enumerate(available_ids[:10], 1):
                    logger.error(f"   {i}. '{aid}'")
                if len(available_ids) > 10:
                    logger.error(f"   ... ä»– {len(available_ids) - 10}ä»¶")
                logger.error(f"")
                logger.error(f"ğŸ’¡ ç¢ºèªäº‹é …:")
                logger.error(f"   1. ã‚¿ã‚¹ã‚¯ID '{task_id}' ãŒ pm_tasks ã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã™ã‚‹ã‹ï¼Ÿ")
                logger.error(f"   2. ã‚¿ã‚¹ã‚¯IDã®åˆ—ãŒæ­£ã—ã„ã‹ï¼Ÿï¼ˆç¾åœ¨: åˆ—{task_id_col + 1}ï¼‰")
                logger.error(f"   3. ã‚¿ã‚¹ã‚¯IDã«ä½™åˆ†ãªç©ºç™½ã‚„ç‰¹æ®Šæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹ï¼Ÿ")
                
                return False
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–° ===
            logger.info(f"ğŸ“‹ [ã‚¹ãƒ†ãƒƒãƒ—7] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å®Ÿè¡Œä¸­...")
            logger.info(f"   å¯¾è±¡ã‚»ãƒ«: è¡Œ{row_index}, åˆ—{status_col + 1}")
            logger.info(f"   æ–°ã—ã„å€¤: '{status}'")
            
            try:
                # Google Sheets API ã§ã‚»ãƒ«ã‚’æ›´æ–°
                task_sheet.update_cell(row_index, status_col + 1, status)
                logger.info(f"âœ… APIå‘¼ã³å‡ºã—æˆåŠŸ")
                
                # æ›´æ–°å¾Œã®æ¤œè¨¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                import time
                time.sleep(0.5)  # APIåæ˜ å¾…ã¡
                
                updated_value = task_sheet.cell(row_index, status_col + 1).value
                logger.info(f"ğŸ” æ›´æ–°å¾Œã®å€¤: '{updated_value}'")
                
                if updated_value == status:
                    logger.info(f"âœ… ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ç¢ºèªå®Œäº†")
                    logger.info("=" * 70)
                    logger.info(f"ğŸ‰ ã‚¿ã‚¹ã‚¯ {task_id} ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ '{status}' ã«æ›´æ–°ã—ã¾ã—ãŸï¼ˆè¡Œ {row_index}ï¼‰")
                    logger.info("=" * 70)
                    return True
                else:
                    logger.warning(f"âš ï¸ æ›´æ–°å€¤ãŒä¸€è‡´ã—ã¾ã›ã‚“: æœŸå¾…='{status}', å®Ÿéš›='{updated_value}'")
                    return False
                    
            except Exception as api_error:
                logger.error(f"âŒ Google Sheets API ã‚¨ãƒ©ãƒ¼: {api_error}")
                logger.error(f"")
                logger.error(f"ğŸ’¡ è€ƒãˆã‚‰ã‚Œã‚‹åŸå› :")
                logger.error(f"   1. ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ¨©é™ä¸è¶³")
                logger.error(f"   2. ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆãŒç·¨é›†ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹")
                logger.error(f"   3. APIã‚¯ã‚©ãƒ¼ã‚¿è¶…é")
                logger.error(f"   4. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã®å•é¡Œ")
                import traceback
                logger.error(traceback.format_exc())
                return False
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
            logger.error(f"")
            logger.error(f"ğŸ”§ ã‚¨ãƒ©ãƒ¼ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:")
            logger.error(f"   ã‚¿ã‚¹ã‚¯ID: {task_id}")
            logger.error(f"   ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}")
            logger.error(f"   ã‚·ãƒ¼ãƒˆ: {sheet_name}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def find_available_task_id(self) -> Optional[str]:
        """åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯IDã‚’æ¤œç´¢ï¼ˆãƒ­ã‚°å‰Šæ¸›ç‰ˆï¼‰"""
        try:
            # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’ä¸€æ™‚çš„ã«ERRORã«
            original_level = logger.level
            logger.setLevel(logging.ERROR)
            
            # ã‚¿ã‚¹ã‚¯IDæ¤œç´¢
            task_ids = await self._search_task_ids()
            
            # ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’æˆ»ã™
            logger.setLevel(original_level)
            
            if task_ids:
                logger.info(f"âœ… åˆ©ç”¨å¯èƒ½ã‚¿ã‚¹ã‚¯: {len(task_ids)}ä»¶")
                return task_ids[0]
            else:
                logger.warning("âš ï¸ åˆ©ç”¨å¯èƒ½ã‚¿ã‚¹ã‚¯ãªã—")
                return None
        
        except Exception as e:
            logger.setLevel(original_level)
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯IDæ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    async def _search_task_ids(self) -> List[str]:
        """å†…éƒ¨æ¤œç´¢ï¼ˆãƒ­ã‚°ãªã—ï¼‰"""
        try:
            # æ—¢å­˜ã®æ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯
            all_values = self.ws.get_all_values()
            
            # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            valid_ids = []
            for row in all_values[1:]:  # ãƒ˜ãƒƒãƒ€ãƒ¼é™¤å¤–
                if len(row) >= 11:
                    task_id = row[0]
                    status = row[10]
                    
                    if task_id and task_id not in ['ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²', 'Review suggested']:
                        if status in ['pending', 'in_progress', '']:
                            valid_ids.append(task_id)
            
            return valid_ids
        
        except Exception as e:
            return []

    async def load_tasks_from_sheet(self, sheet_name: str = "pm_tasks") -> List[Dict]:
        """æŒ‡å®šã•ã‚ŒãŸã‚·ãƒ¼ãƒˆã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã‚¨ãƒ©ãƒ¼ä¿®æ­£ç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæ¥ç¶šã¨åŸºæœ¬è¨­å®š ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            try:
                task_sheet = sheet.worksheet(sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.error(f"âŒ ã‚·ãƒ¼ãƒˆ '{sheet_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return []
        
            # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ‡ãƒ¼ã‚¿å–å¾—æ–¹æ³•ã®è©¦è¡Œï¼ˆè¤‡æ•°æ–¹å¼ï¼‰ ===
            logger.info(f"ğŸ“¥ ã‚·ãƒ¼ãƒˆ '{sheet_name}' ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­...")
            
            try:
                # æ–¹æ³•1: get_all_records() ã‚’è©¦ã™
                records = task_sheet.get_all_records()
                logger.info(f"âœ… get_all_records() ã§ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: {len(records)}è¡Œ")
            except Exception as e:
                logger.warning(f"âš ï¸ get_all_records() å¤±æ•—: {e}")
                logger.info("ğŸ”§ ä»£æ›¿æ–¹æ³•ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™...")
                
                # æ–¹æ³•2: ç”Ÿãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦æ‰‹å‹•ã§å‡¦ç†
                all_values = task_sheet.get_all_values()
                
                if len(all_values) <= 1:
                    logger.info("ğŸ“­ ãƒ‡ãƒ¼ã‚¿è¡ŒãŒã‚ã‚Šã¾ã›ã‚“")
                    return []
                
                # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’å–å¾—
                headers = all_values[0]
                logger.info(f"ğŸ“‹ ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
                
                # ãƒ‡ãƒ¼ã‚¿è¡Œã‚’å‡¦ç†
                records = []
                for i, row in enumerate(all_values[1:], start=2):
                    if not any(row):  # ç©ºè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
                        continue
                    
                    record = {}
                    for j, header in enumerate(headers):
                        if j < len(row) and header:  # ãƒ˜ãƒƒãƒ€ãƒ¼ãŒç©ºã§ãªã„å ´åˆã®ã¿
                            record[header] = row[j]
                        elif j < len(row):
                            record[f'column_{j+1}'] = row[j]  # ç©ºãƒ˜ãƒƒãƒ€ãƒ¼ã®å ´åˆ
                    
                    records.append(record)
                
                logger.info(f"âœ… ä»£æ›¿æ–¹æ³•ã§ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ: {len(records)}è¡Œ")
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ¬ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã‚¿ã‚¹ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ› ===
            tasks = []
            for i, record in enumerate(records, start=2):
                # ã‚¿ã‚¹ã‚¯IDã®å‡¦ç†ã‚’æ”¹å–„
                task_id = str(record.get('task_id', '')).strip()
                if not task_id and 'task_id' not in record:
                    # æœ€åˆã®åˆ—ã‚’ã‚¿ã‚¹ã‚¯IDã¨ã—ã¦ä½¿ç”¨
                    first_col = list(record.values())[0] if record else ''
                    task_id = str(first_col).strip()
                
                task = {
                    'task_id': task_id,
                    'description': record.get('task_description', record.get('description', '')),
                    'required_role': record.get('required_role', ''),
                    'status': record.get('status', ''),
                    'priority': record.get('priority', 'medium'),
                    'estimated_time': record.get('estimated_time', ''),
                    'dependencies': record.get('dependencies', ''),
                    'created_at': record.get('created_at', ''),
                    'batch_id': record.get('batch_id', ''),
                    'review_target_task_id': record.get('review_target_task_id', ''),
                    'post_action': record.get('post_action', ''),
                    'language': record.get('language', ''),
                    'polylang_lang': record.get('polylang_lang', '')
                }
                
                # åŸºæœ¬çš„ãªæ¤œè¨¼
                if task['description'] and task['required_role']:
                    tasks.append(task)
        
            logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿: {len(tasks)}ä»¶ï¼ˆã‚·ãƒ¼ãƒˆ: {sheet_name}ï¼‰")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¨çµæœè¿”å´ ===
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            if tasks:
                logger.info(f"ğŸ“ æœ€åˆã®ã‚¿ã‚¹ã‚¯: {tasks[0].get('description', '')[:50]}...")
            else:
                logger.info("ğŸ“­ èª­ã¿è¾¼ã¾ã‚ŒãŸã‚¿ã‚¹ã‚¯ã¯0ä»¶ã§ã™")
                
            return tasks
        
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ï¼ˆã‚·ãƒ¼ãƒˆ: {sheet_name}ï¼‰: {e}")
            return []

    async def save_task_output(self, output_data: Dict):
        """ã‚¿ã‚¹ã‚¯ã®å‡ºåŠ›ã‚’ä¿å­˜"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆã®æº–å‚™ ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å‡ºåŠ›ã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèªã¨ä½œæˆ ===
            # å‡ºåŠ›ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            try:
                output_sheet = sheet.worksheet("task_outputs")
            except gspread.exceptions.WorksheetNotFound:
                # ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
                logger.info("'task_outputs' ã‚·ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™")
                output_sheet = sheet.add_worksheet(title="task_outputs", rows=1000, cols=10)
                # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
                headers = ["task_id", "summary", "full_text", "screenshot", "timestamp"]
                output_sheet.append_row(headers)
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ ===
            # ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            row = [
                output_data.get('task_id', ''),
                output_data.get('summary', ''),
                output_data.get('full_text', ''),
                output_data.get('screenshot', ''),
                output_data.get('timestamp', '')
            ]
            output_sheet.append_row(row)
        
            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ä¿å­˜: {output_data.get('task_id', '')}")
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯å‡ºåŠ›ä¿å­˜")
            return False
    
    def save_result_to_sheet(self, results: List[Dict], mode: str = "text") -> None:
        """
        çµæœã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«ä¿å­˜
        
        Args:
            results: çµæœã®ãƒªã‚¹ãƒˆ
            mode: "text" ã¾ãŸã¯ "image"
        """
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆåã®æº–å‚™ ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            # çµæœã‚·ãƒ¼ãƒˆåã‚’æ±ºå®š
            result_sheet_name = f"result_{mode}"
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèªã¨ä½œæˆ ===
            # ã‚·ãƒ¼ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
            try:
                result_sheet = sheet.worksheet(result_sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.info(f"ã‚·ãƒ¼ãƒˆ '{result_sheet_name}' ã‚’ä½œæˆã—ã¾ã™")
                result_sheet = sheet.add_worksheet(title=result_sheet_name, rows=1000, cols=10)
                
                # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
                headers = ['Index', 'Prompt', 'Status', 'Filename', 'Timestamp', 'Error', 'Mode']
                result_sheet.append_row(headers)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: çµæœãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜ ===
            # çµæœã‚’è¿½åŠ 
            for result in results:
                row = [
                    result.get('index', ''),
                    result.get('prompt', '')[:100],  # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¯æœ€åˆã®100æ–‡å­—
                    result.get('status', ''),
                    result.get('filename', ''),
                    result.get('timestamp', ''),
                    result.get('error', ''),
                    result.get('mode', mode)
                ]
                result_sheet.append_row(row)
            
            logger.info(f"âœ… {len(results)}ä»¶ã®çµæœã‚’ '{result_sheet_name}' ã«ä¿å­˜ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "çµæœä¿å­˜")
            logger.warning("çµæœã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸãŒã€å‡¦ç†ã‚’ç¶šè¡Œã—ã¾ã™")
    
    def extract_file_id_from_url(self, url: str) -> Optional[str]:
        """
        Google Driveã®URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡º
        
        å¯¾å¿œå½¢å¼:
        - https://drive.google.com/file/d/FILE_ID/view
        - https://drive.google.com/open?id=FILE_ID
        - https://docs.google.com/document/d/FILE_ID/edit
        """
        # === ãƒ‘ãƒ¼ãƒˆ1: æ­£è¦è¡¨ç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®šç¾© ===
        patterns = [
            r'/file/d/([a-zA-Z0-9_-]+)',
            r'id=([a-zA-Z0-9_-]+)',
            r'/d/([a-zA-Z0-9_-]+)',
        ]
        
        # === ãƒ‘ãƒ¼ãƒˆ2: ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã®å®Ÿè¡Œ ===
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                file_id = match.group(1)
                logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡º: {file_id}")
                return file_id
        
        logger.warning(f"âš ï¸ URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ: {url}")
        return None
    
    def read_file_from_drive(self, file_id_or_url: str) -> Optional[str]:
        """
        Google Driveã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦èª­ã¿è¾¼ã‚€ï¼ˆè¶…è©³ç´°ãƒ­ã‚°ç‰ˆï¼‰
        
        Args:
            file_id_or_url: ãƒ•ã‚¡ã‚¤ãƒ«ID ã¾ãŸã¯ Google Driveã®URL
            
        Returns:
            ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ï¼ˆãƒ†ã‚­ã‚¹ãƒˆï¼‰ã€å¤±æ•—æ™‚ã¯None
        """
        try:
            logger.info("="*60)
            logger.info("ã€Google Driveèª­ã¿è¾¼ã¿é–‹å§‹ã€‘")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: Drive APIã‚µãƒ¼ãƒ“ã‚¹ã®ç¢ºèª ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘1ã€‘Drive APIã‚µãƒ¼ãƒ“ã‚¹ã‚’ç¢ºèª")
            if not self.drive_service:
                logger.error("âŒ Google Drive APIã‚µãƒ¼ãƒ“ã‚¹ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                logger.error("  â†’ ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆèªè¨¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                return None
            logger.info("âœ… Drive APIã‚µãƒ¼ãƒ“ã‚¹: æ­£å¸¸")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å…¥åŠ›å€¤ã®è§£æã¨ãƒ•ã‚¡ã‚¤ãƒ«IDã®æŠ½å‡º ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘2ã€‘å…¥åŠ›å€¤ã‚’è§£æ")
            logger.info(f"  å…¥åŠ›: {file_id_or_url[:100]}")
            
            if file_id_or_url.startswith('http'):
                logger.info("  â†’ URLå½¢å¼ã¨åˆ¤å®š")
                file_id = self.extract_file_id_from_url(file_id_or_url)
                if not file_id:
                    logger.error("âŒ URLã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«IDã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
                    return None
                logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«IDæŠ½å‡ºæˆåŠŸ: {file_id}")
            else:
                file_id = file_id_or_url
                logger.info(f"  â†’ ãƒ•ã‚¡ã‚¤ãƒ«IDå½¢å¼: {file_id}")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾— ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘3ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            try:
                from googleapiclient.http import MediaIoBaseDownload
                import io
                
                file_metadata = self.drive_service.files().get(
                    fileId=file_id, 
                    fields='name,mimeType,size,permissions'
                ).execute()
                
                file_name = file_metadata.get('name', 'Unknown')
                mime_type = file_metadata.get('mimeType', '')
                file_size = file_metadata.get('size', '0')
                
                logger.info("âœ… ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—æˆåŠŸ")
                logger.info(f"  ãƒ•ã‚¡ã‚¤ãƒ«å: {file_name}")
                logger.info(f"  MIME Type: {mime_type}")
                logger.info(f"  ã‚µã‚¤ã‚º: {file_size} bytes")
                
            except Exception as e:
                logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
                logger.error("  è€ƒãˆã‚‰ã‚Œã‚‹åŸå› :")
                logger.error("  - ãƒ•ã‚¡ã‚¤ãƒ«IDãŒé–“é•ã£ã¦ã„ã‚‹")
                logger.error("  - ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æ¨©é™ãŒãªã„")
                logger.error("  - ãƒ•ã‚¡ã‚¤ãƒ«ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘4ã€‘ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰")
            try:
                request = self.drive_service.files().get_media(fileId=file_id)
                
                fh = io.BytesIO()
                downloader = MediaIoBaseDownload(fh, request)
                
                done = False
                chunk_count = 0
                while not done:
                    status, done = downloader.next_chunk()
                    chunk_count += 1
                    if status:
                        progress = int(status.progress() * 100)
                        logger.debug(f"  â³ ãƒãƒ£ãƒ³ã‚¯{chunk_count}: {progress}%")
                
                logger.info(f"âœ… ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†: {chunk_count}ãƒãƒ£ãƒ³ã‚¯")
                
            except Exception as e:
                logger.error(f"âŒ ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: {e}")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã¸ã®å¤‰æ› ===
            logger.info("ã€åˆ‡ã‚Šåˆ†ã‘5ã€‘ãƒã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›")
            try:
                content = fh.getvalue().decode('utf-8')
                logger.info(f"âœ… å¤‰æ›æˆåŠŸ: {len(content)}æ–‡å­—")
                logger.info(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
                
                # å†…å®¹ã®æ¤œè¨¼
                if len(content) < 10:
                    logger.warning(f"âš ï¸ å†…å®¹ãŒçŸ­ã™ãã¾ã™: {len(content)}æ–‡å­—")
                
                return content
                
            except UnicodeDecodeError as e:
                logger.error(f"âŒ UTF-8ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: {e}")
                logger.error("  â†’ ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§ã¯ãªã„å¯èƒ½æ€§")
                return None
            except Exception as e:
                logger.error(f"âŒ å¤‰æ›ã‚¨ãƒ©ãƒ¼: {e}")
                return None
            
        except Exception as e:
            logger.error(f"âŒ Google Driveãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def get_current_pc_id(self) -> int:
        """ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®B12ã‚»ãƒ«ã‹ã‚‰PC_IDã‚’èª­ã¿å–ã‚‹"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæ¥ç¶šã¨ã‚»ãƒ«èª­ã¿å–ã‚Š ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
            
            pc_id_value = setting_sheet.cell(12, 2).value
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å€¤ã®æ¤œè¨¼ã¨å¤‰æ› ===
            if pc_id_value:
                try:
                    pc_id = int(pc_id_value)
                    logger.info(f"âœ… ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰PC_ID={pc_id}ã‚’èª­ã¿å–ã‚Šã¾ã—ãŸ(ã‚»ãƒ«B12)")
                    return pc_id
                except ValueError:
                    logger.warning(f"âš ï¸ B12ã‚»ãƒ«ã®å€¤ '{pc_id_value}' ã‚’æ•´æ•°ã«å¤‰æ›ã§ãã¾ã›ã‚“ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤1ã‚’ä½¿ç”¨ã—ã¾ã™")
                    return 1
            else:
                logger.warning("âš ï¸ B12ã‚»ãƒ«ãŒç©ºã§ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤1ã‚’ä½¿ç”¨ã—ã¾ã™")
                return 1
                
        except Exception as e:
            ErrorHandler.log_error(e, "PC_IDèª­ã¿å–ã‚Š")
            logger.warning("âš ï¸ PC_IDã®èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤1ã‚’ä½¿ç”¨ã—ã¾ã™")
            return 1
    
    def load_pc_settings(self, pc_id: int = 1) -> Dict[str, str]:
        """PCå›ºæœ‰ã®è¨­å®šã‚’settingã‚·ãƒ¼ãƒˆã‹ã‚‰èª­ã¿è¾¼ã¿"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆæ¥ç¶šã¨åŸºæœ¬è¨­å®š ===
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
        
            col_index = 1 + pc_id
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å„è¨­å®šå€¤ã®èª­ã¿è¾¼ã¿ ===
            settings = {
                'google_id': self._get_cell_value(setting_sheet, 2, col_index),
                'google_pass': self._get_cell_value(setting_sheet, 3, col_index),
                'service_mail': self._get_cell_value(setting_sheet, 4, col_index),
                'download_image_folder': self._get_cell_value(setting_sheet, 5, col_index),
                'download_text_folder': self._get_cell_value(setting_sheet, 6, col_index),
                'browser_data_dir': self._get_cell_value(setting_sheet, 7, col_index),
                'service_account_file': self._get_cell_value(setting_sheet, 8, col_index),
                'cookies_file': self._get_cell_value(setting_sheet, 9, col_index),
                'generation_mode': self._get_cell_value(setting_sheet, 10, col_index),
                'text_format': self._get_cell_value(setting_sheet, 11, col_index),
                'service_type': self._get_cell_value(setting_sheet, 13, col_index),
                'agent_output_folder': self._get_cell_value(setting_sheet, 14, col_index),
                'max_iterations': self._get_cell_value(setting_sheet, 15, col_index),
                'wp_url': self._get_cell_value(setting_sheet, 16, col_index),
                'wp_user': self._get_cell_value(setting_sheet, 17, col_index),
                'wp_pass': self._get_cell_value(setting_sheet, 18, col_index),
            }
        
            # === ãƒ‘ãƒ¼ãƒˆ3: è¨­å®šå€¤ã®æ¤œè¨¼ã¨æ­£è¦åŒ– ===
            # generation_modeã®æ¤œè¨¼
            mode = settings.get('generation_mode', '').strip().lower()
            if mode not in ['text', 'image']:
                logger.warning(f"âš ï¸ ä¸æ­£ãªgeneration_modeå€¤: '{mode}' â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 'image' ã‚’ä½¿ç”¨")
                settings['generation_mode'] = 'image'
            else:
                settings['generation_mode'] = mode
        
            # max_iterationsã®æ¤œè¨¼
            try:
                max_iter = int(settings.get('max_iterations', '3'))
                if max_iter < 1 or max_iter > 10:
                    logger.warning(f"âš ï¸ ä¸æ­£ãªmax_iterationså€¤: {max_iter} â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 3 ã‚’ä½¿ç”¨")
                    settings['max_iterations'] = 3
                else:
                    settings['max_iterations'] = max_iter
            except (ValueError, TypeError):
                logger.warning(f"âš ï¸ max_iterationsã®å¤‰æ›ã‚¨ãƒ©ãƒ¼ â†’ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 3 ã‚’ä½¿ç”¨")
                settings['max_iterations'] = 3
        
            logger.info(f"âœ… PC_ID={pc_id} ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
            return settings
        
        except Exception as e:
            ErrorHandler.log_error(e, f"PC_ID={pc_id} ã®è¨­å®šèª­ã¿è¾¼ã¿")
            raise

    def _get_cell_value(self, sheet, row: int, col: int) -> str:
        """ã‚»ãƒ«ã®å€¤ã‚’å®‰å…¨ã«å–å¾—"""
        try:
            value = sheet.cell(row, col).value
            return value if value is not None else ""
        except Exception:
            return ""
    
    def _get_column_letter(self, col_index: int) -> str:
        """åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’åˆ—æ–‡å­—ã«å¤‰æ›(1â†’A, 2â†’B, ...)"""
        result = ""
        while col_index > 0:
            col_index -= 1
            result = chr(col_index % 26 + ord('A')) + result
            col_index //= 26
        return result
    
    def load_credentials_from_sheet(self, pc_id: int = 1) -> Dict[str, str]:
        """èªè¨¼æƒ…å ±ã‚’èª­ã¿è¾¼ã¿(PC_IDå¯¾å¿œç‰ˆ)"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: è¨­å®šèª­ã¿è¾¼ã¿ ===
            settings = self.load_pc_settings(pc_id)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: èªè¨¼æƒ…å ±ã®æŠ½å‡º ===
            credentials = {
                'email': settings['google_id'],
                'password': settings['google_pass'],
                'service_mail': settings.get('service_mail')
            }
            
            return credentials
            
        except Exception as e:
            ErrorHandler.log_error(e, "èªè¨¼æƒ…å ±èª­ã¿è¾¼ã¿")
            raise
    
    # sheets_manager.py ã«ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ 

    async def verify_task_exists(self, task_id: int, sheet_name: str = "pm_tasks") -> bool:
        """ã‚¿ã‚¹ã‚¯ãŒã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã™ã‚‹ã‹æ¤œè¨¼ï¼ˆè¿½åŠ ï¼‰"""
        try:
            self._ensure_client()
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            task_sheet = sheet.worksheet(sheet_name)
        
            # å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            all_data = task_sheet.get_all_values()
        
            if len(all_data) <= 1:
                logger.warning(f"ã‚¿ã‚¹ã‚¯ã‚·ãƒ¼ãƒˆã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ˜ãƒƒãƒ€ãƒ¼è§£æ
            headers = all_data[0]
            task_id_col = None
        
            for i, header in enumerate(headers):
                header_lower = header.lower()
                if 'task_id' in header_lower or 'id' in header_lower:
                    task_id_col = i
                    break
        
            if task_id_col is None:
                task_id_col = 0
        
            # ã‚¿ã‚¹ã‚¯IDæ¤œç´¢ï¼ˆå‹ã®ä¸ä¸€è‡´ã‚’è€ƒæ…®ï¼‰
            task_id_str = str(task_id)
            for row in all_data[1:]:
                if len(row) > task_id_col:
                    cell_value = str(row[task_id_col]).strip()
                    if cell_value == task_id_str:
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} ã®å­˜åœ¨ã‚’ç¢ºèª")
                        return True
        
            logger.warning(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã¯ã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã—ã¾ã›ã‚“")
            return False
        
        except Exception as e:
            logger.error(f"ã‚¿ã‚¹ã‚¯å­˜åœ¨ç¢ºèªã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def _enhanced_task_search(self, task_sheet, task_id: int, task_id_col: int) -> tuple:
        """å¼·åŒ–ç‰ˆã‚¿ã‚¹ã‚¯æ¤œç´¢ï¼ˆä¿®æ­£ï¼‰"""
        try:
            all_data = task_sheet.get_all_values()
            task_id_str = str(task_id)
        
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã®åé›†
            available_ids = []
            for i, row in enumerate(all_data[1:], start=2):
                if len(row) > task_id_col and row[task_id_col]:
                    cell_value = str(row[task_id_col]).strip()
                    available_ids.append(cell_value)
                    if cell_value == task_id_str:
                        return (i, True)  # (è¡Œç•ªå·, è¦‹ã¤ã‹ã£ãŸã‹)
        
            logger.warning(f"ğŸ” æ¤œç´¢å¯¾è±¡ID: '{task_id_str}'")
            logger.warning(f"ğŸ” åˆ©ç”¨å¯èƒ½ãªã‚¿ã‚¹ã‚¯ID: {available_ids}")
            return (None, False)
        
        except Exception as e:
            logger.error(f"ã‚¿ã‚¹ã‚¯æ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
            return (None, False)
    
    def validate_sheet_structure(self) -> bool:
        """ã‚·ãƒ¼ãƒˆæ§‹é€ ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã‚·ãƒ¼ãƒˆä¸€è¦§ã®å–å¾— ===
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            required_sheets = ["setting"]
            existing_sheets = [ws.title for ws in sheet.worksheets()]
            
            # === ãƒ‘ãƒ¼ãƒˆ2: å¿…é ˆã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèª ===
            for required_sheet in required_sheets:
                if required_sheet not in existing_sheets:
                    logger.error(f"âŒ å¿…è¦ãªã‚·ãƒ¼ãƒˆ '{required_sheet}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return False
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚·ãƒ¼ãƒˆã®å­˜åœ¨ç¢ºèª ===
            if "prompt_text" not in existing_sheets and "prompt" not in existing_sheets:
                logger.error("âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚·ãƒ¼ãƒˆ ('prompt_text' ã¾ãŸã¯ 'prompt') ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            logger.info("âœ… ã‚·ãƒ¼ãƒˆæ§‹é€ ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯å®Œäº†")
            return True
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚·ãƒ¼ãƒˆæ§‹é€ ãƒã‚§ãƒƒã‚¯")
            return False

#system_cli_executor.py
"""
system_cli_executor.py - ã‚·ã‚¹ãƒ†ãƒ CLIã‚¿ã‚¹ã‚¯å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
WP-CLIã€ACFã€ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãªã©ã®ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¹ã‚¯ã‚’æ‹…å½“
"""

import asyncio
import subprocess
import logging
from typing import Dict, List, Optional, Any
from pathlib import Path
from datetime import datetime

# è¨­å®š
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

# ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
try:
    from agents.command_monitor_agent import CommandMonitorAgent
    HAS_COMMAND_MONITOR = True
except ImportError:
    HAS_COMMAND_MONITOR = False
    CommandMonitorAgent = None

logger = logging.getLogger(__name__)


class SystemCLIExecutor:
    """
    ã‚·ã‚¹ãƒ†ãƒ CLIã‚¿ã‚¹ã‚¯ã®å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    WP-CLIã€ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆã€ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã€
    ã‚¤ãƒ³ãƒ•ãƒ©ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚’çµ±åˆç®¡ç†
    """
    
    def __init__(self, sheets_manager: GoogleSheetsManager):
        """
        åˆæœŸåŒ–
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        """
        self.sheets_manager = sheets_manager
        
        # ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
        if HAS_COMMAND_MONITOR and CommandMonitorAgent:
            try:
                self.command_monitor = CommandMonitorAgent()
                logger.info("âœ… CommandMonitorAgent åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ CommandMonitorAgent åˆæœŸåŒ–å¤±æ•—: {e}")
                self.command_monitor = None
        else:
            logger.info("â„¹ï¸ CommandMonitorAgent ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.command_monitor = None
        
        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
        self.default_timeout = 60.0
        self.long_timeout = 300.0
        
        # WP-CLIè¨­å®š
        self.wp_cli_path = self._detect_wp_cli_path()
        
        logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
    
    def _detect_wp_cli_path(self) -> str:
        """WP-CLIãƒ‘ã‚¹ã‚’æ¤œå‡º"""
        candidates = [
            'wp',  # PATHå†…
            '/usr/local/bin/wp',
            '/usr/bin/wp',
            './wp-cli.phar'
        ]
        
        for candidate in candidates:
            try:
                result = subprocess.run(
                    [candidate, '--version'],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    logger.info(f"âœ… WP-CLIæ¤œå‡º: {candidate}")
                    return candidate
            except:
                continue
        
        logger.warning("âš ï¸ WP-CLIæœªæ¤œå‡º - 'wp'ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½¿ç”¨")
        return 'wp'
    
    async def execute_cli_task(self, task: Dict) -> Dict:
        """
        CLIã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("=" * 60)
            logger.info(f"âš™ï¸ CLIã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info("=" * 60)
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®š
            cli_type = self._determine_cli_type(task)
            logger.info(f"CLIã‚¿ã‚¤ãƒ—: {cli_type}")
            
            # ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ
            if cli_type == 'wp-cli':
                result = await self._execute_wp_cli_task(task)
            elif cli_type == 'acf':
                result = await self._execute_acf_task(task)
            elif cli_type == 'file':
                result = await self._execute_file_operation_task(task)
            elif cli_type == 'generic':
                result = await self._execute_generic_command_task(task)
            else:
                logger.warning(f"âš ï¸ æœªçŸ¥ã®CLIã‚¿ã‚¤ãƒ—: {cli_type}")
                result = await self._execute_generic_command_task(task)
            
            if result.get('success'):
                logger.info(f"âœ… CLIã‚¿ã‚¹ã‚¯ {task_id} å®Œäº†")
            else:
                logger.error(f"âŒ CLIã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•—")
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ CLIã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"SystemCLIExecutor.execute_cli_task({task_id})")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_cli_type(self, task: Dict) -> str:
        """
        CLIã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ— ('wp-cli', 'acf', 'file', 'generic')
        """
        description = task.get('description', '').lower()
        command = task.get('command', '').lower()
        
        # WP-CLIã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        if any(kw in description or kw in command for kw in ['wp ', 'wp-cli', 'wordpress cli']):
            return 'wp-cli'
        
        # ACFã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        if any(kw in description or kw in command for kw in ['acf', 'advanced custom fields', 'acf-json']):
            return 'acf'
        
        # ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        if any(kw in description for kw in ['ãƒ•ã‚¡ã‚¤ãƒ«', 'ã‚³ãƒ”ãƒ¼', 'ç§»å‹•', 'å‰Šé™¤', 'mkdir', 'cp', 'mv', 'rm']):
            return 'file'
        
        return 'generic'
    
    async def _execute_wp_cli_task(self, task: Dict) -> Dict:
        """
        WP-CLIã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸŒ WP-CLIã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ")
            
            # ã‚³ãƒãƒ³ãƒ‰æ§‹ç¯‰
            command = task.get('command', '')
            if not command:
                # ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰æŠ½å‡ºã‚’è©¦è¡Œ
                description = task.get('description', '')
                if 'wp ' in description:
                    command = description[description.find('wp '):]
                else:
                    return {
                        'success': False,
                        'error': 'WP-CLIã‚³ãƒãƒ³ãƒ‰ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    }
            
            # WP-CLIãƒ‘ã‚¹ä»˜åŠ 
            if not command.startswith(self.wp_cli_path):
                command = f"{self.wp_cli_path} {command}"
            
            # ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            wp_path = task.get('wp_path', config.WP_PATH if hasattr(config, 'WP_PATH') else None)
            
            # ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä½¿ç”¨
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            else:
                # ç›´æ¥å®Ÿè¡Œï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                result = await self._direct_command_execution(
                    command,
                    cwd=wp_path,
                    timeout=self.default_timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ WP-CLIå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_acf_task(self, task: Dict) -> Dict:
        """
        ACFé–¢é€£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“¦ ACFã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            # ACFæ“ä½œã‚¿ã‚¤ãƒ—åˆ¤å®š
            description = task.get('description', '').lower()
            
            if 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ' in description or 'import' in description:
                # ACFã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                acf_file = task.get('acf_file', task.get('file_path', ''))
                
                if not acf_file:
                    return {
                        'success': False,
                        'error': 'ACFãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    }
                
                if self.command_monitor and hasattr(self.command_monitor, 'monitor_acf_import_process'):
                    result = await self.command_monitor.monitor_acf_import_process(acf_file)
                else:
                    # WP-CLIçµŒç”±ã§ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                    command = f"{self.wp_cli_path} acf import {acf_file}"
                    result = await self._direct_command_execution(
                        command,
                        timeout=self.long_timeout
                    )
                
                return result
            
            elif 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ' in description or 'export' in description:
                # ACFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
                output_path = task.get('output_path', './acf-export.json')
                command = f"{self.wp_cli_path} acf export --path={output_path}"
                
                result = await self._direct_command_execution(
                    command,
                    timeout=self.default_timeout
                )
                
                return result
            
            else:
                return {
                    'success': False,
                    'error': 'ACFæ“ä½œã‚¿ã‚¤ãƒ—ãŒä¸æ˜ã§ã™'
                }
        
        except Exception as e:
            logger.error(f"âŒ ACFã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_file_operation_task(self, task: Dict) -> Dict:
        """
        ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            
            description = task.get('description', '').lower()
            
            # æ“ä½œã‚¿ã‚¤ãƒ—åˆ¤å®š
            if 'ã‚³ãƒ”ãƒ¼' in description or 'copy' in description:
                return await self._file_copy(task)
            elif 'ç§»å‹•' in description or 'move' in description:
                return await self._file_move(task)
            elif 'å‰Šé™¤' in description or 'delete' in description:
                return await self._file_delete(task)
            elif 'ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ' in description or 'mkdir' in description:
                return await self._directory_create(task)
            else:
                return {
                    'success': False,
                    'error': 'ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¿ã‚¤ãƒ—ãŒä¸æ˜ã§ã™'
                }
        
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _file_copy(self, task: Dict) -> Dict:
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': 'ã‚³ãƒ”ãƒ¼å…ƒã¾ãŸã¯ã‚³ãƒ”ãƒ¼å…ˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            shutil.copy2(source, dest)
            logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«ã‚³ãƒ”ãƒ¼æˆåŠŸ: {source} -> {dest}")
            return {'success': True, 'message': f'ã‚³ãƒ”ãƒ¼å®Œäº†: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'ã‚³ãƒ”ãƒ¼å¤±æ•—: {e}'}
    
    async def _file_move(self, task: Dict) -> Dict:
        """ãƒ•ã‚¡ã‚¤ãƒ«ç§»å‹•"""
        import shutil
        
        source = task.get('source', task.get('source_path', ''))
        dest = task.get('destination', task.get('dest_path', ''))
        
        if not source or not dest:
            return {'success': False, 'error': 'ç§»å‹•å…ƒã¾ãŸã¯ç§»å‹•å…ˆãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            shutil.move(source, dest)
            logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«ç§»å‹•æˆåŠŸ: {source} -> {dest}")
            return {'success': True, 'message': f'ç§»å‹•å®Œäº†: {source} -> {dest}'}
        except Exception as e:
            return {'success': False, 'error': f'ç§»å‹•å¤±æ•—: {e}'}
    
    async def _file_delete(self, task: Dict) -> Dict:
        """ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤"""
        target = task.get('target', task.get('file_path', ''))
        
        if not target:
            return {'success': False, 'error': 'å‰Šé™¤å¯¾è±¡ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            path = Path(target)
            if path.is_file():
                path.unlink()
            elif path.is_dir():
                import shutil
                shutil.rmtree(path)
            else:
                return {'success': False, 'error': f'ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {target}'}
            
            logger.info(f"âœ… å‰Šé™¤æˆåŠŸ: {target}")
            return {'success': True, 'message': f'å‰Šé™¤å®Œäº†: {target}'}
        except Exception as e:
            return {'success': False, 'error': f'å‰Šé™¤å¤±æ•—: {e}'}
    
    async def _directory_create(self, task: Dict) -> Dict:
        """ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ"""
        dir_path = task.get('directory', task.get('path', ''))
        
        if not dir_path:
            return {'success': False, 'error': 'ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            Path(dir_path).mkdir(parents=True, exist_ok=True)
            logger.info(f"âœ… ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆæˆåŠŸ: {dir_path}")
            return {'success': True, 'message': f'ä½œæˆå®Œäº†: {dir_path}'}
        except Exception as e:
            return {'success': False, 'error': f'ä½œæˆå¤±æ•—: {e}'}
    
    async def _execute_generic_command_task(self, task: Dict) -> Dict:
        """
        æ±ç”¨ã‚³ãƒãƒ³ãƒ‰ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info("ğŸ”§ æ±ç”¨ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ")
            
            command = task.get('command', '')
            if not command:
                return {
                    'success': False,
                    'error': 'ã‚³ãƒãƒ³ãƒ‰ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            timeout = task.get('timeout', self.default_timeout)
            cwd = task.get('cwd', None)
            
            # ã‚³ãƒãƒ³ãƒ‰ç›£è¦–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä½¿ç”¨
            if self.command_monitor:
                result = await self.command_monitor.execute_command(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            else:
                result = await self._direct_command_execution(
                    command,
                    cwd=cwd,
                    timeout=timeout
                )
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ æ±ç”¨ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _direct_command_execution(
        self,
        command: str,
        cwd: Optional[str] = None,
        timeout: float = 60.0
    ) -> Dict:
        """
        ã‚³ãƒãƒ³ãƒ‰ã‚’ç›´æ¥å®Ÿè¡Œï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        
        Args:
            command: å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
            cwd: ä½œæ¥­ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            timeout: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        try:
            logger.info(f"ğŸ”§ ã‚³ãƒãƒ³ãƒ‰ç›´æ¥å®Ÿè¡Œ: {command}")
            
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                return {
                    'success': False,
                    'error': f'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({timeout}ç§’)'
                }
            
            returncode = process.returncode
            stdout_text = stdout.decode('utf-8') if stdout else ''
            stderr_text = stderr.decode('utf-8') if stderr else ''
            
            if returncode == 0:
                logger.info(f"âœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡ŒæˆåŠŸ")
                return {
                    'success': True,
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
            else:
                logger.error(f"âŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œå¤±æ•— (ã‚³ãƒ¼ãƒ‰: {returncode})")
                return {
                    'success': False,
                    'error': f'ã‚³ãƒãƒ³ãƒ‰å¤±æ•— (ã‚³ãƒ¼ãƒ‰: {returncode})',
                    'stdout': stdout_text,
                    'stderr': stderr_text,
                    'returncode': returncode
                }
        
        except Exception as e:
            logger.error(f"âŒ ã‚³ãƒãƒ³ãƒ‰ç›´æ¥å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#system_integration_agent.py
# system_integration_agent.py
"""
ã‚·ã‚¹ãƒ†ãƒ çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
æ—¢å­˜ã®MATaskExecutorã¨ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ ã‚’çµ±åˆ
"""

import asyncio
import logging
import inspect
import traceback
from typing import Dict, Any, Optional, Callable
from functools import wraps
from datetime import datetime

from data_models import ErrorContextModel, BugFixTask, create_bug_fix_task_from_exception

logger = logging.getLogger(__name__)


class SystemIntegrationAgent:
    """
    ã‚·ã‚¹ãƒ†ãƒ çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    æ©Ÿèƒ½:
    - æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ã‚¨ãƒ©ãƒ¼ãƒ•ãƒƒã‚¯è¨­ç½®
    - ã‚¨ãƒ©ãƒ¼è‡ªå‹•æ¤œå‡ºã¨ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°
    - ä¿®æ­£å¾Œã®ã‚¿ã‚¹ã‚¯å†å®Ÿè¡Œ
    - ã‚·ã‚¹ãƒ†ãƒ é–“ã®çŠ¶æ…‹åŒæœŸ
    """
    
    def __init__(
        self,
        ma_task_executor=None,
        hybrid_fix_system=None,
        auto_fix_enabled: bool = True,
        auto_retry_enabled: bool = True,
        max_retry_attempts: int = 3
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            ma_task_executor: MATaskExecutorï¼ˆæ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ï¼‰
            hybrid_fix_system: HybridFixSystemï¼ˆæ–°ã‚·ã‚¹ãƒ†ãƒ ï¼‰
            auto_fix_enabled: è‡ªå‹•ä¿®æ­£æœ‰åŠ¹ãƒ•ãƒ©ã‚°
            auto_retry_enabled: è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤æœ‰åŠ¹ãƒ•ãƒ©ã‚°
            max_retry_attempts: æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å›æ•°
        """
        self.ma_executor = ma_task_executor
        self.hybrid_system = hybrid_fix_system
        self.auto_fix_enabled = auto_fix_enabled
        self.auto_retry_enabled = auto_retry_enabled
        self.max_retry_attempts = max_retry_attempts
        
        # ã‚¨ãƒ©ãƒ¼ãƒ•ãƒƒã‚¯ã®ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
        self.error_hooks = {}
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_errors_caught": 0,
            "auto_fixed_errors": 0,
            "retry_successes": 0,
            "integration_failures": 0
        }
        
        # ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿå±¥æ­´
        self.error_history = []
        
        logger.info("âœ… SystemIntegrationAgent åˆæœŸåŒ–å®Œäº†")
    
    async def integrate_with_ma_executor(self):
        """MATaskExecutorã¨çµ±åˆ"""
        try:
            logger.info("ğŸ”— MATaskExecutorã¨ã®çµ±åˆé–‹å§‹")
            
            if not self.ma_executor:
                logger.warning("âš ï¸ MATaskExecutorãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # 1. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’æ³¨å…¥
            self._inject_error_handlers()
            
            # 2. ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—
            self._wrap_task_execution_methods()
            
            # 3. ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­ç½®
            self._setup_component_error_handlers()
            
            logger.info("âœ… MATaskExecutorã¨ã®çµ±åˆå®Œäº†")
            return True
            
        except Exception as e:
            logger.error(f"âŒ çµ±åˆã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            return False
    
    def _inject_error_handlers(self):
        """ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’æ³¨å…¥"""
        try:
            # MATaskExecutorã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—
            if hasattr(self.ma_executor, 'execute_task'):
                original_execute = self.ma_executor.execute_task
                self.ma_executor.execute_task = self._wrap_with_error_handler(
                    original_execute,
                    "execute_task"
                )
                logger.info("âœ… execute_taskãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã—ãŸ")
            
            # ä»–ã®é‡è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚‚åŒæ§˜ã«ãƒ©ãƒƒãƒ—
            methods_to_wrap = [
                'process_task',
                'run_single_task',
                '_execute_with_retry'
            ]
            
            for method_name in methods_to_wrap:
                if hasattr(self.ma_executor, method_name):
                    original_method = getattr(self.ma_executor, method_name)
                    wrapped_method = self._wrap_with_error_handler(
                        original_method,
                        method_name
                    )
                    setattr(self.ma_executor, method_name, wrapped_method)
                    logger.info(f"âœ… {method_name}ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã—ãŸ")
            
        except Exception as e:
            logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼æ³¨å…¥å¤±æ•—: {e}")
    
    def _wrap_with_error_handler(
        self,
        original_method: Callable,
        method_name: str
    ) -> Callable:
        """ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã§ãƒ©ãƒƒãƒ—"""
        
        @wraps(original_method)
        async def wrapper(*args, **kwargs):
            retry_count = 0
            last_error = None
            
            while retry_count <= self.max_retry_attempts:
                try:
                    # å…ƒã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè¡Œ
                    if inspect.iscoroutinefunction(original_method):
                        result = await original_method(*args, **kwargs)
                    else:
                        result = original_method(*args, **kwargs)
                    
                    # æˆåŠŸã—ãŸã‚‰ãƒªãƒˆãƒ©ã‚¤ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
                    if retry_count > 0:
                        self.stats["retry_successes"] += 1
                        logger.info(f"âœ… ãƒªãƒˆãƒ©ã‚¤æˆåŠŸ: {method_name} (è©¦è¡Œ{retry_count + 1}å›ç›®)")
                    
                    return result
                
                except Exception as e:
                    last_error = e
                    self.stats["total_errors_caught"] += 1
                    
                    logger.error(
                        f"âŒ ã‚¨ãƒ©ãƒ¼æ•æ‰: {method_name} "
                        f"(è©¦è¡Œ{retry_count + 1}/{self.max_retry_attempts + 1})"
                    )
                    logger.error(f"   ã‚¨ãƒ©ãƒ¼: {type(e).__name__}: {str(e)}")
                    
                    # ã‚¿ã‚¹ã‚¯æƒ…å ±ã‚’å–å¾—
                    task_id = self._extract_task_id(args, kwargs)
                    file_path = self._extract_file_path(e)
                    
                    # ã‚¨ãƒ©ãƒ¼å±¥æ­´ã«è¨˜éŒ²
                    self.error_history.append({
                        "timestamp": datetime.now().isoformat(),
                        "method": method_name,
                        "error_type": type(e).__name__,
                        "error_message": str(e),
                        "task_id": task_id,
                        "retry_count": retry_count
                    })
                    
                    # è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œ
                    if self.auto_fix_enabled and self.hybrid_system:
                        fix_result = await self._attempt_auto_fix(
                            error=e,
                            task_id=task_id,
                            method_name=method_name,
                            file_path=file_path
                        )
                        
                        if fix_result and fix_result.get("success"):
                            self.stats["auto_fixed_errors"] += 1
                            logger.info(f"âœ… è‡ªå‹•ä¿®æ­£æˆåŠŸ: {task_id}")
                            
                            # è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ãŒæœ‰åŠ¹ãªå ´åˆã€ä¿®æ­£å¾Œã«å†å®Ÿè¡Œ
                            if self.auto_retry_enabled:
                                retry_count += 1
                                logger.info(f"ğŸ”„ ã‚¿ã‚¹ã‚¯å†å®Ÿè¡Œ: {task_id} (è©¦è¡Œ{retry_count + 1}å›ç›®)")
                                await asyncio.sleep(2)  # å°‘ã—å¾…æ©Ÿ
                                continue
                    
                    # ãƒªãƒˆãƒ©ã‚¤åˆ¤å®š
                    if retry_count < self.max_retry_attempts and self.auto_retry_enabled:
                        retry_count += 1
                        logger.warning(f"ğŸ”„ ãƒªãƒˆãƒ©ã‚¤: {method_name} (è©¦è¡Œ{retry_count + 1}å›ç›®)")
                        await asyncio.sleep(5)  # ãƒªãƒˆãƒ©ã‚¤å‰ã«å¾…æ©Ÿ
                    else:
                        # ãƒªãƒˆãƒ©ã‚¤ä¸Šé™åˆ°é”
                        logger.error(f"âŒ ãƒªãƒˆãƒ©ã‚¤ä¸Šé™åˆ°é”: {method_name}")
                        raise
            
            # ã™ã¹ã¦ã®ãƒªãƒˆãƒ©ã‚¤ãŒå¤±æ•—
            if last_error:
                raise last_error
        
        return wrapper
    
    async def _attempt_auto_fix(
        self,
        error: Exception,
        task_id: str,
        method_name: str,
        file_path: Optional[str]
    ) -> Optional[Dict[str, Any]]:
        """è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œ"""
        try:
            logger.info(f"ğŸ”§ è‡ªå‹•ä¿®æ­£ã‚’è©¦è¡Œ: {task_id}")
            
            if not self.hybrid_system:
                logger.warning("âš ï¸ HybridFixSystemãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return None
            
            # ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®æ¨å®š
            if not file_path:
                file_path = self._infer_file_path(method_name)
            
            # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’åé›†
            context = {
                "method_name": method_name,
                "task_id": task_id,
                "auto_fix_attempt": True
            }
            
            # HybridFixSystemã®handle_errorã‚’å‘¼ã³å‡ºã—
            fix_result = await self.hybrid_system.handle_error(
                error=error,
                task_id=task_id,
                file_path=file_path,
                context=context
            )
            
            return fix_result
            
        except Exception as e:
            logger.error(f"âŒ è‡ªå‹•ä¿®æ­£è©¦è¡Œã‚¨ãƒ©ãƒ¼: {e}")
            self.stats["integration_failures"] += 1
            return None
    
    def _wrap_task_execution_methods(self):
        """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—"""
        try:
            # WordPressAgent, PluginAgentç­‰ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ãƒ©ãƒƒãƒ—
            agents_to_wrap = [
                'wp_agent',
                'plugin_agent',
                'content_writer',
                'acf_agent',
                'cpt_agent'
            ]
            
            for agent_name in agents_to_wrap:
                if hasattr(self.ma_executor, agent_name):
                    agent = getattr(self.ma_executor, agent_name)
                    if agent:
                        self._wrap_agent_methods(agent, agent_name)
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ãƒ©ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
    
    def _wrap_agent_methods(self, agent, agent_name: str):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—"""
        try:
            # ä¸»è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç‰¹å®š
            method_names = [
                name for name in dir(agent)
                if not name.startswith('_') and callable(getattr(agent, name))
            ]
            
            for method_name in method_names[:5]:  # æœ€åˆã®5ã¤ã®ã¿ï¼ˆä¾‹ï¼‰
                try:
                    original_method = getattr(agent, method_name)
                    wrapped_method = self._wrap_with_error_handler(
                        original_method,
                        f"{agent_name}.{method_name}"
                    )
                    setattr(agent, method_name, wrapped_method)
                except:
                    pass  # ãƒ©ãƒƒãƒ—ã§ããªã„ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã‚¹ã‚­ãƒƒãƒ—
            
            logger.info(f"âœ… {agent_name}ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ©ãƒƒãƒ—ã—ã¾ã—ãŸ")
            
        except Exception as e:
            logger.warning(f"âš ï¸ {agent_name}ã®ãƒ©ãƒƒãƒ—å¤±æ•—: {e}")
    
    def _setup_component_error_handlers(self):
        """ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­ç½®"""
        try:
            # CommandMonitorAgentã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
            if hasattr(self.ma_executor, 'cmd_monitor'):
                cmd_monitor = self.ma_executor.cmd_monitor
                if cmd_monitor and hasattr(cmd_monitor, 'execute_command'):
                    original_execute = cmd_monitor.execute_command
                    cmd_monitor.execute_command = self._wrap_with_error_handler(
                        original_execute,
                        "cmd_monitor.execute_command"
                    )
                    logger.info("âœ… CommandMonitorAgentã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­ç½®")
            
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­ç½®å¤±æ•—: {e}")
    
    # ========================================
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    # ========================================
    
    def _extract_task_id(self, args: tuple, kwargs: dict) -> str:
        """å¼•æ•°ã‹ã‚‰ã‚¿ã‚¹ã‚¯IDã‚’æŠ½å‡º"""
        # argsã‹ã‚‰æŠ½å‡ºã‚’è©¦ã¿ã‚‹
        for arg in args:
            if isinstance(arg, dict) and 'task_id' in arg:
                return arg['task_id']
            if isinstance(arg, str) and arg.startswith('Task'):
                return arg
        
        # kwargsã‹ã‚‰æŠ½å‡ºã‚’è©¦ã¿ã‚‹
        if 'task_id' in kwargs:
            return kwargs['task_id']
        if 'task' in kwargs and isinstance(kwargs['task'], dict):
            return kwargs['task'].get('task_id', 'Unknown')
        
        return f"Unknown-{datetime.now().strftime('%H%M%S')}"
    
    def _extract_file_path(self, error: Exception) -> Optional[str]:
        """ã‚¨ãƒ©ãƒ¼ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æŠ½å‡º"""
        try:
            tb = traceback.extract_tb(error.__traceback__)
            if tb:
                # æœ€å¾Œã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—
                return tb[-1].filename
        except:
            pass
        
        return None
    
    def _infer_file_path(self, method_name: str) -> str:
        """ãƒ¡ã‚½ãƒƒãƒ‰åã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ¨å®š"""
        # ãƒ¡ã‚½ãƒƒãƒ‰åã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«åã‚’æ¨å®š
        if 'wp_agent' in method_name:
            return 'wordpress/wp_agent.py'
        elif 'plugin' in method_name:
            return 'wordpress/wp_plugin_manager.py'
        elif 'content' in method_name:
            return 'content_writers/base_writer.py'
        elif 'acf' in method_name:
            return 'wordpress/wp_dev/wp_acf_agent.py'
        elif 'cpt' in method_name:
            return 'wordpress/wp_dev/wp_cpt_agent.py'
        else:
            return 'task_executor/task_executor_ma.py'
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        auto_fix_rate = 0.0
        if self.stats["total_errors_caught"] > 0:
            auto_fix_rate = (
                self.stats["auto_fixed_errors"] / 
                self.stats["total_errors_caught"]
            )
        
        return {
            **self.stats,
            "auto_fix_rate": auto_fix_rate,
            "recent_errors": self.error_history[-10:]  # ç›´è¿‘10ä»¶
        }
    
    def print_stats(self):
        """çµ±è¨ˆæƒ…å ±ã‚’è¡¨ç¤º"""
        stats = self.get_stats()
        
        print("\n" + "=" * 80)
        print("ğŸ“Š ã‚·ã‚¹ãƒ†ãƒ çµ±åˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ çµ±è¨ˆæƒ…å ±")
        print("=" * 80)
        print(f"æ•æ‰ã‚¨ãƒ©ãƒ¼ç·æ•°: {stats['total_errors_caught']}")
        print(f"è‡ªå‹•ä¿®æ­£æˆåŠŸ: {stats['auto_fixed_errors']}")
        print(f"è‡ªå‹•ä¿®æ­£ç‡: {stats['auto_fix_rate']:.1%}")
        print(f"ãƒªãƒˆãƒ©ã‚¤æˆåŠŸ: {stats['retry_successes']}")
        print(f"çµ±åˆå¤±æ•—: {stats['integration_failures']}")
        
        if stats['recent_errors']:
            print("\næœ€è¿‘ã®ã‚¨ãƒ©ãƒ¼:")
            for err in stats['recent_errors'][-5:]:
                print(f"  - {err['timestamp']}: {err['error_type']} in {err['method']}")
        
        print("=" * 80 + "\n")

#task_coordinator.py
"""
task_coordinator.py - ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®çµ±åˆèª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼
æ—¢å­˜ã®TaskExecutorã‚’è£œå®Œã—ã€ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ã¨çµæœé›†ç´„ã‚’æ‹…å½“
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

# æ—¢å­˜ã®TaskExecutor
from task_executor import TaskExecutor

# å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆæ–°è¦ï¼‰
try:
    from content_task_executor import ContentTaskExecutor
    HAS_CONTENT_EXECUTOR = True
except ImportError:
    HAS_CONTENT_EXECUTOR = False
    ContentTaskExecutor = None

try:
    from system_cli_executor import SystemCLIExecutor
    HAS_CLI_EXECUTOR = True
except ImportError:
    HAS_CLI_EXECUTOR = False
    SystemCLIExecutor = None

try:
    from workflow_executor import WorkflowExecutor
    HAS_WORKFLOW_EXECUTOR = True
except ImportError:
    HAS_WORKFLOW_EXECUTOR = False
    WorkflowExecutor = None

logger = logging.getLogger(__name__)


class TaskCoordinator:
    """
    ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã®çµ±åˆèª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼
    
    æ—¢å­˜ã®TaskExecutorã‚’æ‹¡å¼µã—ã€å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®
    ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘ã¨çµæœé›†ç´„ã‚’è¡Œã†
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            task_executor: æ—¢å­˜ã®TaskExecutorã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            'total_executed': 0,
            'content_tasks': 0,
            'cli_tasks': 0,
            'workflow_tasks': 0,
            'fallback_tasks': 0,
            'success': 0,
            'failed': 0
        }
        
        logger.info("=" * 60)
        logger.info("ğŸ¯ TaskCoordinator åˆæœŸåŒ–ä¸­...")
        logger.info("=" * 60)
        
        # å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®åˆæœŸåŒ–
        self._initialize_specialized_executors()
        
        logger.info("=" * 60)
        logger.info("âœ… TaskCoordinator åˆæœŸåŒ–å®Œäº†")
        logger.info("=" * 60)
    
    def _initialize_specialized_executors(self):
        """å°‚é–€å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–"""
        
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if HAS_CONTENT_EXECUTOR and ContentTaskExecutor:
            try:
                self.content_executor = ContentTaskExecutor(
                    browser_controller=self.browser,
                    sheets_manager=self.sheets_manager
                )
                logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ ContentTaskExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                self.content_executor = None
        else:
            logger.info("â„¹ï¸ ContentTaskExecutor ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆæ—¢å­˜å®Ÿè£…ã‚’ä½¿ç”¨ï¼‰")
            self.content_executor = None
        
        # CLIã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if HAS_CLI_EXECUTOR and SystemCLIExecutor:
            try:
                self.cli_executor = SystemCLIExecutor(
                    sheets_manager=self.sheets_manager
                )
                logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ SystemCLIExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                self.cli_executor = None
        else:
            logger.info("â„¹ï¸ SystemCLIExecutor ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.cli_executor = None
        
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
            try:
                self.workflow_executor = WorkflowExecutor(
                    task_executor=self.task_executor,
                    sheets_manager=self.sheets_manager,
                    browser_controller=self.browser
                )
                logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.warning(f"âš ï¸ WorkflowExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                self.workflow_executor = None
        else:
            logger.info("â„¹ï¸ WorkflowExecutor ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.workflow_executor = None
            
    def determine_executor_type(self, task: Dict) -> str:
        """
        ã‚¿ã‚¹ã‚¯ã«æœ€é©ãªå®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ¤å®š
            
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
                
        Returns:
            str: å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ— ('content', 'cli', 'workflow', 'review', 'fallback')
        """
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
            
        # ========================================
        # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯åˆ¤å®šï¼ˆæœ€å„ªå…ˆ - æ–°è¦è¿½åŠ ï¼‰
        # ========================================
        if role == 'review' or 'ãƒ¬ãƒ“ãƒ¥ãƒ¼' in description or 'review' in description:
            return 'review'
        # ========================================
            
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
        workflow_keywords = [
            'å¤šè¨€èª', 'ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—', 'ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£',
            'ã‚·ãƒ¼ã‚±ãƒ³ã‚¹', 'ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³', 'ãƒã‚§ãƒ¼ãƒ³'
        ]
        if any(kw in description for kw in workflow_keywords):
            return 'workflow'
            
        # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
        content_keywords = [
            'è¨˜äº‹', 'ç”Ÿæˆ', 'åŸ·ç­†', 'ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°', 
            'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„', 'ai', 'gemini', 'deepseek',
            'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ', 'æŠ½å‡º'
        ]
        if any(kw in description for kw in content_keywords):
            return 'content'
            
        # CLIã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
        cli_keywords = [
            'wp-cli', 'acf', 'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ', 'ã‚¤ãƒ³ãƒãƒ¼ãƒˆ',
            'ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ', 'ã‚·ã‚¹ãƒ†ãƒ ', 'ã‚¤ãƒ³ãƒ•ãƒ©'
        ]
        if any(kw in description for kw in cli_keywords):
            return 'cli'
            
        # ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹åˆ¤å®š
        if role in ['content', 'writer', 'seo']:
            return 'content'
        elif role in ['dev', 'system', 'admin']:
            return 'cli'
            
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        return 'fallback'
    
    async def execute_task_coordinated(self, task: Dict) -> Dict:
        """
        ã‚¿ã‚¹ã‚¯ã‚’é©åˆ‡ãªå®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«æŒ¯ã‚Šåˆ†ã‘ã¦å®Ÿè¡Œ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        self.stats['total_executed'] += 1
        
        try:
            # å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            executor_type = self.determine_executor_type(task)
            
            logger.info("=" * 60)
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘: {task_id}")
            logger.info(f"å®Ÿè¡Œã‚¿ã‚¤ãƒ—: {executor_type.upper()}")
            logger.info("=" * 60)
            
            result = None
            
            # ========================================
            # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆæ–°è¦è¿½åŠ ï¼‰
            # ========================================
            if executor_type == 'review':
                logger.info("ğŸ” ReviewAgent ã§å®Ÿè¡Œ")
                
                # TaskExecutorçµŒç”±ã§review_agentã‚’å®Ÿè¡Œ
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'review',
                    'message': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œå®Œäº†' if success else 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œå¤±æ•—'
                }
            # ========================================
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
            elif executor_type == 'workflow' and self.workflow_executor:
                logger.info("ğŸ”„ WorkflowExecutor ã§å®Ÿè¡Œ")
                self.stats['workflow_tasks'] += 1
                result = await self.workflow_executor.execute_workflow_task(task)
            
            # ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå®Ÿè¡Œ
            elif executor_type == 'content' and self.content_executor:
                logger.info("âœï¸ ContentTaskExecutor ã§å®Ÿè¡Œ")
                self.stats['content_tasks'] += 1
                result = await self.content_executor.execute_content_task(task)
            
            # CLIã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
            elif executor_type == 'cli' and self.cli_executor:
                logger.info("âš™ï¸ SystemCLIExecutor ã§å®Ÿè¡Œ")
                self.stats['cli_tasks'] += 1
                result = await self.cli_executor.execute_cli_task(task)
            
            # æ—¢å­˜å®Ÿè£…ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            else:
                logger.info("ğŸ”™ æ—¢å­˜ TaskExecutor ã§å®Ÿè¡Œï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰")
                self.stats['fallback_tasks'] += 1
                success = await self.task_executor.execute_task(task)
                result = {
                    'success': success,
                    'executor_type': 'fallback',
                    'message': 'æ—¢å­˜å®Ÿè£…ã§å®Ÿè¡Œå®Œäº†'
                }
            
            # çµ±è¨ˆæ›´æ–°
            if result and result.get('success'):
                self.stats['success'] += 1
            else:
                self.stats['failed'] += 1
            
            # å®Ÿè¡Œæƒ…å ±ã‚’çµæœã«è¿½åŠ 
            if result:
                result['executor_type'] = executor_type
                result['coordinated_execution'] = True
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª¿æ•´ã‚¨ãƒ©ãƒ¼: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª¿æ•´ã‚¨ãƒ©ãƒ¼: {task_id}")
            ErrorHandler.log_error(e, f"TaskCoordinator.execute_task_coordinated({task_id})")
            self.stats['failed'] += 1
            
            return {
                'success': False,
                'error': str(e),
                'executor_type': 'error',
                'coordinated_execution': True
            }
    
    async def run_all_tasks_coordinated(
        self,
        auto_continue: bool = False,
        enable_review: bool = True
    ):
        """
        å…¨ã‚¿ã‚¹ã‚¯ã‚’èª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼çµŒç”±ã§å®Ÿè¡Œ
        
        Args:
            auto_continue: è‡ªå‹•ç¶™ç¶šãƒ•ãƒ©ã‚°
            enable_review: ãƒ¬ãƒ“ãƒ¥ãƒ¼æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°
        """
        logger.info("\n" + "=" * 60)
        logger.info("ğŸš€ ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œé–‹å§‹")
        logger.info("=" * 60)
        
        try:
            iteration = 0
            max_iterations = self.task_executor.max_iterations
            
            while iteration < max_iterations:
                iteration += 1
                
                logger.info(f"\n{'=' * 60}")
                logger.info(f"åå¾© {iteration}/{max_iterations}")
                logger.info(f"{'=' * 60}")
                
                # ä¿ç•™ä¸­ã‚¿ã‚¹ã‚¯ã®èª­ã¿è¾¼ã¿
                pending_tasks = await self.task_executor.load_pending_tasks()
                
                if not pending_tasks:
                    logger.info("âœ… å…¨ã‚¿ã‚¹ã‚¯å®Œäº†ã¾ãŸã¯ä¿ç•™ã‚¿ã‚¹ã‚¯ãªã—")
                    break
                
                logger.info(f"ğŸ“‹ å®Ÿè¡Œäºˆå®šã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
                
                # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ«ãƒ¼ãƒ—
                for task in pending_tasks:
                    task_id = task.get('task_id', 'UNKNOWN')
                    
                    try:
                        logger.info(f"\n{'â”€' * 60}")
                        logger.info(f"ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_id}")
                        logger.info(f"{'â”€' * 60}")
                        
                        # èª¿æ•´ãƒ¬ã‚¤ãƒ¤ãƒ¼çµŒç”±ã§å®Ÿè¡Œ
                        result = await self.execute_task_coordinated(task)
                        
                        if result and result.get('success'):
                            logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ")
                        else:
                            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•—")
                        
                        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªï¼ˆè‡ªå‹•ç¶™ç¶šã§ãªã„å ´åˆï¼‰
                        if not auto_continue:
                            continue_task = input(
                                f"\næ¬¡ã®ã‚¿ã‚¹ã‚¯ã«é€²ã¿ã¾ã™ã‹? "
                                f"(y/n/a=ä»¥é™å…¨ã¦å®Ÿè¡Œ): "
                            ).lower()
                            
                            if continue_task == 'n':
                                logger.info("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                                return
                            elif continue_task == 'a':
                                auto_continue = True
                                logger.info("è‡ªå‹•å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ")
                        
                        await asyncio.sleep(2)
                        
                    except KeyboardInterrupt:
                        logger.warning("â¸ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                        raise
                    
                    except Exception as e:
                        logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼")
                        ErrorHandler.log_error(e, f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­")
                        
                        if not auto_continue:
                            cont = input(
                                f"\nâš ï¸ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç¶šè¡Œã—ã¾ã™ã‹? (y/n): "
                            ).lower()
                            if cont != 'y':
                                logger.info("ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                                break
            
            # æœ€çµ‚çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆ
            self._print_coordination_report()
            
        except KeyboardInterrupt:
            logger.warning("\nâ¸ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
            self._print_coordination_report()
            raise
        
        except Exception as e:
            logger.error("âŒ ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œå…¨ä½“ã§é‡å¤§ã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, "TaskCoordinator.run_all_tasks_coordinated")
            self._print_coordination_report()
            raise
    
    def _print_coordination_report(self):
        """ã‚¿ã‚¹ã‚¯èª¿æ•´ã®çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆã‚’å‡ºåŠ›"""
        logger.info("\n" + "=" * 60)
        logger.info("ğŸ“Š ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œãƒ¬ãƒãƒ¼ãƒˆ")
        logger.info("=" * 60)
        logger.info(f"ç·å®Ÿè¡Œæ•°: {self.stats['total_executed']}")
        logger.info(f"  - ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯: {self.stats['content_tasks']}")
        logger.info(f"  - CLIã‚¿ã‚¹ã‚¯: {self.stats['cli_tasks']}")
        logger.info(f"  - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯: {self.stats['workflow_tasks']}")
        logger.info(f"  - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: {self.stats['fallback_tasks']}")
        logger.info(f"æˆåŠŸ: {self.stats['success']}")
        logger.info(f"å¤±æ•—: {self.stats['failed']}")
        logger.info("=" * 60)
        
        # ã‚³ãƒ³ã‚½ãƒ¼ãƒ«å‡ºåŠ›
        print("\n" + "=" * 60)
        print("ğŸ“Š ã‚¿ã‚¹ã‚¯èª¿æ•´å®Ÿè¡Œãƒ¬ãƒãƒ¼ãƒˆ")
        print("=" * 60)
        print(f"ç·å®Ÿè¡Œæ•°: {self.stats['total_executed']}")
        print(f"  - ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¿ã‚¹ã‚¯: {self.stats['content_tasks']}")
        print(f"  - CLIã‚¿ã‚¹ã‚¯: {self.stats['cli_tasks']}")
        print(f"  - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯: {self.stats['workflow_tasks']}")
        print(f"  - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: {self.stats['fallback_tasks']}")
        print(f"æˆåŠŸ: {self.stats['success']}")
        print(f"å¤±æ•—: {self.stats['failed']}")
        print("=" * 60 + "\n")
    
    def get_stats(self) -> Dict:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        return self.stats.copy()

#task_executor.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== è¨­å®šã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
from config_utils import ErrorHandler, config

# ===== ãƒ‡ãƒ¼ã‚¿ç®¡ç† =====
from sheets_manager import GoogleSheetsManager

# ===== ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("âš ï¸ error_handler_enhancedæœªæ¤œå‡ºï¼ˆæ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ä½¿ç”¨ï¼‰")

# ===== åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPressé€£æºï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼(ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆ)"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            sheets_manager: GoogleSheetsManager ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
            max_iterations: æœ€å¤§åå¾©å›æ•°
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: æœ€å¤§åå¾©å›æ•° = {self.max_iterations}")
        
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’è‡ªå‹•åˆæœŸåŒ–
        self._initialize_agents()
        
        # === åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ– ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # è¨˜äº‹ç”Ÿæˆå°‚ç”¨ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("âœ… ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
                
                # M&Aå°‚ç”¨ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("âœ… MATaskExecutor åˆæœŸåŒ–å®Œäº†")
                
                logger.info("="*60)
                logger.info("åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–å®Œäº†")
                logger.info("  - ContentTaskExecutor (è¨˜äº‹ç”Ÿæˆå°‚ç”¨)")
                logger.info("  - MATaskExecutor (M&A/ä¼æ¥­æ¤œç´¢å°‚ç”¨)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"âš ï¸ åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–å¤±æ•—: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("âš ï¸ åˆ†é›¢ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
            self.content_executor = None
            self.ma_executor = None
        
        # === WordPressé–‹ç™ºå°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ– ===
        logger.info("\n" + "="*60)
        logger.info("ğŸ”§ WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        logger.info("="*60)
        
        # WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_dev) ã®åˆæœŸåŒ–
        self.wp_dev_agent = None
        try:
            from wordpress.wp_dev import WordPressDevAgent
            
            if self.browser:
                self.wp_dev_agent = WordPressDevAgent(self.browser)
                if hasattr(self.wp_dev_agent, 'sheets_manager'):
                    self.wp_dev_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_dev'] = self.wp_dev_agent
                logger.info("âœ… WordPressDevAgent (wp_dev) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æœªåˆæœŸåŒ–ã®ãŸã‚ wp_dev ã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ wordpress/wp_dev.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã¯æ¨™æº– dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ wp_dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        # WordPressè¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (wp_design) ã®åˆæœŸåŒ–
        self.wp_design_agent = None
        try:
            from wordpress.wp_design import WordPressDesignAgent
            
            if self.browser:
                self.wp_design_agent = WordPressDesignAgent(self.browser)
                if hasattr(self.wp_design_agent, 'sheets_manager'):
                    self.wp_design_agent.sheets_manager = self.sheets_manager
                
                self.agents['wp_design'] = self.wp_design_agent
                logger.info("âœ… WordPressDesignAgent (wp_design) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼æœªåˆæœŸåŒ–ã®ãŸã‚ wp_design ã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ wordpress/wp_design.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯ã¯æ¨™æº– design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å‡¦ç†ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ wp_design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        logger.info("="*60)
        logger.info("WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        if self.wp_dev_agent:
            logger.info("  - WordPressDevAgent (ã‚«ã‚¹ã‚¿ãƒ é–‹ç™º)")
        if self.wp_design_agent:
            logger.info("  - WordPressDesignAgent (ãƒ†ãƒ¼ãƒ/CSS)")
        logger.info("="*60)
        

        # ========================================
        # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆæ–°è¦è¿½åŠ ï¼‰
        # ========================================
        
        logger.info("\n" + "="*60)
        logger.info("ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ä¸­...")
        logger.info("="*60)
        
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (review) ã®åˆæœŸåŒ–
        self.review_agent_instance = None
        try:
            from review_agent import ReviewAgent
            
            if self.browser:
                self.review_agent_instance = ReviewAgent(self.browser)
                if hasattr(self.review_agent_instance, 'sheets_manager'):
                    self.review_agent_instance.sheets_manager = self.sheets_manager
                
                self.agents['review'] = self.review_agent_instance
                logger.info("âœ… ReviewAgent (review) ç™»éŒ²å®Œäº†")
            else:
                logger.warning("âš ï¸ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©æœªåˆæœŸåŒ–ã®ãŸã‚ review ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¹ã‚­ãƒƒãƒ—")
                
        except ImportError as e:
            logger.warning(f"âš ï¸ review_agent.py ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            logger.info("ğŸ’¡ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã¯æ¨™æº–å‡¦ç†ã§ã‚¹ã‚­ãƒƒãƒ—ã•ã‚Œã¾ã™")
        except Exception as e:
            logger.warning(f"âš ï¸ review ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        
        logger.info("="*60)
        if self.review_agent_instance:
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
            logger.info("  - ReviewAgent (å“è³ªãƒã‚§ãƒƒã‚¯ãƒ»ä»•æ§˜ç¢ºèª)")
        else:
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
        logger.info("="*60)

        # ========================================
        # ğŸ“¦ æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆï¼ˆ__init__ãƒ¡ã‚½ãƒƒãƒ‰å†…ã«è¿½åŠ ï¼‰
        # ========================================

        logger.info("\n" + "="*60)
        logger.info("ğŸ“¦ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆãƒã‚§ãƒƒã‚¯")
        logger.info("="*60)

        # task_executor.tas__init__ ã‹ã‚‰æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        try:
            from task_executor.tas__init__ import (
                TaskCoordinator,
                ContentTaskExecutor as NewContentExecutor,
                SystemCLIExecutor,
                WorkflowExecutor,
                HAS_COORDINATOR,
                HAS_CONTENT_EXECUTOR,
                HAS_CLI_EXECUTOR,
                HAS_WORKFLOW_EXECUTOR,
                print_module_status
            )
            
            # TaskCoordinator ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_COORDINATOR:
                try:
                    logger.info("âœ… TaskCoordinator åˆ©ç”¨å¯èƒ½")
                    self._has_coordinator = True
                except Exception as e:
                    logger.warning(f"âš ï¸ TaskCoordinator åˆæœŸåŒ–ã‚¹ã‚­ãƒƒãƒ—: {e}")
                    self._has_coordinator = False
            else:
                logger.info("â„¹ï¸ TaskCoordinator ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰")
                self._has_coordinator = False
            
            # æ–°è¦ ContentTaskExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_CONTENT_EXECUTOR and NewContentExecutor:
                try:
                    self.new_content_executor = NewContentExecutor(
                        browser_controller=self.browser,
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("âœ… æ–°è¦ ContentTaskExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ æ–°è¦ ContentTaskExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.new_content_executor = None
            else:
                logger.info("â„¹ï¸ æ–°è¦ ContentTaskExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.new_content_executor = None
            
            # SystemCLIExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_CLI_EXECUTOR and SystemCLIExecutor:
                try:
                    self.cli_executor = SystemCLIExecutor(
                        sheets_manager=self.sheets_manager
                    )
                    logger.info("âœ… SystemCLIExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ SystemCLIExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.cli_executor = None
            else:
                logger.info("â„¹ï¸ SystemCLIExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.cli_executor = None
            
            # WorkflowExecutor ã®åˆæœŸåŒ–ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            if HAS_WORKFLOW_EXECUTOR and WorkflowExecutor:
                try:
                    self.workflow_executor = WorkflowExecutor(
                        task_executor=self,
                        sheets_manager=self.sheets_manager,
                        browser_controller=self.browser
                    )
                    logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
                except Exception as e:
                    logger.warning(f"âš ï¸ WorkflowExecutor åˆæœŸåŒ–å¤±æ•—: {e}")
                    self.workflow_executor = None
            else:
                logger.info("â„¹ï¸ WorkflowExecutor ã¯é…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                self.workflow_executor = None
            
            logger.info("="*60)
            logger.info("æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«çµ±åˆå®Œäº†")
            logger.info("="*60)

        except ImportError as e:
            logger.info("="*60)
            logger.info("â„¹ï¸ æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æœªé…ç½®ï¼ˆæ—¢å­˜æ©Ÿèƒ½ã®ã¿ä½¿ç”¨ï¼‰")
            logger.info(f"è©³ç´°: {e}")
            logger.info("="*60)
            self._has_coordinator = False
            self.new_content_executor = None
            self.cli_executor = None
            self.workflow_executor = None

    def _initialize_agents(self):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è‡ªå‹•åˆæœŸåŒ–"""
        logger.info("ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ä¸­...")
        # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å¤–éƒ¨ã‹ã‚‰ register_agent() ã§ç™»éŒ²ã•ã‚Œã‚‹
        logger.info("ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")

    def register_agent(self, role: str, agent):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.agents[role] = agent
        logger.info(f"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

    def register_review_agent(self, review_agent):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.review_agent = review_agent
        logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")

    async def execute_task_with_extensions(self, task: Dict) -> bool:
        """
        æ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ãŸã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
        
        æ–°è¦ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã¯å„ªå…ˆçš„ã«ä½¿ç”¨ã—ã€
        ãã†ã§ãªã‘ã‚Œã°æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            # CLIã‚¿ã‚¹ã‚¯åˆ¤å®š
            if self.cli_executor and any(kw in description for kw in ['wp-cli', 'acf', 'ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ']):
                logger.info(f"ğŸ”§ SystemCLIExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
                result = await self.cli_executor.execute_cli_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¹ã‚¯åˆ¤å®š
            if self.workflow_executor and any(kw in description for kw in ['å¤šè¨€èª', 'ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£', 'ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—']):
                logger.info(f"ğŸ”„ WorkflowExecutor ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
                result = await self.workflow_executor.execute_workflow_task(task)
                return result.get('success', False) if isinstance(result, dict) else bool(result)
            
            # æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            logger.info(f"ğŸ”™ æ—¢å­˜å®Ÿè£…ã§ã‚¿ã‚¹ã‚¯ {task_id} ã‚’å®Ÿè¡Œ")
            return await self.execute_task(task)
        
        except Exception as e:
            logger.error(f"âŒ æ‹¡å¼µå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, f"execute_task_with_extensions({task_id})")
            # ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚æ—¢å­˜å®Ÿè£…ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            return await self.execute_task(task)

    async def load_pending_tasks(self) -> List[Dict]:
        """ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€ï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info("ğŸ“‹ ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("ğŸ“­ pm_tasksã‚·ãƒ¼ãƒˆã«ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                return []
            
            # statusãŒ'pending'ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"ğŸ“Š ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
            
            # ãƒ‡ãƒãƒƒã‚°æƒ…å ±
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... ä»– {len(pending_tasks)-3}ä»¶")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return []

    async def update_task_status(self, task: Dict, status: str, **kwargs):
        """
        ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ï¼ˆå¼•æ•°çµ±ä¸€ç‰ˆï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            status: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ('completed', 'failed', ãªã©)
            **kwargs: ãã®ä»–ã®å¼•æ•°ï¼ˆerrorãªã©ï¼‰
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å–å¾—
            error_msg = kwargs.get('error', '')
            
            logger.info(f"ğŸ’¬ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°: {status}")
            if error_msg:
                logger.info(f"   ã‚¨ãƒ©ãƒ¼: {error_msg}")
            
            # ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒã‚ã‚‹å ´åˆã®ã¿æ›´æ–°
            if self.sheets_manager:
                try:
                    # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ—ã«æ›¸ãè¾¼ã¿
                    row = task.get('_row_index')
                    if row:
                        self.sheets_manager.ws.update_cell(row, 11, status)
                        
                        # ã‚¨ãƒ©ãƒ¼ãŒã‚ã‚‹å ´åˆã¯ãƒ¡ãƒ¢åˆ—ã«æ›¸ãè¾¼ã¿
                        if error_msg and status == 'failed':
                            self.sheets_manager.ws.update_cell(row, 12, f"ã‚¨ãƒ©ãƒ¼: {error_msg}")
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚·ãƒ¼ãƒˆæ›´æ–°å¤±æ•—: {e}")
            
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
    
    async def execute_task(self, task: Dict) -> bool:
        """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰"""
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            print(f"\n{'='*70}")
            print(f"ğŸ¯ ã‚¿ã‚¹ã‚¯: {task_id}")
            print(f"èª¬æ˜: {task.get('description', 'N/A')[:50]}...")
            print(f"{'='*70}\n")
            
            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            await self.update_task_status(task, 'in_progress')
            
            role = task['required_role'].lower()
            
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
            task_timeout = 180.0
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—
            agent = self.agents.get(role)
            
            if not agent:
                logger.error(f"âŒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                await self.update_task_status(task, 'failed', error=f'ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²: {role}')
                return False
            
            # ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆexecute ã¾ãŸã¯ process_taskï¼‰
            result = None
            
            try:
                if hasattr(agent, 'execute'):
                    logger.info(f"å®Ÿè¡Œ: {role}.execute()")
                    result = await asyncio.wait_for(
                        agent.execute(task),
                        timeout=task_timeout
                    )
                elif hasattr(agent, 'process_task'):
                    logger.info(f"å®Ÿè¡Œ: {role}.process_task()")
                    result = await asyncio.wait_for(
                        agent.process_task(task),
                        timeout=task_timeout
                    )
                else:
                    logger.error(f"âŒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ã«execute/process_taskãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“")
                    await self.update_task_status(task, 'failed', error='ãƒ¡ã‚½ãƒƒãƒ‰ä¸åœ¨')
                    return False
                
            except asyncio.TimeoutError:
                logger.error(f"â±ï¸ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {task_id}")
                await self.update_task_status(task, 'failed', error='ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ')
                return False
            
            # çµæœåˆ¤å®š
            if result and result.get('success'):
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
                await self.update_task_status(task, 'completed')
                
                # çµæœä¿å­˜
                try:
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"âš ï¸ çµæœä¿å­˜å¤±æ•—: {e}")
                
                
                # ========================================
                # ğŸ” ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯è‡ªå‹•ç”Ÿæˆï¼ˆæ–°è¦è¿½åŠ ï¼‰
                # ========================================
                try:
                    await self._generate_review_task_if_needed(task, result)
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
                # ========================================
                                
                return True
            else:
                error = result.get('error', 'ä¸æ˜') if result else 'çµæœãªã—'
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {error}")
                await self.update_task_status(task, 'failed', error=error)
                return False
        
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            try:
                await self.update_task_status(task, 'failed', error=str(e))
            except:
                pass
            
            return False
    
    def _determine_task_type_safe(self, task: Dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆã‚»ãƒ¼ãƒ•ç‰ˆï¼‰"""
        try:
            if HAS_TASK_ROUTER and task_router:
                return task_router.determine_task_type(task)
        except:
            pass
        
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆ¤å®š
        description = task.get('description', '').lower()
        role = task.get('required_role', '').lower()
        
        if any(kw in description for kw in ['è¦ä»¶å®šç¾©', 'requirements', 'wordpress']):
            return 'requirements'
        elif role in ['ma', 'content', 'review']:
            return role
        else:
            return 'default'
    
    async def _fallback_generic_task(self, task: Dict) -> Dict:
        """æ±ç”¨ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†"""
        logger.warning(f"âš ï¸ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸åœ¨ - æ±ç”¨å‡¦ç†")
        
        return {
            'success': True,
            'message': 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†å®Œäº†',
            'summary': f'ã‚¿ã‚¹ã‚¯ {task.get("task_id")} ã‚’æ±ç”¨å‡¦ç†ã§å®Œäº†'
        }

    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œ"""
        logger.info("\n" + "="*80)
        logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
        logger.info("="*80 + "\n")
            
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
            
        try:
            logger.info("ğŸ“‹ ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            pending_tasks = await self.load_pending_tasks()
                
            if not pending_tasks:
                logger.info("ğŸ“­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                summary['end_time'] = datetime.now()
                return summary
                
            summary['total'] = len(pending_tasks)
            logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            logger.info(f"ğŸ‘¥ ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {list(self.agents.keys())}\n")
                
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                    
                self.current_iteration += 1
                if self.current_iteration > self.max_iterations:
                    logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•° ({self.max_iterations}) ã«åˆ°é”")
                    summary['skipped'] = summary['total'] - index + 1
                    break
                    
                logger.info(f"\n{'â”€'*80}")
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                logger.info(f"{'â”€'*80}")
                    
                try:
                    success = await self.execute_task(task)
                        
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                        
                    if success:
                        summary['success'] += 1
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                        
                    await asyncio.sleep(1)
                        
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¨ãƒ©ãƒ¼: {e}")
                
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
                
            logger.info("\n" + "="*80)
            logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            logger.info("="*80)
            logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
            logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
            logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
            logger.info(f"  â­ï¸  ã‚¹ã‚­ãƒƒãƒ—:  {summary['skipped']:>3}ä»¶")
            logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
            logger.info("="*80 + "\n")
                
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
                
            return summary
                
        except Exception as e:
            logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "run_all_tasks")
            summary['end_time'] = datetime.now()
            return summary
            
        finally:
            logger.info("\nğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—...")
            self.current_iteration = 0
            logger.info("âœ… å®Œäº†\n")
    
    async def _generate_review_task_if_needed(self, completed_task: Dict, result: Dict):
        """
        å®Œäº†ã‚¿ã‚¹ã‚¯ã«å¯¾ã—ã¦ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªå ´åˆã€è‡ªå‹•çš„ã«ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆ
                
        Args:
            completed_task: å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯æƒ…å ±
            result: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œçµæœ
        """
        task_id = completed_task.get('task_id', 'UNKNOWN')
        role = completed_task.get('required_role', '').lower()
        description = completed_task.get('description', '').lower()
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        review_trigger_keywords = [
            'è¦ä»¶å®šç¾©', 'è©³ç´°è¨­è¨ˆ', 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—', 'acfè¨­è¨ˆ',
            'ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆä½œæˆ', 'ãƒ†ãƒ¼ãƒã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º', 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–‹ç™º',
            'requirements', 'design', 'template', 'custom post type'
        ]
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªãƒ­ãƒ¼ãƒ«
        review_trigger_roles = ['dev', 'wp_dev', 'design', 'wp_design']
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ç”Ÿæˆæ¡ä»¶ãƒã‚§ãƒƒã‚¯
        should_create_review = False
                
        # ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯
        if any(keyword in description for keyword in review_trigger_keywords):
            should_create_review = True
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {task_id} ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å«ã‚“ã§ã„ã¾ã™")
                
        # ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒã‚§ãƒƒã‚¯
        if role in review_trigger_roles:
            should_create_review = True
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {task_id} ã®ãƒ­ãƒ¼ãƒ« '{role}' ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã§ã™")
                
        # ã‚¿ã‚¹ã‚¯çµæœã«é‡è¦ãªã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆãŒã‚ã‚‹å ´åˆ
        if result.get('output_path') or result.get('created_files'):
            should_create_review = True
            logger.info(f"ğŸ“‹ ã‚¿ã‚¹ã‚¯ {task_id} ã¯æˆæœç‰©ã‚’ç”Ÿæˆã—ã¾ã—ãŸ")
                
        if not should_create_review:
            logger.debug(f"ã‚¿ã‚¹ã‚¯ {task_id} ã¯ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸è¦ã¨åˆ¤æ–­")
            return
                
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®ç”Ÿæˆ
        try:
            logger.info(f"ğŸ” ã‚¿ã‚¹ã‚¯ {task_id} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆä¸­...")
                    
            # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®èª¬æ˜æ–‡ç”Ÿæˆ
            review_description = f"ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€‘ID:{task_id} ({completed_task.get('description', '')[:30]}...) ã®æˆæœç‰©ãƒ¬ãƒ“ãƒ¥ãƒ¼"
                    
            # æ–°ã—ã„ã‚¿ã‚¹ã‚¯IDã®ç”Ÿæˆ
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            review_task_id = f"REVIEW_{task_id}_{timestamp}"
                    
            # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿
            review_task_data = {
                'task_id': review_task_id,
                'description': review_description,
                'required_role': 'review',  # â† é‡è¦: ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æŒ‡å®š
                'status': 'pending',
                'priority': 'high',
                'parent_task_id': task_id,  # å…ƒã‚¿ã‚¹ã‚¯ã¸ã®å‚ç…§
                'target_output': result.get('output_path', ''),
                'created_at': timestamp
            }
                    
            # Google Sheetsã«è¿½åŠ 
            if self.sheets_manager:
                try:
                    # pm_tasksã‚·ãƒ¼ãƒˆã«æ–°è¦è¡Œã‚’è¿½åŠ 
                    new_row = [
                        review_task_id,
                        review_description,
                        'review',  # required_role
                        'high',    # priority
                        'pending', # status
                        '',        # assigned_to
                        '',        # started_at
                        '',        # completed_at
                        task_id,   # parent_task_id
                        result.get('output_path', ''),  # target_output
                        '',        # result
                        f'å…ƒã‚¿ã‚¹ã‚¯: {task_id}'  # memo
                    ]
                            
                    # ã‚·ãƒ¼ãƒˆã«è¿½åŠ 
                    ws = self.sheets_manager.ws
                    ws.append_row(new_row)
                            
                    logger.info(f"âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ {review_task_id} ã‚’ç”Ÿæˆã—ã¾ã—ãŸ")
                    logger.info(f"   å¯¾è±¡: {task_id}")
                    logger.info(f"   èª¬æ˜: {review_description}")
                            
                except Exception as e:
                    logger.error(f"âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®ã‚·ãƒ¼ãƒˆè¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            else:
                logger.warning("âš ï¸ sheets_manager ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
                        
        except Exception as e:
            logger.error(f"âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
    
    

#task_executor_content.py
"""
task_executor_content.py
è¨˜äº‹ç”Ÿæˆå°‚ç”¨ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
task_executor.pyã‹ã‚‰åˆ†é›¢
"""
import logging
from typing import Dict, List
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class ContentTaskExecutor:
    """è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯å°‚ç”¨ã®å®Ÿè¡Œã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, agents: Dict):
        self.agents = agents
    
    async def execute_writer_task(self, task: Dict, role: str) -> Dict:
        """è¨€èªåˆ¥ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯æƒ…å ±ã®æŠ½å‡º ===
        task_language = task.get('language')
        polylang_lang = task.get('polylang_lang')
        
        # === ãƒ‘ãƒ¼ãƒˆ2: å®Ÿè¡Œé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
        logger.info("â”Œ" + "â”€"*58 + "â”")
        logger.info(f"â”‚ âœï¸ ãƒ©ã‚¤ã‚¿ãƒ¼AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­ ({role})")
        logger.info("â”œ" + "â”€"*58 + "â”¤")
        logger.info(f"â”‚ è¨€èª: {task_language}")
        logger.info(f"â”‚ Polylang: {polylang_lang}")
        logger.info("â””" + "â”€"*58 + "â”˜")
        
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é¸æŠã¨å®Ÿè¡Œ ===
        if role == 'writer' or role == 'content':
            # === ãƒ‘ãƒ¼ãƒˆ3-1: æ±ç”¨ãƒ©ã‚¤ã‚¿ãƒ¼ã®å‡¦ç† ===
            logger.info("ğŸ“ æ±ç”¨ãƒ©ã‚¤ã‚¿ãƒ¼ã‚’ä½¿ç”¨(å¾Œæ–¹äº’æ›æ€§ãƒ¢ãƒ¼ãƒ‰)")
            agent = self.agents.get('writer')
            if not agent:
                logger.error("âŒ writerã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'writer ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            result = await agent.process_task(task)
        else:
            # === ãƒ‘ãƒ¼ãƒˆ3-2: è¨€èªåˆ¥ãƒ©ã‚¤ã‚¿ãƒ¼ã®å‡¦ç† ===
            agent = self.agents.get(role)
            if not agent:
                logger.error(f"âŒ {role}ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': f'æœªå¯¾å¿œã®è¨€èªãƒ©ã‚¤ã‚¿ãƒ¼: {role}'
                }
            
            # === ãƒ‘ãƒ¼ãƒˆ3-3: è¨€èªç¢ºèª ===
            if task_language and hasattr(agent, 'get_language_code'):
                if agent.get_language_code() != task_language:
                    logger.warning(f"âš ï¸ è¨€èªä¸ä¸€è‡´: ã‚¿ã‚¹ã‚¯={task_language}, ãƒ©ã‚¤ã‚¿ãƒ¼={agent.get_language_code()}")
            
            result = await agent.process_task(task)
        
        # === ãƒ‘ãƒ¼ãƒˆ4: çµæœã®å‡¦ç† ===
        if result.get('success'):
            logger.info(f"âœ… ãƒ©ã‚¤ã‚¿ãƒ¼AI ({role}): ã‚¿ã‚¹ã‚¯å®Œäº†")
            # è¨€èªæƒ…å ±ã‚’è¿½åŠ 
            if hasattr(agent, 'get_language_code'):
                result['language'] = agent.get_language_code()
                result['polylang_lang'] = polylang_lang or agent.get_language_code()
        else:
            logger.error(f"âŒ ãƒ©ã‚¤ã‚¿ãƒ¼AI ({role}): å¤±æ•— - {result.get('error', 'ä¸æ˜')}")
        
        return result
    
    def display_suggested_tasks(self, suggested_tasks: List[Dict]):
        """ææ¡ˆã‚¿ã‚¹ã‚¯ã®è©³ç´°ã‚’è¡¨ç¤º"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
        print("\n" + "="*60)
        print("ææ¡ˆã‚¿ã‚¹ã‚¯è©³ç´°")
        print("="*60)

        # === ãƒ‘ãƒ¼ãƒˆ2: å„ã‚¿ã‚¹ã‚¯ã®è©³ç´°è¡¨ç¤º ===
        for i, task in enumerate(suggested_tasks, 1):
            # === ãƒ‘ãƒ¼ãƒˆ2-1: å„ªå…ˆåº¦ãƒãƒ¼ã‚¯ã®è¨­å®š ===
            priority_mark = {
                'high': 'ğŸ”´[é«˜]',
                'medium': 'ğŸŸ¡[ä¸­]', 
                'low': 'ğŸŸ¢[ä½]'
            }.get(task.get('priority', 'medium'), 'âšª[ä¸­]')
        
            # === ãƒ‘ãƒ¼ãƒˆ2-2: å½¹å‰²ãƒ©ãƒ™ãƒ«ã®è¨­å®š ===
            role_label = {
                'design': 'ğŸ“[è¨­è¨ˆ]',
                'dev': 'ğŸ’»[é–‹ç™º]',
                'ui': 'ğŸ¨[UI]',
                'review': 'âœ…[ãƒ¬ãƒ“ãƒ¥ãƒ¼]',
                'wordpress': 'ğŸŒ[WordPress]',
                'writer': 'âœï¸[ãƒ©ã‚¤ã‚¿ãƒ¼]',
                'writer_ja': 'ğŸ‡¯ğŸ‡µ[æ—¥æœ¬èª]',
                'writer_en': 'ğŸ‡¬ğŸ‡§[è‹±èª]',
                'writer_ru': 'ğŸ‡·ğŸ‡º[ãƒ­ã‚·ã‚¢èª]',
                'content': 'ğŸ“„[ã‚³ãƒ³ãƒ†ãƒ³ãƒ„]'
            }.get(task.get('required_role', 'dev'), 'ğŸ“‹[ã‚¿ã‚¹ã‚¯]')
        
            # === ãƒ‘ãƒ¼ãƒˆ2-3: ã‚¿ã‚¹ã‚¯æƒ…å ±ã®è¡¨ç¤º ===
            print(f"\n{i}. {priority_mark} {role_label} {task.get('description', 'N/A')}")
            print(f"   ç†ç”±: {task.get('reasoning', 'N/A')}")
            print(f"   æ‹…å½“: {task.get('required_role', 'dev')}")
            print(f"   å„ªå…ˆåº¦: {task.get('priority', 'medium')}")

        # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ•ãƒƒã‚¿ãƒ¼è¡¨ç¤º ===
        print("="*60)
    
    async def edit_suggested_tasks(self, suggested_tasks: List[Dict]) -> List[Dict]:
        """ææ¡ˆã‚¿ã‚¹ã‚¯ã‚’ç·¨é›†"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å¤‰æ•°åˆæœŸåŒ– ===
            edited_tasks = []
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å„ã‚¿ã‚¹ã‚¯ã®ç·¨é›†ãƒ«ãƒ¼ãƒ— ===
            for i, task in enumerate(suggested_tasks, 1):
                # === ãƒ‘ãƒ¼ãƒˆ2-1: ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯æƒ…å ±è¡¨ç¤º ===
                print(f"\n--- ã‚¿ã‚¹ã‚¯ {i}/{len(suggested_tasks)} ã®ç·¨é›† ---")
                print(f"ç¾åœ¨ã®å†…å®¹:")
                print(f"  èª¬æ˜: {task.get('description', '')}")
                print(f"  æ‹…å½“: {task.get('required_role', 'dev')}")
                print(f"  å„ªå…ˆåº¦: {task.get('priority', 'medium')}")
                print(f"  ç†ç”±: {task.get('reasoning', '')}")
            
                # === ãƒ‘ãƒ¼ãƒˆ2-2: ç·¨é›†ã‚ªãƒ—ã‚·ãƒ§ãƒ³è¡¨ç¤º ===
                print(f"\nç·¨é›†ã‚ªãƒ—ã‚·ãƒ§ãƒ³:")
                print("  (d)èª¬æ˜ã‚’å¤‰æ›´ / (r)æ‹…å½“ã‚’å¤‰æ›´ / (p)å„ªå…ˆåº¦ã‚’å¤‰æ›´ / (e)ç†ç”±ã‚’å¤‰æ›´")
                print("  (s)ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ã‚¹ã‚­ãƒƒãƒ— / (k)ã“ã®ã‚¿ã‚¹ã‚¯ã‚’ä¿æŒ / (q)ç·¨é›†ã‚’çµ‚äº†")
            
                # === ãƒ‘ãƒ¼ãƒˆ2-3: ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã®å–å¾— ===
                edit_choice = input("é¸æŠ: ").lower()
            
                # === ãƒ‘ãƒ¼ãƒˆ2-4: å„é¸æŠè‚¢ã®å‡¦ç† ===
                if edit_choice == 'd':
                    # èª¬æ˜å¤‰æ›´
                    new_desc = input("æ–°ã—ã„èª¬æ˜: ").strip()
                    if new_desc:
                        task['description'] = new_desc
                    edited_tasks.append(task)
                
                elif edit_choice == 'r':
                    # æ‹…å½“å¤‰æ›´
                    print("åˆ©ç”¨å¯èƒ½ãªæ‹…å½“:")
                    print("  design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                    new_role = input("æ–°ã—ã„æ‹…å½“: ").strip()
                    valid_roles = ['design', 'dev', 'ui', 'review', 'wordpress', 'writer', 
                                'writer_ja', 'writer_en', 'writer_ru', 'writer_uz', 
                                'writer_zh', 'writer_ko', 'writer_tr', 'plugin', 'content']
                    if new_role in valid_roles:
                        task['required_role'] = new_role
                    else:
                        print("ç„¡åŠ¹ãªæ‹…å½“ã§ã™ã€‚å¤‰æ›´ã—ã¾ã›ã‚“ã€‚")
                    edited_tasks.append(task)
                
                elif edit_choice == 'p':
                    # å„ªå…ˆåº¦å¤‰æ›´
                    print("å„ªå…ˆåº¦: high, medium, low")
                    new_priority = input("æ–°ã—ã„å„ªå…ˆåº¦: ").strip()
                    if new_priority in ['high', 'medium', 'low']:
                        task['priority'] = new_priority
                    else:
                        print("ç„¡åŠ¹ãªå„ªå…ˆåº¦ã§ã™ã€‚å¤‰æ›´ã—ã¾ã›ã‚“ã€‚")
                    edited_tasks.append(task)
                
                elif edit_choice == 'e':
                    # ç†ç”±å¤‰æ›´
                    new_reason = input("æ–°ã—ã„ç†ç”±: ").strip()
                    if new_reason:
                        task['reasoning'] = new_reason
                    edited_tasks.append(task)
                
                elif edit_choice == 's':
                    # ã‚¹ã‚­ãƒƒãƒ—
                    print(f"ã‚¿ã‚¹ã‚¯ {i} ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ")
                    continue
                
                elif edit_choice == 'k':
                    # ä¿æŒ
                    edited_tasks.append(task)
                    print(f"ã‚¿ã‚¹ã‚¯ {i} ã‚’ãã®ã¾ã¾ä¿æŒã—ã¾ã—ãŸ")
                
                elif edit_choice == 'q':
                    # ç·¨é›†çµ‚äº†
                    print("ç·¨é›†ã‚’çµ‚äº†ã—ã¾ã™")
                    break
                
                else:
                    # ä¸æ­£ãªå…¥åŠ›
                    print("ä¸æ­£ãªå…¥åŠ›ã§ã™ã€‚ã‚¿ã‚¹ã‚¯ã‚’ãã®ã¾ã¾ä¿æŒã—ã¾ã™ã€‚")
                    edited_tasks.append(task)
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ç·¨é›†çµæœã®è¡¨ç¤º ===
            if edited_tasks:
                print(f"\nç·¨é›†å¾Œã®ã‚¿ã‚¹ã‚¯ ({len(edited_tasks)}ä»¶):")
                self.display_suggested_tasks(edited_tasks)
            
            return edited_tasks
        
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ4: ä¾‹å¤–å‡¦ç† ===
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ç·¨é›†")
            return suggested_tasks
    
    async def create_manual_tasks(self) -> List[Dict]:
        """æ‰‹å‹•ã§ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å¤‰æ•°åˆæœŸåŒ– ===
            manual_tasks = []
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ä½œæˆé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
            print("\n" + "="*60)
            print("æ‰‹å‹•ã‚¿ã‚¹ã‚¯ä½œæˆ")
            print("="*60)
            print("æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’æ‰‹å‹•ã§ä½œæˆã—ã¾ã™ã€‚")
            print("ç©ºã®èª¬æ˜ã§çµ‚äº†ã—ã¾ã™ã€‚")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ä½œæˆãƒ«ãƒ¼ãƒ— ===
            while True:
                # === ãƒ‘ãƒ¼ãƒˆ3-1: ã‚¿ã‚¹ã‚¯ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
                print(f"\n--- ã‚¿ã‚¹ã‚¯ {len(manual_tasks) + 1} ---")
                
                # === ãƒ‘ãƒ¼ãƒˆ3-2: ã‚¿ã‚¹ã‚¯èª¬æ˜ã®å…¥åŠ› ===
                description = input("ã‚¿ã‚¹ã‚¯èª¬æ˜: ").strip()
                if not description:
                    break
                    
                # === ãƒ‘ãƒ¼ãƒˆ3-3: æ‹…å½“ã®å…¥åŠ› ===
                print("åˆ©ç”¨å¯èƒ½ãªæ‹…å½“: design, dev, ui, review, wordpress, writer, writer_ja, writer_en, writer_ru, plugin")
                role = input("æ‹…å½“ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: dev): ").strip() or "dev"
                
                # === ãƒ‘ãƒ¼ãƒˆ3-4: å„ªå…ˆåº¦ã®å…¥åŠ› ===
                print("å„ªå…ˆåº¦: high, medium, low")
                priority = input("å„ªå…ˆåº¦ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: medium): ").strip() or "medium"
                
                # === ãƒ‘ãƒ¼ãƒˆ3-5: ç†ç”±ã®å…¥åŠ› ===
                reasoning = input("ç†ç”±: ").strip()
                
                # === ãƒ‘ãƒ¼ãƒˆ3-6: ã‚¿ã‚¹ã‚¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ ===
                task = {
                    'description': description,
                    'required_role': role,
                    'priority': priority,
                    'reasoning': reasoning
                }
                
                # === ãƒ‘ãƒ¼ãƒˆ3-7: ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã¸ã®è¿½åŠ  ===
                manual_tasks.append(task)
                print(f"ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ãŸ (åˆè¨ˆ: {len(manual_tasks)}ä»¶)")
                
                # === ãƒ‘ãƒ¼ãƒˆ3-8: ç¶™ç¶šç¢ºèª ===
                more = input("ã•ã‚‰ã«ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã™ã‹? (y/n): ").lower()
                if more != 'y':
                    break
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ä½œæˆçµæœã®è¡¨ç¤º ===
            if manual_tasks:
                print(f"\nä½œæˆã—ãŸã‚¿ã‚¹ã‚¯ ({len(manual_tasks)}ä»¶):")
                self.display_suggested_tasks(manual_tasks)
                
            return manual_tasks
            
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ5: ä¾‹å¤–å‡¦ç† ===
            ErrorHandler.log_error(e, "æ‰‹å‹•ã‚¿ã‚¹ã‚¯ä½œæˆ")
            return []

#task_executor_ma.py
# task_executor_ma.py
# M&A/ä¼æ¥­æ¤œç´¢å°‚ç”¨ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆå®Œå…¨ç‰ˆï¼‰

import asyncio
import logging
from typing import Dict, Optional, Any, List
from datetime import datetime
from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class MATaskExecutor:
    """M&A/ä¼æ¥­æ¤œç´¢ã‚¿ã‚¹ã‚¯å°‚ç”¨ã®å®Ÿè¡Œã‚¯ãƒ©ã‚¹ï¼ˆä¾å­˜é–¢ä¿‚æ³¨å…¥å¯¾å¿œç‰ˆï¼‰"""

    def __init__(self, sheets_manager, browser, max_iterations: int = 30, 
                 wp_agent=None, plugin_agent=None):
        """
        MATaskExecutorã®åˆæœŸåŒ–ï¼ˆç·©å’Œç‰ˆ - å¿…é ˆãƒã‚§ãƒƒã‚¯ã‚’å‰Šé™¤ï¼‰
    
        Args:
            sheets_manager: Google Sheetsãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
            browser: ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
            max_iterations: æœ€å¤§ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ•°
            wp_agent: WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå¾Œã§è¨­å®šå¯èƒ½ï¼‰
            plugin_agent: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå¾Œã§è¨­å®šå¯èƒ½ï¼‰
        """
        # === ãƒ‘ãƒ¼ãƒˆ1: åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®è¨­å®š ===
        self.sheets_manager = sheets_manager
        self.browser = browser
        self.max_iterations = max_iterations
        self.agents = {}  # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆè¾æ›¸ã‚’ç©ºã§åˆæœŸåŒ–
        self.review_agent = None
    
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¨­å®šï¼ˆå¿…é ˆãƒã‚§ãƒƒã‚¯ã‚’å‰Šé™¤ï¼‰===
        self.wp_agent = wp_agent
        self.plugin_agent = plugin_agent
    
        # === ãƒ‘ãƒ¼ãƒˆ3: é…å»¶åˆæœŸåŒ–ãƒ•ãƒ©ã‚° ===
        self._initialized = False
    
        logger.info(f"âœ… MATaskExecutor åŸºæœ¬åˆæœŸåŒ–å®Œäº† (max_iterations={max_iterations})")
        logger.info(f"   - wp_agent: {'âœ… è¨­å®šæ¸ˆã¿' if wp_agent else 'âš ï¸ æœªè¨­å®šï¼ˆå¾Œã§è¨­å®šå¯èƒ½ï¼‰'}")
        logger.info(f"   - plugin_agent: {'âœ… è¨­å®šæ¸ˆã¿' if plugin_agent else 'âš ï¸ æœªè¨­å®šï¼ˆå¾Œã§è¨­å®šå¯èƒ½ï¼‰'}")

    def set_wordpress_agent(self, wp_agent):
        """WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å¾Œã‹ã‚‰è¨­å®š"""
        if not wp_agent:
            logger.error("âŒ è¨­å®šã™ã‚‹WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒNoneã§ã™")
            return False
    
        self.wp_agent = wp_agent
        self.agents['wordpress'] = wp_agent
        logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å¾Œã‹ã‚‰è¨­å®šã—ã¾ã—ãŸ")
    
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚‚è‡ªå‹•ç™»éŒ²
        if hasattr(wp_agent, 'plugin_manager') and wp_agent.plugin_manager:
            self.plugin_agent = wp_agent.plugin_manager
            self.agents['plugin'] = wp_agent.plugin_manager
            logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’è‡ªå‹•ç™»éŒ²ã—ã¾ã—ãŸ")
    
        self._initialized = True
        return True

    def set_plugin_agent(self, plugin_agent):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å¾Œã‹ã‚‰è¨­å®š"""
        if not plugin_agent:
            logger.error("âŒ è¨­å®šã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒNoneã§ã™")
            return False
    
        self.plugin_agent = plugin_agent
        self.agents['plugin'] = plugin_agent
        logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å¾Œã‹ã‚‰è¨­å®šã—ã¾ã—ãŸ")
        return True

    def ensure_agents_ready(self):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒæº–å‚™ã§ãã¦ã„ã‚‹ã‹ç¢ºèª"""
        if not self.wp_agent:
            logger.error("âŒ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã¾ã è¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        return True
    
    def _register_core_agents(self):
        """ã‚³ã‚¢ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’è‡ªå‹•ç™»éŒ²"""
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
        self.agents['wordpress'] = self.wp_agent
        logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰
        if self.plugin_agent:
            self.agents['plugin'] = self.plugin_agent
            logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
        elif hasattr(self.wp_agent, 'plugin_manager') and self.wp_agent.plugin_manager:
            self.agents['plugin'] = self.wp_agent.plugin_manager
            logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
        else:
            logger.warning("âš ï¸ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
    # === è¿½åŠ ãƒ¡ã‚½ãƒƒãƒ‰: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²æ©Ÿèƒ½ ===
    def register_agent(self, agent_name: str, agent):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.agents[agent_name] = agent
        logger.info(f"âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{agent_name}' ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
    
    def register_review_agent(self, review_agent):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²"""
        self.review_agent = review_agent
        self.agents['review'] = review_agent
        logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
    # ========================================
    async def load_pending_tasks(self):
        """
        ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã‚€
        
        Returns:
            List[Dict]: pendingã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ
        """
        try:
            logger.info("ğŸ“‹ ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿ä¸­...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("ğŸ”­ pm_tasksã‚·ãƒ¼ãƒˆã«ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                return []
            
            # statusãŒ'pending'ã®ã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"ğŸ“Š ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯: {len(pending_tasks)}ä»¶")
            return pending_tasks
            
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return []
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
    # ========================================
    async def execute_task(self, task: Dict) -> bool:
        """
        ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆåŸºæœ¬çš„ãªå®Ÿè£…ï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            bool: å®Ÿè¡ŒæˆåŠŸãƒ•ãƒ©ã‚°
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info(f"ğŸ¯ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: {task_id}")
            
            # M&Aã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ
            result = await self.execute_ma_task(task)
            
            if result and result.get('success'):
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
                return True
            else:
                error = result.get('error', 'ä¸æ˜') if result else 'çµæœãªã—'
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {error}")
                return False
                
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    # ========================================
    # âœ… ã“ã“ã«è¿½åŠ : å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
    # ========================================
    async def run_all_tasks(self, auto_continue: bool = True, enable_review: bool = True) -> Dict[str, Any]:
        """
        å…¨ã‚¿ã‚¹ã‚¯ã‚’ä¸€æ‹¬å®Ÿè¡Œ
        
        Args:
            auto_continue: è‡ªå‹•ç¶™ç¶šãƒ•ãƒ©ã‚°
            enable_review: ãƒ¬ãƒ“ãƒ¥ãƒ¼æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°
            
        Returns:
            Dict: å®Ÿè¡Œçµæœã‚µãƒãƒªãƒ¼
        """
        from datetime import datetime
        
        logger.info("\n" + "="*80)
        logger.info("ğŸš€ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™")
        logger.info("="*80 + "\n")
        
        summary = {
            'total': 0,
            'success': 0,
            'failed': 0,
            'skipped': 0,
            'results': [],
            'start_time': datetime.now(),
            'end_time': None
        }
        
        try:
            # ä¿ç•™ä¸­ã®ã‚¿ã‚¹ã‚¯ã‚’èª­ã¿è¾¼ã¿
            pending_tasks = await self.load_pending_tasks()
            
            if not pending_tasks:
                logger.info("ğŸ”­ å®Ÿè¡Œã™ã¹ãã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“")
                summary['end_time'] = datetime.now()
                return summary
            
            summary['total'] = len(pending_tasks)
            logger.info(f"ğŸ“Š å®Ÿè¡Œå¯¾è±¡ã‚¿ã‚¹ã‚¯: {summary['total']}ä»¶\n")
            
            # ã‚¿ã‚¹ã‚¯ã‚’é †ç•ªã«å®Ÿè¡Œ
            for index, task in enumerate(pending_tasks, 1):
                task_id = task.get('task_id', 'UNKNOWN')
                
                logger.info(f"\n{'â”€'*80}")
                logger.info(f"ğŸ“Œ ã‚¿ã‚¹ã‚¯ {index}/{summary['total']}: {task_id}")
                logger.info(f"{'â”€'*80}")
                
                try:
                    success = await self.execute_task(task)
                    
                    task_result = {
                        'task_id': task_id,
                        'success': success,
                        'index': index,
                        'timestamp': datetime.now()
                    }
                    summary['results'].append(task_result)
                    
                    if success:
                        summary['success'] += 1
                        logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} æˆåŠŸ ({index}/{summary['total']})")
                    else:
                        summary['failed'] += 1
                        logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ {task_id} å¤±æ•— ({index}/{summary['total']})")
                    
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    summary['failed'] += 1
                    logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¨ãƒ©ãƒ¼: {e}")
            
            summary['end_time'] = datetime.now()
            elapsed_time = (summary['end_time'] - summary['start_time']).total_seconds()
            
            logger.info("\n" + "="*80)
            logger.info("ğŸ“Š å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå®Œäº†")
            logger.info("="*80)
            logger.info(f"  ç·ã‚¿ã‚¹ã‚¯æ•°:   {summary['total']:>3}ä»¶")
            logger.info(f"  âœ… æˆåŠŸ:      {summary['success']:>3}ä»¶")
            logger.info(f"  âŒ å¤±æ•—:      {summary['failed']:>3}ä»¶")
            logger.info(f"  â±ï¸  å®Ÿè¡Œæ™‚é–“:  {elapsed_time:.2f}ç§’")
            logger.info("="*80 + "\n")
            
            if summary['total'] > 0:
                success_rate = (summary['success'] / summary['total']) * 100
                logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
            
            return summary
            
        except Exception as e:
            logger.error(f"âŒ å…¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            summary['end_time'] = datetime.now()
            return summary

    async def execute_ma_task(self, task: Dict) -> Dict:
        """
        M&Aé–¢é€£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
    
        ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã‚’è§£æã—ã¦ã€é©åˆ‡ãªãƒ¡ã‚½ãƒƒãƒ‰ã«æŒ¯ã‚Šåˆ†ã‘ã‚‹
        """
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å®Ÿè¡Œé–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼ ===
            logger.info("="*60)
            logger.info("ğŸ“Š M&Aæ¡ˆä»¶å‡¦ç†ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            logger.info("="*60)
        
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å†…å®¹ã®è§£æ ===
            description = task.get('description', '').lower()
            parameters = task.get('parameters', {})
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆ¤å®šï¼ˆæœ€ã‚‚ç¢ºå®Ÿï¼‰===
            if 'cpt_slug' in parameters or 'cpt_labels' in parameters:
                logger.info("â†’ Custom Post Typeä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_cpt_creation(task)
        
            elif 'acf_field_group_name' in parameters or 'acf_fields' in parameters:
                logger.info("â†’ ACFè¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy_slug' in parameters or 'taxonomy_labels' in parameters:
                logger.info("â†’ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_taxonomy_creation(task)
        
            elif 'facets' in parameters or 'facetwp' in description:
                logger.info("â†’ æ¤œç´¢æ©Ÿèƒ½è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_search_setup(task)
        
            elif 'role_slug' in parameters or 'role_name' in parameters:
                logger.info("â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_user_role_setup(task)
        
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®åˆ¤å®š ===
            elif 'custom post type' in description or 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—' in description:
                logger.info("â†’ Custom Post Typeä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®šï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰")
                return await self._execute_cpt_creation(task)
        
            elif 'acf' in description or 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰' in description:
                logger.info("â†’ ACFè¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®šï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰")
                return await self._execute_acf_setup(task)
        
            elif 'taxonomy' in description or 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼' in description:
                logger.info("â†’ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã¨åˆ¤å®šï¼ˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼‰")
                return await self._execute_taxonomy_creation(task)
        
            elif 'm&aæ¡ˆä»¶' in description or 'ma_case' in description:
                logger.info("â†’ M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_ma_case_post(task)
        
            elif 'æ¤œç´¢' in description or 'search' in description:
                logger.info("â†’ æ¤œç´¢æ©Ÿèƒ½è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_search_setup(task)
        
            elif 'user role' in description or 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«' in description:
                logger.info("â†’ ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã‚¿ã‚¹ã‚¯ã¨åˆ¤å®š")
                return await self._execute_user_role_setup(task)
        
            else:
                # === ãƒ‘ãƒ¼ãƒˆ5: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç† ===
                logger.info("â†’ æ±ç”¨WordPressã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                wp_agent = self.agents.get('wordpress')
                if wp_agent:
                    return await wp_agent.process_task(task)
                else:
                    return {
                        'success': False,
                        'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                    }
    
        except Exception as e:
            # === ãƒ‘ãƒ¼ãƒˆ6: ä¾‹å¤–å‡¦ç† ===
            ErrorHandler.log_error(e, "M&Aã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_cpt_creation(self, task: Dict) -> Dict:
        """Custom Post Typeä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€Custom Post Typeä½œæˆã€‘")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'cpt_slug': parameters.get('cpt_slug', 'ma_case'),
            'cpt_labels': parameters.get('cpt_labels', {
                'singular': 'M&Aæ¡ˆä»¶',
                'plural': 'M&Aæ¡ˆä»¶ä¸€è¦§'
            }),
            'cpt_supports': parameters.get('cpt_supports', ['title', 'editor', 'thumbnail', 'custom-fields']),
            'cpt_settings': parameters.get('cpt_settings', {
                'public': True,
                'has_archive': True,
                'show_in_rest': True,
                'menu_icon': 'dashicons-portfolio'
            })
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'configure_custom_post_type'):
            result = await wp_agent.configure_custom_post_type(task_params)
        else:
            logger.warning("configure_custom_post_type ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_acf_setup(self, task: Dict) -> Dict:
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šã€‘")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'acf_field_group_name': parameters.get('acf_field_group_name', 'M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±'),
            'acf_fields': parameters.get('acf_fields', [
                {'name': 'case_id', 'type': 'text', 'label': 'æ¡ˆä»¶ID'},
                {'name': 'ma_scheme', 'type': 'select', 'label': 'M&Aã‚¹ã‚­ãƒ¼ãƒ '},
                {'name': 'desired_price', 'type': 'number', 'label': 'å¸Œæœ›ä¾¡æ ¼'},
                {'name': 'industry_category', 'type': 'taxonomy', 'label': 'æ¥­ç¨®'},
                {'name': 'region', 'type': 'taxonomy', 'label': 'åœ°åŸŸ'},
                {'name': 'established_year', 'type': 'number', 'label': 'è¨­ç«‹å¹´'},
                {'name': 'employees', 'type': 'number', 'label': 'å¾“æ¥­å“¡æ•°'},
            ]),
            'acf_location_rules': parameters.get('acf_location_rules', {
                'post_type': 'ma_case'
            })
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'configure_acf_fields'):
            result = await wp_agent.configure_acf_fields(task_params)
        else:
            logger.warning("configure_acf_fields ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await wp_agent.process_task(task)
        
        return result
    
    async def _execute_taxonomy_creation(self, task: Dict) -> Dict:
        """ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã€‘")
        
        wp_agent = self.agents.get('wordpress')
        if not wp_agent:
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
            }
        
        parameters = task.get('parameters', {})
        
        # ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
        task_params = {
            'taxonomy_slug': parameters.get('taxonomy_slug', 'industry_category'),
            'taxonomy_labels': parameters.get('taxonomy_labels', {
                'singular': 'æ¥­ç¨®',
                'plural': 'æ¥­ç¨®ä¸€è¦§'
            }),
            'taxonomy_post_types': parameters.get('taxonomy_post_types', ['ma_case']),
            'taxonomy_hierarchical': parameters.get('taxonomy_hierarchical', True)
        }
        
        # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(wp_agent, 'configure_custom_taxonomy'):
            result = await wp_agent.configure_custom_taxonomy(task_params)
        else:
            logger.warning("configure_custom_taxonomy ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await wp_agent.process_task(task)
        
        return result
    
    # === ä¿®æ­£: M&Aæ¡ˆä»¶æŠ•ç¨¿ãƒ¡ã‚½ãƒƒãƒ‰ ===
    async def _execute_ma_case_post(self, task: Dict) -> Dict:
        """M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰"""
        logger.info("ã€M&Aæ¡ˆä»¶æŠ•ç¨¿ã€‘")

        # === ãƒ‘ãƒ¼ãƒˆ1: è¤‡æ•°ã®æ–¹æ³•ã§WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å–å¾— ===
        wp_agent = None
        
        # æ–¹æ³•1: ç›´æ¥å±æ€§ã‹ã‚‰å–å¾—
        if hasattr(self, 'wp_agent') and self.wp_agent:
            wp_agent = self.wp_agent
            logger.info("âœ… wp_agent å±æ€§ã‹ã‚‰å–å¾—")
        
        # æ–¹æ³•2: agentsè¾æ›¸ã‹ã‚‰å–å¾—
        elif 'wordpress' in self.agents and self.agents['wordpress']:
            wp_agent = self.agents['wordpress']
            logger.info("âœ… agentsè¾æ›¸ã‹ã‚‰å–å¾—")
        
        # æ–¹æ³•3: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ - ç™»éŒ²æ¸ˆã¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰æ¤œç´¢
        else:
            logger.error("âŒ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ç™»éŒ²çŠ¶æ³:")
            for agent_name, agent_instance in self.agents.items():
                logger.error(f"  - {agent_name}: {agent_instance}")
            
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ä»¥ä¸‹ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã¿ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™: ' + 
                        ', '.join(self.agents.keys())
            }

        if not wp_agent:
            logger.error("âŒ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—")
            return {
                'success': False,
                'error': 'WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'
            }

        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ§‹ç¯‰ ===
        parameters = task.get('parameters', {})
        
        task_params = {
            'post_type': 'ma_case',
            'post_title': parameters.get('post_title', 'æ–°è¦M&Aæ¡ˆä»¶'),
            'post_content': parameters.get('post_content', ''),
            'acf_fields': parameters.get('acf_fields', {}),
            'polylang_lang': parameters.get('polylang_lang', 'ja'),
            'post_status': parameters.get('post_status', 'draft')
        }
        
        # === ãƒ‘ãƒ¼ãƒˆ3: WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ ===
        try:
            logger.info(f"ğŸ“ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ: {task_params['post_title']}")
            
            if hasattr(wp_agent, 'create_ma_case_post'):
                result = await wp_agent.create_ma_case_post(task_params)
            else:
                logger.warning("âš ï¸ create_ma_case_post ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€process_task ã‚’ä½¿ç”¨")
                modified_task = task.copy()
                modified_task['parameters'] = task_params
                result = await wp_agent.process_task(modified_task)
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ M&Aæ¡ˆä»¶æŠ•ç¨¿å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_search_setup(self, task: Dict) -> Dict:
        """æ¤œç´¢æ©Ÿèƒ½è¨­å®šã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆï¼‰"""
        logger.info("ã€æ¤œç´¢æ©Ÿèƒ½è¨­å®šã€‘")

        # === ãƒ‘ãƒ¼ãƒˆ1: è¤‡æ•°ã®æ–¹æ³•ã§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å–å¾— ===
        plugin_agent = None
        
        # æ–¹æ³•1: ç›´æ¥å±æ€§ã‹ã‚‰å–å¾—
        if hasattr(self, 'plugin_agent') and self.plugin_agent:
            plugin_agent = self.plugin_agent
            logger.info("âœ… plugin_agent å±æ€§ã‹ã‚‰å–å¾—")
        
        # æ–¹æ³•2: agentsè¾æ›¸ã‹ã‚‰å–å¾—
        elif 'plugin' in self.agents and self.agents['plugin']:
            plugin_agent = self.agents['plugin']
            logger.info("âœ… agentsè¾æ›¸ã‹ã‚‰å–å¾—")
        
        # æ–¹æ³•3: WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰å–å¾—
        elif hasattr(self, 'wp_agent') and self.wp_agent and hasattr(self.wp_agent, 'plugin_manager'):
            plugin_agent = self.wp_agent.plugin_manager
            logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰plugin_managerã‚’å–å¾—")
        
        # æ–¹æ³•4: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        else:
            logger.error("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ä»£æ›¿æ–¹æ³•ã‚’è©¦è¡Œ...")
            
            # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ç›´æ¥å‡¦ç†ã‚’è©¦ã¿ã‚‹
            if hasattr(self, 'wp_agent') and self.wp_agent:
                logger.info("ğŸ”§ WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ç›´æ¥å‡¦ç†")
                return await self.wp_agent.process_task(task)
            else:
                logger.error("âŒ ä»£æ›¿æ–¹æ³•ã‚‚å¤±æ•—")
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚‚åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚'
                }

        if not plugin_agent:
            logger.error("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—")
            return {
                'success': False,
                'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ'
            }

        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ ===
        parameters = task.get('parameters', {})
        
        task_params = {
            'plugin_name': 'facetwp',
            'action': 'configure',
            'facets': parameters.get('facets', [
                {
                    'name': 'æ¥­ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
                    'type': 'checkboxes',
                    'source': 'tax/industry_category'
                },
                {
                    'name': 'ä¾¡æ ¼å¸¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼', 
                    'type': 'slider',
                    'source': 'cf/desired_price'
                }
            ])
        }
        
        try:
            logger.info("ğŸ”§ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§è¨­å®šå®Ÿè¡Œ")
            
            if hasattr(plugin_agent, 'configure_facetwp'):
                result = await plugin_agent.configure_facetwp(task_params)
            else:
                logger.warning("âš ï¸ configure_facetwp ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€change_plugin_settings ã‚’ä½¿ç”¨")
                result = await plugin_agent.change_plugin_settings(None, task)
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ æ¤œç´¢æ©Ÿèƒ½è¨­å®šå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_user_role_setup(self, task: Dict) -> Dict:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«è¨­å®šã€‘")
    
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä»˜ãï¼‰ ===
        plugin_agent = self.agents.get('plugin')
    
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒãªã„å ´åˆã€WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
        if not plugin_agent:
            logger.warning("âš ï¸ plugin ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç›´æ¥ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        
            wp_agent = self.agents.get('wordpress')
            if wp_agent and hasattr(wp_agent, 'plugin_manager'):
                plugin_agent = wp_agent.plugin_manager
                logger.info("âœ… WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰plugin_managerã‚’å–å¾—ã—ã¾ã—ãŸ")
            else:
                logger.error("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
                }
        
        parameters = task.get('parameters', {})
        
        # User Role Editorè¨­å®šã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ
        task_params = {
            'plugin_name': 'user-role-editor',
            'action': 'configure',
            'role_slug': parameters.get('role_slug', 'ma_partner'),
            'role_name': parameters.get('role_name', 'ææºãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼'),
            'capabilities': parameters.get('capabilities', {
                'read': True,
                'edit_posts': True,
                'delete_posts': True,
                'edit_published_posts': True,
                'publish_posts': False
            })
        }
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§å®Ÿè¡Œ
        if hasattr(plugin_agent, 'configure_user_roles'):
            result = await plugin_agent.configure_user_roles(None, task_params)
        else:
            logger.warning("configure_user_roles ãƒ¡ã‚½ãƒƒãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            result = await plugin_agent.change_plugin_settings(None, task)
        
        return result
    
def validate_ma_task(self, task: Dict) -> tuple[bool, Optional[str]]:
    """
    M&Aã‚¿ã‚¹ã‚¯ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ¤œè¨¼
        
    Returns:
        (valid: bool, error_message: Optional[str])
    """
    try:
        parameters = task.get('parameters', {})
            
        # === ãƒ‘ãƒ¼ãƒˆ1: Custom Post Typeä½œæˆã®æ¤œè¨¼ ===
        if 'cpt_slug' in parameters:
            if not parameters['cpt_slug']:
                return False, "cpt_slugãŒç©ºã§ã™"
            if not parameters['cpt_slug'].replace('_', '').isalnum():
                return False, "cpt_slugã¯è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™"
            
        # === ãƒ‘ãƒ¼ãƒˆ2: ACFè¨­å®šã®æ¤œè¨¼ ===
        if 'acf_field_group_name' in parameters:
            if not parameters['acf_field_group_name']:
                return False, "acf_field_group_nameãŒç©ºã§ã™"
                
            acf_fields = parameters.get('acf_fields', [])
            if not isinstance(acf_fields, list):
                return False, "acf_fieldsã¯ãƒªã‚¹ãƒˆå½¢å¼ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™"
                
            for field in acf_fields:
                if 'name' not in field or 'type' not in field:
                    return False, "ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯nameã¨typeãŒå¿…è¦ã§ã™"
            
        # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã®æ¤œè¨¼ ===
        if 'taxonomy_slug' in parameters:
            if not parameters['taxonomy_slug']:
                return False, "taxonomy_slugãŒç©ºã§ã™"
            if not parameters['taxonomy_slug'].replace('_', '').isalnum():
                return False, "taxonomy_slugã¯è‹±æ•°å­—ã¨ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã®ã¿ä½¿ç”¨å¯èƒ½ã§ã™"
            
        # === ãƒ‘ãƒ¼ãƒˆ4: æ¤œè¨¼æˆåŠŸ ===
        return True, None
            
    except Exception as e:
        # === ãƒ‘ãƒ¼ãƒˆ5: æ¤œè¨¼ä¸­ã®ä¾‹å¤–å‡¦ç† ===
        return False, f"æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {str(e)}"

#test_tasks.py
"""
test_tasks.py - æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç”¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆã‚¨ãƒ©ãƒ¼è¨ºæ–­å¼·åŒ–ç‰ˆï¼‰
"""

import logging
import asyncio
import argparse
import inspect
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

# åŸºæœ¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
from config_utils import config, ErrorHandler, PathManager
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController

# ãƒ­ã‚¬ãƒ¼è¨­å®š
logger = logging.getLogger(__name__)


class ClassInspector:
    """ã‚¯ãƒ©ã‚¹è¨ºæ–­ãƒ„ãƒ¼ãƒ« - å¼•æ•°ä¸ä¸€è‡´ã‚¨ãƒ©ãƒ¼ã®æ ¹æœ¬åŸå› ã‚’ç‰¹å®š"""
    
    @staticmethod
    def diagnose_class_initialization(class_obj, provided_args: Dict, class_name: str) -> Dict:
        """
        ã‚¯ãƒ©ã‚¹åˆæœŸåŒ–ã®è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
        
        Args:
            class_obj: è¨ºæ–­å¯¾è±¡ã®ã‚¯ãƒ©ã‚¹
            provided_args: æ¸¡ãã†ã¨ã—ã¦ã„ã‚‹å¼•æ•°
            class_name: ã‚¯ãƒ©ã‚¹åï¼ˆãƒ­ã‚°ç”¨ï¼‰
        
        Returns:
            è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ
        """
        try:
            # ã‚¯ãƒ©ã‚¹ã®__init__ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å–å¾—
            init_signature = inspect.signature(class_obj.__init__)
            expected_params = list(init_signature.parameters.keys())
            
            # æä¾›ã•ã‚Œã¦ã„ã‚‹å¼•æ•°
            provided_params = list(provided_args.keys())
            
            # è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ
            report = {
                'class_name': class_name,
                'expected_parameters': expected_params,
                'provided_parameters': provided_params,
                'missing_parameters': [],
                'extra_parameters': [],
                'parameter_match': False,
                'diagnosis': '',
                'recommendation': ''
            }
            
            # æœŸå¾…ã•ã‚Œã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
            for expected in expected_params[1:]:  # selfã‚’é™¤å¤–
                if expected not in provided_params:
                    report['missing_parameters'].append(expected)
            
            # ä½™åˆ†ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
            for provided in provided_params:
                if provided not in expected_params[1:]:  # selfã‚’é™¤å¤–
                    report['extra_parameters'].append(provided)
            
            # è¨ºæ–­çµæœ
            report['parameter_match'] = (len(report['missing_parameters']) == 0 and 
                                       len(report['extra_parameters']) == 0)
            
            # è¨ºæ–­ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ§‹ç¯‰
            if report['parameter_match']:
                report['diagnosis'] = "âœ… ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®Œå…¨ä¸€è‡´"
            else:
                diagnosis_parts = []
                if report['missing_parameters']:
                    diagnosis_parts.append(f"ä¸è¶³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: {report['missing_parameters']}")
                if report['extra_parameters']:
                    diagnosis_parts.append(f"ä½™åˆ†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: {report['extra_parameters']}")
                report['diagnosis'] = "âŒ " + ", ".join(diagnosis_parts)
            
            # æ¨å¥¨äº‹é …
            if not report['parameter_match']:
                report['recommendation'] = (
                    f"ä¿®æ­£ãŒå¿…è¦: {class_name}.__init__() ã‚’ç¢ºèªã—ã€"
                    f"æœŸå¾…ã•ã‚Œã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: {expected_params[1:]} ã«åˆã‚ã›ã¦ä¿®æ­£ã—ã¦ãã ã•ã„"
                )
            
            return report
            
        except Exception as e:
            return {
                'class_name': class_name,
                'error': f"è¨ºæ–­ã‚¨ãƒ©ãƒ¼: {str(e)}",
                'diagnosis': 'âŒ è¨ºæ–­å¤±æ•—',
                'recommendation': 'ã‚¯ãƒ©ã‚¹å®šç¾©ã‚’ç¢ºèªã—ã¦ãã ã•ã„'
            }


class ArgumentResolver:
    """å¼•æ•°è§£æ±ºã‚¯ãƒ©ã‚¹ - å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å¼•æ•°è¦ä»¶ã«åˆã‚ã›ã¦å‹•çš„ã«è§£æ±º"""
    
    def __init__(self, browser_controller, sheets_manager):
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        self.argument_profiles = self._build_argument_profiles()
    
    def _build_argument_profiles(self) -> Dict:
        """å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å¼•æ•°ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ§‹ç¯‰"""
        return {
            'DesignAgent': {
                'browser': self.browser,
                'browser_controller': self.browser,
                'output_folder': None
            },
            'DevAgent': {
                'browser': self.browser,
                'browser_controller': self.browser,
                'output_folder': None
            },
            'ContentWriterAgent': {
                'browser': self.browser,
                'browser_controller': self.browser,
                'output_folder': None
            },
            'ReviewAgent': {
                # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å¼•æ•°ãªã—
            },
            'WordPressAgent': {
                'browser_controller': self.browser,
                'wp_credentials': {}
            },
            'WordPressDevAgent': {
                'browser_controller': self.browser
            },
            'WordPressDesignAgent': {
                'browser_controller': self.browser
            }
        }
    
    def resolve_arguments(self, class_obj, class_name: str) -> Dict:
        """
        ã‚¯ãƒ©ã‚¹ã®å¼•æ•°è¦ä»¶ã«åŸºã¥ã„ã¦é©åˆ‡ãªå¼•æ•°ã‚’è§£æ±º
        
        Returns:
            è§£æ±ºã•ã‚ŒãŸå¼•æ•°ã®è¾æ›¸
        """
        try:
            # ã‚¯ãƒ©ã‚¹ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å–å¾—
            init_signature = inspect.signature(class_obj.__init__)
            expected_params = list(init_signature.parameters.keys())[1:]  # selfã‚’é™¤å¤–
            
            # å¼•æ•°ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è§£æ±º
            resolved_args = {}
            profile = self.argument_profiles.get(class_name, {})
            
            for param in expected_params:
                if param in profile:
                    resolved_args[param] = profile[param]
                else:
                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®å–å¾—ã‚’è©¦ã¿ã‚‹
                    param_obj = init_signature.parameters[param]
                    if param_obj.default != inspect.Parameter.empty:
                        resolved_args[param] = param_obj.default
                    else:
                        logger.warning(f"âš ï¸ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ '{param}' ã®è§£æ±ºæ–¹æ³•ãŒä¸æ˜ã§ã™")
            
            return resolved_args
            
        except Exception as e:
            logger.error(f"âŒ å¼•æ•°è§£æ±ºã‚¨ãƒ©ãƒ¼ ({class_name}): {e}")
            return {}


class TaskExecutorResolver:
    """TaskExecutorã®å‹•çš„è§£æ±ºã‚¯ãƒ©ã‚¹"""
    
    @staticmethod
    def resolve_executor():
        """åˆ©ç”¨å¯èƒ½ãªTaskExecutorã‚’è§£æ±º"""
        executor_candidates = [
            ('task_executor.task_executor_ma', 'MATaskExecutor', 'M&A'),
            ('task_executor.content_task_executor', 'ContentTaskExecutor', 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„'),
            ('task_executor.task_coordinator', 'TaskCoordinator', 'ã‚³ãƒ¼ãƒ‡ã‚£ãƒãƒ¼ã‚¿ãƒ¼'),
        ]
        
        for module_path, class_name, executor_type in executor_candidates:
            try:
                module = __import__(module_path, fromlist=[class_name])
                executor_class = getattr(module, class_name)
                logger.info(f"ğŸ main âœ… INFO {executor_type} Executor ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: {class_name}")
                return executor_class
            except (ImportError, AttributeError) as e:
                logger.debug(f"ğŸ main ğŸ› DEBUG âš ï¸ {module_path}.{class_name} ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
        
        logger.error("ğŸ main âŒ ERROR åˆ©ç”¨å¯èƒ½ãªTaskExecutorã‚¯ãƒ©ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return None


class AgentInitializer:
    """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å°‚ç”¨ã‚¯ãƒ©ã‚¹ï¼ˆè¨ºæ–­æ©Ÿèƒ½å¼·åŒ–ç‰ˆï¼‰"""
    
    def __init__(self, browser_controller: BrowserController, sheets_manager: GoogleSheetsManager):
        self.browser = browser_controller
        self.sheets_manager = sheets_manager
        self.agents = {}
        self.argument_resolver = ArgumentResolver(browser_controller, sheets_manager)
        self.diagnostic_reports = {}
    
    async def initialize_all_agents(self, settings: Dict) -> Dict[str, any]:
        """
        å…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–ï¼ˆè¨ºæ–­æ©Ÿèƒ½ä»˜ãï¼‰
        """
        logger.info("=" * 60)
        logger.info("ğŸ¤– ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–é–‹å§‹ï¼ˆè¨ºæ–­ãƒ¢ãƒ¼ãƒ‰ï¼‰")
        logger.info("=" * 60)
        
        # è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆç”¨
        initialization_summary = {
            'total_agents': 0,
            'successful': 0,
            'failed': 0,
            'diagnostic_details': []
        }
        
        # å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’é †æ¬¡åˆæœŸåŒ–
        agents_to_initialize = [
            ('design', self._init_design_agent),
            ('dev', self._init_dev_agent),
            ('review', self._init_review_agent),
            ('content_writer', self._init_content_writer_agent),
            ('wordpress', lambda: self._init_wordpress_agent(settings)),
            ('wp_dev', self._init_wp_dev_agent),
            ('wp_design', self._init_wp_design_agent),
        ]
        
        for agent_name, init_func in agents_to_initialize:
            initialization_summary['total_agents'] += 1
            success = await init_func()
            if success:
                initialization_summary['successful'] += 1
            else:
                initialization_summary['failed'] += 1
        
        # è¨ºæ–­ã‚µãƒãƒªãƒ¼ã‚’è¡¨ç¤º
        self._display_diagnostic_summary(initialization_summary)
        
        logger.info("=" * 60)
        logger.info(f"âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†: {len(self.agents)}å€‹")
        logger.info("=" * 60)
        
        return self.agents
    
    def _display_diagnostic_summary(self, summary: Dict):
        """è¨ºæ–­ã‚µãƒãƒªãƒ¼ã‚’è¡¨ç¤º"""
        logger.info("\n" + "=" * 60)
        logger.info("ğŸ” ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–è¨ºæ–­ã‚µãƒãƒªãƒ¼")
        logger.info("=" * 60)
        logger.info(f"ç·ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ•°: {summary['total_agents']}")
        logger.info(f"âœ… æˆåŠŸ: {summary['successful']}")
        logger.info(f"âŒ å¤±æ•—: {summary['failed']}")
        logger.info(f"ğŸ“Š æˆåŠŸç‡: {summary['successful']/summary['total_agents']*100:.1f}%")
        
        # è¨ºæ–­è©³ç´°ã‚’è¡¨ç¤º
        if hasattr(self, 'diagnostic_reports') and self.diagnostic_reports:
            logger.info("\nğŸ“‹ è©³ç´°è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ:")
            for agent_name, report in self.diagnostic_reports.items():
                status = "âœ…" if report.get('success', False) else "âŒ"
                logger.info(f"  {status} {agent_name}: {report.get('diagnosis', 'N/A')}")
        
        logger.info("=" * 60)
    
    async def _init_design_agent(self) -> bool:
        """è¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        return await self._initialize_agent_with_diagnosis(
            'design', 'DesignAgent', 'design_agent'
        )
    
    async def _init_dev_agent(self) -> bool:
        """é–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        return await self._initialize_agent_with_diagnosis(
            'dev', 'DevAgent', 'dev_agent'
        )
    
    async def _init_review_agent(self) -> bool:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        return await self._initialize_agent_with_diagnosis(
            'review', 'ReviewAgent', 'review_agent'
        )
    
    async def _init_content_writer_agent(self) -> bool:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        return await self._initialize_agent_with_diagnosis(
            'content_writer', 'ContentWriterAgent', 'content_writer_agent'
        )
    
    async def _init_wordpress_agent(self, settings: Dict) -> bool:
        """WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        try:
            from wordpress.wp_agent import WordPressAgent
            
            # WordPressèªè¨¼æƒ…å ±ã‚’æ§‹ç¯‰
            wp_credentials = {
                'wp_url': settings.get('wp_url', '').strip(),
                'wp_user': settings.get('wp_user', '').strip(),
                'wp_pass': settings.get('wp_pass', '').strip()
            }
            
            # å¼•æ•°ã‚’è§£æ±º
            resolved_args = self.argument_resolver.resolve_arguments(WordPressAgent, 'WordPressAgent')
            resolved_args['wp_credentials'] = wp_credentials
            
            # è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆ
            diagnostic_report = ClassInspector.diagnose_class_initialization(
                WordPressAgent, resolved_args, 'WordPressAgent'
            )
            
            logger.info(f"ğŸ” WordPressAgent è¨ºæ–­: {diagnostic_report['diagnosis']}")
            
            if not diagnostic_report['parameter_match']:
                logger.warning(f"âš ï¸ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸ä¸€è‡´: {diagnostic_report['recommendation']}")
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
            agent = WordPressAgent(**resolved_args)
            agent.sheets_manager = self.sheets_manager
            
            # WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–
            if all([wp_credentials['wp_url'], wp_credentials['wp_user'], wp_credentials['wp_pass']]):
                try:
                    await agent.initialize_wp_session()
                    logger.info("ğŸŒ wp-agent âœ… INFO WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†")
                except Exception as session_error:
                    logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å¤±æ•—: {session_error}")
            
            self.agents['wordpress'] = agent
            
            # è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆã‚’ä¿å­˜
            self.diagnostic_reports['wordpress'] = {
                'success': True,
                'diagnosis': diagnostic_report['diagnosis'],
                'details': diagnostic_report
            }
            
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressAgentåˆæœŸåŒ–å®Œäº†")
            return True
            
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            self.diagnostic_reports['wordpress'] = {
                'success': False,
                'error': str(e),
                'diagnosis': 'âŒ åˆæœŸåŒ–å¤±æ•—'
            }
            return False
    
    async def _init_wp_dev_agent(self) -> bool:
        """WordPressé–‹ç™ºã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        return await self._initialize_agent_with_diagnosis(
            'wp_dev', 'WordPressDevAgent', 'wordpress.wp_dev'
        )
    
    async def _init_wp_design_agent(self) -> bool:
        """WordPressè¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­ä»˜ãï¼‰"""
        return await self._initialize_agent_with_diagnosis(
            'wp_design', 'WordPressDesignAgent', 'wordpress.wp_design'
        )
    
    async def _initialize_agent_with_diagnosis(self, agent_key: str, class_name: str, module_path: str) -> bool:
        """
        ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã®çµ±ä¸€ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆè¨ºæ–­æ©Ÿèƒ½ä»˜ãï¼‰
        """
        try:
            # ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
            module = __import__(module_path, fromlist=[class_name])
            agent_class = getattr(module, class_name)
            
            # å¼•æ•°ã®è§£æ±º
            resolved_args = self.argument_resolver.resolve_arguments(agent_class, class_name)
            
            # è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
            diagnostic_report = ClassInspector.diagnose_class_initialization(
                agent_class, resolved_args, class_name
            )
            
            logger.info(f"ğŸ” {class_name} è¨ºæ–­: {diagnostic_report['diagnosis']}")
            
            # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸ä¸€è‡´ã®è­¦å‘Š
            if not diagnostic_report['parameter_match']:
                logger.warning(f"âš ï¸ {class_name} ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¸ä¸€è‡´:")
                logger.warning(f"   æœŸå¾…: {diagnostic_report['expected_parameters']}")
                logger.warning(f"   æä¾›: {diagnostic_report['provided_parameters']}")
                logger.warning(f"   æ¨å¥¨: {diagnostic_report['recommendation']}")
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
            agent = agent_class(**resolved_args)
            
            # sheets_managerã®è¨­å®šï¼ˆå¯èƒ½ãªå ´åˆï¼‰
            if hasattr(agent, 'sheets_manager'):
                agent.sheets_manager = self.sheets_manager
            
            self.agents[agent_key] = agent
            
            # è¨ºæ–­ãƒ¬ãƒãƒ¼ãƒˆã‚’ä¿å­˜
            self.diagnostic_reports[agent_key] = {
                'success': True,
                'diagnosis': diagnostic_report['diagnosis'],
                'details': diagnostic_report
            }
            
            logger.info(f"âœ… {agent_key} âœ… INFO {class_name}åˆæœŸåŒ–å®Œäº†")
            return True
            
        except ImportError as e:
            logger.warning(f"âš ï¸ {agent_key} âš ï¸ WARN ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {e}")
            self.diagnostic_reports[agent_key] = {
                'success': False,
                'error': f"ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¤±æ•—: {str(e)}",
                'diagnosis': 'âŒ ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æœªè¦‹ã¤ã‹ã‚Š'
            }
            return False
        except Exception as e:
            logger.error(f"âŒ {agent_key} âŒ ERROR åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            self.diagnostic_reports[agent_key] = {
                'success': False,
                'error': str(e),
                'diagnosis': 'âŒ åˆæœŸåŒ–å¤±æ•—',
                'traceback': traceback.format_exc()
            }
            return False


class TaskTester:
    """æ—¢å­˜ã‚¿ã‚¹ã‚¯ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç”¨ã‚¯ãƒ©ã‚¹ï¼ˆè¨ºæ–­æ©Ÿèƒ½å¼·åŒ–ç‰ˆï¼‰"""
    
    def __init__(self, spreadsheet_id: str, service_account_file: str = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.sheets_manager = None
        self.browser = None
        self.task_executor = None
        self.agent_initializer = None
    
    async def initialize(self):
        """ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ï¼ˆè¨ºæ–­ãƒ¢ãƒ¼ãƒ‰ï¼‰"""
        try:
            logger.info("=" * 60)
            logger.info("ğŸš€ ã‚¿ã‚¹ã‚¯ãƒ†ã‚¹ã‚¿ãƒ¼åˆæœŸåŒ–ä¸­ï¼ˆè¨ºæ–­ãƒ¢ãƒ¼ãƒ‰ï¼‰...")
            logger.info("=" * 60)
            
            # 1. Google Sheetsæ¥ç¶š
            await self._initialize_sheets()
            
            # 2. è¨­å®šèª­ã¿è¾¼ã¿
            settings = await self._load_settings()
            
            # 3. ãƒ–ãƒ©ã‚¦ã‚¶åˆæœŸåŒ–
            await self._initialize_browser(settings)
            
            # 4. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­æ©Ÿèƒ½ä»˜ãï¼‰
            await self._initialize_agents(settings)
            
            # 5. TaskExecutoråˆæœŸåŒ–
            await self._initialize_task_executor()
            
            # 6. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²
            await self._register_agents_to_executor()
            
            logger.info("=" * 60)
            logger.info("âœ… ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†")
            logger.info("=" * 60)
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "ğŸ main ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–")
            return False
    
    async def _initialize_sheets(self):
        """Google SheetsåˆæœŸåŒ–"""
        logger.info("ğŸ“Š Google Sheetsæ¥ç¶šä¸­...")
        self.sheets_manager = GoogleSheetsManager(
            self.spreadsheet_id,
            self.service_account_file
        )
    
    async def _load_settings(self):
        """è¨­å®šèª­ã¿è¾¼ã¿"""
        pc_id = self.sheets_manager.get_current_pc_id()
        settings = self.sheets_manager.load_pc_settings(pc_id)
        
        logger.info(f"âš™ï¸ config âœ… INFO PCè¨­å®šèª­ã¿è¾¼ã¿å®Œäº†: {pc_id}")
        return settings
    
    async def _initialize_browser(self, settings: Dict):
        """ãƒ–ãƒ©ã‚¦ã‚¶åˆæœŸåŒ–"""
        logger.info("ğŸŒ browser âœ… INFO ãƒ–ãƒ©ã‚¦ã‚¶åˆæœŸåŒ–ä¸­...")
        
        # å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š
        download_folder = self._setup_download_folder(settings)
        
        # ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®š
        config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
        config.COOKIES_FILE = settings.get('cookies_file')
        config.GENERATION_MODE = 'text'
        config.SERVICE_TYPE = 'google'
        
        # ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•
        self.browser = BrowserController(
            download_folder,
            mode='text',
            service='google'
        )
        await self.browser.setup_browser()
        await self.browser.navigate_to_gemini()
        
        logger.info("ğŸŒ browser âœ… INFO ãƒ–ãƒ©ã‚¦ã‚¶åˆæœŸåŒ–å®Œäº†")
    
    def _setup_download_folder(self, settings: Dict) -> Path:
        """ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒ•ã‚©ãƒ«ãƒ€è¨­å®š"""
        agent_output = settings.get('agent_output_folder')
        
        if not agent_output or agent_output.startswith('http'):
            download_folder = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
            download_folder.mkdir(exist_ok=True, parents=True)
            return download_folder
        else:
            return PathManager.get_safe_path(agent_output)
    
    async def _initialize_agents(self, settings: Dict):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆè¨ºæ–­æ©Ÿèƒ½ä»˜ãï¼‰"""
        logger.info("ğŸ¤– ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–é–‹å§‹ï¼ˆè¨ºæ–­ãƒ¢ãƒ¼ãƒ‰ï¼‰...")
        
        # AgentInitializerã‚’ä½¿ç”¨ã—ã¦è¨ºæ–­ä»˜ãã§åˆæœŸåŒ–
        self.agent_initializer = AgentInitializer(self.browser, self.sheets_manager)
        agents = await self.agent_initializer.initialize_all_agents(settings)
        
        logger.info(f"âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†: {len(agents)}å€‹")
    
    async def _initialize_task_executor(self):
        """TaskExecutoråˆæœŸåŒ–"""
        logger.info("âš™ï¸ config âœ… INFO ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–ä¸­...")
        
        executor_class = TaskExecutorResolver.resolve_executor()
        if not executor_class:
            raise ImportError("åˆ©ç”¨å¯èƒ½ãªTaskExecutorãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        
        logger.info(f"ğŸ main âœ… INFO ä½¿ç”¨ã™ã‚‹Executor: {executor_class.__name__}")
        
        # Executorã®ç¨®åˆ¥åˆ¤å®š
        is_ma_executor = 'MATaskExecutor' in executor_class.__name__
        
        # åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        init_params = {
            'sheets_manager': self.sheets_manager,
            'browser': self.browser,
            'max_iterations': 30
        }
        
        # MATaskExecutorç”¨ã®è¿½åŠ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        if is_ma_executor:
            wp_agent = self.agent_initializer.agents.get('wordpress')
            init_params.update({
                'wp_agent': wp_agent,
                'plugin_agent': None
            })
        
        self.task_executor = executor_class(**init_params)
        logger.info(f"âš™ï¸ config âœ… INFO {executor_class.__name__} åˆæœŸåŒ–å®Œäº†")
    
    async def _register_agents_to_executor(self):
        """ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²"""
        if not self.task_executor or not self.agent_initializer:
            return
        
        registration_map = {
            'design': ['design'],
            'dev': ['dev'],
            'review': ['review'],
            'content_writer': ['writer', 'content'],
            'wordpress': ['wordpress'],
            'wp_dev': ['wp_dev'],
            'wp_design': ['wp_design'],
        }
        
        for agent_name, executor_keys in registration_map.items():
            agent_instance = self.agent_initializer.agents.get(agent_name)
            if not agent_instance:
                continue
            
            for key in executor_keys:
                try:
                    self.task_executor.register_agent(key, agent_instance)
                    logger.info(f"âœ… {key} ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å®Œäº†")
                except Exception as e:
                    logger.error(f"âŒ {key} ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç™»éŒ²å¤±æ•—: {e}")
        
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ç‰¹åˆ¥ç™»éŒ²
        review_agent = self.agent_initializer.agents.get('review')
        if review_agent and hasattr(self.task_executor, 'register_review_agent'):
            self.task_executor.register_review_agent(review_agent)
            logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç‰¹åˆ¥ç™»éŒ²")

    # æ—¢å­˜ã®ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤‰æ›´ãªã—
    async def test_tasks_by_role(self, role: str, auto: bool = False):
        """ç‰¹å®šã®å½¹å‰²ã®ã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...

    async def test_all_pending_tasks(self, auto: bool = False):
        """å…¨ã¦ã®pendingã‚¿ã‚¹ã‚¯ã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""
        # å®Ÿè£…ã¯å¤‰æ›´ãªã—...

    async def cleanup(self):
        """ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.browser:
            await self.browser.cleanup()


async def main():
    """ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    # å®Ÿè£…ã¯å¤‰æ›´ãªã—...
    pass


if __name__ == "__main__":
    asyncio.run(main())

#workflow_executor.py
"""
workflow_executor.py - è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
ãƒãƒ«ãƒã‚¹ãƒ†ãƒƒãƒ—ãƒ»ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€£æºã‚¿ã‚¹ã‚¯ã‚’çµ±åˆç®¡ç†
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# è¨­å®š
from config_utils import ErrorHandler, config

# ãƒ‡ãƒ¼ã‚¿ç®¡ç†
from sheets_manager import GoogleSheetsManager

# æ—¢å­˜ã®TaskExecutor
from task_executor import TaskExecutor

logger = logging.getLogger(__name__)


class WorkflowExecutor:
    """
    è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
    
    è¤‡æ•°ã‚¹ãƒ†ãƒƒãƒ—ã€ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€£æºã€
    ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£ã‚µã‚¤ã‚¯ãƒ«ã€å¤šè¨€èªå±•é–‹ãªã©ã‚’çµ±åˆç®¡ç†
    """
    
    def __init__(
        self,
        task_executor: TaskExecutor,
        sheets_manager: GoogleSheetsManager,
        browser_controller=None
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            task_executor: æ—¢å­˜ã®TaskExecutorã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
        """
        self.task_executor = task_executor
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        
        # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±è¨ˆ
        self.workflow_stats = {
            'total_workflows': 0,
            'completed': 0,
            'failed': 0,
            'partial_success': 0
        }
        
        logger.info("âœ… WorkflowExecutor åˆæœŸåŒ–å®Œäº†")
    
    async def execute_workflow_task(self, task: Dict) -> Dict:
        """
        ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        workflow_type = self._determine_workflow_type(task)
        
        self.workflow_stats['total_workflows'] += 1
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ”„ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œé–‹å§‹: {task_id}")
            logger.info(f"ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—: {workflow_type}")
            logger.info("=" * 60)
            
            result = None
            
            # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ
            if workflow_type == 'multilingual':
                result = await self._execute_multilingual_workflow(task)
            elif workflow_type == 'review_cycle':
                result = await self._execute_review_cycle_workflow(task)
            elif workflow_type == 'sequential':
                result = await self._execute_sequential_workflow(task)
            elif workflow_type == 'parallel':
                result = await self._execute_parallel_workflow(task)
            elif workflow_type == 'conditional':
                result = await self._execute_conditional_workflow(task)
            else:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«å®Ÿè¡Œ
                result = await self._execute_sequential_workflow(task)
            
            # çµ±è¨ˆæ›´æ–°
            if result and result.get('success'):
                self.workflow_stats['completed'] += 1
            elif result and result.get('partial_success'):
                self.workflow_stats['partial_success'] += 1
            else:
                self.workflow_stats['failed'] += 1
            
            return result
        
        except Exception as e:
            logger.error(f"âŒ ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ {task_id} å®Ÿè¡Œã‚¨ãƒ©ãƒ¼")
            ErrorHandler.log_error(e, f"WorkflowExecutor.execute_workflow_task({task_id})")
            self.workflow_stats['failed'] += 1
            return {
                'success': False,
                'error': str(e)
            }
    
    def _determine_workflow_type(self, task: Dict) -> str:
        """
        ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            str: ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¿ã‚¤ãƒ—
        """
        description = task.get('description', '').lower()
        
        # å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['å¤šè¨€èª', 'ç¿»è¨³', 'multilingual', 'translation']):
            return 'multilingual'
        
        # ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£', 'review cycle', 'iterative review']):
            return 'review_cycle'
        
        # ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['ä¸¦åˆ—', 'åŒæ™‚', 'parallel', 'concurrent']):
            return 'parallel'
        
        # æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        if any(kw in description for kw in ['æ¡ä»¶', 'åˆ†å²', 'conditional', 'if-then']):
            return 'conditional'
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«
        return 'sequential'
    
    async def _execute_multilingual_workflow(self, task: Dict) -> Dict:
        """
        å¤šè¨€èªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆPolylangé€£æºå¼·åŒ–ç‰ˆï¼‰
            
        1. æ—¥æœ¬èªè¨˜äº‹ç”Ÿæˆ
        2. è‹±èªç¿»è¨³
        3. ãã®ä»–è¨€èªç¿»è¨³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
        4. WordPresså¤šè¨€èªæŠ•ç¨¿ï¼ˆPolylangé€£æºï¼‰
            
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
                
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
            
        try:
            logger.info("ğŸŒ å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œï¼ˆPolylangé€£æºç‰ˆï¼‰")
                
            # ã‚¿ãƒ¼ã‚²ãƒƒãƒˆè¨€èªãƒªã‚¹ãƒˆ
            target_languages = task.get('target_languages', ['ja', 'en'])
            base_language = task.get('base_language', 'ja')
                
            # Polylangè¨€èªã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°
            polylang_lang_codes = {
                'ja': 'ja',
                'en': 'en',
                'uz': 'uz_UZ',  # ã‚¦ã‚ºãƒ™ã‚¯èª
                'ru': 'ru_RU',  # ãƒ­ã‚·ã‚¢èª
                'tr': 'tr_TR',  # ãƒˆãƒ«ã‚³èª
                'zh': 'zh_CN',  # ä¸­å›½èª
                'ko': 'ko_KR'   # éŸ“å›½èª
            }
                
            results = {}
            contents = {}
            post_ids = {}  # æŠ•ç¨¿IDã‚’ä¿å­˜ï¼ˆPolylangé€£æºç”¨ï¼‰
                
            # ========================================
            # ã‚¹ãƒ†ãƒƒãƒ—1: åŸºæœ¬è¨€èªã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
            # ========================================
            logger.info(f"--- ã‚¹ãƒ†ãƒƒãƒ—1: {base_language} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ ---")
                
            base_task = {
                **task,
                'task_id': f"{task_id}_base_{base_language}",
                'language': base_language,
                'required_role': 'content'
            }
                
            base_result = await self.task_executor.execute_task(base_task)
                
            if not base_result:
                return {
                    'success': False,
                    'error': f'{base_language} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—'
                }
                
            results[base_language] = base_result
                
            # åŸºæœ¬ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å–å¾—
            base_content = ""
            if hasattr(base_result, 'get'):
                base_content = base_result.get('full_text', base_result.get('content', ''))
                
            contents[base_language] = base_content
                
            # ========================================
            # ã‚¹ãƒ†ãƒƒãƒ—2: ä»–è¨€èªã¸ã®ç¿»è¨³
            # ========================================
            for lang in target_languages:
                if lang == base_language:
                    continue
                    
                logger.info(f"--- ã‚¹ãƒ†ãƒƒãƒ—2-{lang}: {lang} ç¿»è¨³ ---")
                    
                translation_task = {
                    'task_id': f"{task_id}_translate_{lang}",
                    'description': f'{base_language}ã‹ã‚‰{lang}ã«ç¿»è¨³',
                    'prompt': f'ä»¥ä¸‹ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’{lang}ã«ç¿»è¨³ã—ã¦ãã ã•ã„:\n\n{base_content}',
                    'required_role': 'content',
                    'language': lang,
                    'source_language': base_language,
                    'target_language': lang,
                    'source_text': base_content
                }
                    
                translate_result = await self.task_executor.execute_task(translation_task)
                    
                results[lang] = translate_result
                    
                if translate_result and hasattr(translate_result, 'get'):
                    translated_content = translate_result.get('full_text', translate_result.get('content', ''))
                    contents[lang] = translated_content
                else:
                    logger.warning(f"âš ï¸ {lang} ç¿»è¨³å¤±æ•—")
                    
                await asyncio.sleep(2)
                
            # ========================================
            # ã‚¹ãƒ†ãƒƒãƒ—3: WordPresså¤šè¨€èªæŠ•ç¨¿ï¼ˆPolylangé€£æºå¼·åŒ–ç‰ˆï¼‰
            # ========================================
            if task.get('auto_publish', False):
                logger.info("--- ã‚¹ãƒ†ãƒƒãƒ—3: WordPresså¤šè¨€èªæŠ•ç¨¿ï¼ˆPolylangé€£æºï¼‰ ---")
                    
                # 3-1: åŸºæœ¬è¨€èªã®æŠ•ç¨¿ã‚’ä½œæˆ
                base_lang_code = polylang_lang_codes.get(base_language, base_language)
                base_wp_task = {
                    'task_id': f"{task_id}_publish_{base_language}",
                    'description': f'{base_language} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’WordPressã«æŠ•ç¨¿',
                    'required_role': 'wordpress',
                    'language': base_language,
                    'polylang_lang': base_lang_code,
                    'post_action': 'create',
                    'post_title': task.get('post_title', f'è¨˜äº‹_{base_language}'),
                    'post_content': contents.get(base_language, ''),
                    'post_status': 'draft'  # ä¸‹æ›¸ãã§ä½œæˆ
                }
                    
                base_publish_result = await self.task_executor.execute_task(base_wp_task)
                results[f'{base_language}_publish'] = base_publish_result
                    
                # æŠ•ç¨¿IDã‚’å–å¾—
                if base_publish_result and hasattr(base_publish_result, 'get'):
                    base_post_id = base_publish_result.get('post_id')
                    if base_post_id:
                        post_ids[base_language] = base_post_id
                        logger.info(f"âœ… {base_language} æŠ•ç¨¿ID: {base_post_id}")
                    
                await asyncio.sleep(2)
                    
                # 3-2: ç¿»è¨³æŠ•ç¨¿ã‚’ä½œæˆã—ã€Polylangã§é€£æº
                for lang, content in contents.items():
                    if lang == base_language or not content:
                        continue
                        
                    lang_code = polylang_lang_codes.get(lang, lang)
                        
                    wp_task = {
                        'task_id': f"{task_id}_publish_{lang}",
                        'description': f'{lang} ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’WordPressã«æŠ•ç¨¿ï¼ˆPolylangé€£æºï¼‰',
                        'required_role': 'wordpress',
                        'language': lang,
                        'polylang_lang': lang_code,
                        'post_action': 'create',
                        'post_title': task.get('post_title', f'è¨˜äº‹_{lang}'),
                        'post_content': content,
                        'post_status': 'draft',
                        # ========================================
                        # ğŸ†• Polylangé€£æºãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆæ–°è¦è¿½åŠ ï¼‰
                        # ========================================
                        'polylang_link_to': post_ids.get(base_language),  # åŸºæœ¬è¨€èªã®æŠ•ç¨¿IDã¨ãƒªãƒ³ã‚¯
                        'polylang_translation_group': task_id  # ç¿»è¨³ã‚°ãƒ«ãƒ¼ãƒ—ID
                    }
                        
                    publish_result = await self.task_executor.execute_task(wp_task)
                    results[f'{lang}_publish'] = publish_result
                        
                    # æŠ•ç¨¿IDã‚’å–å¾—
                    if publish_result and hasattr(publish_result, 'get'):
                        post_id = publish_result.get('post_id')
                        if post_id:
                            post_ids[lang] = post_id
                            logger.info(f"âœ… {lang} æŠ•ç¨¿ID: {post_id}")
                        
                    await asyncio.sleep(2)
                    
                # ========================================
                # ğŸ†• ã‚¹ãƒ†ãƒƒãƒ—3-3: Polylangç¿»è¨³ãƒªãƒ³ã‚¯ã®è¨­å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰
                # ========================================
                if len(post_ids) > 1:
                    logger.info("--- ã‚¹ãƒ†ãƒƒãƒ—3-3: Polylangç¿»è¨³ãƒªãƒ³ã‚¯è¨­å®š ---")
                        
                    polylang_link_task = {
                        'task_id': f"{task_id}_polylang_link",
                        'description': 'Polylangç¿»è¨³ãƒªãƒ³ã‚¯ã‚’è¨­å®š',
                        'required_role': 'wordpress',
                        'action': 'polylang_link_translations',
                        'post_ids': post_ids,  # {'ja': 123, 'en': 124, ...}
                        'translation_group': task_id
                    }
                        
                    link_result = await self.task_executor.execute_task(polylang_link_task)
                    results['polylang_link'] = link_result
                        
                    if link_result and hasattr(link_result, 'get') and link_result.get('success'):
                        logger.info("âœ… Polylangç¿»è¨³ãƒªãƒ³ã‚¯è¨­å®šå®Œäº†")
                    else:
                        logger.warning("âš ï¸ Polylangç¿»è¨³ãƒªãƒ³ã‚¯è¨­å®šå¤±æ•—ï¼ˆæ‰‹å‹•ã§è¨­å®šãŒå¿…è¦ï¼‰")
                
            # ========================================
            # çµæœé›†ç´„
            # ========================================
            success_count = sum(1 for r in results.values() if r and (r is True or (hasattr(r, 'get') and r.get('success'))))
            total_count = len(results)
                
            logger.info(f"âœ… å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Œäº†: {success_count}/{total_count} æˆåŠŸ")
                
            return {
                'success': success_count == total_count,
                'partial_success': success_count > 0 and success_count < total_count,
                'results': results,
                'contents': contents,
                'post_ids': post_ids,  # æŠ•ç¨¿IDæƒ…å ±ã‚’è¿½åŠ 
                'summary': f'{success_count}/{total_count} è¨€èªã§æˆåŠŸï¼ˆæŠ•ç¨¿æ•°: {len(post_ids)}ï¼‰',
                'full_text': '\n\n---\n\n'.join([f'[{lang}]\n{content}' for lang, content in contents.items()])
            }
            
        except Exception as e:
            logger.error(f"âŒ å¤šè¨€èªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_multilingual_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_review_cycle_workflow(self, task: Dict) -> Dict:
        """
        ãƒ¬ãƒ“ãƒ¥ãƒ¼â†’ä¿®æ­£ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        
        1. ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
        2. ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
        3. ä¿®æ­£æŒ‡ç¤ºã«åŸºã¥ã„ã¦å†ç”Ÿæˆ
        4. æœ€çµ‚æ‰¿èªã¾ã§ç¹°ã‚Šè¿”ã—
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        max_iterations = task.get('max_review_iterations', 3)
        
        try:
            logger.info("ğŸ”„ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            
            iteration = 0
            current_content = None
            review_history = []
            
            while iteration < max_iterations:
                iteration += 1
                logger.info(f"--- ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ« {iteration}/{max_iterations} ---")
                
                # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆï¼ˆåˆå›ï¼‰ã¾ãŸã¯ä¿®æ­£ï¼ˆ2å›ç›®ä»¥é™ï¼‰
                if iteration == 1:
                    logger.info("åˆå›ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ")
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'required_role': 'content'
                    }
                else:
                    logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã«åŸºã¥ãä¿®æ­£")
                    last_review = review_history[-1]
                    feedback = last_review.get('feedback', '')
                    
                    content_task = {
                        **task,
                        'task_id': f"{task_id}_content_v{iteration}",
                        'prompt': f'{task.get("prompt", "")}\n\nå‰å›ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯:\n{feedback}\n\nä¸Šè¨˜ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’åæ˜ ã—ã¦ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚',
                        'required_role': 'content'
                    }
                
                content_result = await self.task_executor.execute_task(content_task)
                
                if not content_result:
                    logger.error("ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆå¤±æ•—")
                    break
                
                if hasattr(content_result, 'get'):
                    current_content = content_result.get('full_text', content_result.get('content', ''))
                else:
                    current_content = str(content_result)
                
                # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
                logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ")
                review_task = {
                    'task_id': f"{task_id}_review_v{iteration}",
                    'description': 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ¬ãƒ“ãƒ¥ãƒ¼',
                    'required_role': 'review',
                    'review_target_task_id': f"{task_id}_content_v{iteration}",
                    'content_to_review': current_content
                }
                
                review_result = await self.task_executor.execute_task(review_task)
                
                if not review_result or not hasattr(review_result, 'get'):
                    logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œå¤±æ•— - ã‚µã‚¤ã‚¯ãƒ«çµ‚äº†")
                    break
                
                review_history.append(review_result)
                
                # ã‚¹ãƒ†ãƒƒãƒ—3: æ‰¿èªåˆ¤å®š
                approved = review_result.get('approved', False)
                
                if approved:
                    logger.info(f"âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼æ‰¿èª (åå¾©{iteration}å›)")
                    return {
                        'success': True,
                        'content': current_content,
                        'iterations': iteration,
                        'review_history': review_history,
                        'full_text': current_content,
                        'summary': f'{iteration}å›ã®åå¾©ã§æ‰¿èª'
                    }
                else:
                    logger.info(f"ğŸ”„ ä¿®æ­£ãŒå¿…è¦ - æ¬¡ã®åå¾©ã¸")
                    await asyncio.sleep(2)
            
            # æœ€å¤§åå¾©å›æ•°åˆ°é”
            logger.warning(f"âš ï¸ æœ€å¤§åå¾©å›æ•°({max_iterations})åˆ°é” - æœ€çµ‚ç‰ˆã‚’è¿”å´")
            
            return {
                'success': False,
                'partial_success': True,
                'content': current_content,
                'iterations': iteration,
                'review_history': review_history,
                'full_text': current_content,
                'summary': f'{iteration}å›åå¾©ã—ãŸãŒæ‰¿èªã•ã‚Œãš',
                'error': 'æœ€å¤§åå¾©å›æ•°åˆ°é”'
            }
        
        except Exception as e:
            logger.error(f"âŒ ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚µã‚¤ã‚¯ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_review_cycle_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_sequential_workflow(self, task: Dict) -> Dict:
        """
        ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆé †æ¬¡å®Ÿè¡Œï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        steps = task.get('steps', [])
        
        if not steps:
            logger.warning("ã‚¹ãƒ†ãƒƒãƒ—å®šç¾©ãªã— - å˜ä¸€ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å®Ÿè¡Œ")
            result = await self.task_executor.execute_task(task)
            return {'success': bool(result), 'result': result}
        
        try:
            logger.info(f"ğŸ“‹ ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ ({len(steps)}ã‚¹ãƒ†ãƒƒãƒ—)")
            
            results = []
            accumulated_output = {}
            
            for i, step in enumerate(steps, 1):
                logger.info(f"--- ã‚¹ãƒ†ãƒƒãƒ— {i}/{len(steps)}: {step.get('description', 'N/A')} ---")
                
                # ã‚¹ãƒ†ãƒƒãƒ—ã‚¿ã‚¹ã‚¯æ§‹ç¯‰
                step_task = {
                    **task,
                    **step,  # ã‚¹ãƒ†ãƒƒãƒ—è¨­å®šã§ä¸Šæ›¸ã
                    'task_id': f"{task_id}_step{i}",
                }
                
                # å‰ã‚¹ãƒ†ãƒƒãƒ—ã®å‡ºåŠ›ã‚’å‚ç…§
                if step.get('use_previous_output') and accumulated_output:
                    prev_output = accumulated_output.get(f'step{i-1}', '')
                    if 'prompt' in step_task:
                        step_task['prompt'] = step_task['prompt'].replace(
                            '{previous_output}',
                            str(prev_output)
                        )
                
                # ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œ
                step_result = await self.task_executor.execute_task(step_task)
                
                results.append(step_result)
                accumulated_output[f'step{i}'] = step_result
                
                # å¤±æ•—æ™‚ã®å‡¦ç†
                if not step_result or (hasattr(step_result, 'get') and not step_result.get('success')):
                    if step.get('continue_on_failure', False):
                        logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—ã—ãŸãŒç¶™ç¶š")
                    else:
                        logger.error(f"âŒ ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•— - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ä¸­æ–­")
                        return {
                            'success': False,
                            'error': f'ã‚¹ãƒ†ãƒƒãƒ— {i} å¤±æ•—',
                            'completed_steps': i - 1,
                            'results': results
                        }
                
                logger.info(f"âœ… ã‚¹ãƒ†ãƒƒãƒ— {i} å®Œäº†")
                await asyncio.sleep(1)
            
            logger.info(f"âœ… å…¨ {len(steps)} ã‚¹ãƒ†ãƒƒãƒ—å®Œäº†")
            
            return {
                'success': True,
                'steps_completed': len(steps),
                'results': results,
                'accumulated_output': accumulated_output,
                'full_text': str(accumulated_output)
            }
        
        except Exception as e:
            logger.error(f"âŒ ã‚·ãƒ¼ã‚±ãƒ³ã‚·ãƒ£ãƒ«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_sequential_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_parallel_workflow(self, task: Dict) -> Dict:
        """
        ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆè¤‡æ•°ã‚¿ã‚¹ã‚¯åŒæ™‚å®Ÿè¡Œï¼‰
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        parallel_tasks = task.get('parallel_tasks', [])
        
        if not parallel_tasks:
            logger.warning("ä¸¦åˆ—ã‚¿ã‚¹ã‚¯å®šç¾©ãªã—")
            return {'success': False, 'error': 'ä¸¦åˆ—ã‚¿ã‚¹ã‚¯ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“'}
        
        try:
            logger.info(f"âš¡ ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ ({len(parallel_tasks)}ã‚¿ã‚¹ã‚¯)")
            
            # ä¸¦åˆ—ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆæ§‹ç¯‰
            coroutines = []
            for i, parallel_task in enumerate(parallel_tasks, 1):
                parallel_task_config = {
                    **task,
                    **parallel_task,
                    'task_id': f"{task_id}_parallel{i}"
                }
                coroutines.append(
                    self.task_executor.execute_task(parallel_task_config)
                )
            
            # ä¸¦åˆ—å®Ÿè¡Œ
            results = await asyncio.gather(*coroutines, return_exceptions=True)
            
            # çµæœåˆ†æ
            success_count = sum(
                1 for r in results 
                if r and not isinstance(r, Exception) and (r is True or (hasattr(r, 'get') and r.get('success')))
            )
            
            logger.info(f"âœ… ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Œäº†: {success_count}/{len(results)} æˆåŠŸ")
            
            return {
                'success': success_count == len(results),
                'partial_success': success_count > 0 and success_count < len(results),
                'results': results,
                'summary': f'{success_count}/{len(results)} ã‚¿ã‚¹ã‚¯æˆåŠŸ'
            }
        
        except Exception as e:
            logger.error(f"âŒ ä¸¦åˆ—ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_parallel_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_conditional_workflow(self, task: Dict) -> Dict:
        """
        æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±è¾æ›¸
            
        Returns:
            Dict: å®Ÿè¡Œçµæœ
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            logger.info("ğŸ”€ æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ")
            
            # æ¡ä»¶è©•ä¾¡ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
            condition_task = task.get('condition_task')
            if not condition_task:
                return {'success': False, 'error': 'æ¡ä»¶ã‚¿ã‚¹ã‚¯ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“'}
            
            condition_result = await self.task_executor.execute_task(condition_task)
            
            # æ¡ä»¶è©•ä¾¡
            condition_met = self._evaluate_condition(condition_result, task.get('condition'))
            
            # åˆ†å²å®Ÿè¡Œ
            if condition_met:
                logger.info("âœ… æ¡ä»¶æˆç«‹ - thenåˆ†å²å®Ÿè¡Œ")
                then_task = task.get('then_task')
                if then_task:
                    result = await self.task_executor.execute_task(then_task)
                    return {'success': True, 'branch': 'then', 'result': result}
            else:
                logger.info("âŒ æ¡ä»¶ä¸æˆç«‹ - elseåˆ†å²å®Ÿè¡Œ")
                else_task = task.get('else_task')
                if else_task:
                    result = await self.task_executor.execute_task(else_task)
                    return {'success': True, 'branch': 'else', 'result': result}
            
            return {'success': True, 'branch': 'none'}
        
        except Exception as e:
            logger.error(f"âŒ æ¡ä»¶åˆ†å²ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")
            ErrorHandler.log_error(e, "WorkflowExecutor._execute_conditional_workflow")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _evaluate_condition(self, result: Any, condition: Dict) -> bool:
        """
        æ¡ä»¶ã‚’è©•ä¾¡
        
        Args:
            result: è©•ä¾¡å¯¾è±¡ã®çµæœ
            condition: æ¡ä»¶å®šç¾©è¾æ›¸
            
        Returns:
            bool: æ¡ä»¶æˆç«‹ãƒ•ãƒ©ã‚°
        """
        if not condition:
            return True
        
        condition_type = condition.get('type', 'success')
        
        if condition_type == 'success':
            return result and (result is True or (hasattr(result, 'get') and result.get('success')))
        elif condition_type == 'contains':
            target_text = condition.get('text', '')
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return target_text.lower() in content.lower()
        elif condition_type == 'length':
            min_length = condition.get('min_length', 0)
            if hasattr(result, 'get'):
                content = result.get('full_text', result.get('content', ''))
                return len(content) >= min_length
        
        return False
    
    def get_workflow_stats(self) -> Dict:
        """ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        return self.workflow_stats.copy()

#wp_acf_agent.py
"""
WordPress ACFè¨­è¨ˆãƒ»è¨­å®šã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressACFAgent:
    """ACFè¨­è¨ˆãƒ»è¨­å®šå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """ACFã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        # å®Ÿè£…ï¼ˆwp_cpt_agent.py ã¨åŒæ§˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        return {
            'success': True,
            'message': 'ACFè¨­å®šå®Œäº†ï¼ˆå®Ÿè£…ä¸­ï¼‰',
            'task_id': task.get('task_id')
        }
        
"""
å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³ä¾‹
ï¼ˆwp_acf_agent.py, wp_cpt_agent.py ãªã©ã«é©ç”¨ï¼‰

âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¿®æ­£å‰ï¼‰
âœ… å®‰å…¨ãªãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆä¿®æ­£å¾Œï¼‰
"""

# ========================================
# âŒ ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³1: æ¡ä»¶åˆ†å²å¤–ã§ã®å¤‰æ•°å‚ç…§
# ========================================

# --- ä¿®æ­£å‰ï¼ˆã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿï¼‰ ---
async def save_generated_code_BAD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """âŒ ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™"""
    
    # æ¡ä»¶åˆ†å²å†…ã§ã®ã¿å¤‰æ•°ã‚’å®šç¾©
    if output_type == 'php':
        php_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        json_filename = f"acf_{task_id}.json"
    
    # ã“ã“ã§å¤‰æ•°ã‚’å‚ç…§ã™ã‚‹ã¨ã€æ¡ä»¶ã«åˆè‡´ã—ãªã‹ã£ãŸå ´åˆã«ã‚¨ãƒ©ãƒ¼ï¼
    # UnboundLocalError: cannot access local variable 'php_filename' where it is not associated with a value
    await self.browser.save_text_to_file(content, php_filename)  # âŒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿç®‡æ‰€


# --- ä¿®æ­£å¾Œï¼ˆå®‰å…¨ï¼‰ ---
async def save_generated_code_GOOD_EXAMPLE(self, task_id: str, content: str, output_type: str):
    """âœ… ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å®‰å…¨ã§ã™"""
    
    # === æ–¹æ³•1: æœ€åˆã«å¤‰æ•°ã‚’åˆæœŸåŒ– ===
    final_filename = None  # æœ€åˆã«åˆæœŸåŒ–ï¼ˆé‡è¦ï¼ï¼‰
    
    if output_type == 'php':
        final_filename = f"template_{task_id}.php"
    elif output_type == 'json':
        final_filename = f"acf_{task_id}.json"
    else:
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®šï¼ˆã©ã®æ¡ä»¶ã«ã‚‚åˆè‡´ã—ãªã„å ´åˆï¼‰
        final_filename = f"output_{task_id}.txt"
    
    # å®‰å…¨ã«å‚ç…§å¯èƒ½
    if final_filename:
        await self.browser.save_text_to_file(content, final_filename)
    else:
        logger.error("âŒ ãƒ•ã‚¡ã‚¤ãƒ«åãŒæ±ºå®šã§ãã¾ã›ã‚“ã§ã—ãŸ")


# ========================================
# âŒ ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³2: è¤‡é›‘ãªæ¡ä»¶åˆ†å²
# ========================================

# --- ä¿®æ­£å‰ï¼ˆã‚¨ãƒ©ãƒ¼ãƒªã‚¹ã‚¯é«˜ï¼‰ ---
async def process_and_save_BAD(self, task: dict, generated_content: str):
    """âŒ è¤‡é›‘ãªæ¡ä»¶ã§ã‚¨ãƒ©ãƒ¼ãƒªã‚¹ã‚¯ãŒé«˜ã„"""
    
    task_type = task.get('type')
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = 'ma_case_template.php'
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = 'acf_fields.json'
    
    # ä¸Šè¨˜ã®æ¡ä»¶ã«åˆè‡´ã—ãªã„å ´åˆã€output_filenameãŒæœªå®šç¾©ï¼
    save_result = await self._save_file(output_filename, generated_content)  # âŒ ã‚¨ãƒ©ãƒ¼


# --- ä¿®æ­£å¾Œï¼ˆå®‰å…¨ï¼‰ ---
async def process_and_save_GOOD(self, task: dict, generated_content: str):
    """âœ… ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§å®‰å…¨ã«å‡¦ç†"""
    
    task_type = task.get('type')
    task_id = task.get('task_id', 'unknown')
    
    # === ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æœ€åˆã«è¨­å®š ===
    output_filename = f"output_{task_id}.txt"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    
    if task_type == 'cpt' and 'ma_case' in task.get('description', ''):
        output_filename = f"ma_case_template_{task_id}.php"
    elif task_type == 'acf' and 'json' in task.get('format', ''):
        output_filename = f"acf_fields_{task_id}.json"
    
    # å¸¸ã«output_filenameãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã®ã§å®‰å…¨
    save_result = await self._save_file(output_filename, generated_content)  # âœ… å®‰å…¨


# ========================================
# âœ… æ¨å¥¨ãƒ‘ã‚¿ãƒ¼ãƒ³: è¦ªã‚¯ãƒ©ã‚¹ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ä½¿ç”¨
# ========================================

class WordPressACFAgent:
    """ACFè¨­è¨ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆä¿®æ­£ä¾‹ï¼‰"""
    
    def __init__(self, browser, output_folder, parent_agent=None):
        self.browser = browser
        self.output_folder = output_folder
        self.parent_agent = parent_agent  # è¦ªã®WordPressDevAgentã¸ã®å‚ç…§
    
    async def execute(self, task: dict):
        """ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ"""
        task_id = task.get('task_id', 'unknown')
        
        try:
            # AIã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
            generated_content = await self._generate_acf_fields(task)
            
            # === æ¨å¥¨: è¦ªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®‰å…¨ãªãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ä½¿ç”¨ ===
            if self.parent_agent and hasattr(self.parent_agent, 'safe_save_code_file'):
                save_result = await self.parent_agent.safe_save_code_file(
                    content=generated_content,
                    task_id=task_id,
                    file_type='json',  # or 'php'
                    custom_filename=None  # è‡ªå‹•ç”Ÿæˆ
                )
                
                if save_result['success']:
                    logger.info(f"âœ… ä¿å­˜æˆåŠŸ: {save_result['filepath']}")
                    return {
                        'success': True,
                        'output_file': save_result['filepath']
                    }
                else:
                    logger.error(f"âŒ ä¿å­˜å¤±æ•—: {save_result['error']}")
                    return {
                        'success': False,
                        'error': save_result['error']
                    }
            else:
                # === ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è‡ªå‰ã§å®‰å…¨ã«å‡¦ç† ===
                return await self._safe_save_fallback(task_id, generated_content)
        
        except Exception as e:
            logger.error(f"âŒ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _safe_save_fallback(self, task_id: str, content: str):
        """å®‰å…¨ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä¿å­˜"""
        # å¤‰æ•°ã‚’æœ€åˆã«åˆæœŸåŒ–
        filename = None
        saved_path = None
        
        try:
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åæ±ºå®š
            filename = f"acf_output_{task_id}_{timestamp}.json"
            output_path = self.output_folder / filename
            
            # ä¿å­˜å®Ÿè¡Œ
            if hasattr(self.browser, 'save_text_to_file'):
                saved_path = await self.browser.save_text_to_file(
                    content,
                    str(output_path)
                )
            else:
                with open(output_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                saved_path = str(output_path)
            
            return {
                'success': True,
                'output_file': saved_path
            }
        
        except Exception as e:
            return {
                'success': False,
                'error': f"ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}"
            }


# ========================================
# ğŸ”§ å®Ÿéš›ã®ä¿®æ­£æ‰‹é †ï¼ˆå„å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§å®Ÿè¡Œï¼‰
# ========================================

"""
1. wordpress/wp_dev/__init__.py ã‚’ç¢ºèªã—ã€è¦ªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å‚ç…§ã‚’æ¸¡ã™:

   from .wp_acf_agent import WordPressACFAgent
   
   # åˆæœŸåŒ–æ™‚ã«è¦ªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ¸¡ã™
   def create_agents(browser, output_folder, parent):
       acf_agent = WordPressACFAgent(
           browser, 
           output_folder,
           parent_agent=parent  # è¿½åŠ 
       )
       return acf_agent

2. å„å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆwp_acf_agent.py ãªã©ï¼‰å†…ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ¢ã™:
   
   æ¤œç´¢ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:
   - "filename" + "if" ã¾ãŸã¯ "elif"
   - "save" + "file"
   - ".php" ã¾ãŸã¯ ".json"

3. ä¸Šè¨˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¾“ã£ã¦ä¿®æ­£:
   
   ä¿®æ­£å‰:
   ```python
   if condition:
       php_filename = "something.php"
   
   await save(php_filename)  # âŒ ã‚¨ãƒ©ãƒ¼
   ```
   
   ä¿®æ­£å¾Œ:
   ```python
   php_filename = None  # æœ€åˆã«åˆæœŸåŒ–
   
   if condition:
       php_filename = "something.php"
   else:
       php_filename = "default.txt"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
   
   if php_filename:
       await save(php_filename)  # âœ… å®‰å…¨
   ```

4. ã¾ãŸã¯ã€è¦ªã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨:
   
   ```python
   result = await self.parent_agent.safe_save_code_file(
       content=generated_code,
       task_id=task_id,
       file_type='php'
   )
   ```
"""

#wp_agent - ã‚³ãƒ”ãƒ¼.py
""" wp_agent.py WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ - ãƒ¡ã‚¤ãƒ³ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼"""
import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path
from playwright.async_api import Page

from config_utils import ErrorHandler
from browser_controller import BrowserController
from datetime import datetime  
from .wp_auth import WordPressAuth
from .wp_post_editor import WordPressPostEditor
from .wp_post_creator import WordPressPostCreator
from .wp_plugin_manager import WordPressPluginManager
from .wp_settings_manager import WordPressSettingsManager
from .wp_tester import WordPressTester
from .wp_utils import TaskTypeAnalyzer

logger = logging.getLogger(__name__)


    # === ä¿®æ­£é–‹å§‹: WordPressAgentã‚¯ãƒ©ã‚¹ã«è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½ã‚’è¿½åŠ  ===

class WordPressAgent:
    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            wp_credentials: WordPress èªè¨¼æƒ…å ±
                - wp_url: ã‚µã‚¤ãƒˆURL
                - wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
                - wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.is_logged_in = False
        
        # WordPress å°‚ç”¨ãƒšãƒ¼ã‚¸ï¼ˆæ–°ã—ã„ã‚¿ãƒ–ï¼‰
        self.wp_page = None
        
        # èªè¨¼æƒ…å ±ã®å–å¾—
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        self.wp_user = self.wp_credentials.get('wp_user', '')
        self.wp_pass = self.wp_credentials.get('wp_pass', '')
        
        # WordPress èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
        if self.wp_url and self.wp_user and self.wp_pass:
            self.auth = WordPressAuth(
                browser_controller=self.browser,
                wp_url=self.wp_url,
                wp_user=self.wp_user,
                wp_pass=self.wp_pass
            )
        else:
            logger.warning("âš ï¸ WordPress èªè¨¼æƒ…å ±ãŒä¸å®Œå…¨ã§ã™")
            self.auth = None
        
        # ========================================
        # âœ… ã“ã“ã«è¿½åŠ ï¼šã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        # ========================================
        
        # ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆå¾Œã§å¤–éƒ¨ã‹ã‚‰è¨­å®šã•ã‚Œã‚‹ï¼‰
        self.sheets_manager = None
        
        # æŠ•ç¨¿ç·¨é›†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        self.post_editor = WordPressPostEditor(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressPostEditor åˆæœŸåŒ–å®Œäº†")
        
        # æŠ•ç¨¿ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
        self.post_creator = WordPressPostCreator(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressPostCreator åˆæœŸåŒ–å®Œäº†")
        
        # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        self.plugin_manager = WordPressPluginManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressPluginManager åˆæœŸåŒ–å®Œäº†")
        
        # è¨­å®šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
        self.settings_manager = WordPressSettingsManager(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressSettingsManager åˆæœŸåŒ–å®Œäº†")
        
        # ãƒ†ã‚¹ã‚¿ãƒ¼
        self.tester = WordPressTester(
            browser_controller=self.browser,
            wp_credentials=self.wp_credentials
        )
        logger.info("âœ… WordPressTester åˆæœŸåŒ–å®Œäº†")
        
        logger.info("="*60)
        logger.info("WordPressAgent å…¨ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
        logger.info("="*60)
    
    async def initialize_wp_session(self) -> bool:
        """
        WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
            
        æ”¹å–„ç‚¹:
        1. æ–°ã—ã„ã‚¿ãƒ–ä½œæˆï¼ˆGemini ã‚»ãƒƒã‚·ãƒ§ãƒ³ã¨ã¯å®Œå…¨ç‹¬ç«‹ï¼‰
        2. ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨ + ç®¡ç†ç”»é¢ã¸ã®å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        3. ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®å³æ ¼ãªæ¤œè¨¼
        4. å¤±æ•—æ™‚ã®æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            
        Returns:
            bool: åˆæœŸåŒ–æˆåŠŸæ™‚ True
        """
        try:
            logger.info("="*60)
            logger.info("ğŸ” WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
            logger.info("="*60)
                
            # âœ… Phase 1: æ–°ã—ã„ã‚¿ãƒ–ã‚’ä½œæˆ
            if not self.browser.context:
                logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            self.wp_page = await self.browser.context.new_page()
            logger.info("âœ… WordPress å°‚ç”¨ã‚¿ãƒ–ã‚’ä½œæˆã—ã¾ã—ãŸ")
                
            # âœ… Phase 2: èªè¨¼æƒ…å ±ã®æ¤œè¨¼
            if not self.auth:
                logger.error("âŒ WordPress èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            # âœ… Phase 3: ãƒ­ã‚°ã‚¤ãƒ³å®Ÿè¡Œï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            logger.info("ğŸ”„ WordPressèªè¨¼ã‚’å®Ÿè¡Œä¸­...")
            login_success = await self.auth.login(self.wp_page)
                
            if login_success:
                self.is_logged_in = True
                logger.info("="*60)
                logger.info("âœ… WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†")
                logger.info("  èªè¨¼æ–¹æ³•: ã‚¯ãƒƒã‚­ãƒ¼ or æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³")
                logger.info("  ãƒšãƒ¼ã‚¸URL: " + self.wp_page.url)
                logger.info("="*60)
                return True
            else:
                logger.error("="*60)
                logger.error("âŒ WordPress ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                logger.error("  åŸå› : èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                logger.error("  å¯¾ç­–: èªè¨¼æƒ…å ±ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                logger.error("="*60)
                    
                # ãƒ‡ãƒãƒƒã‚°ç”¨: å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("ğŸ“¸ ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: wp_session_init_failed.png")
                except:
                    pass
                    
                return False
                    
        except Exception as e:
            logger.error(f"âŒ WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False

    async def ensure_logged_in(self) -> bool:
        """
        ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿è¨¼
    
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã¾ãŸã¯ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        if self.is_logged_in and self.wp_page:
            # å®šæœŸçš„ã«ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            if await self.auth._verify_login_status(self.wp_page):
                return True
    
        # ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„å ´åˆã¯å†åˆæœŸåŒ–
        logger.info("ğŸ”„ WordPress å†ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œã—ã¾ã™")
        return await self.initialize_wp_session()
    
    async def _try_cookie_login(self, wp_url: str) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ãŸãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œ"""
        try:
            if not wp_url:
                logger.warning("âš ï¸ WordPress URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
        
            # WordPressã‚¯ãƒƒã‚­ãƒ¼ã‚’ãƒ­ãƒ¼ãƒ‰
            cookie_loaded = await self.browser.load_wordpress_cookies(wp_url)
            if not cookie_loaded:
                return False
        
            # ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            admin_url = f"{wp_url.rstrip('/')}/wp-admin/"
            await self.browser.page.goto(admin_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°ãƒã‚§ãƒƒã‚¯
            return await self._verify_wordpress_login_status()
        
        except Exception as e:
            logger.warning(f"âš ï¸ ã‚¯ãƒƒã‚­ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def _verify_wordpress_login_status(self) -> bool:
        """WordPressãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°æ¤œè¨¼"""
        try:
            page = self.browser.page
        
            # è¤‡æ•°ã®æ–¹æ³•ã§ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            checks = []
        
            # 1. ç®¡ç†ãƒãƒ¼ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('ç®¡ç†ãƒãƒ¼', bool(admin_bar)))
        
            # 2. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¦ç´ ãƒã‚§ãƒƒã‚¯
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰', bool(dashboard)))
        
            # 3. ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®ä¸åœ¨ãƒã‚§ãƒƒã‚¯
            login_form = await page.query_selector('#loginform')
            checks.append(('ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ä¸åœ¨', not bool(login_form)))
        
            # 4. URLãƒã‚§ãƒƒã‚¯ï¼ˆãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ï¼‰
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('ç®¡ç†ãƒšãƒ¼ã‚¸URL', is_admin_page))
        
            # çµæœã®é›†è¨ˆ
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
        
            logger.info(f"ğŸ” ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼: {total_passed}/4 åˆæ ¼")
            if total_passed >= 3:  # 4ã¤ã®ã†ã¡3ã¤ä»¥ä¸Šåˆæ ¼ãªã‚‰ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ
                logger.info(f"  åˆæ ¼é …ç›®: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  ä¸åˆæ ¼é …ç›®ãŒå¤šã™ãã¾ã™")
                return False
            
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def _manual_wordpress_login(self) -> bool:
        """æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³"""
        try:
            wp_url = self.wp_credentials.get('wp_url', '')
            wp_user = self.wp_credentials.get('wp_user', '')
            wp_pass = self.wp_credentials.get('wp_pass', '')
        
            if not all([wp_url, wp_user, wp_pass]):
                logger.error("âŒ WordPressèªè¨¼æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
                return False
        
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            login_url = f"{wp_url.rstrip('/')}/wp-login.php"
            await self.browser.page.goto(login_url, wait_until='networkidle')
            await asyncio.sleep(2)
        
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›
            user_field = await self.browser.page.query_selector('#user_login')
            if user_field:
                await user_field.fill(wp_user)
                logger.info("âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›å®Œäº†")
            else:
                logger.error("âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›
            pass_field = await self.browser.page.query_selector('#user_pass')
            if pass_field:
                await pass_field.fill(wp_pass)
                logger.info("âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›å®Œäº†")
            else:
                logger.error("âŒ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
            login_button = await self.browser.page.query_selector('#wp-submit')
            if login_button:
                await login_button.click()
                logger.info("âœ… ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯")
            else:
                logger.error("âŒ ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
        
            # ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾…æ©Ÿ
            await self.browser.page.wait_for_load_state('networkidle')
            await asyncio.sleep(3)
        
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸç¢ºèª
            if await self._verify_wordpress_login_status():
                logger.info("âœ… æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                return True
            else:
                logger.error("âŒ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•— - èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                return False
            
        except Exception as e:
            logger.error(f"âŒ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def ensure_logged_in(self) -> bool:
        """ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿è¨¼"""
        if self.is_logged_in:
            return True
    
        # å®šæœŸçš„ã«ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
        if await self._verify_wordpress_login_status():
            self.is_logged_in = True
            return True
    
        # ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„å ´åˆã¯å†åˆæœŸåŒ–
        return await self.initialize_wp_session()
       
    async def process_task(self, task: Dict) -> Dict:
        """WordPressã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†"""
        try:
            # ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            if not await self.ensure_logged_in():
                return {
                    'success': False,
                    'error': 'WordPress ã«ãƒ­ã‚°ã‚¤ãƒ³ã§ãã¾ã›ã‚“ã§ã—ãŸ'
                }
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹ ===
            logger.info("="*60)
            logger.info("WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹")
            logger.info(f"ã‚¿ã‚¹ã‚¯: {task['description']}")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼è¨­å®š ===
            self.post_editor.sheets_manager = self.sheets_manager
            self.post_creator.sheets_manager = self.sheets_manager
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—è§£æ ===
            task_type = TaskTypeAnalyzer.analyze(task['description'])
            logger.info(f"è§£æã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—: {task_type}")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‡¦ç†å®Ÿè¡Œ ===
            result = await self._execute_task_by_type(task, task_type)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressã‚¿ã‚¹ã‚¯å‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_task_by_type(self, task: Dict, task_type: str) -> Dict:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦é©åˆ‡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å‡¦ç†ã‚’å§”è­²"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–¢é€£ã‚¿ã‚¹ã‚¯ ===
            if task_type == 'plugin_install':
                result = await self.plugin_manager.install_plugin(self.wp_page, task)
            elif task_type == 'plugin_settings':
                result = await self.plugin_manager.change_plugin_settings(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ2: æŠ•ç¨¿é–¢é€£ã‚¿ã‚¹ã‚¯ ===
            elif task_type == 'edit_post':
                result = await self.post_editor.edit_post(self.wp_page, task)
            elif task_type == 'content_create':
                result = await self.post_creator.create_post(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: è¨­å®šé–¢é€£ã‚¿ã‚¹ã‚¯ ===
            elif task_type == 'theme_change':
                result = await self.settings_manager.change_theme(self.wp_page, task)
            elif task_type == 'setting_change':
                result = await self.settings_manager.change_settings(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ ===
            elif task_type == 'test_functionality':
                result = await self.tester.test_functionality(self.wp_page, task)
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ãã®ä»–ã®ã‚¿ã‚¹ã‚¯ ===
            else:
                result = await self._generic_execution(task)
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }
            
    def get_plugin_manager(self):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å®‰å…¨ã«å–å¾—"""
        if hasattr(self, 'plugin_manager') and self.plugin_manager:
            return self.plugin_manager
        else:
            logger.error("âŒ plugin_manager ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
            return None

    async def execute_plugin_task(self, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–¢é€£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå®‰å…¨ãªãƒ©ãƒƒãƒ‘ãƒ¼ï¼‰"""
        try:
            if not self.plugin_manager:
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
        
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦é©åˆ‡ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™
            task_type = task.get('type', '')
        
            if task_type == 'facetwp_configure':
                return await self.plugin_manager.configure_facetwp(task.get('parameters', {}))
            elif task_type == 'user_role_configure':
                return await self.plugin_manager.configure_user_roles(task.get('parameters', {}))
            else:
                return await self.plugin_manager.change_plugin_settings(None, task)
            
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def create_post(self, page: Page, task: Dict) -> Dict:
        """æ–°è¦æŠ•ç¨¿ã‚’ä½œæˆï¼ˆpost_statuså¯¾å¿œç‰ˆï¼‰"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾— ===
            post_status = task.get('post_status', 'draft')
            post_action = task.get('post_action', 'create')
        
            logger.info(f"WordPressæŠ•ç¨¿ä½œæˆ:")
            logger.info(f"  ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {post_action}")
            logger.info(f"  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}")
        
            # === ãƒ‘ãƒ¼ãƒˆ2: è¨˜äº‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¨­å®š ===
            # ï¼ˆæ—¢å­˜ã®è¨˜äº‹å–å¾—ãƒ»ã‚¿ã‚¤ãƒˆãƒ«ãƒ»æœ¬æ–‡è¨­å®šå‡¦ç†ï¼‰
            article_title = "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒˆãƒ«"  # å®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªå€¤ã‚’è¨­å®š
            polylang_lang = "ja"
            language = "æ—¥æœ¬èª"
            article_body = ""
            screenshot_path = None
        
            # === ãƒ‘ãƒ¼ãƒˆ3: æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸå‡¦ç† ===
            status_result = await self._handle_post_status(page, post_status, post_action)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: çµæœã‚µãƒãƒªãƒ¼æ§‹ç¯‰ ===
            summary = self._build_create_summary(
                article_title, polylang_lang, language, 
                len(article_body), post_status, status_result['message']
            )
        
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'action': post_action,
                'screenshot': screenshot_path
            }
        
        except Exception as e:
            logger.error(f"âŒ WordPressæŠ•ç¨¿ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _handle_post_status(self, page: Page, post_status: str, post_action: str) -> Dict:
        """æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸä¿å­˜/å…¬é–‹å‡¦ç†"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ä¸‹æ›¸ãä¿å­˜ã®å ´åˆ ===
            if post_status == 'draft' or post_action == 'create':
                logger.info("\nã€ä¸‹æ›¸ãä¿å­˜ä¸­...ã€‘")
                saved = await self._save_draft(page)
            
                if saved:
                    logger.info("âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†")
                    return {'success': True, 'message': 'ä¸‹æ›¸ãä¿å­˜'}
                else:
                    logger.warning("âš ï¸ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                    return {'success': False, 'message': 'ä¿å­˜ç¢ºèªæ¨å¥¨'}
        
            # === ãƒ‘ãƒ¼ãƒˆ2: å…¬é–‹ã®å ´åˆ ===
            elif post_status == 'publish' or post_action == 'publish':
                logger.info("\nã€è¨˜äº‹ã‚’å…¬é–‹ä¸­...ã€‘")
                published = await self._publish_post(page)
            
                if published:
                    logger.info("âœ… è¨˜äº‹å…¬é–‹å®Œäº†")
                    return {'success': True, 'message': 'å…¬é–‹å®Œäº†'}
                else:
                    logger.warning("âš ï¸ å…¬é–‹ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                    return {'success': False, 'message': 'å…¬é–‹ç¢ºèªæ¨å¥¨'}
        
            # === ãƒ‘ãƒ¼ãƒˆ3: ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å ´åˆ ===
            else:
                logger.info(f"\nã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ã€‘")
                saved = await self._save_draft(page)
                return {
                    'success': saved, 
                    'message': f'ä¿å­˜å®Œäº†ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ï¼‰'
                }
        
        except Exception as e:
            logger.error(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'message': f'ã‚¨ãƒ©ãƒ¼: {str(e)}'}


    async def _publish_post(self, page: Page) -> bool:
        """æŠ•ç¨¿ã‚’å…¬é–‹"""
        # === ãƒ‘ãƒ¼ãƒˆ1: å…¬é–‹ãƒœã‚¿ãƒ³ã‚»ãƒ¬ã‚¯ã‚¿å®šç¾© ===
        publish_selectors = [
            'button:has-text("å…¬é–‹")',
            'button[aria-label="å…¬é–‹"]',
            '.editor-post-publish-button',
            'button.editor-post-publish-button__button'
        ]
    
        logger.debug("å…¬é–‹ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
    
        # === ãƒ‘ãƒ¼ãƒˆ2: å…¬é–‹ãƒœã‚¿ãƒ³æ¢ç´¢ãƒ«ãƒ¼ãƒ— ===
        for i, selector in enumerate(publish_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(publish_selectors)}: {selector}")
            try:
                publish_button = await page.query_selector(selector)
                if not publish_button:
                    continue
                    
                # === ãƒ‘ãƒ¼ãƒˆ3: ãƒœã‚¿ãƒ³çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ ===
                is_visible = await publish_button.is_visible()
                is_disabled = await publish_button.is_disabled() if is_visible else True
            
                logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === ãƒ‘ãƒ¼ãƒˆ4: å…¬é–‹ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ ===
                    await publish_button.click()
                    await page.wait_for_timeout(2000)
                
                    # === ãƒ‘ãƒ¼ãƒˆ5: ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç† ===
                    try:
                        confirm_button = await page.query_selector('button:has-text("å…¬é–‹")')
                        if confirm_button and await confirm_button.is_visible():
                            await confirm_button.click()
                            await page.wait_for_timeout(3000)
                    except:
                        pass
                
                    logger.info("âœ… å…¬é–‹ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                    return True
                    
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
    
        logger.warning("âŒ å…¬é–‹ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False


    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ä¿å­˜ãƒœã‚¿ãƒ³ã‚»ãƒ¬ã‚¯ã‚¿å®šç¾© ===
        save_selectors = [
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
    
        logger.debug("ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
    
        # === ãƒ‘ãƒ¼ãƒˆ2: ä¿å­˜ãƒœã‚¿ãƒ³æ¢ç´¢ãƒ«ãƒ¼ãƒ— ===
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if not save_button:
                    continue
                    
                # === ãƒ‘ãƒ¼ãƒˆ3: ãƒœã‚¿ãƒ³çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯ ===
                is_visible = await save_button.is_visible()
                is_disabled = await save_button.is_disabled() if is_visible else True
            
                logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
            
                if is_visible and not is_disabled:
                    # === ãƒ‘ãƒ¼ãƒˆ4: ä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ ===
                    await save_button.click()
                    await page.wait_for_timeout(4000)
                    logger.info("âœ… ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                    return True
                    
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
    
        logger.warning("âŒ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False


    def _build_create_summary(self, title: str, polylang_lang: str, 
                             language: str, content_length: int, 
                             post_status: str, status_message: str) -> str:
        """æ–°è¦æŠ•ç¨¿ä½œæˆã®ã‚µãƒãƒªãƒ¼ã‚’æ§‹ç¯‰"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ã‚µãƒãƒªãƒ¼è¡Œã®æ§‹ç¯‰ ===
        summary_lines = []
        summary_lines.append("ã€WordPressæŠ•ç¨¿å®Œäº†ã€‘")
        summary_lines.append(f"ã‚¿ã‚¤ãƒˆãƒ«: {title}")
        summary_lines.append(f"è¨€èª: {language}")
        summary_lines.append(f"Polylangè¨­å®š: {polylang_lang}")
        summary_lines.append(f"æœ¬æ–‡: {content_length}æ–‡å­—ï¼ˆHTMLå½¢å¼ï¼‰")
        summary_lines.append(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}")
        summary_lines.append(f"âœ… {status_message}")
    
        # === ãƒ‘ãƒ¼ãƒˆ2: ã‚µãƒãƒªãƒ¼æ–‡å­—åˆ—ã®çµåˆ ===
        return '\n'.join(summary_lines)
    
    
    async def _generic_execution(self, task: Dict) -> Dict:
        """æ±ç”¨çš„ãªã‚¿ã‚¹ã‚¯å®Ÿè¡Œ(Geminiã«ç¢ºèªã—ãªãŒã‚‰å®Ÿè¡Œ)"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: å®Ÿè¡Œé–‹å§‹ ===
            logger.info("æ±ç”¨ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: Geminiãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ ===
            gemini_prompt = self._build_gemini_prompt(task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: Geminiã«é€ä¿¡ ===
            await self.browser.send_prompt(gemini_prompt)
            await self.browser.wait_for_text_generation(max_wait=120)
            response = await self.browser.extract_latest_text_response()
            
            logger.info("Geminiã‹ã‚‰å®Ÿè¡Œæ‰‹é †ã‚’å–å¾—ã—ã¾ã—ãŸ")
            logger.info(f"æ‰‹é †:\n{response[:500]}...")
            
            # === ãƒ‘ãƒ¼ãƒˆ4: çµæœè¿”å´ ===
            return self._build_generic_result(task, response)
            
        except Exception as e:
            ErrorHandler.log_error(e, "æ±ç”¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }

    def _build_gemini_prompt(self, task: Dict) -> str:
        """Geminiç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        return f"""
        WordPressã§ä»¥ä¸‹ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ãŸã„ã§ã™:

        ã€ã‚¿ã‚¹ã‚¯ã€‘
        {task['description']}

        ã€WordPressæƒ…å ±ã€‘
        - URL: {self.wp_url}
        - ç®¡ç†ç”»é¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿

        ã€è³ªå•ã€‘
        ã“ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®å…·ä½“çš„ãªæ‰‹é †ã‚’ã€WordPressç®¡ç†ç”»é¢ã®æ“ä½œã¨ã—ã¦æ•™ãˆã¦ãã ã•ã„ã€‚

        ä»¥ä¸‹ã®å½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„:
        1. ç§»å‹•ã™ã‚‹ãƒšãƒ¼ã‚¸ã®URL(ç›¸å¯¾ãƒ‘ã‚¹)
        2. ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯å…¥åŠ›ã™ã‚‹è¦ç´ ã®ã‚»ãƒ¬ã‚¯ã‚¿
        3. å…¥åŠ›ã™ã‚‹å€¤
        4. ç¢ºèªã™ã¹ããƒã‚¤ãƒ³ãƒˆ

        ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã§ãã‚‹ã ã‘å…·ä½“çš„ã«(id, class, nameå±æ€§ãªã©)ã€‚
        """

    def _build_generic_result(self, task: Dict, response: str) -> Dict:
        """æ±ç”¨å®Ÿè¡Œã®çµæœã‚’æ§‹ç¯‰"""
        logger.info("âš ï¸ å®Ÿéš›ã®å®Ÿè¡Œã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': 'Geminiã‹ã‚‰å®Ÿè¡Œæ‰‹é †ã‚’å–å¾—ã—ã¾ã—ãŸã€‚æ‰‹é †ã‚’ç¢ºèªã—ã¦å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚',
            'full_text': f'ã€ã‚¿ã‚¹ã‚¯ã€‘\n{task["description"]}\n\nã€å®Ÿè¡Œæ‰‹é †ã€‘\n{response}'
        }
    
    async def cleanup(self):
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        # === ãƒ‘ãƒ¼ãƒˆ1: ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚º ===
        if self.wp_page:
            await self.wp_page.close()
            logger.info("WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã—ãŸ")


# === è¿½åŠ æ©Ÿèƒ½ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆåˆ†å‰²æ¸ˆã¿ï¼‰ ===

    async def configure_acf_fields(self, task_params: Dict) -> Dict:
        """Advanced Custom Fieldsã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¨­å®š"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾— ===
            field_group_name = task_params.get('acf_field_group_name')
            fields = task_params.get('acf_fields', [])
            location_rules = task_params.get('acf_location_rules', {})
            
            logger.info(f"ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— '{field_group_name}' ã‚’è¨­å®šä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ACFç”»é¢ç§»å‹• ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/edit.php?post_type=acf-field-group")
            await self.wp_page.wait_for_timeout(2000)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: æ–°è¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—è¿½åŠ  ===
            await self._click_acf_add_new_button()
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åå…¥åŠ› ===
            await self._input_acf_field_group_name(field_group_name)
            
            # === ãƒ‘ãƒ¼ãƒˆ5: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã¨çµæœè¿”å´ ===
            return await self._build_acf_result(field_group_name, fields, location_rules)
            
        except Exception as e:
            logger.error(f"ACFè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _click_acf_add_new_button(self):
        """ACFæ–°è¦è¿½åŠ ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯"""
        add_button_selectors = [
            'a.page-title-action:has-text("æ–°è¦è¿½åŠ ")',
            'a:has-text("Add New")',
            '.page-title-action'
        ]
        
        for selector in add_button_selectors:
            try:
                add_button = await self.wp_page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await self.wp_page.wait_for_timeout(3000)
                    break
            except:
                continue

    async def _input_acf_field_group_name(self, field_group_name: str):
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›"""
        title_input = await self.wp_page.query_selector('#title')
        if title_input:
            await title_input.fill(field_group_name)
            logger.info(f"ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›: {field_group_name}")

    async def _build_acf_result(self, field_group_name: str, fields: list, location_rules: dict) -> Dict:
        """ACFè¨­å®šçµæœã‚’æ§‹ç¯‰"""
        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
        screenshot_path = f"acf_setup_{datetime.now().strftime('%H%M%S')}.png"  # âœ… datetime ãŒåˆ©ç”¨å¯èƒ½
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("âš ï¸ ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è©³ç´°è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': f'ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— "{field_group_name}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'field_group_name': field_group_name,
            'fields_count': len(fields),
            'screenshot': screenshot_path,
            'full_text': f'ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—è¨­å®š\nåå‰: {field_group_name}\nãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: {len(fields)}\nâ€»ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }

    # ï¼ˆä»–ã®è¿½åŠ æ©Ÿèƒ½ãƒ¡ã‚½ãƒƒãƒ‰ã‚‚åŒæ§˜ã«åˆ†å‰²ã€‚ä»¥ä¸‹ã¯ä¸€éƒ¨ã®ã¿è¡¨ç¤ºï¼‰

    async def configure_custom_post_type(self, task_params: Dict) -> Dict:
        """Custom Post Type UIã§ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆ"""
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å–å¾— ===
            cpt_slug = task_params.get('cpt_slug')
            cpt_labels = task_params.get('cpt_labels', {})
            cpt_supports = task_params.get('cpt_supports', [])
            cpt_settings = task_params.get('cpt_settings', {})
            
            logger.info(f"ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— '{cpt_slug}' ã‚’ä½œæˆä¸­...")
            
            # === ãƒ‘ãƒ¼ãƒˆ2: CPT UIç”»é¢ç§»å‹• ===
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_post_types")
            await self.wp_page.wait_for_timeout(3000)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: åŸºæœ¬æƒ…å ±å…¥åŠ› ===
            await self._input_cpt_basic_info(cpt_slug, cpt_labels)
            
            # === ãƒ‘ãƒ¼ãƒˆ4: çµæœæ§‹ç¯‰ ===
            return await self._build_cpt_result(cpt_slug, cpt_labels)
            
        except Exception as e:
            logger.error(f"Custom Post Typeä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    async def _input_cpt_basic_info(self, cpt_slug: str, cpt_labels: dict):
        """CPTåŸºæœ¬æƒ…å ±ã‚’å…¥åŠ›"""
        # Post Type Slugå…¥åŠ›
        slug_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[name]"]')
        if slug_input:
            await slug_input.fill(cpt_slug)
            logger.info(f"ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {cpt_slug}")
        
        # Plural Labelå…¥åŠ›
        plural_label = cpt_labels.get('plural', cpt_slug)
        plural_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[label]"]')
        if plural_input:
            await plural_input.fill(plural_label)
            logger.info(f"è¤‡æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {plural_label}")
        
        # Singular Labelå…¥åŠ›
        singular_label = cpt_labels.get('singular', cpt_slug)
        singular_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[singular_label]"]')
        if singular_input:
            await singular_input.fill(singular_label)
            logger.info(f"å˜æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {singular_label}")

    async def _build_cpt_result(self, cpt_slug: str, cpt_labels: dict) -> Dict:
        """CPTä½œæˆçµæœã‚’æ§‹ç¯‰"""
        screenshot_path = f"cpt_creation_{cpt_slug}_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("âš ï¸ è©³ç´°è¨­å®šã¨Supportsè¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': f'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— "{cpt_slug}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'cpt_slug': cpt_slug,
            'cpt_labels': cpt_labels,
            'screenshot': screenshot_path,
            'full_text': f'Custom Post Typeä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {cpt_slug}\nãƒ©ãƒ™ãƒ«: {cpt_labels}\nâ€»Supportsè¨­å®šç­‰ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }


    # === 3. ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆæ©Ÿèƒ½ ===
    async def configure_custom_taxonomy(self, task_params: Dict) -> Dict:
        """
        Custom Post Type UIã§ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚’ä½œæˆ
        
        Parameters:
            taxonomy_slug: str - ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚¹ãƒ©ãƒƒã‚°
            taxonomy_labels: dict - ãƒ©ãƒ™ãƒ«è¨­å®š
            taxonomy_post_types: list - ç´ã¥ã‘ã‚‹æŠ•ç¨¿ã‚¿ã‚¤ãƒ—
            taxonomy_hierarchical: bool - éšå±¤æ§‹é€ ã®æœ‰ç„¡
        """
        try:
            taxonomy_slug = task_params.get('taxonomy_slug')
            taxonomy_labels = task_params.get('taxonomy_labels', {})
            taxonomy_post_types = task_params.get('taxonomy_post_types', [])
            taxonomy_hierarchical = task_params.get('taxonomy_hierarchical', True)
            
            logger.info(f"ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ '{taxonomy_slug}' ã‚’ä½œæˆä¸­...")
            
            # 1 Custom Post Type UI - Taxonomiesç”»é¢ã«ç§»å‹•
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_taxonomies")
            await self.wp_page.wait_for_timeout(3000)
            
            # 2 Taxonomy Slugå…¥åŠ›
            slug_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[name]"]')
            if slug_input:
                await slug_input.fill(taxonomy_slug)
                logger.info(f"ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {taxonomy_slug}")
            
            # 3 Plural Labelå…¥åŠ›
            plural_label = taxonomy_labels.get('plural', taxonomy_slug)
            plural_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[label]"]')
            if plural_input:
                await plural_input.fill(plural_label)
                logger.info(f"è¤‡æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {plural_label}")
            
            # 4 Singular Labelå…¥åŠ›
            singular_label = taxonomy_labels.get('singular', taxonomy_slug)
            singular_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[singular_label]"]')
            if singular_input:
                await singular_input.fill(singular_label)
                logger.info(f"å˜æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {singular_label}")
            
            # 5 ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"taxonomy_creation_{taxonomy_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("âš ï¸ Attach to Post Typesã¨éšå±¤è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': f'ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ "{taxonomy_slug}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'taxonomy_slug': taxonomy_slug,
                'taxonomy_labels': taxonomy_labels,
                'screenshot': screenshot_path,
                'full_text': f'Custom Taxonomyä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {taxonomy_slug}\nãƒ©ãƒ™ãƒ«: {taxonomy_labels}\nâ€»æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç´ä»˜ã‘ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
            }
            
        except Exception as e:
            logger.error(f"ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 4. M&Aæ¡ˆä»¶æŠ•ç¨¿æ©Ÿèƒ½ï¼ˆACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãï¼‰ ===
    async def create_ma_case_post(self, task_params: Dict) -> Dict:
        """
        M&Aæ¡ˆä»¶ã‚’ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãã§æŠ•ç¨¿
        
        Parameters:
            post_title: str - æŠ•ç¨¿ã‚¿ã‚¤ãƒˆãƒ«
            post_content: str - æœ¬æ–‡
            acf_fields: dict - ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å€¤
            polylang_lang: str - è¨€èªè¨­å®š
            post_status: str - æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
        """
        try:
            post_title = task_params.get('post_title')
            post_content = task_params.get('post_content', '')
            acf_fields = task_params.get('acf_fields', {})
            polylang_lang = task_params.get('polylang_lang', 'ja')
            post_status = task_params.get('post_status', 'draft')
            
            logger.info(f"M&Aæ¡ˆä»¶æŠ•ç¨¿: {post_title}")
            
            # 1 æ–°è¦æŠ•ç¨¿ç”»é¢ã«ç§»å‹•ï¼ˆma_caseæŠ•ç¨¿ã‚¿ã‚¤ãƒ—ï¼‰
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post-new.php?post_type=ma_case")
            await self.wp_page.wait_for_timeout(5000)
            
            # 2 ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
            await self._input_title(self.wp_page, post_title)
            
            # 3 æœ¬æ–‡å…¥åŠ›ï¼ˆã‚ã‚‹å ´åˆï¼‰
            if post_content:
                await self._input_content(self.wp_page, post_content)
            
            # 4 ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ã‚’å…¥åŠ›
            logger.info("ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ã‚’å…¥åŠ›ä¸­...")
            for field_name, field_value in acf_fields.items():
                try:
                    # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‹ã‚‰ã‚»ãƒ¬ã‚¯ã‚¿ã‚’æ¨æ¸¬
                    field_selector = f'input[name="acf[{field_name}]"]'
                    field_input = await self.wp_page.query_selector(field_selector)
                    
                    if field_input:
                        await field_input.fill(str(field_value))
                        logger.info(f"  {field_name}: {field_value}")
                    else:
                        logger.warning(f"  ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                except Exception as e:
                    logger.warning(f"  ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field_name}' å…¥åŠ›ã‚¨ãƒ©ãƒ¼: {e}")
            
            # 5 Polylangè¨€èªè¨­å®š
            await self._set_polylang_language(self.wp_page, polylang_lang)
            
            # 6 ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"ma_case_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            # 7 ä¿å­˜ã¾ãŸã¯å…¬é–‹
            if post_status == 'draft':
                saved = await self._save_draft(self.wp_page)
                status_message = "ä¸‹æ›¸ãä¿å­˜å®Œäº†" if saved else "ä¿å­˜ç¢ºèªæ¨å¥¨"
            elif post_status == 'publish':
                published = await self._publish_post(self.wp_page)
                status_message = "å…¬é–‹å®Œäº†" if published else "å…¬é–‹ç¢ºèªæ¨å¥¨"
            else:
                saved = await self._save_draft(self.wp_page)
                status_message = f"ä¿å­˜å®Œäº†ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ï¼‰"
            
            summary = f"""ã€M&Aæ¡ˆä»¶æŠ•ç¨¿å®Œäº†ã€‘
    ã‚¿ã‚¤ãƒˆãƒ«: {post_title}
    è¨€èª: {polylang_lang}
    ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: {len(acf_fields)}ä»¶
    æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}
    âœ… {status_message}"""
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'acf_fields_count': len(acf_fields),
                'screenshot': screenshot_path,
                'full_text': summary
            }
            
        except Exception as e:
            logger.error(f"M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }


    # === 5. Polylangç¿»è¨³é€£æºæ©Ÿèƒ½ ===
    async def link_polylang_translations(self, original_post_id: int, translated_post_id: int, lang_code: str) -> Dict:
        """
        Polylangã§æŠ•ç¨¿åŒå£«ã‚’ç¿»è¨³é–¢ä¿‚ã¨ã—ã¦é€£æº
        
        Parameters:
            original_post_id: int - å…ƒã®æŠ•ç¨¿ID
            translated_post_id: int - ç¿»è¨³å…ˆã®æŠ•ç¨¿ID
            lang_code: str - ç¿»è¨³å…ˆã®è¨€èªã‚³ãƒ¼ãƒ‰
        """
        try:
            logger.info(f"Polylangç¿»è¨³é€£æº: {original_post_id} â†’ {translated_post_id} ({lang_code})")
            
            # å…ƒã®æŠ•ç¨¿ã®ç·¨é›†ç”»é¢ã‚’é–‹ã
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post.php?post={original_post_id}&action=edit")
            await self.wp_page.wait_for_timeout(3000)
            
            # Polylangè¨€èªãƒ¡ã‚¿ãƒœãƒƒã‚¯ã‚¹ã§+ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            logger.info("Polylangè¨€èªè¨­å®šãƒ¡ã‚¿ãƒœãƒƒã‚¯ã‚¹ã‚’æ“ä½œä¸­...")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"polylang_link_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("âš ï¸ Polylangç¿»è¨³é€£æºã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': f'æŠ•ç¨¿ID {original_post_id} ã®ç·¨é›†ç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚Polylangè¨­å®šã§æŠ•ç¨¿ID {translated_post_id} ã‚’é€£æºã—ã¦ãã ã•ã„ã€‚',
                'original_post_id': original_post_id,
                'translated_post_id': translated_post_id,
                'lang_code': lang_code,
                'screenshot': screenshot_path,
                'full_text': f'Polylangç¿»è¨³é€£æº\nå…ƒæŠ•ç¨¿ID: {original_post_id}\nç¿»è¨³å…ˆID: {translated_post_id}\nè¨€èª: {lang_code}\nâ€»æ‰‹å‹•ã§é€£æºã‚’å®Œäº†ã—ã¦ãã ã•ã„'
            }
            
        except Exception as e:
            logger.error(f"Polylangç¿»è¨³é€£æºã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _calculate_dynamic_timeout(self, text_content: str) -> int:
        """å‹•çš„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨ˆç®— - WPå‡¦ç†å¯¾å¿œ"""
        base_timeout = 120
            
        # æ—¢å­˜ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        long_task_keywords = [
            'è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ', 'å®Ÿè£…'
        ]
            
        # === æ–°è¦è¿½åŠ : WordPresså°‚ç”¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ ===
        wp_long_task_keywords = [
            'FacetWP', 'Relevanssi', 'ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰',
            'WP-CLI', 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç§»è¡Œ', 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€æ‹¬',
            'ACF Pro ãƒ©ã‚¤ã‚»ãƒ³ã‚¹', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åŒæœŸ'
        ]
            
        # é€šå¸¸ã®é•·æ™‚é–“ã‚¿ã‚¹ã‚¯
        if any(kw in text_content for kw in long_task_keywords):
            base_timeout = 300
            
        # === WPç‰¹åŒ–ã®è¶…é•·æ™‚é–“ã‚¿ã‚¹ã‚¯ ===
        if any(kw in text_content for kw in wp_long_task_keywords):
            base_timeout = 600  # 10åˆ†
            logger.info(f"â±ï¸ config WPé•·æ™‚é–“å‡¦ç†ã‚’æ¤œå‡º - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {base_timeout}ç§’")
        
        async def cleanup(self):
            """WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
            if self.wp_page:
                try:
                    await self.wp_page.close()
                    logger.info("WordPress ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ WordPress ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚ºã‚¨ãƒ©ãƒ¼: {e}")
            
        return base_timeout
            

#wp_agent.py
"""
wp_agent.py - WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆãƒ»å…¨æ©Ÿèƒ½ä¿æŒï¼‰

ã‚¨ãƒ©ãƒ¼å¯¾ç­–:
1. __init__ã®å¼•æ•°åã‚’ browser_controller ã«çµ±ä¸€
2. wp_credentials ã‚’è¾æ›¸å‹ã§å—ã‘å–ã‚‹è¨­è¨ˆ
3. ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®å¼•æ•°æ¸¡ã—ã‚’çµ±ä¸€
4. åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ãƒ­ã‚°å‡ºåŠ›
5. å…ƒã®ã‚³ãƒ¼ãƒ‰ã®å…¨æ©Ÿèƒ½ã‚’ä¿æŒ
"""

import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path
from playwright.async_api import Page
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController

# WordPressã‚µãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
from .wp_auth import WordPressAuth
from .wp_post_editor import WordPressPostEditor
from .wp_post_creator import WordPressPostCreator
from .wp_plugin_manager import WordPressPluginManager
from .wp_settings_manager import WordPressSettingsManager
from .wp_tester import WordPressTester
from .wp_utils import TaskTypeAnalyzer

logger = logging.getLogger(__name__)


class WordPressAgent:
    """
    WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ - ãƒ¡ã‚¤ãƒ³ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆå…¨æ©Ÿèƒ½ç‰ˆï¼‰
    
    é‡è¦: åˆæœŸåŒ–å¼•æ•°ã¯ browser_controller ã¨ wp_credentials ã®2ã¤ã®ã¿
    """
    
    def __init__(self, browser_controller: BrowserController, wp_credentials: Dict = None):
        """
        åˆæœŸåŒ–ï¼ˆã‚¨ãƒ©ãƒ¼å¯¾ç­–ç‰ˆï¼‰
        
        Args:
            browser_controller: BrowserControllerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆå¿…é ˆï¼‰
            wp_credentials: WordPressèªè¨¼æƒ…å ±ã®è¾æ›¸ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
                - wp_url: ã‚µã‚¤ãƒˆURL
                - wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
                - wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        """
        logger.info("=" * 60)
        logger.info("ğŸŒ wp-agent âœ… INFO WordPressAgentåˆæœŸåŒ–é–‹å§‹")
        logger.info("=" * 60)
        
        # âœ… åŸºæœ¬ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¨­å®š
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.is_logged_in = False
        self.wp_page = None  # WordPresså°‚ç”¨ãƒšãƒ¼ã‚¸
        self.sheets_manager = None  # å¾Œã§å¤–éƒ¨ã‹ã‚‰è¨­å®šã•ã‚Œã‚‹
        
        # âœ… èªè¨¼æƒ…å ±ã®å–å¾—
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        self.wp_user = self.wp_credentials.get('wp_user', '')
        self.wp_pass = self.wp_credentials.get('wp_pass', '')
        
        # âœ… èªè¨¼æƒ…å ±ã®æ¤œè¨¼ã¨ãƒ­ã‚°å‡ºåŠ›
        self._validate_credentials()
        
        # âœ… èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–
        self._initialize_auth_module()
        
        # âœ… ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–
        self._initialize_sub_agents()
        
        logger.info("=" * 60)
        logger.info("ğŸŒ wp-agent âœ… INFO WordPressAgentåˆæœŸåŒ–å®Œäº†")
        logger.info("=" * 60)
    
    def _validate_credentials(self):
        """èªè¨¼æƒ…å ±ã®æ¤œè¨¼"""
        missing = []
        
        if not self.wp_url:
            missing.append('wp_url')
        if not self.wp_user:
            missing.append('wp_user')
        if not self.wp_pass:
            missing.append('wp_pass')
        
        if missing:
            logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN âš ï¸ WordPressèªè¨¼æƒ…å ±ãŒä¸å®Œå…¨ã§ã™: {', '.join(missing)}")
            logger.warning("ğŸŒ wp-agent âš ï¸ WARN è¨˜äº‹ä½œæˆæ©Ÿèƒ½ã®ã¿åˆ©ç”¨å¯èƒ½ï¼ˆæŠ•ç¨¿æ©Ÿèƒ½ã¯åˆ¶é™ã•ã‚Œã¾ã™ï¼‰")
        else:
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressèªè¨¼æƒ…å ±ã®ç¢ºèªå®Œäº†")
    
    def _initialize_auth_module(self):
        """èªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–"""
        if self.wp_url and self.wp_user and self.wp_pass:
            try:
                self.auth = WordPressAuth(
                    browser_controller=self.browser,
                    wp_url=self.wp_url,
                    wp_user=self.wp_user,
                    wp_pass=self.wp_pass
                )
                logger.info("ğŸŒ wp-agent âœ… INFO WordPressAuthåˆæœŸåŒ–å®Œäº†")
            except Exception as e:
                logger.error(f"ğŸŒ wp-agent âŒ ERROR WordPressAuthåˆæœŸåŒ–å¤±æ•—: {e}")
                self.auth = None
        else:
            logger.warning("ğŸŒ wp-agent âš ï¸ WARN WordPressAuthåˆæœŸåŒ–ã‚¹ã‚­ãƒƒãƒ—ï¼ˆèªè¨¼æƒ…å ±ä¸è¶³ï¼‰")
            self.auth = None
    
    def _initialize_sub_agents(self):
        """
        ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ï¼ˆå¼•æ•°çµ±ä¸€ç‰ˆï¼‰
        
        é‡è¦: å…¨ã¦ã®ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã« browser_controller ã¨ wp_credentials ã‚’æ¸¡ã™
        """
        try:
            # âœ… æŠ•ç¨¿ç·¨é›†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
            self.post_editor = WordPressPostEditor(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressPostEditoråˆæœŸåŒ–å®Œäº†")
            
            # âœ… æŠ•ç¨¿ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
            self.post_creator = WordPressPostCreator(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressPostCreatoråˆæœŸåŒ–å®Œäº†")
            
            # âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
            self.plugin_manager = WordPressPluginManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressPluginManageråˆæœŸåŒ–å®Œäº†")
            
            # âœ… è¨­å®šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
            self.settings_manager = WordPressSettingsManager(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressSettingsManageråˆæœŸåŒ–å®Œäº†")
            
            # âœ… ãƒ†ã‚¹ã‚¿ãƒ¼
            self.tester = WordPressTester(
                browser_controller=self.browser,
                wp_credentials=self.wp_credentials
            )
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressTesteråˆæœŸåŒ–å®Œäº†")
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            raise
    
    async def initialize_wp_session(self) -> bool:
        """
        WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
        
        æ”¹å–„ç‚¹:
        1. æ–°ã—ã„ã‚¿ãƒ–ä½œæˆï¼ˆGeminiã‚»ãƒƒã‚·ãƒ§ãƒ³ã¨å®Œå…¨ç‹¬ç«‹ï¼‰
        2. ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨ + ç®¡ç†ç”»é¢ã¸ã®å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        3. ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã®å³æ ¼ãªæ¤œè¨¼
        4. å¤±æ•—æ™‚ã®æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        
        Returns:
            bool: åˆæœŸåŒ–æˆåŠŸæ™‚ True
        """
        try:
            logger.info("=" * 60)
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ä¸­...")
            logger.info("=" * 60)
            
            # âœ… Phase 1: æ–°ã—ã„ã‚¿ãƒ–ã‚’ä½œæˆ
            if not self.browser.context:
                logger.error("ğŸŒ wp-agent âŒ ERROR ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            self.wp_page = await self.browser.context.new_page()
            logger.info("ğŸŒ wp-agent âœ… INFO WordPresså°‚ç”¨ã‚¿ãƒ–ã‚’ä½œæˆã—ã¾ã—ãŸ")
            
            # âœ… Phase 2: èªè¨¼æƒ…å ±ã®æ¤œè¨¼
            if not self.auth:
                logger.error("ğŸŒ wp-agent âŒ ERROR WordPressèªè¨¼ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # âœ… Phase 3: ãƒ­ã‚°ã‚¤ãƒ³å®Ÿè¡Œï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressèªè¨¼ã‚’å®Ÿè¡Œä¸­...")
            login_success = await self.auth.login(self.wp_page)
            
            if login_success:
                self.is_logged_in = True
                logger.info("=" * 60)
                logger.info("ğŸŒ wp-agent âœ… INFO WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–å®Œäº†")
                logger.info(f"  èªè¨¼æ–¹æ³•: ã‚¯ãƒƒã‚­ãƒ¼ or æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³")
                logger.info(f"  ãƒšãƒ¼ã‚¸URL: {self.wp_page.url}")
                logger.info("=" * 60)
                return True
            else:
                logger.error("=" * 60)
                logger.error("ğŸŒ wp-agent âŒ ERROR WordPressãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                logger.error("  åŸå› : èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                logger.error("  å¯¾ç­–: èªè¨¼æƒ…å ±ã‚’ç¢ºèªã—ã¦ãã ã•ã„")
                logger.error("=" * 60)
                
                # ãƒ‡ãƒãƒƒã‚°ç”¨: å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                try:
                    await self.wp_page.screenshot(path="wp_session_init_failed.png")
                    logger.info("ğŸŒ wp-agent ğŸ“¸ INFO ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: wp_session_init_failed.png")
                except:
                    pass
                
                return False
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def ensure_logged_in(self) -> bool:
        """
        ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ä¿è¨¼
        
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã¾ãŸã¯ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        if self.is_logged_in and self.wp_page:
            # å®šæœŸçš„ã«ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            if await self.auth._verify_login_status(self.wp_page):
                return True
        
        # ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ãªã„å ´åˆã¯å†åˆæœŸåŒ–
        logger.info("ğŸŒ wp-agent âœ… INFO WordPresså†ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œã—ã¾ã™")
        return await self.initialize_wp_session()
    
    async def _try_cookie_login(self, wp_url: str) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä½¿ç”¨ã—ãŸãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œ"""
        try:
            if not wp_url:
                logger.warning("ğŸŒ wp-agent âš ï¸ WARN WordPress URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
            
            # WordPressã‚¯ãƒƒã‚­ãƒ¼ã‚’ãƒ­ãƒ¼ãƒ‰
            cookie_loaded = await self.browser.load_wordpress_cookies(wp_url)
            if not cookie_loaded:
                return False
            
            # ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            admin_url = f"{wp_url.rstrip('/')}/wp-admin/"
            await self.browser.page.goto(admin_url, wait_until='networkidle')
            await asyncio.sleep(2)
            
            # ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°ãƒã‚§ãƒƒã‚¯
            return await self._verify_wordpress_login_status()
        
        except Exception as e:
            logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN ã‚¯ãƒƒã‚­ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def _verify_wordpress_login_status(self) -> bool:
        """WordPressãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°æ¤œè¨¼"""
        try:
            page = self.browser.page
            
            # è¤‡æ•°ã®æ–¹æ³•ã§ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            checks = []
            
            # 1. ç®¡ç†ãƒãƒ¼ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('ç®¡ç†ãƒãƒ¼', bool(admin_bar)))
            
            # 2. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¦ç´ ãƒã‚§ãƒƒã‚¯
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰', bool(dashboard)))
            
            # 3. ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®ä¸åœ¨ãƒã‚§ãƒƒã‚¯
            login_form = await page.query_selector('#loginform')
            checks.append(('ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ä¸åœ¨', not bool(login_form)))
            
            # 4. URLãƒã‚§ãƒƒã‚¯ï¼ˆãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã•ã‚Œã¦ã„ãªã„ã‹ï¼‰
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('ç®¡ç†ãƒšãƒ¼ã‚¸URL', is_admin_page))
            
            # çµæœã®é›†è¨ˆ
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼: {total_passed}/4 åˆæ ¼")
            if total_passed >= 3:  # 4ã¤ã®ã†ã¡3ã¤ä»¥ä¸Šåˆæ ¼ãªã‚‰ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ
                logger.info(f"  åˆæ ¼é …ç›®: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN ä¸åˆæ ¼é …ç›®ãŒå¤šã™ãã¾ã™")
                return False
        
        except Exception as e:
            logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def _manual_wordpress_login(self) -> bool:
        """æ‰‹å‹•WordPressãƒ­ã‚°ã‚¤ãƒ³"""
        try:
            wp_url = self.wp_credentials.get('wp_url', '')
            wp_user = self.wp_credentials.get('wp_user', '')
            wp_pass = self.wp_credentials.get('wp_pass', '')
            
            if not all([wp_url, wp_user, wp_pass]):
                logger.error("ğŸŒ wp-agent âŒ ERROR WordPressèªè¨¼æƒ…å ±ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
                return False
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            login_url = f"{wp_url.rstrip('/')}/wp-login.php"
            await self.browser.page.goto(login_url, wait_until='networkidle')
            await asyncio.sleep(2)
            
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›
            user_field = await self.browser.page.query_selector('#user_login')
            if user_field:
                await user_field.fill(wp_user)
                logger.info("ğŸŒ wp-agent âœ… INFO ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›å®Œäº†")
            else:
                logger.error("ğŸŒ wp-agent âŒ ERROR ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›
            pass_field = await self.browser.page.query_selector('#user_pass')
            if pass_field:
                await pass_field.fill(wp_pass)
                logger.info("ğŸŒ wp-agent âœ… INFO ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›å®Œäº†")
            else:
                logger.error("ğŸŒ wp-agent âŒ ERROR ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
            login_button = await self.browser.page.query_selector('#wp-submit')
            if login_button:
                await login_button.click()
                logger.info("ğŸŒ wp-agent âœ… INFO ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯")
            else:
                logger.error("ğŸŒ wp-agent âŒ ERROR ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            # ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾…æ©Ÿ
            await self.browser.page.wait_for_load_state('networkidle')
            await asyncio.sleep(3)
            
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸç¢ºèª
            if await self._verify_wordpress_login_status():
                logger.info("ğŸŒ wp-agent âœ… INFO æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                return True
            else:
                logger.error("ğŸŒ wp-agent âŒ ERROR æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•— - èªè¨¼æƒ…å ±ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®å•é¡Œ")
                return False
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def process_task(self, task: Dict) -> Dict:
        """
        WordPressã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†
        
        Args:
            task: ã‚¿ã‚¹ã‚¯æƒ…å ±ï¼ˆdescription, task_idç­‰ï¼‰
        
        Returns:
            å‡¦ç†çµæœã®è¾æ›¸
        """
        try:
            # ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèª
            if not await self.ensure_logged_in():
                return {
                    'success': False,
                    'error': 'WordPressã«ãƒ­ã‚°ã‚¤ãƒ³ã§ãã¾ã›ã‚“ã§ã—ãŸ'
                }
            
            logger.info("=" * 60)
            logger.info("ğŸŒ wp-agent âœ… INFO WordPressã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹")
            logger.info(f"ã‚¿ã‚¹ã‚¯: {task['description']}")
            logger.info("=" * 60)
            
            # ã‚·ãƒ¼ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼è¨­å®š
            self.post_editor.sheets_manager = self.sheets_manager
            self.post_creator.sheets_manager = self.sheets_manager
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—è§£æ
            task_type = TaskTypeAnalyzer.analyze(task['description'])
            logger.info(f"ğŸŒ wp-agent âœ… INFO è§£æã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—: {task_type}")
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸå‡¦ç†å®Ÿè¡Œ
            result = await self._execute_task_by_type(task, task_type)
            
            return result
        
        except Exception as e:
            ErrorHandler.log_error(e, "ğŸŒ wp-agent WordPressã‚¿ã‚¹ã‚¯å‡¦ç†")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _execute_task_by_type(self, task: Dict, task_type: str) -> Dict:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦é©åˆ‡ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«å‡¦ç†ã‚’å§”è­²"""
        try:
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–¢é€£ã‚¿ã‚¹ã‚¯
            if task_type == 'plugin_install':
                result = await self.plugin_manager.install_plugin(self.wp_page, task)
            elif task_type == 'plugin_settings':
                result = await self.plugin_manager.change_plugin_settings(self.wp_page, task)
            
            # æŠ•ç¨¿é–¢é€£ã‚¿ã‚¹ã‚¯
            elif task_type == 'edit_post':
                result = await self.post_editor.edit_post(self.wp_page, task)
            elif task_type == 'content_create':
                result = await self.post_creator.create_post(self.wp_page, task)
            
            # è¨­å®šé–¢é€£ã‚¿ã‚¹ã‚¯
            elif task_type == 'theme_change':
                result = await self.settings_manager.change_theme(self.wp_page, task)
            elif task_type == 'setting_change':
                result = await self.settings_manager.change_settings(self.wp_page, task)
            
            # ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯
            elif task_type == 'test_functionality':
                result = await self.tester.test_functionality(self.wp_page, task)
            
            # ãã®ä»–ã®ã‚¿ã‚¹ã‚¯
            else:
                result = await self._generic_execution(task)
            
            return result
        
        except Exception as e:
            ErrorHandler.log_error(e, "ğŸŒ wp-agent ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¥å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _generic_execution(self, task: Dict) -> Dict:
        """æ±ç”¨çš„ãªã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆGeminiã«ç¢ºèªã—ãªãŒã‚‰å®Ÿè¡Œï¼‰"""
        try:
            logger.info("ğŸŒ wp-agent âœ… INFO æ±ç”¨ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œä¸­...")
            
            # Geminiãƒ—ãƒ­ãƒ³ãƒ—ãƒˆä½œæˆ
            gemini_prompt = self._build_gemini_prompt(task)
            
            # Geminiã«é€ä¿¡
            await self.browser.send_prompt(gemini_prompt)
            await self.browser.wait_for_text_generation(max_wait=120)
            response = await self.browser.extract_latest_text_response()
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO Geminiã‹ã‚‰å®Ÿè¡Œæ‰‹é †ã‚’å–å¾—ã—ã¾ã—ãŸ")
            logger.info(f"æ‰‹é †:\n{response[:500]}...")
            
            return self._build_generic_result(task, response)
        
        except Exception as e:
            ErrorHandler.log_error(e, "ğŸŒ wp-agent æ±ç”¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _build_gemini_prompt(self, task: Dict) -> str:
        """Geminiç”¨ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
        return f"""
WordPressã§ä»¥ä¸‹ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ãŸã„ã§ã™:

ã€ã‚¿ã‚¹ã‚¯ã€‘
{task['description']}

ã€WordPressæƒ…å ±ã€‘
- URL: {self.wp_url}
- ç®¡ç†ç”»é¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿

ã€è³ªå•ã€‘
ã“ã®ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®å…·ä½“çš„ãªæ‰‹é †ã‚’ã€WordPressç®¡ç†ç”»é¢ã®æ“ä½œã¨ã—ã¦æ•™ãˆã¦ãã ã•ã„ã€‚

ä»¥ä¸‹ã®å½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„:
1. ç§»å‹•ã™ã‚‹ãƒšãƒ¼ã‚¸ã®URLï¼ˆç›¸å¯¾ãƒ‘ã‚¹ï¼‰
2. ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯å…¥åŠ›ã™ã‚‹è¦ç´ ã®ã‚»ãƒ¬ã‚¯ã‚¿
3. å…¥åŠ›ã™ã‚‹å€¤
4. ç¢ºèªã™ã¹ããƒã‚¤ãƒ³ãƒˆ

ã‚»ãƒ¬ã‚¯ã‚¿ã¯ã§ãã‚‹ã ã‘å…·ä½“çš„ã«ï¼ˆid, class, nameå±æ€§ãªã©ï¼‰ã€‚
"""
    
    def _build_generic_result(self, task: Dict, response: str) -> Dict:
        """æ±ç”¨å®Ÿè¡Œã®çµæœã‚’æ§‹ç¯‰"""
        logger.info("ğŸŒ wp-agent âš ï¸ WARN å®Ÿéš›ã®å®Ÿè¡Œã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': 'Geminiã‹ã‚‰å®Ÿè¡Œæ‰‹é †ã‚’å–å¾—ã—ã¾ã—ãŸã€‚æ‰‹é †ã‚’ç¢ºèªã—ã¦å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚',
            'full_text': f'ã€ã‚¿ã‚¹ã‚¯ã€‘\n{task["description"]}\n\nã€å®Ÿè¡Œæ‰‹é †ã€‘\n{response}'
        }
    
    def get_plugin_manager(self):
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’å®‰å…¨ã«å–å¾—"""
        if hasattr(self, 'plugin_manager') and self.plugin_manager:
            return self.plugin_manager
        else:
            logger.error("ğŸŒ wp-agent âŒ ERROR plugin_manager ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
            return None
    
    async def execute_plugin_task(self, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³é–¢é€£ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå®‰å…¨ãªãƒ©ãƒƒãƒ‘ãƒ¼ï¼‰"""
        try:
            if not self.plugin_manager:
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            task_type = task.get('type', '')
            
            if task_type == 'facetwp_configure':
                return await self.plugin_manager.configure_facetwp(task.get('parameters', {}))
            elif task_type == 'user_role_configure':
                return await self.plugin_manager.configure_user_roles(task.get('parameters', {}))
            else:
                return await self.plugin_manager.change_plugin_settings(None, task)
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    # ========================================
    # âœ… å…ƒã®ã‚³ãƒ¼ãƒ‰ã®å…¨æ©Ÿèƒ½ã‚’ä»¥ä¸‹ã«ä¿æŒ
    # ========================================
    
    async def create_post(self, page: Page, task: Dict) -> Dict:
        """æ–°è¦æŠ•ç¨¿ã‚’ä½œæˆï¼ˆpost_statuså¯¾å¿œç‰ˆï¼‰"""
        try:
            post_status = task.get('post_status', 'draft')
            post_action = task.get('post_action', 'create')
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO WordPressæŠ•ç¨¿ä½œæˆ:")
            logger.info(f"  ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {post_action}")
            logger.info(f"  ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}")
            
            # è¨˜äº‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è¨­å®š
            article_title = "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒˆãƒ«"
            polylang_lang = "ja"
            language = "æ—¥æœ¬èª"
            article_body = ""
            screenshot_path = None
            
            # æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸå‡¦ç†
            status_result = await self._handle_post_status(page, post_status, post_action)
            
            # çµæœã‚µãƒãƒªãƒ¼æ§‹ç¯‰
            summary = self._build_create_summary(
                article_title, polylang_lang, language,
                len(article_body), post_status, status_result['message']
            )
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'action': post_action,
                'screenshot': screenshot_path
            }
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR WordPressæŠ•ç¨¿ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _handle_post_status(self, page: Page, post_status: str, post_action: str) -> Dict:
        """æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«å¿œã˜ãŸä¿å­˜/å…¬é–‹å‡¦ç†"""
        try:
            # ä¸‹æ›¸ãä¿å­˜ã®å ´åˆ
            if post_status == 'draft' or post_action == 'create':
                logger.info("ğŸŒ wp-agent âœ… INFO ã€ä¸‹æ›¸ãä¿å­˜ä¸­...ã€‘")
                saved = await self._save_draft(page)
                
                if saved:
                    logger.info("ğŸŒ wp-agent âœ… INFO ä¸‹æ›¸ãä¿å­˜å®Œäº†")
                    return {'success': True, 'message': 'ä¸‹æ›¸ãä¿å­˜'}
                else:
                    logger.warning("ğŸŒ wp-agent âš ï¸ WARN ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                    return {'success': False, 'message': 'ä¿å­˜ç¢ºèªæ¨å¥¨'}
            
            # å…¬é–‹ã®å ´åˆ
            elif post_status == 'publish' or post_action == 'publish':
                logger.info("ğŸŒ wp-agent âœ… INFO ã€è¨˜äº‹ã‚’å…¬é–‹ä¸­...ã€‘")
                published = await self._publish_post(page)
                
                if published:
                    logger.info("ğŸŒ wp-agent âœ… INFO è¨˜äº‹å…¬é–‹å®Œäº†")
                    return {'success': True, 'message': 'å…¬é–‹å®Œäº†'}
                else:
                    logger.warning("ğŸŒ wp-agent âš ï¸ WARN å…¬é–‹ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                    return {'success': False, 'message': 'å…¬é–‹ç¢ºèªæ¨å¥¨'}
            
            # ãã®ä»–ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã®å ´åˆ
            else:
                logger.info(f"ğŸŒ wp-agent âœ… INFO ã€ã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ã€‘")
                saved = await self._save_draft(page)
                return {
                    'success': saved,
                    'message': f'ä¿å­˜å®Œäº†ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ï¼‰'
                }
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'message': f'ã‚¨ãƒ©ãƒ¼: {str(e)}'}
    
    async def _publish_post(self, page: Page) -> bool:
        """æŠ•ç¨¿ã‚’å…¬é–‹"""
        publish_selectors = [
            'button:has-text("å…¬é–‹")',
            'button[aria-label="å…¬é–‹"]',
            '.editor-post-publish-button',
            'button.editor-post-publish-button__button'
        ]
        
        logger.debug("ğŸŒ wp-agent ğŸ› DEBUG å…¬é–‹ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(publish_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(publish_selectors)}: {selector}")
            try:
                publish_button = await page.query_selector(selector)
                if not publish_button:
                    continue
                
                is_visible = await publish_button.is_visible()
                is_disabled = await publish_button.is_disabled() if is_visible else True
                
                logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
                
                if is_visible and not is_disabled:
                    await publish_button.click()
                    await page.wait_for_timeout(2000)
                    
                    # ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç†
                    try:
                        confirm_button = await page.query_selector('button:has-text("å…¬é–‹")')
                        if confirm_button and await confirm_button.is_visible():
                            await confirm_button.click()
                            await page.wait_for_timeout(3000)
                    except:
                        pass
                    
                    logger.info("ğŸŒ wp-agent âœ… INFO å…¬é–‹ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                    return True
            
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("ğŸŒ wp-agent âš ï¸ WARN å…¬é–‹ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        save_selectors = [
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
        
        logger.debug("ğŸŒ wp-agent ğŸ› DEBUG ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if not save_button:
                    continue
                
                is_visible = await save_button.is_visible()
                is_disabled = await save_button.is_disabled() if is_visible else True
                
                logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
                
                if is_visible and not is_disabled:
                    await save_button.click()
                    await page.wait_for_timeout(4000)
                    logger.info("ğŸŒ wp-agent âœ… INFO ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                    return True
            
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("ğŸŒ wp-agent âš ï¸ WARN ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    def _build_create_summary(self, title: str, polylang_lang: str,
                             language: str, content_length: int,
                             post_status: str, status_message: str) -> str:
        """æ–°è¦æŠ•ç¨¿ä½œæˆã®ã‚µãƒãƒªãƒ¼ã‚’æ§‹ç¯‰"""
        summary_lines = []
        summary_lines.append("ã€WordPressæŠ•ç¨¿å®Œäº†ã€‘")
        summary_lines.append(f"ã‚¿ã‚¤ãƒˆãƒ«: {title}")
        summary_lines.append(f"è¨€èª: {language}")
        summary_lines.append(f"Polylangè¨­å®š: {polylang_lang}")
        summary_lines.append(f"æœ¬æ–‡: {content_length}æ–‡å­—ï¼ˆHTMLå½¢å¼ï¼‰")
        summary_lines.append(f"æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}")
        summary_lines.append(f"âœ… {status_message}")
        
        return '\n'.join(summary_lines)
    
    # ========================================
    # âœ… ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®šæ©Ÿèƒ½
    # ========================================
    
    async def configure_acf_fields(self, task_params: Dict) -> Dict:
        """Advanced Custom Fieldsã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¨­å®š"""
        try:
            field_group_name = task_params.get('acf_field_group_name')
            fields = task_params.get('acf_fields', [])
            location_rules = task_params.get('acf_location_rules', {})
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— '{field_group_name}' ã‚’è¨­å®šä¸­...")
            
            # ACFç”»é¢ç§»å‹•
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/edit.php?post_type=acf-field-group")
            await self.wp_page.wait_for_timeout(2000)
            
            # æ–°è¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—è¿½åŠ 
            await self._click_acf_add_new_button()
            
            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åå…¥åŠ›
            await self._input_acf_field_group_name(field_group_name)
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã¨çµæœè¿”å´
            return await self._build_acf_result(field_group_name, fields, location_rules)
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR ACFè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _click_acf_add_new_button(self):
        """ACFæ–°è¦è¿½åŠ ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯"""
        add_button_selectors = [
            'a.page-title-action:has-text("æ–°è¦è¿½åŠ ")',
            'a:has-text("Add New")',
            '.page-title-action'
        ]
        
        for selector in add_button_selectors:
            try:
                add_button = await self.wp_page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await self.wp_page.wait_for_timeout(3000)
                    break
            except:
                continue
    
    async def _input_acf_field_group_name(self, field_group_name: str):
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›"""
        title_input = await self.wp_page.query_selector('#title')
        if title_input:
            await title_input.fill(field_group_name)
            logger.info(f"ğŸŒ wp-agent âœ… INFO ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›: {field_group_name}")
    
    async def _build_acf_result(self, field_group_name: str, fields: list, location_rules: dict) -> Dict:
        """ACFè¨­å®šçµæœã‚’æ§‹ç¯‰"""
        screenshot_path = f"acf_setup_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("ğŸŒ wp-agent âš ï¸ WARN ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®è©³ç´°è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': f'ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ— "{field_group_name}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'field_group_name': field_group_name,
            'fields_count': len(fields),
            'screenshot': screenshot_path,
            'full_text': f'ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—è¨­å®š\nåå‰: {field_group_name}\nãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ•°: {len(fields)}\nâ€»ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }
    
    # ========================================
    # âœ… ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆæ©Ÿèƒ½
    # ========================================
    
    async def configure_custom_post_type(self, task_params: Dict) -> Dict:
        """Custom Post Type UIã§ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆ"""
        try:
            cpt_slug = task_params.get('cpt_slug')
            cpt_labels = task_params.get('cpt_labels', {})
            cpt_supports = task_params.get('cpt_supports', [])
            cpt_settings = task_params.get('cpt_settings', {})
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— '{cpt_slug}' ã‚’ä½œæˆä¸­...")
            
            # CPT UIç”»é¢ç§»å‹•
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_post_types")
            await self.wp_page.wait_for_timeout(3000)
            
            # åŸºæœ¬æƒ…å ±å…¥åŠ›
            await self._input_cpt_basic_info(cpt_slug, cpt_labels)
            
            # çµæœæ§‹ç¯‰
            return await self._build_cpt_result(cpt_slug, cpt_labels)
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR Custom Post Typeä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _input_cpt_basic_info(self, cpt_slug: str, cpt_labels: dict):
        """CPTåŸºæœ¬æƒ…å ±ã‚’å…¥åŠ›"""
        # Post Type Slugå…¥åŠ›
        slug_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[name]"]')
        if slug_input:
            await slug_input.fill(cpt_slug)
            logger.info(f"ğŸŒ wp-agent âœ… INFO ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {cpt_slug}")
        
        # Plural Labelå…¥åŠ›
        plural_label = cpt_labels.get('plural', cpt_slug)
        plural_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[label]"]')
        if plural_input:
            await plural_input.fill(plural_label)
            logger.info(f"ğŸŒ wp-agent âœ… INFO è¤‡æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {plural_label}")
        
        # Singular Labelå…¥åŠ›
        singular_label = cpt_labels.get('singular', cpt_slug)
        singular_input = await self.wp_page.query_selector('input[name="cpt_custom_post_type[singular_label]"]')
        if singular_input:
            await singular_input.fill(singular_label)
            logger.info(f"ğŸŒ wp-agent âœ… INFO å˜æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {singular_label}")
    
    async def _build_cpt_result(self, cpt_slug: str, cpt_labels: dict) -> Dict:
        """CPTä½œæˆçµæœã‚’æ§‹ç¯‰"""
        screenshot_path = f"cpt_creation_{cpt_slug}_{datetime.now().strftime('%H%M%S')}.png"
        await self.wp_page.screenshot(path=screenshot_path)
        
        logger.info("ğŸŒ wp-agent âš ï¸ WARN è©³ç´°è¨­å®šã¨Supportsè¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
        
        return {
            'success': True,
            'summary': f'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— "{cpt_slug}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'cpt_slug': cpt_slug,
            'cpt_labels': cpt_labels,
            'screenshot': screenshot_path,
            'full_text': f'Custom Post Typeä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {cpt_slug}\nãƒ©ãƒ™ãƒ«: {cpt_labels}\nâ€»Supportsè¨­å®šç­‰ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }
    
    # ========================================
    # âœ… ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆæ©Ÿèƒ½
    # ========================================
    
    async def configure_custom_taxonomy(self, task_params: Dict) -> Dict:
        """Custom Post Type UIã§ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚’ä½œæˆ"""
        try:
            taxonomy_slug = task_params.get('taxonomy_slug')
            taxonomy_labels = task_params.get('taxonomy_labels', {})
            taxonomy_post_types = task_params.get('taxonomy_post_types', [])
            taxonomy_hierarchical = task_params.get('taxonomy_hierarchical', True)
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ '{taxonomy_slug}' ã‚’ä½œæˆä¸­...")
            
            # Custom Post Type UI - Taxonomiesç”»é¢ã«ç§»å‹•
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/admin.php?page=cptui_manage_taxonomies")
            await self.wp_page.wait_for_timeout(3000)
            
            # Taxonomy Slugå…¥åŠ›
            slug_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[name]"]')
            if slug_input:
                await slug_input.fill(taxonomy_slug)
                logger.info(f"ğŸŒ wp-agent âœ… INFO ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {taxonomy_slug}")
            
            # Plural Labelå…¥åŠ›
            plural_label = taxonomy_labels.get('plural', taxonomy_slug)
            plural_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[label]"]')
            if plural_input:
                await plural_input.fill(plural_label)
                logger.info(f"ğŸŒ wp-agent âœ… INFO è¤‡æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {plural_label}")
            
            # Singular Labelå…¥åŠ›
            singular_label = taxonomy_labels.get('singular', taxonomy_slug)
            singular_input = await self.wp_page.query_selector('input[name="cpt_custom_tax[singular_label]"]')
            if singular_input:
                await singular_input.fill(singular_label)
                logger.info(f"ğŸŒ wp-agent âœ… INFO å˜æ•°å½¢ãƒ©ãƒ™ãƒ«ã‚’å…¥åŠ›: {singular_label}")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"taxonomy_creation_{taxonomy_slug}_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("ğŸŒ wp-agent âš ï¸ WARN Attach to Post Typesã¨éšå±¤è¨­å®šã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': f'ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ "{taxonomy_slug}" ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
                'taxonomy_slug': taxonomy_slug,
                'taxonomy_labels': taxonomy_labels,
                'screenshot': screenshot_path,
                'full_text': f'Custom Taxonomyä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {taxonomy_slug}\nãƒ©ãƒ™ãƒ«: {taxonomy_labels}\nâ€»æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç´ä»˜ã‘ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
            }
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    # ========================================
    # âœ… M&Aæ¡ˆä»¶æŠ•ç¨¿æ©Ÿèƒ½ï¼ˆACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãï¼‰
    # ========================================
    
    async def create_ma_case_post(self, task_params: Dict) -> Dict:
        """M&Aæ¡ˆä»¶ã‚’ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»˜ãã§æŠ•ç¨¿"""
        try:
            post_title = task_params.get('post_title')
            post_content = task_params.get('post_content', '')
            acf_fields = task_params.get('acf_fields', {})
            polylang_lang = task_params.get('polylang_lang', 'ja')
            post_status = task_params.get('post_status', 'draft')
            
            logger.info(f"ğŸŒ wp-agent âœ… INFO M&Aæ¡ˆä»¶æŠ•ç¨¿: {post_title}")
            
            # æ–°è¦æŠ•ç¨¿ç”»é¢ã«ç§»å‹•ï¼ˆma_caseæŠ•ç¨¿ã‚¿ã‚¤ãƒ—ï¼‰
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post-new.php?post_type=ma_case")
            await self.wp_page.wait_for_timeout(5000)
            
            # ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
            await self._input_title(self.wp_page, post_title)
            
            # æœ¬æ–‡å…¥åŠ›ï¼ˆã‚ã‚‹å ´åˆï¼‰
            if post_content:
                await self._input_content(self.wp_page, post_content)
            
            # ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ã‚’å…¥åŠ›
            logger.info("ğŸŒ wp-agent âœ… INFO ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ã‚’å…¥åŠ›ä¸­...")
            for field_name, field_value in acf_fields.items():
                try:
                    field_selector = f'input[name="acf[{field_name}]"]'
                    field_input = await self.wp_page.query_selector(field_selector)
                    
                    if field_input:
                        await field_input.fill(str(field_value))
                        logger.info(f"  {field_name}: {field_value}")
                    else:
                        logger.warning(f"  ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                except Exception as e:
                    logger.warning(f"  ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field_name}' å…¥åŠ›ã‚¨ãƒ©ãƒ¼: {e}")
            
            # Polylangè¨€èªè¨­å®š
            await self._set_polylang_language(self.wp_page, polylang_lang)
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"ma_case_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            # ä¿å­˜ã¾ãŸã¯å…¬é–‹
            if post_status == 'draft':
                saved = await self._save_draft(self.wp_page)
                status_message = "ä¸‹æ›¸ãä¿å­˜å®Œäº†" if saved else "ä¿å­˜ç¢ºèªæ¨å¥¨"
            elif post_status == 'publish':
                published = await self._publish_post(self.wp_page)
                status_message = "å…¬é–‹å®Œäº†" if published else "å…¬é–‹ç¢ºèªæ¨å¥¨"
            else:
                saved = await self._save_draft(self.wp_page)
                status_message = f"ä¿å­˜å®Œäº†ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}ï¼‰"
            
            summary = f"""ã€M&Aæ¡ˆä»¶æŠ•ç¨¿å®Œäº†ã€‘
ã‚¿ã‚¤ãƒˆãƒ«: {post_title}
è¨€èª: {polylang_lang}
ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: {len(acf_fields)}ä»¶
æŠ•ç¨¿ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {post_status}
âœ… {status_message}"""
            
            return {
                'success': True,
                'summary': summary,
                'post_status': post_status,
                'acf_fields_count': len(acf_fields),
                'screenshot': screenshot_path,
                'full_text': summary
            }
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR M&Aæ¡ˆä»¶æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _input_title(self, page: Page, title: str):
        """ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›"""
        title_input = await page.query_selector('#title, .editor-post-title__input')
        if title_input:
            await title_input.fill(title)
            logger.info(f"ğŸŒ wp-agent âœ… INFO ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›: {title}")
    
    async def _input_content(self, page: Page, content: str):
        """æœ¬æ–‡å…¥åŠ›"""
        # ãƒ–ãƒ­ãƒƒã‚¯ã‚¨ãƒ‡ã‚£ã‚¿ã®å ´åˆ
        content_block = await page.query_selector('.block-editor-writing-flow')
        if content_block:
            await content_block.click()
            await page.keyboard.type(content)
            logger.info(f"ğŸŒ wp-agent âœ… INFO æœ¬æ–‡å…¥åŠ›å®Œäº†ï¼ˆ{len(content)}æ–‡å­—ï¼‰")
    
    async def _set_polylang_language(self, page: Page, lang_code: str):
        """Polylangè¨€èªè¨­å®š"""
        try:
            lang_selector = f'select#post_lang_choice option[value="{lang_code}"]'
            lang_option = await page.query_selector(lang_selector)
            if lang_option:
                await lang_option.click()
                logger.info(f"ğŸŒ wp-agent âœ… INFO Polylangè¨€èªè¨­å®š: {lang_code}")
        except Exception as e:
            logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN Polylangè¨€èªè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
    
    # ========================================
    # âœ… Polylangç¿»è¨³é€£æºæ©Ÿèƒ½
    # ========================================
    
    async def link_polylang_translations(self, original_post_id: int, translated_post_id: int, lang_code: str) -> Dict:
        """Polylangã§æŠ•ç¨¿åŒå£«ã‚’ç¿»è¨³é–¢ä¿‚ã¨ã—ã¦é€£æº"""
        try:
            logger.info(f"ğŸŒ wp-agent âœ… INFO Polylangç¿»è¨³é€£æº: {original_post_id} â†’ {translated_post_id} ({lang_code})")
            
            # å…ƒã®æŠ•ç¨¿ã®ç·¨é›†ç”»é¢ã‚’é–‹ã
            await self.wp_page.goto(f"{self.wp_url}/wp-admin/post.php?post={original_post_id}&action=edit")
            await self.wp_page.wait_for_timeout(3000)
            
            # Polylangè¨€èªãƒ¡ã‚¿ãƒœãƒƒã‚¯ã‚¹ã§+ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            logger.info("ğŸŒ wp-agent âœ… INFO Polylangè¨€èªè¨­å®šãƒ¡ã‚¿ãƒœãƒƒã‚¯ã‚¹ã‚’æ“ä½œä¸­...")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"polylang_link_{datetime.now().strftime('%H%M%S')}.png"
            await self.wp_page.screenshot(path=screenshot_path)
            
            logger.info("ğŸŒ wp-agent âš ï¸ WARN Polylangç¿»è¨³é€£æºã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': f'æŠ•ç¨¿ID {original_post_id} ã®ç·¨é›†ç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚Polylangè¨­å®šã§æŠ•ç¨¿ID {translated_post_id} ã‚’é€£æºã—ã¦ãã ã•ã„ã€‚',
                'original_post_id': original_post_id,
                'translated_post_id': translated_post_id,
                'lang_code': lang_code,
                'screenshot': screenshot_path,
                'full_text': f'Polylangç¿»è¨³é€£æº\nå…ƒæŠ•ç¨¿ID: {original_post_id}\nç¿»è¨³å…ˆID: {translated_post_id}\nè¨€èª: {lang_code}\nâ€»æ‰‹å‹•ã§é€£æºã‚’å®Œäº†ã—ã¦ãã ã•ã„'
            }
        
        except Exception as e:
            logger.error(f"ğŸŒ wp-agent âŒ ERROR Polylangç¿»è¨³é€£æºã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    # ========================================
    # âœ… å‹•çš„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨ˆç®—
    # ========================================
    
    def _calculate_dynamic_timeout(self, text_content: str) -> int:
        """å‹•çš„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨ˆç®— - WPå‡¦ç†å¯¾å¿œ"""
        base_timeout = 120
        
        # æ—¢å­˜ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        long_task_keywords = [
            'è¦ä»¶å®šç¾©', 'è¨­è¨ˆæ›¸', 'ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ', 'å®Ÿè£…'
        ]
        
        # WordPresså°‚ç”¨ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        wp_long_task_keywords = [
            'FacetWP', 'Relevanssi', 'ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å†æ§‹ç¯‰',
            'WP-CLI', 'ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç§»è¡Œ', 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€æ‹¬',
            'ACF Pro ãƒ©ã‚¤ã‚»ãƒ³ã‚¹', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åŒæœŸ'
        ]
        
        # é€šå¸¸ã®é•·æ™‚é–“ã‚¿ã‚¹ã‚¯
        if any(kw in text_content for kw in long_task_keywords):
            base_timeout = 300
        
        # WPç‰¹åŒ–ã®è¶…é•·æ™‚é–“ã‚¿ã‚¹ã‚¯
        if any(kw in text_content for kw in wp_long_task_keywords):
            base_timeout = 600  # 10åˆ†
            logger.info(f"ğŸŒ wp-agent â±ï¸ INFO WPé•·æ™‚é–“å‡¦ç†ã‚’æ¤œå‡º - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {base_timeout}ç§’")
        
        return base_timeout
    
    async def cleanup(self):
        """WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        if self.wp_page:
            try:
                await self.wp_page.close()
                logger.info("ğŸŒ wp-agent âœ… INFO WordPressã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’çµ‚äº†ã—ã¾ã—ãŸ")
            except Exception as e:
                logger.warning(f"ğŸŒ wp-agent âš ï¸ WARN WordPressãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚ºã‚¨ãƒ©ãƒ¼: {e}")

#wp_auth.py
"""WordPressèªè¨¼ãƒ»ãƒ­ã‚°ã‚¤ãƒ³ç®¡ç†ï¼ˆå®Œå…¨ä¿®æ­£ç‰ˆ - ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰"""
import asyncio
import logging
import json
import time
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressAuth:
    """WordPressèªè¨¼ç®¡ç†ï¼ˆBrowserControllerçµ±åˆç‰ˆ + ã‚¯ãƒƒã‚­ãƒ¼å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰"""
    
    def __init__(self, browser_controller, wp_url: str, wp_user: str, wp_pass: str):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            wp_url: WordPress ã‚µã‚¤ãƒˆURL
            wp_user: ãƒ¦ãƒ¼ã‚¶ãƒ¼å
            wp_pass: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
        """
        self.browser = browser_controller
        self.wp_url = wp_url.rstrip('/')
        self.wp_user = wp_user
        self.wp_pass = wp_pass
    
    async def login(self, page: Page) -> bool:
        """
        WordPressã«ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ç‰ˆï¼‰
        
        æ”¹å–„ç‚¹:
        1. ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨å¾Œã«å¿…ãšç®¡ç†ç”»é¢URLã¸ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        2. ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã®å³æ ¼åŒ–
        3. å¤±æ•—æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¼·åŒ–
        
        Args:
            page: Playwright Page ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        try:
            logger.info("="*60)
            logger.info("WordPress: ãƒ­ã‚°ã‚¤ãƒ³é–‹å§‹ï¼ˆã‚¯ãƒƒã‚­ãƒ¼å„ªå…ˆ + å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰")
            logger.info(f"URL: {self.wp_url}")
            logger.info("="*60)
            
            # âœ… Phase 1: ã‚¯ãƒƒã‚­ãƒ¼ã§ã®ãƒ­ã‚°ã‚¤ãƒ³ã‚’è©¦è¡Œ
            cookies_loaded = await self.browser.load_wordpress_cookies(self.wp_url)
            
            if cookies_loaded:
                logger.info("âœ… WordPress ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ")
                
                # âœ… é‡è¦: ã‚¯ãƒƒã‚­ãƒ¼é©ç”¨å¾Œã«ç®¡ç†ç”»é¢ã«å¼·åˆ¶ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
                admin_url = f"{self.wp_url}/wp-admin/"
                logger.info(f"ğŸ”„ ç®¡ç†ç”»é¢ã«ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ä¸­: {admin_url}")
                
                try:
                    await page.goto(admin_url, timeout=30000, wait_until="domcontentloaded")
                    await asyncio.sleep(3)  # ã‚»ãƒƒã‚·ãƒ§ãƒ³ç¢ºç«‹ã‚’å¾…æ©Ÿ
                    
                    # âœ… Phase 2: ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’å³æ ¼ã«æ¤œè¨¼
                    if await self._verify_login_status(page):
                        logger.info("âœ… ã‚¯ãƒƒã‚­ãƒ¼èªè¨¼æˆåŠŸ - æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿")
                        
                        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜
                        screenshot_path = f"wp_cookie_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                        await page.screenshot(path=screenshot_path)
                        logger.info(f"ğŸ“¸ ã‚¯ãƒƒã‚­ãƒ¼ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ: {screenshot_path}")
                        
                        return True
                    else:
                        logger.warning("âš ï¸ ã‚¯ãƒƒã‚­ãƒ¼èªè¨¼å¤±æ•— - æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™")
                        
                except Exception as nav_error:
                    logger.warning(f"âš ï¸ ç®¡ç†ç”»é¢ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {nav_error}")
            
            # âœ… Phase 3: ã‚¯ãƒƒã‚­ãƒ¼èªè¨¼ãŒå¤±æ•—ã—ãŸå ´åˆã¯æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³
            return await self.manual_login(page)
                
        except Exception as e:
            logger.error(f"âŒ ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³
            return await self.manual_login(page)
    
    async def manual_login(self, page: Page) -> bool:
        """
        æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å/ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ–¹å¼ï¼‰
        
        Args:
            page: Playwright Page ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ True
        """
        try:
            logger.info("ğŸ” æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            login_url = f"{self.wp_url}/wp-login.php"
            await page.goto(login_url, timeout=30000, wait_until="domcontentloaded")
            await asyncio.sleep(2)
            
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›
            user_field = await page.query_selector('#user_login')
            if not user_field:
                logger.error("âŒ ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            await user_field.fill(self.wp_user)
            await asyncio.sleep(0.5)
            logger.info("âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼åå…¥åŠ›å®Œäº†")
            
            # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›
            pass_field = await page.query_selector('#user_pass')
            if not pass_field:
                logger.error("âŒ ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            await pass_field.fill(self.wp_pass)
            await asyncio.sleep(0.5)
            logger.info("âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å…¥åŠ›å®Œäº†")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            login_button = await page.query_selector('#wp-submit')
            if not login_button:
                logger.error("âŒ ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            await login_button.click()
            await asyncio.sleep(5)
            logger.info("âœ… ãƒ­ã‚°ã‚¤ãƒ³ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
            
            # ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸç¢ºèª
            if await self._verify_login_status(page):
                logger.info("âœ… WordPressæ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ")
                
                # âœ… ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸæ™‚ã«ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜
                await self.browser.save_wordpress_cookies(self.wp_url)
                
                # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜
                screenshot_path = f"wp_manual_login_success_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                logger.info(f"ğŸ“¸ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ: {screenshot_path}")
                
                return True
            else:
                logger.error("âŒ WordPressãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—")
                
                # å¤±æ•—æ™‚ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
                await page.screenshot(path="wp_login_failed.png")
                
                # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç¢ºèª
                error_element = await page.query_selector('#login_error')
                if error_element:
                    error_text = await error_element.text_content()
                    logger.error(f"ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {error_text}")
                
                return False
                
        except Exception as e:
            logger.error(f"âŒ æ‰‹å‹•ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    async def _verify_login_status(self, page: Page) -> bool:
        """
        WordPressãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’è©³ç´°æ¤œè¨¼ï¼ˆå³æ ¼ç‰ˆï¼‰
        
        æ”¹å–„ç‚¹:
        1. URLç¢ºèªã‚’æœ€å„ªå…ˆ
        2. 4ã¤ã®ãƒã‚§ãƒƒã‚¯ã®ã†ã¡3ã¤ä»¥ä¸Šã§åˆæ ¼åˆ¤å®š
        3. å„ãƒã‚§ãƒƒã‚¯çµæœã‚’è©³ç´°ã«ãƒ­ã‚°å‡ºåŠ›
        
        Args:
            page: Playwright Page ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            
        Returns:
            bool: ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã®å ´åˆ True
        """
        try:
            checks = []
            
            # âœ… 1. URLç¢ºèªï¼ˆæœ€å„ªå…ˆï¼‰
            current_url = page.url
            is_admin_page = '/wp-admin/' in current_url and 'wp-login.php' not in current_url
            checks.append(('ç®¡ç†ãƒšãƒ¼ã‚¸URL', is_admin_page))
            
            # âœ… 2. ç®¡ç†ãƒãƒ¼ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
            admin_bar = await page.query_selector('#wpadminbar')
            checks.append(('ç®¡ç†ãƒãƒ¼', bool(admin_bar)))
            
            # âœ… 3. ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰è¦ç´ ãƒã‚§ãƒƒã‚¯
            dashboard = await page.query_selector('#wpbody-content')
            checks.append(('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰', bool(dashboard)))
            
            # âœ… 4. ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®ä¸åœ¨ãƒã‚§ãƒƒã‚¯
            login_form = await page.query_selector('#loginform')
            checks.append(('ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ä¸åœ¨', not bool(login_form)))
            
            # çµæœã®é›†è¨ˆ
            passed_checks = [name for name, passed in checks if passed]
            total_passed = len(passed_checks)
            
            logger.info(f"ğŸ” ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼: {total_passed}/4 åˆæ ¼")
            
            # âœ… è©³ç´°ãƒ­ã‚°å‡ºåŠ›
            for name, passed in checks:
                status = "âœ…" if passed else "âŒ"
                logger.info(f"  {status} {name}")
            
            if total_passed >= 3:  # 4ã¤ã®ã†ã¡3ã¤ä»¥ä¸Šåˆæ ¼ãªã‚‰ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ
                logger.info(f"  âœ… åˆæ ¼é …ç›®: {', '.join(passed_checks)}")
                return True
            else:
                logger.warning(f"  âŒ ä¸åˆæ ¼ãŒå¤šã™ãã¾ã™ï¼ˆåˆæ ¼: {total_passed}/4ï¼‰")
                logger.warning(f"  ç¾åœ¨URL: {current_url}")
                return False
                
        except Exception as e:
            logger.warning(f"âš ï¸ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False

#wp_cpt_agent.py
"""
WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    PROMPT_TEMPLATE = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€ã‚¿ã‚¹ã‚¯ã€‘
ä»¥ä¸‹ã®ä»•æ§˜ã§ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆã™ã‚‹PHPã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

{cpt_spec}

ã€å‡ºåŠ›è¦ä»¶ã€‘
1. å®Œå…¨ã«å‹•ä½œã™ã‚‹PHPã‚³ãƒ¼ãƒ‰
2. register_post_type() ã‚’ä½¿ç”¨
3. å¤šè¨€èªå¯¾å¿œï¼ˆPolylangäº’æ›ï¼‰
4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ã
5. ã‚³ãƒ¡ãƒ³ãƒˆä»˜ã

ã€å‡ºåŠ›å½¢å¼ã€‘
```php
<?php
/**
 * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_name}
 * ä½œæˆæ—¥: {date}
 */

function register_cpt_{cpt_slug}() {{
    // ã‚³ãƒ¼ãƒ‰å®Ÿè£…
}}
add_action('init', 'register_cpt_{cpt_slug}', 0);
å®Œå…¨ãªPHPã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
"""
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder

    async def execute(self, task: Dict) -> Dict:
        """CPTä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '')
        
        try:
            logger.info("ğŸ”§ ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆé–‹å§‹")
            
            # CPTä»•æ§˜ã‚’æŠ½å‡º
            cpt_spec = self._extract_cpt_spec(description)
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
            prompt = self.PROMPT_TEMPLATE.format(
                cpt_spec=cpt_spec,
                cpt_name=cpt_spec.get('name', 'N/A'),
                cpt_slug=cpt_spec.get('slug', 'custom_post'),
                date=datetime.now().strftime('%Y-%m-%d')
            )
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡
            await self.browser.send_prompt(prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=180)
            
            if not success:
                return {'success': False, 'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'}
            
            # å¿œç­”å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            # PHPä¿å­˜
            output_file = await self._save_php_code(response_text, cpt_spec['slug'], task_id)
            
            return {
                'success': True,
                'message': f'CPTä½œæˆå®Œäº†: {cpt_spec["slug"]}',
                'output_file': str(output_file),
                'cpt_slug': cpt_spec['slug'],
                'task_id': task_id
            }
            
        except Exception as e:
            logger.error(f"âŒ CPTä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {'success': False, 'error': str(e), 'task_id': task_id}

    def _extract_cpt_spec(self, description: str) -> Dict:
        """èª¬æ˜ã‹ã‚‰CPTä»•æ§˜ã‚’æŠ½å‡º"""
        # M&Aæ¡ˆä»¶ã®å ´åˆ
        if 'ma_case' in description.lower() or 'm&aæ¡ˆä»¶' in description:
            return {
                'slug': 'ma_case',
                'name': 'M&Aæ¡ˆä»¶',
                'singular': 'M&Aæ¡ˆä»¶',
                'plural': 'M&Aæ¡ˆä»¶ä¸€è¦§'
            }
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return {
            'slug': 'custom_post',
            'name': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿',
            'singular': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿',
            'plural': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ä¸€è¦§'
        }

    async def _save_php_code(self, code: str, slug: str, task_id: str) -> Path:
        """PHPã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"cpt_{slug}_{task_id}_{timestamp}.php"
        output_path = self.output_folder / filename
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        logger.info(f"âœ… PHPä¿å­˜: {filename}")
        return output_path

#### 3-3. `wordpress/wp_dev/wp_taxonomy_agent.py`
"""
WordPressã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
"""

import logging
from typing import Dict
from pathlib import Path

logger = logging.getLogger(__name__)


class WordPressTaxonomyAgent:
    """ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ"""
    
    def __init__(self, browser, output_folder: Path):
        self.browser = browser
        self.output_folder = output_folder
    
    async def execute(self, task: Dict) -> Dict:
        """ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        # å®Ÿè£…ï¼ˆwp_cpt_agent.py ã¨åŒæ§˜ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
        return {
            'success': True,
            'message': 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ä½œæˆå®Œäº†ï¼ˆå®Ÿè£…ä¸­ï¼‰',
            'task_id': task.get('task_id')
        }

#wp_design.py
# wp_design.py
"""
WordPressè¨­è¨ˆãƒ»é–‹ç™ºã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
task_executor.py ã® WordPress å°‚ç”¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æä¾›
"""

import asyncio
import logging
from typing import Dict, Any, Optional

# ãƒ­ã‚¬ãƒ¼ã®è¨­å®š
logger = logging.getLogger(__name__)

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ•ãƒ©ã‚°ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ã«è¨­å®šã•ã‚Œã‚‹ã¹ãï¼‰
HAS_TASK_ROUTER = False
HAS_ENHANCED_HANDLER = False

# ãƒ€ãƒŸãƒ¼ã‚¯ãƒ©ã‚¹å®šç¾©ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªã‚¯ãƒ©ã‚¹ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼‰
class EnhancedErrorHandler:
    @staticmethod
    async def timeout_wrapper(coro, timeout, context):
        return await asyncio.wait_for(coro, timeout=timeout)
    
    @staticmethod
    def log_error_with_context(e, context):
        logger.error(f"{context}: {e}")

class ErrorHandler:
    @staticmethod
    def log_error(e, context):
        logger.error(f"{context}: {e}")

class TaskRouter:
    @staticmethod
    def determine_task_type(task):
        return task.get('task_type', 'default')

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
task_router = TaskRouter() if HAS_TASK_ROUTER else None


class WordPressTaskExecutor:
    """
    WordPresså°‚ç”¨ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¯ãƒ©ã‚¹
    """
    
    def __init__(self, agents=None, ma_executor=None, content_executor=None, review_agent=None):
        """åˆæœŸåŒ–"""
        self.agents = agents or {}
        self.ma_executor = ma_executor
        self.content_executor = content_executor
        self.review_agent = review_agent
        
        logger.info("âœ… WordPressTaskExecutor åˆæœŸåŒ–å®Œäº†")
    
    async def execute_task(self, task: Dict) -> bool:
        """å˜ä¸€ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆWordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå¯¾å¿œç‰ˆï¼‰"""
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¿ã‚¹ã‚¯é–‹å§‹ãƒ˜ãƒƒãƒ€ãƒ¼è¡¨ç¤º ===
            # ============================================================
            print("\n" + "ğŸ“·"*40)
            print("=" * 80)
            print(f"ğŸ¯ ã‚¿ã‚¹ã‚¯é–‹å§‹: {task_id}")
            print("=" * 80)
            print(f"ğŸ“ å†…å®¹: {task['description'][:70]}...")
            print(f"ğŸ‘¤ æ‹…å½“ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: {task['required_role'].upper()}")
            
            print("=" * 80)
            print("ğŸ“·"*40 + "\n")
            
            logger.info(f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œé–‹å§‹")
            
            # ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’'in_progress'ã«æ›´æ–°
            try:
                await self.update_task_status(task, 'in_progress')
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°å¤±æ•—ï¼ˆç¶šè¡Œï¼‰: {e}")
            
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š ===
            # ============================================================
            role = task['required_role'].lower()
            
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒãƒƒãƒ—
            timeout_map = {
                'ma': 300.0,
                'content': 240.0,
                'review': 180.0,
                'wordpress': 300.0,
                'wp_design': 300.0,  # WordPressè¨­è¨ˆ
                'wp_dev': 300.0,     # WordPressé–‹ç™º
                'default': 180.0
            }
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
            task_type = 'default'
            if HAS_TASK_ROUTER and task_router:
                try:
                    task_type = task_router.determine_task_type(task)
                    logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®š: {task_type}")
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šå¤±æ•—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‡¦ç†: {e}")
            
            task_timeout = timeout_map.get(task_type, timeout_map.get(role, 180.0))
            
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ3: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œï¼ˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæŒ¯ã‚Šåˆ†ã‘ï¼‰ ===
            # ============================================================
            result = None
            
            try:
                # --- 3-1: WordPresså°‚ç”¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¤å®šï¼ˆæœ€å„ªå…ˆï¼‰ ---
                if role == 'wp_design':
                    logger.info("="*60)
                    logger.info("ğŸ¨ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
                    logger.info("="*60)
                    task_coro = self._execute_wp_design_task(task)
                
                elif role == 'wp_dev':
                    logger.info("="*60)
                    logger.info("ğŸ’» WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
                    logger.info("="*60)
                    task_coro = self._execute_wp_dev_task(task)
                
                # --- 3-2: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ãƒ™ãƒ¼ã‚¹ã®åˆ†å² ---
                elif task_type == 'ma' and self.ma_executor:
                    logger.info("="*60)
                    logger.info("ğŸ“Š M&A/ä¼æ¥­æ¤œç´¢ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                    logger.info("="*60)
                    task_coro = self.ma_executor.execute_ma_task(task)
                
                elif task_type == 'content' and self.content_executor:
                    logger.info("="*60)
                    logger.info("âœï¸ è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                    logger.info("="*60)
                    task_coro = self.content_executor.execute_writer_task(task, role)
                
                elif task_type == 'review':
                    logger.info("="*60)
                    logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã¨ã—ã¦å‡¦ç†")
                    logger.info("="*60)
                    task_coro = self._execute_review_task(task)
                
                # --- 3-3: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ­ãƒ¼ãƒ«åˆ†å² ---
                else:
                    logger.info("="*60)
                    logger.info(f"ğŸ“‹ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¹ã‚¯ ({role}) ã¨ã—ã¦å‡¦ç†")
                    logger.info("="*60)
                    
                    if role == 'design':
                        task_coro = self._execute_design_task(task)
                    elif role == 'dev':
                        task_coro = self._execute_dev_task(task)
                    elif role == 'ui':
                        task_coro = self._execute_ui_task(task)
                    elif role == 'wordpress':
                        task_coro = self._execute_wordpress_task(task)
                    elif role == 'plugin':
                        task_coro = self._execute_plugin_task(task)
                    else:
                        # æœªç™»éŒ²ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
                        agent = self.agents.get(role)
                        if not agent:
                            logger.warning(f"æ‹…å½“ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ '{role}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ - ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™")
                            await self.update_task_status(task, 'skipped', error=f"ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªç™»éŒ²")
                            return False
                        task_coro = agent.process_task(task)
                
                # --- 3-4: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã§å®Ÿè¡Œ ---
                if HAS_ENHANCED_HANDLER:
                    result = await EnhancedErrorHandler.timeout_wrapper(
                        task_coro,
                        timeout=task_timeout,
                        context=f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œ"
                    )
                else:
                    result = await asyncio.wait_for(task_coro, timeout=task_timeout)
            
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ4: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ===
            # ============================================================
            except asyncio.TimeoutError:
                logger.error("="*60)
                logger.error(f"â±ï¸ ã‚¿ã‚¹ã‚¯ {task_id} ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{task_timeout}ç§’ï¼‰")
                logger.error("="*60)
                
                await self.update_task_status(
                    task, 
                    'failed', 
                    error=f'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{task_timeout}ç§’ï¼‰'
                )
                
                print("\n" + "ğŸ“·"*40)
                print("=" * 80)
                print(f"â±ï¸ ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {task_id}")
                print(f"åˆ¶é™æ™‚é–“: {task_timeout}ç§’")
                print("=" * 80)
                print("ğŸ“·"*40 + "\n")
                
                return False
            
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ5: ä¸€èˆ¬çš„ãªä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ===
            # ============================================================
            except Exception as e:
                logger.error("="*60)
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œä¸­ã«ä¾‹å¤–ç™ºç”Ÿ")
                logger.error(f"ã‚¨ãƒ©ãƒ¼: {str(e)}")
                logger.error("="*60)
                
                if HAS_ENHANCED_HANDLER:
                    EnhancedErrorHandler.log_error_with_context(
                        e, 
                        f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œ"
                    )
                
                await self.update_task_status(task, 'failed', error=str(e))
                
                print("\n" + "ğŸ“·"*40)
                print("=" * 80)
                print(f"ğŸ’¥ ã‚¿ã‚¹ã‚¯ä¾‹å¤–: {task_id}")
                print(f"ä¾‹å¤–: {str(e)}")
                print("=" * 80)
                print("ğŸ“·"*40 + "\n")
                
                return False
            
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ6: å®Ÿè¡Œçµæœã®å‡¦ç†ï¼ˆæˆåŠŸæ™‚ï¼‰ ===
            # ============================================================
            if result and result.get('success'):
                logger.info("="*60)
                logger.info(f"âœ… ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡ŒæˆåŠŸ")
                logger.info("="*60)
                
                # --- 6-1: çµæœä¿å­˜ ---
                try:
                    await self.update_task_status(task, 'completed')
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"âš ï¸ çµæœä¿å­˜å¤±æ•—ï¼ˆã‚¿ã‚¹ã‚¯è‡ªä½“ã¯æˆåŠŸï¼‰: {e}")
                
                # --- 6-2: ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã§ãƒã‚§ãƒƒã‚¯ ---
                if self.review_agent and role != 'review' and task_type != 'review':
                    try:
                        logger.info("="*60)
                        logger.info("âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã§ãƒã‚§ãƒƒã‚¯ã‚’é–‹å§‹")
                        logger.info("="*60)
                        
                        if HAS_ENHANCED_HANDLER:
                            await EnhancedErrorHandler.timeout_wrapper(
                                self.perform_review_and_add_tasks(task, result),
                                timeout=120.0,
                                context=f"ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆã‚¿ã‚¹ã‚¯ {task_id}ï¼‰"
                            )
                        else:
                            await asyncio.wait_for(
                                self.perform_review_and_add_tasks(task, result),
                                timeout=120.0
                            )
                    except Exception as e:
                        logger.warning(f"âš ï¸ ãƒ¬ãƒ“ãƒ¥ãƒ¼å¤±æ•—ï¼ˆç„¡è¦–ï¼‰: {e}")
                
                # --- 6-3: æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º ---
                print("\n" + "ğŸ“·"*40)
                print("=" * 80)
                print(f"âœ… ã‚¿ã‚¹ã‚¯å®Œäº†: {task_id}")
                print(f"ã‚¿ã‚¤ãƒ—: {task_type.upper()}")
                print(f"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: æˆåŠŸ")
                print("=" * 80)
                print("ğŸ“·"*40 + "\n")
                
                return True
            
            # ============================================================
            # === ãƒ‘ãƒ¼ãƒˆ7: å®Ÿè¡Œçµæœã®å‡¦ç†ï¼ˆå¤±æ•—æ™‚ï¼‰ ===
            # ============================================================
            else:
                error_msg = result.get('error', 'ä¸æ˜') if result else 'çµæœãªã—'
                logger.error("="*60)
                logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œå¤±æ•—")
                logger.error(f"ã‚¨ãƒ©ãƒ¼: {error_msg}")
                logger.error("="*60)
                
                await self.update_task_status(task, 'failed', error=error_msg)
                
                print("\n" + "ğŸ“·"*40)
                print("=" * 80)
                print(f"âŒ ã‚¿ã‚¹ã‚¯å¤±æ•—: {task_id}")
                print(f"ã‚¿ã‚¤ãƒ—: {task_type.upper()}")
                print(f"ã‚¨ãƒ©ãƒ¼: {error_msg}")
                print("=" * 80)
                print("ğŸ“·"*40 + "\n")
                
                return False
        
        # ============================================================
        # === ãƒ‘ãƒ¼ãƒˆ8: æœ€å¤–å±¤ã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° ===
        # ============================================================
        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¹ã‚¯ {task_id} å‡¦ç†å…¨ä½“ã§äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼")
            
            if HAS_ENHANCED_HANDLER:
                EnhancedErrorHandler.log_error_with_context(
                    e, 
                    f"ã‚¿ã‚¹ã‚¯ {task_id} å…¨ä½“å‡¦ç†"
                )
            else:
                ErrorHandler.log_error(e, f"ã‚¿ã‚¹ã‚¯ {task_id} å®Ÿè¡Œ")
            
            try:
                await self.update_task_status(task, 'failed', error=str(e))
            except:
                pass
            
            print("\n" + "ğŸ“·"*40)
            print("=" * 80)
            print(f"ğŸ’¥ ã‚¿ã‚¹ã‚¯é‡å¤§ã‚¨ãƒ©ãƒ¼: {task_id}")
            print(f"ä¾‹å¤–: {str(e)}")
            print("=" * 80)
            print("ğŸ“·"*40 + "\n")
            
            return False

    async def _execute_wp_design_task(self, task: Dict) -> Dict:
        """WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("â”Œ" + "â”€"*58 + "â”")
        logger.info("â”‚ ğŸ¨ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
        logger.info("â”œ" + "â”€"*58 + "â”¤")
        logger.info(f"â”‚ ã‚¿ã‚¹ã‚¯: {task.get('description', 'N/A')[:50]}")
        logger.info("â””" + "â”€"*58 + "â”˜")
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾— ===
            agent = self.agents.get('wp_design')
            if not agent:
                logger.error("âŒ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'wp_design ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }

            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ ===
            result = await agent.process_task(task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: çµæœãƒ­ã‚°å‡ºåŠ› ===
            if result.get('success'):
                logger.info("âœ… WordPressè¨­è¨ˆAI: ã‚¿ã‚¹ã‚¯å®Œäº†")
            else:
                logger.error(f"âŒ WordPressè¨­è¨ˆAI: å¤±æ•— - {result.get('error', 'ä¸æ˜')}")
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            logger.error(f"âŒ WordPressè¨­è¨ˆAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ä¾‹å¤–ç™ºç”Ÿ - {str(e)}")
            return {
                'success': False,
                'error': f'WordPressè¨­è¨ˆã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}'
            }

    async def _execute_wp_dev_task(self, task: Dict) -> Dict:
        """WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        logger.info("â”Œ" + "â”€"*58 + "â”")
        logger.info("â”‚ ğŸ’» WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œä¸­")
        logger.info("â”œ" + "â”€"*58 + "â”¤")
        logger.info(f"â”‚ ã‚¿ã‚¹ã‚¯: {task.get('description', 'N/A')[:50]}")
        logger.info("â””" + "â”€"*58 + "â”˜")
        
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå–å¾— ===
            agent = self.agents.get('wp_dev')
            if not agent:
                logger.error("âŒ WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'wp_dev ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“'
                }
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ ===
            result = await agent.process_task(task)
            
            # === ãƒ‘ãƒ¼ãƒˆ3: çµæœãƒ­ã‚°å‡ºåŠ› ===
            if result.get('success'):
                logger.info("âœ… WordPressé–‹ç™ºAI: ã‚¿ã‚¹ã‚¯å®Œäº†")
            else:
                logger.error(f"âŒ WordPressé–‹ç™ºAI: å¤±æ•— - {result.get('error', 'ä¸æ˜')}")
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯å®Ÿè¡Œ")
            logger.error(f"âŒ WordPressé–‹ç™ºAIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ä¾‹å¤–ç™ºç”Ÿ - {str(e)}")
            return {
                'success': False,
                'error': f'WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {str(e)}'
            }

    # ã‚¹ã‚¿ãƒ–ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ã«å®šç¾©ï¼‰
    async def update_task_status(self, task: Dict, status: str, error: Optional[str] = None):
        """ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°"""
        logger.info(f"ã‚¿ã‚¹ã‚¯ {task.get('task_id')} ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ {status} ã«æ›´æ–°")
        if error:
            logger.info(f"ã‚¨ãƒ©ãƒ¼: {error}")

    async def save_task_output(self, task: Dict, result: Dict):
        """ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ä¿å­˜"""
        logger.info(f"ã‚¿ã‚¹ã‚¯ {task.get('task_id')} ã®çµæœã‚’ä¿å­˜")

    async def perform_review_and_add_tasks(self, task: Dict, result: Dict):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿè¡Œã—ã¦ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ """
        logger.info(f"ã‚¿ã‚¹ã‚¯ {task.get('task_id')} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿè¡Œ")

    async def _execute_review_task(self, task: Dict) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        return {'success': True}

    async def _execute_design_task(self, task: Dict) -> Dict:
        """ãƒ‡ã‚¶ã‚¤ãƒ³ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        return {'success': True}

    async def _execute_dev_task(self, task: Dict) -> Dict:
        """é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        return {'success': True}

    async def _execute_ui_task(self, task: Dict) -> Dict:
        """UIã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        return {'success': True}

    async def _execute_wordpress_task(self, task: Dict) -> Dict:
        """WordPressã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        return {'success': True}

    async def _execute_plugin_task(self, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
        return {'success': True}


# ä½¿ç”¨ä¾‹
async def main():
    """ãƒ†ã‚¹ãƒˆç”¨ã®ãƒ¡ã‚¤ãƒ³é–¢æ•°"""
    executor = WordPressTaskExecutor()
    
    # ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯
    test_task = {
        'task_id': 'TEST_001',
        'description': 'WordPressã‚µã‚¤ãƒˆã®ãƒ‡ã‚¶ã‚¤ãƒ³ä½œæˆ',
        'required_role': 'wp_design'
    }
    
    result = await executor.execute_task(test_task)
    print(f"ã‚¿ã‚¹ã‚¯å®Ÿè¡Œçµæœ: {result}")


if __name__ == "__main__":
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    asyncio.run(main())

#wp_dev.py
"""
WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ãƒ«ãƒ¼ã‚¿ãƒ¼ï¼ˆå®Œå…¨å‹•ä½œç‰ˆï¼‰
"""

import asyncio
import logging
from typing import Dict, Optional
from pathlib import Path

from config_utils import ErrorHandler

logger = logging.getLogger(__name__)


class WordPressDevAgent:
    """WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯ãƒ«ãƒ¼ã‚¿ãƒ¼ï¼ˆå®Œå…¨å‹•ä½œç‰ˆï¼‰"""
    
    def __init__(self, browser, output_folder: Path = None):
        self.browser = browser
        self.output_folder = output_folder or Path('./outputs/wordpress')
        self.output_folder.mkdir(parents=True, exist_ok=True)
        
        # å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®åˆæœŸåŒ–
        self._init_specialized_agents()
        
        logger.info("âœ… WordPressDevAgent åˆæœŸåŒ–å®Œäº†")
    
    def _init_specialized_agents(self):
        """å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åˆæœŸåŒ–"""
        try:
            from wordpress.wp_dev import (
                WordPressRequirementsAgent,
                WordPressCPTAgent,
                WordPressTaxonomyAgent,
                WordPressACFAgent
            )
            
            self.requirements_agent = WordPressRequirementsAgent(
                self.browser, 
                self.output_folder
            )
            self.cpt_agent = WordPressCPTAgent(self.browser, self.output_folder)
            self.taxonomy_agent = WordPressTaxonomyAgent(self.browser, self.output_folder)
            self.acf_agent = WordPressACFAgent(self.browser, self.output_folder)
            
            logger.info("âœ… å°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆæœŸåŒ–å®Œäº†")
            
        except ImportError as e:
            logger.warning(f"âš ï¸ ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            self.requirements_agent = None
            self.cpt_agent = None
            self.taxonomy_agent = None
            self.acf_agent = None
    
    async def execute(self, task: Dict) -> Dict:
        """
        execute ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆï¼‰
        ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®äº’æ›æ€§ã®ãŸã‚
        """
        return await self.process_task(task)
    
    async def process_task(self, task: Dict) -> Dict:
        """
        process_task ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå¿…é ˆï¼‰
        å®Ÿéš›ã®ã‚¿ã‚¹ã‚¯å‡¦ç†
        """
        task_id = task.get('task_id', 'UNKNOWN')
        description = task.get('description', '').lower()
        
        try:
            logger.info(f"ğŸ”§ WordPressé–‹ç™ºã‚¿ã‚¹ã‚¯: {task_id}")
            
            # ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            task_type = self._determine_task_type(description)
            logger.info(f"ğŸ“Š ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—: {task_type}")
            
            # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«æŒ¯ã‚Šåˆ†ã‘
            if task_type == 'requirements':
                if self.requirements_agent:
                    return await self.requirements_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'cpt':
                if self.cpt_agent:
                    return await self.cpt_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'taxonomy':
                if self.taxonomy_agent:
                    return await self.taxonomy_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            elif task_type == 'acf':
                if self.acf_agent:
                    return await self.acf_agent.execute(task)
                else:
                    return await self._fallback_execution(task)
            
            else:
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                return await self._fallback_execution(task)
        
        except Exception as e:
            logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return {
                'success': False,
                'error': str(e),
                'task_id': task_id
            }
    
    def _determine_task_type(self, description: str) -> str:
        """ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ¤å®šï¼ˆæŸ”è»Ÿç‰ˆï¼‰"""
        # è¦ä»¶å®šç¾©ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        requirements_patterns = [
            'è¦ä»¶å®šç¾©', 'requirements', 'ä»•æ§˜æ›¸', 'è¨­è¨ˆæ›¸',
            'ãƒãƒ¼ã‚¿ãƒ«', 'cocoon', 'polylang', 'å¤šè¨€èª',
            'm&a', 'ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³', 'wordpress'
        ]
        
        if any(kw in description for kw in requirements_patterns):
            return 'requirements'
        
        # CPT
        if any(kw in description for kw in ['cpt', 'custom post type', 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿', 'ma_case']):
            return 'cpt'
        
        # ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼
        if any(kw in description for kw in ['taxonomy', 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼', 'ã‚«ãƒ†ã‚´ãƒª', 'industry']):
            return 'taxonomy'
        
        # ACF
        if any(kw in description for kw in ['acf', 'advanced custom fields', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰']):
            return 'acf'
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return 'requirements'
    
    async def _fallback_execution(self, task: Dict) -> Dict:
        """ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ"""
        logger.warning("âš ï¸ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸åœ¨ - Geminiã§ç›´æ¥å®Ÿè¡Œ")
        
        try:
            prompt = f"""WordPressã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ï¼š

{task.get('description', '')}

ç°¡æ½”ã«å®Ÿè£…æ–¹æ³•ã‚’èª¬æ˜ã—ã¦ãã ã•ã„ã€‚"""
            
            await self.browser.send_prompt(prompt)
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if success:
                response = await self.browser.extract_latest_text_response()
                return {
                    'success': True,
                    'message': 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œå®Œäº†',
                    'summary': response[:300] if response else 'N/A',
                    'full_text': response or ''
                }
            else:
                return {
                    'success': False,
                    'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ'
                }
        
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

#wp_plugin_manager.py
"""wp_plugin_manager.py - WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†"""
import logging
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout

logger = logging.getLogger(__name__)


class PluginNameExtractor:
    """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åæŠ½å‡ºãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£"""
    
    @staticmethod
    def extract(description: str) -> str:
        """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º"""
        # ã‚·ãƒ³ãƒ—ãƒ«ãªæŠ½å‡ºãƒ­ã‚¸ãƒƒã‚¯ - å®Ÿéš›ã®è¦ä»¶ã«å¿œã˜ã¦æ‹¡å¼µ
        import re
        patterns = [
            r'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³[ã€Œ"](.+?)[ã€"]',
            r'plugin[ã€Œ"](.+?)[ã€"]',
            r'install[\s\w]+\s(.+?)\s',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                return match.group(1).strip()
        
        # è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯èª¬æ˜æ–‡ã®æœ€åˆã®æ•°å˜èªã‚’ä½¿ç”¨
        return description.split()[0] if description else "unknown_plugin"


class WordPressPluginManager:
    """WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç®¡ç†æ©Ÿèƒ½ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰"""

    def __init__(self, browser_controller, wp_credentials: Dict = None):
        """
        åˆæœŸåŒ–
        
        Args:
            browser_controller: BrowserController ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            wp_credentials: WordPress èªè¨¼æƒ…å ±
        """
        self.browser = browser_controller
        self.wp_credentials = wp_credentials or {}
        self.wp_url = self.wp_credentials.get('wp_url', '').rstrip('/')
        
        logger.info(f"WordPressPluginManager åˆæœŸåŒ–: {self.wp_url}")

    async def install_plugin(self, page: Page, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦æœ‰åŠ¹åŒ–"""
        try:
            plugin_name = PluginNameExtractor.extract(task['description'])
            logger.info(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«é–‹å§‹: {plugin_name}")
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/plugin-install.php")
            await page.wait_for_timeout(2000)
            
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢ã¨ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Ÿè¡Œ
            search_success = await self._search_plugin(page, plugin_name)
            if not search_success:
                return {
                    'success': False,
                    'error': 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢ã«å¤±æ•—ã—ã¾ã—ãŸ'
                }
            
            # ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨æœ‰åŠ¹åŒ–
            installed, status = await self._install_and_activate(page)
            
            # çµæœè¨˜éŒ²
            screenshot_path = f"wp_plugin_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            if installed:
                return self._build_success_result(plugin_name, status, screenshot_path)
            else:
                return self._build_manual_result(plugin_name, screenshot_path)
                
        except Exception as e:
            logger.error(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def _search_plugin(self, page: Page, plugin_name: str) -> bool:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’æ¤œç´¢"""
        search_box = await page.query_selector('#search-plugins')
        if not search_box:
            return False
            
        await search_box.fill(plugin_name)
        await page.keyboard.press('Enter')
        await page.wait_for_timeout(4000)
        
        logger.info(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢å®Œäº†: {plugin_name}")
        return True

    async def _install_and_activate(self, page: Page) -> tuple[bool, str]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»æœ‰åŠ¹åŒ–"""
        install_selectors = [
            'a.install-now:has-text("ä»Šã™ãã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«")',
            '.plugin-card-top a.install-now',
            'a[data-slug]:has-text("ä»Šã™ãã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«")',
        ]
        
        for selector in install_selectors:
            try:
                install_button = await page.query_selector(selector)
                if install_button and await install_button.is_visible():
                    logger.info(f"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯: {selector}")
                    await install_button.click()
                    await page.wait_for_timeout(5000)
                    
                    # æœ‰åŠ¹åŒ–å‡¦ç†
                    return await self._activate_plugin(page)
            except Exception as e:
                logger.warning(f"ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«è©¦è¡Œã‚¨ãƒ©ãƒ¼ ({selector}): {e}")
                continue
        
        return False, "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¤±æ•—"

    async def _activate_plugin(self, page: Page) -> tuple[bool, str]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’æœ‰åŠ¹åŒ–"""
        activate_button = await page.query_selector('a:has-text("æœ‰åŠ¹åŒ–")')
        if activate_button:
            logger.info("æœ‰åŠ¹åŒ–ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
            await activate_button.click()
            await page.wait_for_timeout(3000)
            logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨æœ‰åŠ¹åŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ")
            return True, "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»æœ‰åŠ¹åŒ–å®Œäº†"
        else:
            logger.info("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒå®Œäº†ã—ã¾ã—ãŸ(æœ‰åŠ¹åŒ–ã¯æ‰‹å‹•)")
            return True, "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†(æœ‰åŠ¹åŒ–ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„)"

    async def change_plugin_settings(self, page: Page, task: Dict) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚’å¤‰æ›´"""
        try:
            plugin_name = PluginNameExtractor.extract(task['description'])
            logger.info(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šå¤‰æ›´: {plugin_name}")
            
            await page.goto(f"{self.wp_url}/wp-admin/plugins.php")
            await page.wait_for_timeout(3000)
            
            settings_found = await self._navigate_to_settings(page, plugin_name)
            screenshot_path = f"wp_plugin_settings_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            if settings_found:
                return self._build_settings_success_result(plugin_name, screenshot_path)
            else:
                return self._build_settings_error_result(plugin_name, screenshot_path)
                
        except Exception as e:
            logger.error(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šå¤‰æ›´ã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def _navigate_to_settings(self, page: Page, plugin_name: str) -> bool:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šç”»é¢ã¸ç§»å‹•"""
        settings_selectors = [
            f'tr:has-text("{plugin_name}") .settings a',
            f'a:has-text("{plugin_name}è¨­å®š")',
            '.plugin-action-buttons a:has-text("è¨­å®š")'
        ]
        
        for selector in settings_selectors:
            try:
                settings_link = await page.query_selector(selector)
                if settings_link and await settings_link.is_visible():
                    await settings_link.click()
                    await page.wait_for_timeout(3000)
                    logger.info(f"âœ… {plugin_name}ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸ")
                    return True
            except Exception:
                continue
        
        return False

    # === ä¸»è¦ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šæ©Ÿèƒ½ ===

    async def configure_facetwp(self, page: Page, task_params: Dict) -> Dict:
        """FacetWP çµã‚Šè¾¼ã¿æ¤œç´¢ã®è¨­å®š"""
        try:
            facets = task_params.get('facets', [])
            logger.info(f"FacetWPè¨­å®šé–‹å§‹: {len(facets)}ä»¶ã®ãƒ•ã‚¡ã‚»ãƒƒãƒˆ")
            
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=facetwp-settings")
            await page.wait_for_timeout(3000)
            
            created_facets = await self._create_facets(page, facets)
            screenshot_path = f"facetwp_setup_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_facetwp_result(created_facets, facets, screenshot_path)
            
        except Exception as e:
            logger.error(f"FacetWPè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def _create_facets(self, page: Page, facets: List[Dict]) -> List[str]:
        """ãƒ•ã‚¡ã‚»ãƒƒãƒˆã‚’ä½œæˆ"""
        created_facets = []
        
        for i, facet in enumerate(facets, 1):
            try:
                logger.info(f"ãƒ•ã‚¡ã‚»ãƒƒãƒˆ {i}/{len(facets)}: {facet.get('name')}")
                
                # æ–°è¦ãƒ•ã‚¡ã‚»ãƒƒãƒˆè¿½åŠ 
                if await self._click_add_new_facet(page):
                    # ãƒ•ã‚¡ã‚»ãƒƒãƒˆè¨­å®š
                    if await self._configure_facet_fields(page, facet):
                        # ä¿å­˜
                        if await self._save_facet(page):
                            created_facets.append(facet.get('name'))
                            logger.info(f"âœ… ãƒ•ã‚¡ã‚»ãƒƒãƒˆ '{facet.get('name')}' ã‚’ä¿å­˜")
                            
                await page.wait_for_timeout(1000)
                
            except Exception as e:
                logger.warning(f"âš ï¸ ãƒ•ã‚¡ã‚»ãƒƒãƒˆ {i} ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
                continue
                
        return created_facets

    async def _click_add_new_facet(self, page: Page) -> bool:
        """æ–°è¦ãƒ•ã‚¡ã‚»ãƒƒãƒˆè¿½åŠ ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯"""
        add_new_selectors = [
            'a.facetwp-add:has-text("Add New")',
            'button:has-text("Add New")',
            '.facetwp-add-facet'
        ]
        
        for selector in add_new_selectors:
            try:
                add_button = await page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await page.wait_for_timeout(1500)
                    return True
            except Exception:
                continue
        return False

    async def _configure_facet_fields(self, page: Page, facet: Dict) -> bool:
        """ãƒ•ã‚¡ã‚»ãƒƒãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¨­å®š"""
        try:
            # ãƒ•ã‚¡ã‚»ãƒƒãƒˆå
            name_input = await page.query_selector('input[name="facet_label"]')
            if name_input:
                await name_input.fill(facet.get('name', ''))
            
            # ãƒ•ã‚¡ã‚»ãƒƒãƒˆã‚¿ã‚¤ãƒ—
            type_select = await page.query_selector('select[name="facet_type"]')
            if type_select:
                await type_select.select_option(facet.get('type', 'checkboxes'))
            
            # ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹
            source = facet.get('source', '')
            if source.startswith('tax/'):
                return await self._configure_taxonomy_source(page, source)
            elif source.startswith('cf/'):
                return await self._configure_custom_field_source(page, source)
            
            return True
        except Exception as e:
            logger.warning(f"ãƒ•ã‚¡ã‚»ãƒƒãƒˆè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return False

    async def _configure_taxonomy_source(self, page: Page, source: str) -> bool:
        """ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚½ãƒ¼ã‚¹ã‚’è¨­å®š"""
        try:
            taxonomy_name = source.replace('tax/', '')
            source_select = await page.query_selector('select[name="facet_source"]')
            if source_select:
                await source_select.select_option('tax')
                await page.wait_for_timeout(500)
            
            taxonomy_select = await page.query_selector('select[name="facet_source_taxonomy"]')
            if taxonomy_select:
                await taxonomy_select.select_option(taxonomy_name)
                logger.info(f"  ã‚½ãƒ¼ã‚¹: Taxonomy - {taxonomy_name}")
                return True
        except Exception as e:
            logger.warning(f"ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ã‚½ãƒ¼ã‚¹è¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
        return False

    async def _configure_custom_field_source(self, page: Page, source: str) -> bool:
        """ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚½ãƒ¼ã‚¹ã‚’è¨­å®š"""
        try:
            field_name = source.replace('cf/', '')
            source_select = await page.query_selector('select[name="facet_source"]')
            if source_select:
                await source_select.select_option('cf')
                await page.wait_for_timeout(500)
            
            field_input = await page.query_selector('input[name="facet_source_custom_field"]')
            if field_input:
                await field_input.fill(field_name)
                logger.info(f"  ã‚½ãƒ¼ã‚¹: Custom Field - {field_name}")
                return True
        except Exception as e:
            logger.warning(f"ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚½ãƒ¼ã‚¹è¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
        return False

    async def _save_facet(self, page: Page) -> bool:
        """ãƒ•ã‚¡ã‚»ãƒƒãƒˆã‚’ä¿å­˜"""
        save_selectors = [
            'button.facetwp-save:has-text("Save")',
            'button:has-text("Save Changes")',
            'input[type="submit"][value="Save"]'
        ]
        
        for selector in save_selectors:
            try:
                save_button = await page.query_selector(selector)
                if save_button and await save_button.is_visible():
                    await save_button.click()
                    await page.wait_for_timeout(2000)
                    return True
            except Exception:
                continue
        return False

    async def configure_user_roles(self, page: Page, task_params: Dict) -> Dict:
        """User Role Editorã§ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ«ã‚’ä½œæˆ"""
        try:
            role_slug = task_params.get('role_slug')
            role_name = task_params.get('role_name')
            
            logger.info(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ä½œæˆ: {role_name}")
            
            await page.goto(f"{self.wp_url}/wp-admin/users.php?page=users-user-role-editor-php")
            await page.wait_for_timeout(3000)
            
            # ãƒ­ãƒ¼ãƒ«ä½œæˆç”»é¢ã‚’é–‹ã
            if await self._open_add_role_dialog(page):
                # ãƒ­ãƒ¼ãƒ«æƒ…å ±å…¥åŠ›
                await self._fill_role_info(page, role_slug, role_name)
                
                screenshot_path = f"user_role_{role_slug}_{datetime.now().strftime('%H%M%S')}.png"
                await page.screenshot(path=screenshot_path)
                
                return self._build_user_role_result(role_name, role_slug, screenshot_path)
            else:
                return self._build_error_result("ãƒ­ãƒ¼ãƒ«è¿½åŠ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ")
                
        except Exception as e:
            logger.error(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def _open_add_role_dialog(self, page: Page) -> bool:
        """ãƒ­ãƒ¼ãƒ«è¿½åŠ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã"""
        add_role_selectors = [
            'button:has-text("Add Role")',
            'input[value="Add Role"]',
            '#ure_add_role_button'
        ]
        
        for selector in add_role_selectors:
            try:
                add_button = await page.query_selector(selector)
                if add_button and await add_button.is_visible():
                    await add_button.click()
                    await page.wait_for_timeout(2000)
                    return True
            except Exception:
                continue
        return False

    async def _fill_role_info(self, page: Page, role_slug: str, role_name: str):
        """ãƒ­ãƒ¼ãƒ«æƒ…å ±ã‚’å…¥åŠ›"""
        slug_input = await page.query_selector('#user_role_id')
        if slug_input:
            await slug_input.fill(role_slug)
            logger.info(f"ãƒ­ãƒ¼ãƒ«ã‚¹ãƒ©ãƒƒã‚°ã‚’å…¥åŠ›: {role_slug}")
        
        name_input = await page.query_selector('#user_role_name')
        if name_input:
            await name_input.fill(role_name)
            logger.info(f"ãƒ­ãƒ¼ãƒ«åã‚’å…¥åŠ›: {role_name}")

    async def configure_wordfence(self, page: Page, task_params: Dict) -> Dict:
        """Wordfence Security ã®åŸºæœ¬è¨­å®š"""
        try:
            logger.info("Wordfence Securityè¨­å®šé–‹å§‹")
            
            await page.goto(f"{self.wp_url}/wp-admin/admin.php?page=Wordfence")
            await page.wait_for_timeout(3000)
            
            screenshot_path = f"wordfence_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_wordfence_result(task_params, screenshot_path)
            
        except Exception as e:
            logger.error(f"Wordfenceè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def configure_wp_rocket(self, page: Page, task_params: Dict) -> Dict:
        """WP Rocket ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨­å®š"""
        try:
            logger.info("WP Rocketè¨­å®šé–‹å§‹")
            
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=wprocket")
            await page.wait_for_timeout(3000)
            
            screenshot_path = f"wp_rocket_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_wp_rocket_result(screenshot_path)
            
        except Exception as e:
            logger.error(f"WP Rocketè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def configure_relevanssi(self, page: Page, task_params: Dict) -> Dict:
        """Relevanssi é«˜åº¦ãªæ¤œç´¢ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨­å®š"""
        try:
            logger.info("Relevanssiè¨­å®šé–‹å§‹")
            
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php?page=relevanssi/relevanssi.php")
            await page.wait_for_timeout(3000)
            
            screenshot_path = f"relevanssi_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            return self._build_relevanssi_result(task_params, screenshot_path)
            
        except Exception as e:
            logger.error(f"Relevanssiè¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def bulk_configure_plugins(self, page: Page, plugin_configs: List[Dict]) -> Dict:
        """è¤‡æ•°ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ä¸€æ‹¬ã§è¨­å®š"""
        try:
            results = []
            
            for i, config in enumerate(plugin_configs, 1):
                plugin_name = config.get('plugin_name')
                logger.info(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®š {i}/{len(plugin_configs)}: {plugin_name}")
                
                # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ç¨®åˆ¥ã«å¿œã˜ã¦è¨­å®šã‚’å®Ÿè¡Œ
                result = await self._configure_single_plugin(page, config)
                results.append({'plugin': plugin_name, 'result': result})
            
            successful = sum(1 for r in results if r['result'].get('success'))
            
            return {
                'success': successful > 0,
                'summary': f'{successful}/{len(plugin_configs)}ä»¶ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šã‚’å®Œäº†',
                'results': results
            }
            
        except Exception as e:
            logger.error(f"ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€æ‹¬è¨­å®šã‚¨ãƒ©ãƒ¼: {e}")
            return self._build_error_result(str(e))

    async def _configure_single_plugin(self, page: Page, config: Dict) -> Dict:
        """å˜ä¸€ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’è¨­å®š"""
        plugin_name = config.get('plugin_name')
        
        plugin_handlers = {
            'facetwp': self.configure_facetwp,
            'user-role-editor': self.configure_user_roles,
            'wordfence': self.configure_wordfence,
            'wp-rocket': self.configure_wp_rocket,
            'relevanssi': self.configure_relevanssi,
        }
        
        handler = plugin_handlers.get(plugin_name)
        if handler:
            return await handler(page, config)
        else:
            return {'success': False, 'error': f'æœªå¯¾å¿œã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugin_name}'}

    # === çµæœãƒ“ãƒ«ãƒ€ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ ===

    def _build_success_result(self, plugin_name: str, status: str, screenshot_path: str) -> Dict:
        """æˆåŠŸçµæœã‚’ä½œæˆ"""
        return {
            'success': True,
            'summary': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ "{plugin_name}" ã‚’{status}',
            'screenshot': screenshot_path,
            'full_text': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å‡¦ç†å®Œäº†\nåå‰: {plugin_name}\nã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
        }

    def _build_manual_result(self, plugin_name: str, screenshot_path: str) -> Dict:
        """æ‰‹å‹•ç¢ºèªãŒå¿…è¦ãªçµæœã‚’ä½œæˆ"""
        return {
            'success': True,
            'summary': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ "{plugin_name}" ã‚’æ¤œç´¢ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
            'screenshot': screenshot_path,
            'full_text': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¤œç´¢: {plugin_name}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}\nâ€»ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸãŸã‚æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }

    def _build_error_result(self, error_message: str) -> Dict:
        """ã‚¨ãƒ©ãƒ¼çµæœã‚’ä½œæˆ"""
        return {
            'success': False,
            'error': error_message
        }

    def _build_settings_success_result(self, plugin_name: str, screenshot_path: str) -> Dict:
        """è¨­å®šæˆåŠŸçµæœã‚’ä½œæˆ"""
        return {
            'success': True,
            'summary': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€Œ{plugin_name}ã€ã®è¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚æ‰‹å‹•ã§è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
            'screenshot': screenshot_path,
            'full_text': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®šç”»é¢è¡¨ç¤º\nãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugin_name}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}\nâ€»è¨­å®šå¤‰æ›´ã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }

    def _build_settings_error_result(self, plugin_name: str, screenshot_path: str) -> Dict:
        """è¨­å®šã‚¨ãƒ©ãƒ¼çµæœã‚’ä½œæˆ"""
        return {
            'success': False,
            'error': f'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã€Œ{plugin_name}ã€ã®è¨­å®šç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ',
            'screenshot': screenshot_path
        }

    def _build_facetwp_result(self, created_facets: List[str], facets: List[Dict], screenshot_path: str) -> Dict:
        """FacetWPè¨­å®šçµæœã‚’ä½œæˆ"""
        summary_lines = ["ã€FacetWPè¨­å®šå®Œäº†ã€‘"]
        summary_lines.append(f"ä½œæˆæˆåŠŸ: {len(created_facets)}/{len(facets)}ä»¶")
        for name in created_facets:
            summary_lines.append(f"  âœ“ {name}")
            
        if len(created_facets) < len(facets):
            summary_lines.append("\nâš ï¸ ä¸€éƒ¨ã®ãƒ•ã‚¡ã‚»ãƒƒãƒˆã¯æ‰‹å‹•ã§ç¢ºèªãŒå¿…è¦ã§ã™")
            
        summary = '\n'.join(summary_lines)
        
        return {
            'success': len(created_facets) > 0,
            'summary': summary,
            'facets_created': created_facets,
            'facets_count': len(facets),
            'screenshot': screenshot_path,
            'full_text': f'{summary}\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
        }

    def _build_user_role_result(self, role_name: str, role_slug: str, screenshot_path: str) -> Dict:
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ä½œæˆçµæœã‚’ä½œæˆ"""
        return {
            'success': True,
            'summary': f'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ« "{role_name}" ã®ä½œæˆç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'role_slug': role_slug,
            'role_name': role_name,
            'screenshot': screenshot_path,
            'full_text': f'User Roleä½œæˆ\nã‚¹ãƒ©ãƒƒã‚°: {role_slug}\nè¡¨ç¤ºå: {role_name}\nâ€»æ¨©é™è¨­å®šã¯æ‰‹å‹•ã§å®Ÿæ–½ã—ã¦ãã ã•ã„'
        }

    def _build_wordfence_result(self, task_params: Dict, screenshot_path: str) -> Dict:
        """Wordfenceè¨­å®šçµæœã‚’ä½œæˆ"""
        firewall_mode = task_params.get('firewall_mode', 'enabled')
        scan_schedule = task_params.get('scan_schedule', 'daily')
        two_factor_auth = task_params.get('two_factor_auth', True)
        
        summary = f"""ã€Wordfence Securityè¨­å®šã€‘
ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ãƒ¢ãƒ¼ãƒ‰: {firewall_mode}
ã‚¹ã‚­ãƒ£ãƒ³ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«: {scan_schedule}
2FA: {'æœ‰åŠ¹' if two_factor_auth else 'ç„¡åŠ¹'}
â€»æ‰‹å‹•ã§è¨­å®šã‚’å®Œäº†ã—ã¦ãã ã•ã„"""
        
        return {
            'success': True,
            'summary': 'Wordfenceè¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'screenshot': screenshot_path,
            'full_text': summary
        }

    def _build_wp_rocket_result(self, screenshot_path: str) -> Dict:
        """WP Rocketè¨­å®šçµæœã‚’ä½œæˆ"""
        summary = """ã€WP Rocketè¨­å®šã€‘
æ¨å¥¨è¨­å®š:
- Mobile Cache: æœ‰åŠ¹
- User Cache: æœ‰åŠ¹
- Minify CSS/JS: æœ‰åŠ¹
- Combine CSS/JS: æœ‰åŠ¹
â€»æ‰‹å‹•ã§è¨­å®šã‚’å®Œäº†ã—ã¦ãã ã•ã„"""
        
        return {
            'success': True,
            'summary': 'WP Rocketè¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'screenshot': screenshot_path,
            'full_text': summary
        }

    def _build_relevanssi_result(self, task_params: Dict, screenshot_path: str) -> Dict:
        """Relevanssiè¨­å®šçµæœã‚’ä½œæˆ"""
        index_fields = task_params.get('index_fields', [])
        
        summary = f"""ã€Relevanssiè¨­å®šã€‘
ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å¯¾è±¡ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰: {len(index_fields)}ä»¶
æ¨å¥¨è¨­å®š:
- Custom fields: ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åã‚’è¿½åŠ 
- Build Index: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹ç¯‰å®Ÿè¡Œ
- Weightè¨­å®š: Title=é«˜, Content=ä¸­, Custom fields=ä¸­
â€»æ‰‹å‹•ã§è¨­å®šã‚’å®Œäº†ã—ã¦ãã ã•ã„"""
        
        return {
            'success': True,
            'summary': 'Relevanssiè¨­å®šç”»é¢ã‚’é–‹ãã¾ã—ãŸã€‚',
            'screenshot': screenshot_path,
            'full_text': summary
        }

#wp_post_creator.py
"""WordPressæŠ•ç¨¿ä½œæˆ"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostCreator:
    """WordPressæŠ•ç¨¿ä½œæˆæ©Ÿèƒ½"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
    
    async def create_post(self, page: Page, task: Dict) -> Dict:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„(æŠ•ç¨¿/ãƒšãƒ¼ã‚¸)ã‚’ä½œæˆ"""
        try:
            logger.info("ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚’å®Ÿè¡Œä¸­...")
            
            # task_idã‚’æŠ½å‡º
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            post_content = None
            post_title = f"AIæŠ•ç¨¿_{datetime.now().strftime('%Y%m%d_%H%M')}"
            
            if target_task_id:
                logger.info(f"task_id {target_task_id} ã®è¨˜äº‹å†…å®¹ã‚’ä½¿ç”¨")
                post_content = await TaskContentFetcher.get_task_content(
                    self.sheets_manager, target_task_id
                )
                
                if post_content:
                    # ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡º(æœ€åˆã®è¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«ã¨ã™ã‚‹)
                    lines = post_content.split('\n')
                    if lines:
                        post_title = lines[0].strip()[:100]
                        # æœ¬æ–‡ã¯2è¡Œç›®ä»¥é™
                        post_content = '\n'.join(lines[1:]).strip()
            
            if not post_content:
                # ã‚¿ã‚¹ã‚¯ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’ç›´æ¥æŠ½å‡º
                title_match = re.search(r'ã‚¿ã‚¤ãƒˆãƒ«[ã€€\s]*(.+?)[\næœ¬æ–‡]', task['description'])
                content_match = re.search(r'æœ¬æ–‡[ã€€\s]*(.+?)[\nã€]', task['description'])
                
                post_title = title_match.group(1).strip() if title_match else post_title
                post_content = content_match.group(1).strip() if content_match else "è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„"
            
            logger.info(f"æŠ•ç¨¿å†…å®¹: ã‚¿ã‚¤ãƒˆãƒ«='{post_title}', æœ¬æ–‡='{post_content[:50]}...'")
            
            # æ–°è¦æŠ•ç¨¿ãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/post-new.php")
            await page.wait_for_timeout(4000)
            
            # ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
            title_filled = await self._fill_title(page, post_title)
            
            # æœ¬æ–‡å…¥åŠ›
            content_filled = await self._fill_content(page, post_content)
            
            # Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«è¨­å®š
            await self._set_polylang_language(page)
            
            # ä¸‹æ›¸ãä¿å­˜
            saved = await self._save_draft(page)
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"wp_post_saved_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            
            if saved:
                return {
                    'success': True,
                    'summary': f'æŠ•ç¨¿ã‚’ä¸‹æ›¸ãä¿å­˜ã—ã¾ã—ãŸã€‚ã‚¿ã‚¤ãƒˆãƒ«: {post_title}',
                    'screenshot': screenshot_path,
                    'full_text': f'æŠ•ç¨¿ä½œæˆå®Œäº†\nã‚¿ã‚¤ãƒˆãƒ«: {post_title}\næœ¬æ–‡: {post_content[:200]}...\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
                }
            else:
                return {
                    'success': True,
                    'summary': f'æŠ•ç¨¿ã‚’ä½œæˆã—ã¾ã—ãŸ(ä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸãŸã‚æ‰‹å‹•ç¢ºèªãŒå¿…è¦)',
                    'screenshot': screenshot_path,
                    'full_text': f'æŠ•ç¨¿ä½œæˆ\nã‚¿ã‚¤ãƒˆãƒ«: {post_title}\næœ¬æ–‡: {post_content[:200]}...\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
                }
                
        except Exception as e:
            logger.error(f"ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _fill_title(self, page: Page, title: str) -> bool:
        """ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ "]',
            'textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]',
            '#post-title-0'
        ]
        
        for selector in title_selectors:
            try:
                title_input = await page.query_selector(selector)
                if title_input and await title_input.is_visible():
                    await title_input.click()
                    await page.wait_for_timeout(500)
                    await title_input.fill(title)
                    await page.wait_for_timeout(1000)
                    logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›å®Œäº†: {title}")
                    return True
            except:
                continue
        
        logger.warning("ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
        return False
    
    # wp_post_creator.py ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    async def _fill_html_content(self, page: Page, html_content: str) -> bool:
        """HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’Gutenbergã‚¨ãƒ‡ã‚£ã‚¿ã«æŒ¿å…¥"""
        try:
            logger.info("HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æŒ¿å…¥ä¸­...")
        
            # ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ 
            await page.keyboard.press('/')
            await page.wait_for_timeout(1000)
            await page.keyboard.type('html')
            await page.wait_for_timeout(1000)
            await page.keyboard.press('Enter')
            await page.wait_for_timeout(2000)
        
            # HTMLå…¥åŠ›ã‚¨ãƒªã‚¢ã‚’è¦‹ã¤ã‘ã‚‹
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]'
            ]
        
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input and await html_input.is_visible():
                        await html_input.click()
                        await page.wait_for_timeout(500)
                        await html_input.fill(html_content)
                        await page.wait_for_timeout(1000)
                        logger.info("âœ… HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„æŒ¿å…¥å®Œäº†")
                        return True
                except Exception as e:
                    logger.debug(f"HTMLå…¥åŠ›è©¦è¡Œã‚¨ãƒ©ãƒ¼ ({selector}): {e}")
                    continue
        
            return False
        
        except Exception as e:
            logger.error(f"HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„æŒ¿å…¥ã‚¨ãƒ©ãƒ¼: {e}")
            return False
    
    async def _fill_content(self, page: Page, content: str) -> bool:
        """æœ¬æ–‡å…¥åŠ›"""
        # Tabã‚­ãƒ¼ã§æœ¬æ–‡ã‚¨ãƒªã‚¢ã«ç§»å‹•
        await page.keyboard.press('Tab')
        await page.wait_for_timeout(500)
        
        content_selectors = [
            'p[data-title="æ®µè½"]',
            '.block-editor-default-block-appender__content',
            '[aria-label="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ "]',
            '.wp-block-paragraph'
        ]
        
        for selector in content_selectors:
            try:
                content_area = await page.query_selector(selector)
                if content_area:
                    await content_area.click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content)
                    await page.wait_for_timeout(1000)
                    logger.info("âœ… æœ¬æ–‡å…¥åŠ›å®Œäº†")
                    return True
            except:
                continue
        
        # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å˜ç´”ã«Tabã‚­ãƒ¼å¾Œã«å…¥åŠ›
        await page.keyboard.type(content)
        await page.wait_for_timeout(1000)
        logger.info("âœ… æœ¬æ–‡å…¥åŠ›å®Œäº†(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)")
        return True
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«è¨­å®šï¼ˆwp_post_editor.pyã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylangè¨€èªè¨­å®šã‚»ãƒ¬ã‚¯ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        # æ—¥æœ¬èªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ¢ã™
                        options = await lang_select.inner_text()
                        logger.debug(f"  â†’ åˆ©ç”¨å¯èƒ½ãªè¨€èª: {options[:100]}")
                        
                        # è¤‡æ•°ã®æ—¥æœ¬èªè¡¨è¨˜ã‚’è©¦ã™
                        japanese_labels = ['æ—¥æœ¬èª', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"âœ… Polylangè¨€èªè¨­å®šæˆåŠŸ: {label}")
                                
                                # ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç†
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ Polylangè¨€èªè¨­å®šè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‡¦ç†ï¼ˆwp_post_editor.pyã¨åŒã˜ï¼‰"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("ã¯ã„")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("âœ… ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§OKã‚’ã‚¯ãƒªãƒƒã‚¯")
                        return
            except:
                continue
    
    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        save_selectors = [
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            '.editor-post-save-draft'
        ]
        
        for selector in save_selectors:
            try:
                save_button = await page.query_selector(selector)
                if save_button and await save_button.is_visible():
                    is_disabled = await save_button.is_disabled()
                    if not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(3000)
                        logger.info("âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†")
                        return True
            except:
                continue
        
        return False

#wp_post_editor.py
"""WordPressæŠ•ç¨¿ç·¨é›†ï¼ˆè¶…å …ç‰¢ç‰ˆãƒ»è©³ç´°ãƒ­ã‚°ä»˜ãï¼‰"""
import logging
import re
from datetime import datetime
from typing import Dict, Optional
from playwright.async_api import Page

from .wp_utils import TaskContentFetcher

logger = logging.getLogger(__name__)


class WordPressPostEditor:
    """WordPressæŠ•ç¨¿ç·¨é›†æ©Ÿèƒ½ï¼ˆè¶…å …ç‰¢ç‰ˆï¼‰"""
    
    def __init__(self, wp_url: str, sheets_manager=None):
        self.wp_url = wp_url
        self.sheets_manager = sheets_manager
        self.debug_screenshots = []  # ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¸€è¦§
    
    async def edit_post(self, page: Page, task: Dict) -> Dict:
        """æ—¢å­˜ã®æŠ•ç¨¿ã‚’ç·¨é›†ï¼ˆã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºæ”¹å–„ç‰ˆï¼‰"""
        try:
            logger.info("="*80)
            logger.info("ã€ã‚¹ãƒ†ãƒƒãƒ—1/10ã€‘æŠ•ç¨¿ç·¨é›†ã‚¿ã‚¹ã‚¯é–‹å§‹")
            logger.info("="*80)
            
            # ã‚¹ãƒ†ãƒƒãƒ—1: ã‚¿ã‚¹ã‚¯å†…å®¹ã®è§£æ - æ”¹å–„ç‰ˆ
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—2/10ã€‘ã‚¿ã‚¹ã‚¯å†…å®¹ã‚’è§£æä¸­...")
            
            # è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡º
            search_title = ""
            description = task['description']
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ã€Œã€ã§å›²ã¾ã‚ŒãŸã‚¿ã‚¤ãƒˆãƒ«
            title_patterns = [
                r'[ã€Œã€](.+?)[ã€ã€].*ã®ä¸‹æ›¸ãä¿å­˜',
                r'ã‚¿ã‚¤ãƒˆãƒ«[ã€€\s]*[ã€Œã€](.+?)[ã€ã€]',
                r'æŠ•ç¨¿[ã€€\s]*[ã€Œã€](.+?)[ã€ã€]',
                r'[ã€Œã€](AIæŠ•ç¨¿)[ã€ã€]'  # æ˜ç¤ºçš„ã«ã€ŒAIæŠ•ç¨¿ã€ã‚’æ¢ã™
            ]
            
            for pattern in title_patterns:
                match = re.search(pattern, description)
                if match:
                    search_title = match.group(1)
                    logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºæˆåŠŸï¼ˆãƒ‘ã‚¿ãƒ¼ãƒ³: {pattern}ï¼‰: {search_title}")
                    break
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: ç‰¹å®šã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰åˆ¤æ–­
            if not search_title:
                if 'AIæŠ•ç¨¿' in description:
                    search_title = 'AIæŠ•ç¨¿'
                    logger.info(f"âœ… ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«æ¨æ¸¬: {search_title}")
            
            if not search_title:
                logger.warning("âš ï¸ ã‚¿ã‚¤ãƒˆãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
                search_title = "AIæŠ•ç¨¿"
            
            logger.info(f"ğŸ” æ¤œç´¢ã‚¿ã‚¤ãƒˆãƒ«: {search_title}")
            
            # ã‚¹ãƒ†ãƒƒãƒ—2: task_idã®æŠ½å‡º
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—3/10ã€‘æ›¸ãæ›ãˆå…ƒè¨˜äº‹ã®task_idã‚’æŠ½å‡ºä¸­...")
            target_task_id = TaskContentFetcher.extract_task_id(task['description'])
            
            if target_task_id:
                logger.info(f"âœ… task_idæŠ½å‡ºæˆåŠŸ: {target_task_id}")
            else:
                logger.error("âŒ task_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return {
                    'success': False,
                    'error': 'task_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚¿ã‚¹ã‚¯èª¬æ˜ã«task_idã‚’å«ã‚ã¦ãã ã•ã„ã€‚'
                }
            
            # ã‚¹ãƒ†ãƒƒãƒ—3: è¨˜äº‹å†…å®¹ã®å–å¾—
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—4/10ã€‘Google Drive/ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‹ã‚‰è¨˜äº‹å†…å®¹ã‚’å–å¾—ä¸­...")
            logger.info(f"å¯¾è±¡: task_id={target_task_id}")
            
            replacement_content = await TaskContentFetcher.get_task_content(
                self.sheets_manager, target_task_id
            )
            
            if not replacement_content:
                logger.error(f"âŒ task_id {target_task_id} ã®è¨˜äº‹å†…å®¹ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
                return {
                    'success': False,
                    'error': f'task_id {target_task_id} ã®è¨˜äº‹å†…å®¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'
                }
            
            logger.info(f"âœ… è¨˜äº‹å†…å®¹å–å¾—æˆåŠŸ: {len(replacement_content)}æ–‡å­—")
            logger.info(f"å…ˆé ­200æ–‡å­—:\n{replacement_content[:200]}...")
            
            # ã‚¹ãƒ†ãƒƒãƒ—3.5: ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—4.5/10ã€‘è¨˜äº‹ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢ä¸­...")
            article_title, article_body = self._extract_title_and_body(replacement_content)
            
            logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«: {article_title}")
            logger.info(f"âœ… æœ¬æ–‡: {len(article_body)}æ–‡å­—")
            
            # ã‚¹ãƒ†ãƒƒãƒ—4: æŠ•ç¨¿ä¸€è¦§ãƒšãƒ¼ã‚¸ã¸ç§»å‹•
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—5/10ã€‘WordPressæŠ•ç¨¿ä¸€è¦§ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ä¸­...")
            await page.goto(f"{self.wp_url}/wp-admin/edit.php", timeout=30000)
            await page.wait_for_timeout(3000)
            
            screenshot_path = await self._save_screenshot(page, "01_post_list")
            logger.info(f"âœ… æŠ•ç¨¿ä¸€è¦§ãƒšãƒ¼ã‚¸åˆ°é”: {screenshot_path}")
            
            # ã‚¹ãƒ†ãƒƒãƒ—5: ã‚¿ã‚¤ãƒˆãƒ«æ¤œç´¢
            if search_title:
                logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—6/10ã€‘ã‚¿ã‚¤ãƒˆãƒ« '{search_title}' ã§æ¤œç´¢ä¸­...")
                search_success = await self._search_post(page, search_title)
                
                if search_success:
                    logger.info("âœ… æ¤œç´¢å®Ÿè¡ŒæˆåŠŸ")
                    screenshot_path = await self._save_screenshot(page, "02_search_result")
                else:
                    logger.warning("âš ï¸ æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
            # ã‚¹ãƒ†ãƒƒãƒ—6: æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ç§»å‹•
            logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—7/10ã€‘æŠ•ç¨¿ '{search_title}' ã®ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ç§»å‹•ä¸­...")
            post_found, post_id = await self._navigate_to_edit_page(page, search_title)
            
            if not post_found:
                logger.error(f"âŒ æŠ•ç¨¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ: {search_title}")
                screenshot_path = await self._save_screenshot(page, "03_post_not_found")
                return {
                    'success': False,
                    'error': f'ã‚¿ã‚¤ãƒˆãƒ«ã€Œ{search_title}ã€ã®æŠ•ç¨¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ',
                    'screenshot': screenshot_path,
                    'debug_screenshots': self.debug_screenshots
                }
            
            logger.info(f"âœ… æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸åˆ°é”: æŠ•ç¨¿ID={post_id}")
            screenshot_path = await self._save_screenshot(page, "04_edit_page")
            
            # ã‚¹ãƒ†ãƒƒãƒ—7.5: ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´
            if article_title != search_title:
                logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—7.5/10ã€‘æŠ•ç¨¿ã‚¿ã‚¤ãƒˆãƒ«ã‚’ '{article_title}' ã«å¤‰æ›´ä¸­...")
                title_changed = await self._change_title(page, article_title)
                
                if title_changed:
                    logger.info("âœ… ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´å®Œäº†")
                else:
                    logger.warning("âš ï¸ ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´ã«å¤±æ•—ã—ã¾ã—ãŸ")
                
                screenshot_path = await self._save_screenshot(page, "04b_after_title_change")
            
            # ã‚¹ãƒ†ãƒƒãƒ—7: Polylangè¨€èªè¨­å®š
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—8/10ã€‘Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«å¤‰æ›´ä¸­...")
            language_changed = await self._set_polylang_language(page)
            
            if language_changed:
                logger.info("âœ… Polylangè¨€èªè¨­å®šå®Œäº†: æ—¥æœ¬èª")
            else:
                logger.warning("âš ï¸ Polylangè¨­å®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
            screenshot_path = await self._save_screenshot(page, "05_after_language")
            
            # ã‚¹ãƒ†ãƒƒãƒ—8: è¨˜äº‹å†…å®¹ã®æ›¸ãæ›ãˆ
            logger.info(f"\nã€ã‚¹ãƒ†ãƒƒãƒ—9/10ã€‘è¨˜äº‹å†…å®¹ã‚’æ›¸ãæ›ãˆä¸­... ({len(article_body)}æ–‡å­—)")
            
            # ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›
            article_html = self._convert_markdown_to_html(article_body)
            logger.info(f"  ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³â†’HTMLå¤‰æ›: {len(article_html)}æ–‡å­—")
            
            content_replaced = await self._replace_content(page, article_html)
            
            if content_replaced:
                logger.info("âœ… è¨˜äº‹å†…å®¹ã®æ›¸ãæ›ãˆå®Œäº†")
            else:
                logger.error("âŒ è¨˜äº‹å†…å®¹ã®æ›¸ãæ›ãˆã«å¤±æ•—ã—ã¾ã—ãŸ")
            
            screenshot_path = await self._save_screenshot(page, "06_after_content")
            
            # ã‚¹ãƒ†ãƒƒãƒ—9: ä¸‹æ›¸ãä¿å­˜
            logger.info("\nã€ã‚¹ãƒ†ãƒƒãƒ—10/10ã€‘ä¸‹æ›¸ãä¿å­˜ä¸­...")
            saved = await self._save_draft(page)
            
            if saved:
                logger.info("âœ… ä¸‹æ›¸ãä¿å­˜å®Œäº†")
            else:
                logger.warning("âš ï¸ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            
            # æœ€çµ‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = await self._save_screenshot(page, "07_final")
            
            # çµæœã‚µãƒãƒªãƒ¼
            logger.info("\n" + "="*80)
            logger.info("ã€å®Œäº†ã€‘æŠ•ç¨¿ç·¨é›†ã‚¿ã‚¹ã‚¯çµ‚äº†")
            logger.info("="*80)
            
            result_summary = self._build_summary(
                search_title, post_id, article_title, language_changed, 
                len(article_body), saved
            )
            summary_text = '\n'.join(result_summary)
            
            logger.info("\nã€æœ€çµ‚çµæœã€‘")
            logger.info(summary_text)
            
            return {
                'success': True,
                'summary': summary_text,
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots,
                'full_text': f'{summary_text}\n\nã€ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã€‘\n' + '\n'.join([f'- {s}' for s in self.debug_screenshots])
            }
                
        except Exception as e:
            logger.error(f"âŒ æŠ•ç¨¿ç·¨é›†ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            
            screenshot_path = await self._save_screenshot(page, "ERROR")
            
            return {
                'success': False,
                'error': str(e),
                'screenshot': screenshot_path,
                'debug_screenshots': self.debug_screenshots
            }
    
    async def _save_screenshot(self, page: Page, name: str) -> str:
        """ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜"""
        try:
            timestamp = datetime.now().strftime('%H%M%S')
            screenshot_path = f"wp_debug_{name}_{timestamp}.png"
            await page.screenshot(path=screenshot_path, full_page=True)
            self.debug_screenshots.append(screenshot_path)
            logger.debug(f"ğŸ“¸ ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜: {screenshot_path}")
            return screenshot_path
        except Exception as e:
            logger.warning(f"ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿å­˜å¤±æ•—: {e}")
            return ""
    
    async def _search_post(self, page: Page, search_title: str) -> bool:
        """æŠ•ç¨¿ã‚’æ¤œç´¢"""
        search_box_selectors = [
            '#post-search-input',
            'input[name="s"]',
            'input[type="search"]',
            '.search-box input'
        ]
        
        for i, selector in enumerate(search_box_selectors, 1):
            try:
                logger.debug(f"æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹è©¦è¡Œ {i}/{len(search_box_selectors)}: {selector}")
                search_box = await page.query_selector(selector)
                
                if search_box:
                    is_visible = await search_box.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        await search_box.fill(search_title)
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Enter')
                        await page.wait_for_timeout(3000)
                        logger.info(f"âœ… æ¤œç´¢å®Ÿè¡ŒæˆåŠŸ: ã‚»ãƒ¬ã‚¯ã‚¿={selector}")
                        return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
    
    # wp_post_editor.py ã® _extract_title_and_body ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä¿®æ­£

    def _extract_title_and_body(self, content: str) -> tuple[str, str]:
        """
        è¨˜äº‹ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡ºï¼ˆHTMLå¯¾å¿œå¼·åŒ–ç‰ˆï¼‰
        """
        try:
            logger.info(f"ã€è¨˜äº‹å†…å®¹è§£æé–‹å§‹ã€‘æ–‡å­—æ•°: {len(content)}")
                
            # HTMLå½¢å¼ã®å ´åˆã¯HTMLCleanerã‚’ä½¿ç”¨
            if '<h1' in content or '<div' in content or '<p>' in content:
                logger.info("âœ… HTMLå½¢å¼ã®è¨˜äº‹ã‚’æ¤œå‡º - HTMLCleanerã‚’ä½¿ç”¨")
                    
                # HTMLCleanerã§ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
                from .wp_utils import HTMLCleaner
                title, body = HTMLCleaner.prepare_html_for_wordpress(content)
                    
                logger.info(f"âœ… HTMLå‡¦ç†å®Œäº†: ã‚¿ã‚¤ãƒˆãƒ«='{title}', æœ¬æ–‡={len(body)}æ–‡å­—")
                return title, body
                
            # Markdownå½¢å¼ã®å‡¦ç†ï¼ˆæ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
            lines = content.split('\n')
            title = ""
            body_lines = []
                
            for i, line in enumerate(lines):
                line_stripped = line.strip()
                    
                # æœ€åˆã® # ã§å§‹ã¾ã‚‹è¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«ã¨ã™ã‚‹
                if line_stripped.startswith('# ') and not title:
                    title = line_stripped[2:].strip()
                    logger.info(f"âœ… Markdownã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡º: {title}")
                    continue
                    
                # ã‚¿ã‚¤ãƒˆãƒ«ãŒè¦‹ã¤ã‹ã£ãŸå¾Œã®è¡Œã‚’æœ¬æ–‡ã¨ã™ã‚‹
                if title:
                    body_lines.append(line)
                # ã‚¿ã‚¤ãƒˆãƒ«ãŒè¦‹ã¤ã‹ã‚‹å‰ã®éç©ºè¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«å€™è£œã¨ã™ã‚‹
                elif line_stripped and not title:
                    title = line_stripped[:100]
                    logger.info(f"âœ… æœ€åˆã®è¡Œã‚’ã‚¿ã‚¤ãƒˆãƒ«ã¨ã—ã¦ä½¿ç”¨: {title}")

            if title:
                body = '\n'.join(body_lines).strip() if body_lines else content
                logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«ãƒ»æœ¬æ–‡åˆ†é›¢å®Œäº†: ã‚¿ã‚¤ãƒˆãƒ«={title[:30]}..., æœ¬æ–‡={len(body)}æ–‡å­—")
                return title, body

            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            logger.warning("âŒ ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
            return "AIæŠ•ç¨¿_è‡ªå‹•ç”Ÿæˆ", content

        except Exception as e:
            logger.error(f"âŒ ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return "AIæŠ•ç¨¿_ã‚¨ãƒ©ãƒ¼", content
    
    async def _change_title(self, page: Page, new_title: str) -> bool:
        """æŠ•ç¨¿ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å¤‰æ›´"""
        title_selectors = [
            '.editor-post-title__input',
            'h1[aria-label="ã‚¿ã‚¤ãƒˆãƒ«ã‚’è¿½åŠ "]',
            'textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]',
            '#post-title-0',
            '.wp-block-post-title'
        ]
        
        logger.debug("ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›æ¬„ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(title_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(title_selectors)}: {selector}")
            try:
                title_input = await page.query_selector(selector)
                if title_input:
                    is_visible = await title_input.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        # æ—¢å­˜ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’ã‚¯ãƒªã‚¢
                        await title_input.click()
                        await page.wait_for_timeout(500)
                        await page.keyboard.press('Control+A')
                        await page.wait_for_timeout(300)
                        
                        # æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›
                        await page.keyboard.type(new_title)
                        await page.wait_for_timeout(1000)
                        
                        logger.info(f"âœ… ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´æˆåŠŸ: {new_title}")
                        return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    def _convert_markdown_to_html(self, markdown_text: str) -> str:
        """
        ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’HTMLã«å¤‰æ›
        
        å¯¾å¿œï¼š
        - ## è¦‹å‡ºã— â†’ <h2>è¦‹å‡ºã—</h2>
        - ### è¦‹å‡ºã— â†’ <h3>è¦‹å‡ºã—</h3>
        - **å¤ªå­—** â†’ <strong>å¤ªå­—</strong>
        - *æ–œä½“* â†’ <em>æ–œä½“</em>
        """
        try:
            import re
            
            html_lines = []
            lines = markdown_text.split('\n')
            
            for line in lines:
                # è¦‹å‡ºã—ã®å¤‰æ›
                if line.strip().startswith('### '):
                    # H3
                    text = line.strip()[4:]
                    html_lines.append(f'<h3>{text}</h3>')
                elif line.strip().startswith('## '):
                    # H2
                    text = line.strip()[3:]
                    html_lines.append(f'<h2>{text}</h2>')
                elif line.strip().startswith('# '):
                    # H1ï¼ˆé€šå¸¸ã¯ã‚¿ã‚¤ãƒˆãƒ«ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                    text = line.strip()[2:]
                    html_lines.append(f'<h1>{text}</h1>')
                else:
                    # æœ¬æ–‡ã®å¤‰æ›
                    converted_line = line
                    
                    # **å¤ªå­—** â†’ <strong>å¤ªå­—</strong>
                    converted_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', converted_line)
                    
                    # *æ–œä½“* â†’ <em>æ–œä½“</em>
                    converted_line = re.sub(r'\*(.+?)\*', r'<em>\1</em>', converted_line)
                    
                    # æ®µè½ã‚¿ã‚°ã§å›²ã‚€ï¼ˆç©ºè¡Œã§ãªã„å ´åˆï¼‰
                    if converted_line.strip():
                        html_lines.append(f'<p>{converted_line}</p>')
                    else:
                        html_lines.append('')
            
            html_content = '\n'.join(html_lines)
            
            logger.info(f"ã€ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³â†’HTMLå¤‰æ›å®Œäº†ã€‘")
            logger.info(f"  å…ƒ: {len(markdown_text)}æ–‡å­—")
            logger.info(f"  å¤‰æ›å¾Œ: {len(html_content)}æ–‡å­—")
            
            return html_content
            
        except Exception as e:
            logger.warning(f"ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å¤‰æ›ã‚¨ãƒ©ãƒ¼: {e}")
            return markdown_text
    
    async def _replace_content(self, page: Page, content: str, is_html: bool = False) -> bool:
        """è¨˜äº‹å†…å®¹ã‚’ç½®æ›ï¼ˆGutenbergãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œç‰ˆï¼‰"""
        logger.info("è¨˜äº‹ã‚¨ãƒ‡ã‚£ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        if is_html:
            logger.info("HTMLå½¢å¼ã®ãŸã‚ã€Gutenbergãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦æŒ¿å…¥ã—ã¾ã™")
            return await self._insert_as_gutenberg_blocks(page, content)
        
        # é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã®å ´åˆ
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  â†’ {len(content_blocks)}å€‹ã®è¦ç´ ç™ºè¦‹")
                    
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"âœ… è¨˜äº‹å†…å®¹æ›¸ãæ›ãˆæˆåŠŸ: {len(content)}æ–‡å­—")
                    return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.error("âŒ ã™ã¹ã¦ã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—")
        return False
    
    async def _insert_as_gutenberg_blocks(self, page: Page, html_content: str) -> bool:
        """HTMLã‚’ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦æŒ¿å…¥ï¼ˆç°¡æ˜“ç‰ˆï¼‰"""
        try:
            logger.info("ã€ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯æŒ¿å…¥é–‹å§‹ã€‘")
            
            # æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‰Šé™¤
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—1: æ—¢å­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å‰Šé™¤")
            await self._clear_all_blocks_simple(page)
            
            # ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ 
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—2: ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ")
            
            # æ–¹æ³•1: /html ã§æ¤œç´¢
            try:
                await page.keyboard.press('/')
                await page.wait_for_timeout(500)
                await page.keyboard.type('html')
                await page.wait_for_timeout(1000)
                await page.keyboard.press('Enter')
                await page.wait_for_timeout(1000)
                logger.info("  â†’ /html ã§æ¤œç´¢æˆåŠŸ")
            except Exception as e:
                logger.debug(f"  æ–¹æ³•1å¤±æ•—: {e}")
                
                # æ–¹æ³•2: ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ ãƒœã‚¿ãƒ³ã‹ã‚‰
                try:
                    await page.click('button[aria-label="ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ "]', timeout=3000)
                    await page.wait_for_timeout(500)
                    await page.type('input[placeholder*="æ¤œç´¢"]', 'html')
                    await page.wait_for_timeout(1000)
                    await page.click('button:has-text("ã‚«ã‚¹ã‚¿ãƒ HTML")', timeout=3000)
                    await page.wait_for_timeout(1000)
                    logger.info("  â†’ ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ ãƒœã‚¿ãƒ³ã‹ã‚‰æˆåŠŸ")
                except Exception as e2:
                    logger.debug(f"  æ–¹æ³•2å¤±æ•—: {e2}")
            
            # HTMLã‚³ãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ã‚’è¦‹ã¤ã‘ã¦è²¼ã‚Šä»˜ã‘
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—3: HTMLã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘")
            
            html_input_selectors = [
                'textarea.block-editor-plain-text',
                '.wp-block-html textarea',
                'textarea[aria-label*="HTML"]',
                'textarea.components-textarea-control__input'
            ]
            
            pasted = False
            for selector in html_input_selectors:
                try:
                    html_input = await page.query_selector(selector)
                    if html_input:
                        is_visible = await html_input.is_visible()
                        if is_visible:
                            await html_input.click()
                            await page.wait_for_timeout(500)
                            
                            # HTMLã‚’è²¼ã‚Šä»˜ã‘
                            await html_input.fill(html_content)
                            await page.wait_for_timeout(1000)
                            
                            logger.info(f"  âœ… HTMLè²¼ã‚Šä»˜ã‘æˆåŠŸ: {len(html_content)}æ–‡å­—")
                            pasted = True
                            break
                except Exception as e:
                    logger.debug(f"  {selector} ã‚¨ãƒ©ãƒ¼: {e}")
                    continue
            
            if not pasted:
                logger.warning("  âš ï¸ HTMLå…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
                return False
            
            # ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆï¼ˆè¦‹ãŸç›®ã‚’ç¢ºèªï¼‰
            logger.info("  ã‚¹ãƒ†ãƒƒãƒ—4: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ")
            try:
                # ã€Œãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€ãƒœã‚¿ãƒ³ã‚’æ¢ã™
                preview_button = await page.query_selector('button:has-text("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼")')
                if preview_button:
                    await preview_button.click()
                    await page.wait_for_timeout(1000)
                    logger.info("  âœ… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰è¡¨ç¤º")
            except Exception as e:
                logger.debug(f"  ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚¨ãƒ©ãƒ¼: {e}")
            
            logger.info(f"âœ… ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯æŒ¿å…¥å®Œäº†")
            return True
            
        except Exception as e:
            logger.error(f"âŒ ã‚«ã‚¹ã‚¿ãƒ HTMLãƒ–ãƒ­ãƒƒã‚¯æŒ¿å…¥ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    async def _clear_all_blocks_simple(self, page: Page) -> bool:
        """æ—¢å­˜ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç°¡æ˜“çš„ã«å‰Šé™¤"""
        try:
            # Ctrl+A ã§å…¨é¸æŠ â†’ Backspace ã§å‰Šé™¤
            await page.keyboard.press('Control+A')
            await page.wait_for_timeout(500)
            await page.keyboard.press('Backspace')
            await page.wait_for_timeout(1000)
            
            logger.info("  âœ… æ—¢å­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å‰Šé™¤å®Œäº†")
            return True
            
        except Exception as e:
            logger.debug(f"  æ—¢å­˜ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å‰Šé™¤ã‚¨ãƒ©ãƒ¼: {e}")
            return False
        
        logger.warning("âŒ ã™ã¹ã¦ã®æ¤œç´¢ãƒœãƒƒã‚¯ã‚¹ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—")
        return False
    
    async def _navigate_to_edit_page(self, page: Page, search_title: str) -> tuple[bool, Optional[str]]:
        """æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ç§»å‹•"""
        logger.info("æŠ•ç¨¿ãƒªãƒ³ã‚¯ã‚’æ¢ç´¢ä¸­...")
        
        # æ–¹æ³•1: ã‚¿ã‚¤ãƒˆãƒ«ãƒªãƒ³ã‚¯ã‹ã‚‰ç›´æ¥ç·¨é›†URL
        logger.debug("ã€æ–¹æ³•1ã€‘ã‚¿ã‚¤ãƒˆãƒ«ãƒªãƒ³ã‚¯ã‹ã‚‰ç·¨é›†URLã‚’å–å¾—")
        try:
            # è¤‡æ•°ã®ã‚»ãƒ¬ã‚¯ã‚¿ã‚’è©¦è¡Œ
            title_selectors = [
                f'a.row-title:has-text("{search_title}")',
                f'td.title a:has-text("{search_title}")',
                f'.row-title:has-text("{search_title}")'
            ]
            
            for i, selector in enumerate(title_selectors, 1):
                logger.debug(f"  è©¦è¡Œ {i}/{len(title_selectors)}: {selector}")
                try:
                    title_link = await page.query_selector(selector)
                    if title_link:
                        href = await title_link.get_attribute('href')
                        if href:
                            post_id_match = re.search(r'post=(\d+)', href)
                            if post_id_match:
                                post_id = post_id_match.group(1)
                                edit_url = f"{self.wp_url}/wp-admin/post.php?post={post_id}&action=edit"
                                logger.info(f"âœ… ç·¨é›†URLæ§‹ç¯‰æˆåŠŸ: æŠ•ç¨¿ID={post_id}")
                                
                                await page.goto(edit_url, timeout=30000)
                                await page.wait_for_timeout(4000)
                                
                                return True, post_id
                except Exception as e:
                    logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                    continue
        except Exception as e:
            logger.debug(f"æ–¹æ³•1å¤±æ•—: {e}")
        
        # æ–¹æ³•2: ç·¨é›†ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯
        logger.debug("ã€æ–¹æ³•2ã€‘ç·¨é›†ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯")
        edit_link_selectors = [
            f'tr:has-text("{search_title}") .row-actions .edit a',
            f'a.row-title:has-text("{search_title}")',
            '.row-actions .edit a',
            f'tr:has(a:has-text("{search_title}")) .edit a'
        ]
        
        for i, selector in enumerate(edit_link_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(edit_link_selectors)}: {selector}")
            try:
                edit_link = await page.query_selector(selector)
                if edit_link:
                    is_visible = await edit_link.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        await edit_link.click()
                        await page.wait_for_timeout(5000)
                        
                        # URLã‹ã‚‰æŠ•ç¨¿IDã‚’å–å¾—
                        current_url = page.url
                        post_id_match = re.search(r'post=(\d+)', current_url)
                        post_id = post_id_match.group(1) if post_id_match else "ä¸æ˜"
                        
                        logger.info(f"âœ… ç·¨é›†ãƒªãƒ³ã‚¯ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ: æŠ•ç¨¿ID={post_id}")
                        return True, post_id
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        # æ–¹æ³•3: æœ€åˆã®æŠ•ç¨¿ã‚’é–‹ãï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        logger.debug("ã€æ–¹æ³•3ã€‘æœ€åˆã®æŠ•ç¨¿ã‚’é–‹ãï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰")
        try:
            first_edit_link = await page.query_selector('.row-actions .edit a')
            if first_edit_link:
                await first_edit_link.click()
                await page.wait_for_timeout(4000)
                logger.warning("âš ï¸ æœ€åˆã®æŠ•ç¨¿ã‚’é–‹ãã¾ã—ãŸï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰")
                return True, "ä¸æ˜"
        except Exception as e:
            logger.debug(f"æ–¹æ³•3å¤±æ•—: {e}")
        
        logger.error("âŒ ã™ã¹ã¦ã®æ–¹æ³•ã§æŠ•ç¨¿ç·¨é›†ãƒšãƒ¼ã‚¸ã¸ã®ç§»å‹•ã«å¤±æ•—")
        return False, None
    
    async def _set_polylang_language(self, page: Page) -> bool:
        """Polylangã®è¨€èªã‚’æ—¥æœ¬èªã«è¨­å®š"""
        polylang_selectors = [
            'select[name="post_lang_choice"]',
            '#post_lang_choice',
            'select.pll-select-flag',
            '#pll_post_lang_choice',
            'select[id*="lang"]'
        ]
        
        logger.debug("Polylangè¨€èªè¨­å®šã‚»ãƒ¬ã‚¯ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(polylang_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(polylang_selectors)}: {selector}")
            try:
                lang_select = await page.query_selector(selector)
                if lang_select:
                    is_visible = await lang_select.is_visible()
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}")
                    
                    if is_visible:
                        # æ—¥æœ¬èªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ¢ã™
                        options = await lang_select.inner_text()
                        logger.debug(f"  â†’ åˆ©ç”¨å¯èƒ½ãªè¨€èª: {options[:100]}")
                        
                        # è¤‡æ•°ã®æ—¥æœ¬èªè¡¨è¨˜ã‚’è©¦ã™
                        japanese_labels = ['æ—¥æœ¬èª', 'ja', 'Japanese', 'japanese']
                        
                        for label in japanese_labels:
                            try:
                                await lang_select.select_option(label=label)
                                await page.wait_for_timeout(2000)
                                logger.info(f"âœ… Polylangè¨€èªè¨­å®šæˆåŠŸ: {label}")
                                
                                # ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°å‡¦ç†
                                await self._handle_confirm_dialog(page)
                                
                                return True
                            except:
                                continue
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ Polylangè¨€èªè¨­å®šè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    async def _handle_confirm_dialog(self, page: Page):
        """ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‡¦ç†"""
        ok_button_selectors = [
            'button:has-text("OK")',
            'button:has-text("ã¯ã„")',
            '.ui-dialog-buttonset button:first-child',
            'button[type="button"]:has-text("OK")'
        ]
        
        for selector in ok_button_selectors:
            try:
                ok_button = await page.query_selector(selector)
                if ok_button:
                    is_visible = await ok_button.is_visible()
                    if is_visible:
                        await ok_button.click()
                        await page.wait_for_timeout(1000)
                        logger.debug("âœ… ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§OKã‚’ã‚¯ãƒªãƒƒã‚¯")
                        return
            except:
                continue
    
    async def _replace_content(self, page: Page, content: str) -> bool:
        """è¨˜äº‹å†…å®¹ã‚’ç½®æ›"""
        logger.info("è¨˜äº‹ã‚¨ãƒ‡ã‚£ã‚¿ã‚’æ¢ç´¢ä¸­...")
        
        # Gutenbergã‚¨ãƒ‡ã‚£ã‚¿ã®ã‚»ãƒ¬ã‚¯ã‚¿
        content_selectors = [
            '.block-editor-rich-text__editable',
            'p.block-editor-rich-text__editable',
            '[data-type="core/paragraph"] .block-editor-rich-text__editable',
            '.editor-post-text-editor',
            'textarea.editor-post-text-editor',
            '#content'  # ã‚¯ãƒ©ã‚·ãƒƒã‚¯ã‚¨ãƒ‡ã‚£ã‚¿
        ]
        
        for i, selector in enumerate(content_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(content_selectors)}: {selector}")
            try:
                content_blocks = await page.query_selector_all(selector)
                
                if content_blocks and len(content_blocks) > 0:
                    logger.debug(f"  â†’ {len(content_blocks)}å€‹ã®è¦ç´ ç™ºè¦‹")
                    
                    # æœ€åˆã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯
                    await content_blocks[0].click()
                    await page.wait_for_timeout(500)
                    logger.debug("  â†’ ã‚¯ãƒªãƒƒã‚¯å®Œäº†")
                    
                    # å…¨é¸æŠã—ã¦å‰Šé™¤
                    await page.keyboard.press('Control+A')
                    await page.wait_for_timeout(300)
                    await page.keyboard.press('Backspace')
                    await page.wait_for_timeout(500)
                    logger.debug("  â†’ æ—¢å­˜å†…å®¹å‰Šé™¤å®Œäº†")
                    
                    # æ–°ã—ã„å†…å®¹ã‚’å…¥åŠ›
                    await page.keyboard.type(content, delay=10)
                    await page.wait_for_timeout(1000)
                    
                    logger.info(f"âœ… è¨˜äº‹å†…å®¹æ›¸ãæ›ãˆæˆåŠŸ: {len(content)}æ–‡å­—")
                    return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.error("âŒ ã™ã¹ã¦ã®ã‚¨ãƒ‡ã‚£ã‚¿ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—")
        return False
    
    async def _save_draft(self, page: Page) -> bool:
        """ä¸‹æ›¸ãä¿å­˜"""
        save_selectors = [
            'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
            'button[aria-label="ä¸‹æ›¸ãä¿å­˜"]',
            '.editor-post-save-draft',
            '#save-post',
            'button.editor-post-save-draft'
        ]
        
        logger.debug("ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...")
        
        for i, selector in enumerate(save_selectors, 1):
            logger.debug(f"  è©¦è¡Œ {i}/{len(save_selectors)}: {selector}")
            try:
                save_button = await page.query_selector(selector)
                if save_button:
                    is_visible = await save_button.is_visible()
                    is_disabled = await save_button.is_disabled() if is_visible else True
                    
                    logger.debug(f"  â†’ è¦ç´ ç™ºè¦‹: è¡¨ç¤º={is_visible}, ç„¡åŠ¹={is_disabled}")
                    
                    if is_visible and not is_disabled:
                        await save_button.click()
                        await page.wait_for_timeout(4000)
                        logger.info("âœ… ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æˆåŠŸ")
                        return True
            except Exception as e:
                logger.debug(f"  â†’ ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        logger.warning("âŒ ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return False
    
    def _build_summary(self, old_title: str, post_id: str, new_title: str, 
                      lang_changed: bool, content_length: int, saved: bool) -> list:
        """çµæœã‚µãƒãƒªãƒ¼ã‚’æ§‹ç¯‰"""
        result_summary = []
        result_summary.append(f"ã€æŠ•ç¨¿ç·¨é›†å®Œäº†ã€‘")
        result_summary.append(f"å…ƒã®ã‚¿ã‚¤ãƒˆãƒ«: {old_title}")
        
        if new_title != old_title:
            result_summary.append(f"æ–°ã—ã„ã‚¿ã‚¤ãƒˆãƒ«: {new_title}")
        
        result_summary.append(f"æŠ•ç¨¿ID: {post_id}")
        result_summary.append("")
        
        if lang_changed:
            result_summary.append("âœ… Polylangè¨€èªè¨­å®š: æ—¥æœ¬èª")
        else:
            result_summary.append("âš ï¸ Polylangè¨€èªè¨­å®š: ã‚¹ã‚­ãƒƒãƒ—")
        
        result_summary.append(f"âœ… è¨˜äº‹å†…å®¹æ›¸ãæ›ãˆ: {content_length}æ–‡å­—ï¼ˆHTMLå¤‰æ›æ¸ˆã¿ï¼‰")
        
        if saved:
            result_summary.append("âœ… ä¸‹æ›¸ãä¿å­˜: å®Œäº†")
        else:
            result_summary.append("âš ï¸ ä¸‹æ›¸ãä¿å­˜: ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ‰‹å‹•ç¢ºèªæ¨å¥¨ï¼‰")
        
        return result_summary

#wp_requirements_agent.py
"""
WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ»æ¤œè¨¼ãƒ»ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Œå‚™
"""

import asyncio
import logging
from typing import Dict, Optional, List
from pathlib import Path
from datetime import datetime
import json
import re

logger = logging.getLogger(__name__)


class WordPressRequirementsAgent:
    """WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    
    # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã¯é•·ã„ã®ã§ç°¡æ½”ç‰ˆã«å¤‰æ›´
    PROMPT_TEMPLATE = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã€è¦ä»¶å®šç¾©ã®ãƒ—ãƒ­ãƒ•ã‚§ãƒƒã‚·ãƒ§ãƒŠãƒ«ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³ã®M&Aãƒãƒ¼ã‚¿ãƒ«ã‚µã‚¤ãƒˆã®å®Œå…¨ãªè¦ä»¶å®šç¾©æ›¸ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±ã€‘
- **ã‚µã‚¤ãƒˆå**: ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³M&Aãƒãƒ¼ã‚¿ãƒ«
- **WordPressãƒ†ãƒ¼ãƒ**: Cocoonï¼ˆæ—¥æœ¬è£½é«˜æ©Ÿèƒ½ãƒ†ãƒ¼ãƒï¼‰
- **å¤šè¨€èª**: Polylangï¼ˆæ—¥è‹±éœ²ã‚¦ã‚ºä¸­éŸ“ãƒˆãƒ«ã‚³èªã®7è¨€èªï¼‰
- **ä¸»è¦ãƒ—ãƒ©ã‚°ã‚¤ãƒ³**: ACF PRO, FacetWP, Relevanssi, Wordfence, WP Rocket

ã€è¦ä»¶å®šç¾©æ›¸ã®æ§‹æˆã€‘
ä»¥ä¸‹ã®æ§‹é€ ã§**è©³ç´°ãªè¦ä»¶å®šç¾©æ›¸**ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

# 1.0 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦
## 1.1 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå
## 1.2 ç›®çš„ãƒ»èƒŒæ™¯
## 1.3 å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼
## 1.4 æˆåŠŸæŒ‡æ¨™ï¼ˆKPIï¼‰

# 2.0 ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ
## 2.1 æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- WordPress 6.4+ã€Cocoonã€Polylang Proã€ACF PROã€FacetWPã€Relevanssi
## 2.2 ã‚µãƒ¼ãƒãƒ¼è¦ä»¶
- PHP 8.0+ã€MySQL 8.0+ã€ãƒ¡ãƒ¢ãƒª 512MB+
## 2.3 é–‹ç™ºãƒ»æœ¬ç•ªç’°å¢ƒ

# 3.0 æ©Ÿèƒ½è¦ä»¶
## 3.1 ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—
### 3.1.1 M&Aæ¡ˆä»¶ï¼ˆma_caseï¼‰
- supports: title, editor, thumbnail, custom-fields, excerpt
- taxonomies: industry_category, region, deal_type
### 3.1.2 ä¼æ¥­æƒ…å ±ï¼ˆcompanyï¼‰
### 3.1.3 ãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼ˆnewsï¼‰

## 3.2 ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼
### 3.2.1 æ¥­ç¨®åˆ†é¡ï¼ˆindustry_categoryï¼‰ - éšå±¤å‹
### 3.2.2 åœ°åŸŸï¼ˆregionï¼‰ - éšå±¤å‹
### 3.2.3 æ¡ˆä»¶ã‚¿ã‚¤ãƒ—ï¼ˆdeal_typeï¼‰ - ééšå±¤å‹

## 3.3 ACFã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
### M&Aæ¡ˆä»¶ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆ20å€‹å®šç¾©ï¼‰
1. case_idï¼ˆæ¡ˆä»¶IDï¼‰ - ãƒ†ã‚­ã‚¹ãƒˆã€å¿…é ˆ
2. ma_schemeï¼ˆM&Aã‚¹ã‚­ãƒ¼ãƒ ï¼‰ - ã‚»ãƒ¬ã‚¯ãƒˆã€å¿…é ˆ
3. desired_priceï¼ˆå¸Œæœ›ä¾¡æ ¼ï¼‰ - æ•°å€¤
4. established_yearï¼ˆè¨­ç«‹å¹´ï¼‰ - æ•°å€¤
5. employeesï¼ˆå¾“æ¥­å“¡æ•°ï¼‰ - æ•°å€¤
6. annual_revenueï¼ˆå¹´å•†ï¼‰ - æ•°å€¤
7. reason_for_saleï¼ˆå£²å´ç†ç”±ï¼‰ - ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢
8. confidential_levelï¼ˆæ©Ÿå¯†ãƒ¬ãƒ™ãƒ«ï¼‰ - ã‚»ãƒ¬ã‚¯ãƒˆ
9-20. ãã®ä»–ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆå…·ä½“çš„ã«è¨˜è¼‰ï¼‰

## 3.4 æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ï¼ˆFacetWPï¼‰
- æ¥­ç¨®åˆ¥æ¤œç´¢ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰
- åœ°åŸŸåˆ¥æ¤œç´¢ï¼ˆãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ï¼‰
- ä¾¡æ ¼å¸¯æ¤œç´¢ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼‰
- æ¡ˆä»¶ã‚¿ã‚¤ãƒ—æ¤œç´¢ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ï¼‰
- ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢ï¼ˆRelevanssiï¼‰

## 3.5 å¤šè¨€èªæ©Ÿèƒ½ï¼ˆPolylangï¼‰
### è¨€èªè¨­å®š
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: æ—¥æœ¬èªï¼ˆjaï¼‰
- ç¿»è¨³è¨€èª: en, ru, uz, zh, ko, tr
### URLãƒãƒƒãƒ”ãƒ³ã‚°
æ—¥æœ¬èª: https://example.com/ma-cases/
è‹±èª: https://example.com/en/ma-cases/
ãƒ­ã‚·ã‚¢èª: https://example.com/ru/ma-cases/

## 3.6 ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†
### ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ«: ma_partner
- è‡ªèº«ã®ä½œæˆã—ãŸ ma_case ã®ã¿ç·¨é›†å¯èƒ½
- ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¡ˆä»¶ã¯é–²è¦§ãƒ»ç·¨é›†ä¸å¯

## 3.7 å•ã„åˆã‚ã›æ©Ÿèƒ½
- Contact Form 7
- å¤šè¨€èªå¯¾å¿œãƒ•ã‚©ãƒ¼ãƒ 

## 3.8 SEOå¯¾ç­–ï¼ˆCocoonæ´»ç”¨ï¼‰
- æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿è‡ªå‹•ç”Ÿæˆ
- OGPã‚¿ã‚°è¨­å®š
- ãƒ‘ãƒ³ããšãƒªã‚¹ãƒˆ

## 3.9 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆWordfenceï¼‰
- ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«: enabled
- ã‚¹ã‚­ãƒ£ãƒ³: é€±1å›

## 3.10 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼ˆWP Rocket + Cocoonï¼‰
- ãƒ¢ãƒã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥: æœ‰åŠ¹
- CSS/JSç¸®å°åŒ–: æœ‰åŠ¹

# 4.0 éæ©Ÿèƒ½è¦ä»¶
## 4.1 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
- ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿: 3ç§’ä»¥å†…
- PageSpeed Insights: 80ç‚¹ä»¥ä¸Š
## 4.2 å¯ç”¨æ€§
- ã‚µãƒ¼ãƒãƒ¼ç¨¼åƒç‡: 99.9%ä»¥ä¸Š
## 4.3 Pydanticãƒ¢ãƒ‡ãƒ«ç§»è¡Œè¨ˆç”»

# 5.0 ç”»é¢è¨­è¨ˆ
## 5.1 ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸
## 5.2 M&Aæ¡ˆä»¶ä¸€è¦§
## 5.3 M&Aæ¡ˆä»¶è©³ç´°

# 6.0 ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
## 6.1 ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—å®šç¾©ï¼ˆJSONï¼‰
```json
{
  "ma_case": {
    "labels": {
      "ja": "M&Aæ¡ˆä»¶",
      "en": "M&A Cases"
    },
    "supports": ["title", "editor", "thumbnail"],
    "taxonomies": ["industry_category", "region"],
    "has_archive": true
  }
}
6.2 ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—å®šç¾©ï¼ˆJSONï¼‰
json{
  "ma_case_fields": {
    "title": "M&Aæ¡ˆä»¶åŸºæœ¬æƒ…å ±",
    "fields": [
      {
        "name": "case_id",
        "type": "text",
        "required": true
      }
    ]
  }
}
7.0 å®Ÿè£…è¨ˆç”»
ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬æ§‹ç¯‰ï¼ˆ1-2é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º2: æ©Ÿèƒ½å®Ÿè£…ï¼ˆ2-3é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º3: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç™»éŒ²ï¼ˆ1é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º4: ãƒ†ã‚¹ãƒˆãƒ»èª¿æ•´ï¼ˆ1é€±é–“ï¼‰
ãƒ•ã‚§ãƒ¼ã‚º5: æœ¬ç•ªå…¬é–‹ï¼ˆ1é€±é–“ï¼‰
8.0 é‹ç”¨ä¿å®ˆ
å®šæœŸä½œæ¥­

WordPress/ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ›´æ–°ï¼ˆæœˆ1å›ï¼‰
ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºèªï¼ˆé€±1å›ï¼‰

9.0 ã‚³ã‚¹ãƒˆè¦‹ç©ã‚‚ã‚Š
åˆæœŸè²»ç”¨
æœˆé¡è²»ç”¨
10.0 ãƒªã‚¹ã‚¯ã¨å¯¾ç­–
æŠ€è¡“çš„ãƒªã‚¹ã‚¯
å¯¾ç­–

ã€å‡ºåŠ›è¦ä»¶ã€‘

ã™ã¹ã¦ã®ç« ç«‹ã¦ï¼ˆ1.0ï½10.0ï¼‰ã‚’å®Œå…¨ã«è¨˜è¼‰
JSONã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯å¿…ãšé–‰ã˜ã‚‹ï¼ˆ```ã§çµ‚äº†ï¼‰
å…·ä½“çš„ãªæ•°å€¤ãƒ»åç§°ã‚’è¨˜è¼‰
Cocoonã€Polylangã®æ©Ÿèƒ½ã‚’æ˜è¨˜
15,000æ–‡å­—ä»¥ä¸Šã‚’ç›®æ¨™

ãã‚Œã§ã¯ã€å®Œå…¨ãªè¦ä»¶å®šç¾©æ›¸ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    
    # çµ±è¨ˆæƒ…å ±
    self.stats = {
        'total_attempts': 0,
        'successful': 0,
        'failed': 0
    }
    
    logger.info("âœ… WordPressRequirementsAgent åˆæœŸåŒ–å®Œäº†")
    logger.info(f"ğŸ“ å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€: {self.output_folder}")

async def execute(self, task: Dict) -> Dict:
    """è¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    task_id = task.get('task_id', 'UNKNOWN')
    self.stats['total_attempts'] += 1
    
    try:
        logger.info("\n" + "="*70)
        logger.info("ğŸ“‹ WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆé–‹å§‹")
        logger.info(f"ã‚¿ã‚¹ã‚¯ID: {task_id}")
        logger.info("="*70 + "\n")
        
        # ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ–ãƒ©ã‚¦ã‚¶ç¢ºèª
        if not self._verify_browser():
            return self._create_error_result(task_id, 'ãƒ–ãƒ©ã‚¦ã‚¶ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“')
        
        # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡
        logger.info("ğŸ“¤ ã‚¹ãƒ†ãƒƒãƒ—1: Geminiã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
        if not await self._send_prompt():
            return self._create_error_result(task_id, 'ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å¤±æ•—')
        
        # ã‚¹ãƒ†ãƒƒãƒ—3: å¿œç­”å¾…æ©Ÿ
        logger.info("â±ï¸ ã‚¹ãƒ†ãƒƒãƒ—2: å¿œç­”å¾…æ©Ÿï¼ˆæœ€å¤§300ç§’ï¼‰")
        if not await self._wait_for_response():
            return self._create_error_result(task_id, 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ300ç§’ï¼‰')
        
        # ã‚¹ãƒ†ãƒƒãƒ—4: å¿œç­”å–å¾—
        logger.info("ğŸ“¥ ã‚¹ãƒ†ãƒƒãƒ—3: å¿œç­”å–å¾—")
        response_text = await self._extract_response()
        
        if not response_text:
            return self._create_error_result(task_id, 'å¿œç­”å–å¾—å¤±æ•—')
        
        # ã‚¹ãƒ†ãƒƒãƒ—5: å“è³ªæ¤œè¨¼
        logger.info("ğŸ” ã‚¹ãƒ†ãƒƒãƒ—4: å“è³ªæ¤œè¨¼")
        validation_result = self._validate_response(response_text)
        
        if not validation_result['valid']:
            logger.warning(f"âš ï¸ å“è³ªè­¦å‘Š: {validation_result['warnings']}")
        
        # ã‚¹ãƒ†ãƒƒãƒ—6: ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
        logger.info("ğŸ’¾ ã‚¹ãƒ†ãƒƒãƒ—5: ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜")
        output_files = await self._save_requirements(response_text, task_id)
        
        # ã‚¹ãƒ†ãƒƒãƒ—7: æˆåŠŸçµæœã®ä½œæˆ
        self.stats['successful'] += 1
        
        logger.info("\n" + "="*70)
        logger.info("âœ… WordPressè¦ä»¶å®šç¾©æ›¸ä½œæˆå®Œäº†")
        logger.info(f"ğŸ“„ æ–‡å­—æ•°: {len(response_text):,}æ–‡å­—")
        logger.info(f"ğŸ“ ä¿å­˜ãƒ•ã‚¡ã‚¤ãƒ«: {len(output_files)}ä»¶")
        logger.info("="*70 + "\n")
        
        return {
            'success': True,
            'message': 'è¦ä»¶å®šç¾©æ›¸ä½œæˆå®Œäº†',
            'task_id': task_id,
            'content_length': len(response_text),
            'output_files': [str(f['path']) for f in output_files],
            'validation': validation_result,
            'summary': f'è¦ä»¶å®šç¾©æ›¸ä½œæˆå®Œäº†ï¼ˆ{len(response_text):,}æ–‡å­—ã€{len(output_files)}ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰',
            'full_text': response_text[:1000] + '...' if len(response_text) > 1000 else response_text
        }
        
    except Exception as e:
        self.stats['failed'] += 1
        logger.error(f"âŒ è¦ä»¶å®šç¾©æ›¸ä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return self._create_error_result(task_id, str(e))

def _verify_browser(self) -> bool:
    """ãƒ–ãƒ©ã‚¦ã‚¶ã®çŠ¶æ…‹ã‚’ç¢ºèª"""
    if not self.browser:
        logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
        return False
    
    if not hasattr(self.browser, 'send_prompt'):
        logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ã« send_prompt ãƒ¡ã‚½ãƒƒãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“")
        return False
    
    logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç¢ºèª: OK")
    return True

async def _send_prompt(self) -> bool:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡"""
    try:
        await self.browser.send_prompt(self.PROMPT_TEMPLATE)
        logger.info("âœ… ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡å®Œäº†")
        return True
    except Exception as e:
        logger.error(f"âŒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡ã‚¨ãƒ©ãƒ¼: {e}")
        return False

async def _wait_for_response(self, max_wait: int = 300) -> bool:
    """å¿œç­”ã‚’å¾…æ©Ÿ"""
    try:
        success = await self.browser.wait_for_text_generation(max_wait=max_wait)
        if success:
            logger.info(f"âœ… å¿œç­”å¾…æ©Ÿå®Œäº†ï¼ˆ{max_wait}ç§’ä»¥å†…ï¼‰")
        else:
            logger.error(f"âŒ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
        return success
    except Exception as e:
        logger.error(f"âŒ å¿œç­”å¾…æ©Ÿã‚¨ãƒ©ãƒ¼: {e}")
        return False

async def _extract_response(self) -> Optional[str]:
    """å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º"""
    try:
        response_text = await self.browser.extract_latest_text_response()
        
        if response_text:
            logger.info(f"âœ… å¿œç­”å–å¾—: {len(response_text):,}æ–‡å­—")
        else:
            logger.error("âŒ å¿œç­”ãŒç©ºã§ã™")
        
        return response_text
    except Exception as e:
        logger.error(f"âŒ å¿œç­”æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
        return None

def _validate_response(self, text: str) -> Dict:
    """å¿œç­”ã®å“è³ªã‚’æ¤œè¨¼"""
    warnings = []
    
    # é•·ã•ãƒã‚§ãƒƒã‚¯
    if len(text) < 10000:
        warnings.append(f'æ–‡å­—æ•°ãŒå°‘ãªã„ï¼ˆ{len(text):,}æ–‡å­—ï¼‰')
    
    # ç« ç«‹ã¦ãƒã‚§ãƒƒã‚¯
    required_sections = [
        '1.0 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦',
        '2.0 ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ',
        '3.0 æ©Ÿèƒ½è¦ä»¶',
        '4.0 éæ©Ÿèƒ½è¦ä»¶',
        '5.0 ç”»é¢è¨­è¨ˆ',
        '6.0 ãƒ‡ãƒ¼ã‚¿æ§‹é€ ',
        '7.0 å®Ÿè£…è¨ˆç”»',
        '8.0 é‹ç”¨ä¿å®ˆ',
        '9.0 ã‚³ã‚¹ãƒˆè¦‹ç©ã‚‚ã‚Š',
        '10.0 ãƒªã‚¹ã‚¯ã¨å¯¾ç­–'
    ]
    
    missing_sections = [s for s in required_sections if s not in text]
    if missing_sections:
        warnings.append(f'æ¬ è½ã‚»ã‚¯ã‚·ãƒ§ãƒ³: {", ".join(missing_sections)}')
    
    # JSONãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒƒã‚¯
    json_blocks = re.findall(r'```json', text)
    if len(json_blocks) < 2:
        warnings.append(f'JSONãƒ–ãƒ­ãƒƒã‚¯ãŒå°‘ãªã„ï¼ˆ{len(json_blocks)}å€‹ï¼‰')
    
    # Cocoonã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    if 'Cocoon' not in text and 'cocoon' not in text:
        warnings.append('Cocoonãƒ†ãƒ¼ãƒã®è¨˜è¿°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
    
    # Polylangã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    if 'Polylang' not in text and 'polylang' not in text:
        warnings.append('Polylangãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®è¨˜è¿°ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“')
    
    valid = len(warnings) == 0
    
    if valid:
        logger.info("âœ… å“è³ªæ¤œè¨¼: åˆæ ¼")
    else:
        logger.warning(f"âš ï¸ å“è³ªæ¤œè¨¼: è­¦å‘Šã‚ã‚Šï¼ˆ{len(warnings)}ä»¶ï¼‰")
        for w in warnings:
            logger.warning(f"  - {w}")
    
    return {
        'valid': valid,
        'warnings': warnings,
        'length': len(text),
        'sections_found': len(required_sections) - len(missing_sections),
        'sections_total': len(required_sections)
    }

async def _save_requirements(self, text: str, task_id: str) -> List[Dict]:
    """è¦ä»¶å®šç¾©æ›¸ã‚’ä¿å­˜"""
    output_files = []
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    try:
        # 1. ãƒ¡ã‚¤ãƒ³è¦ä»¶å®šç¾©æ›¸ï¼ˆMarkdownï¼‰
        doc_filename = f"requirements_wordpress_{task_id}_{timestamp}.md"
        doc_path = self.output_folder / doc_filename
        
        with open(doc_path, 'w', encoding='utf-8') as f:
            f.write(f"# WordPressè¦ä»¶å®šç¾©æ›¸ - ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³M&Aãƒãƒ¼ã‚¿ãƒ«\n\n")
            f.write(f"**ä½œæˆæ—¥æ™‚**: {datetime.now().strftime('%Yå¹´%mæœˆ%dæ—¥ %H:%M:%S')}\n")
            f.write(f"**ã‚¿ã‚¹ã‚¯ID**: {task_id}\n")
            f.write(f"**æ–‡å­—æ•°**: {len(text):,}æ–‡å­—\n\n")
            f.write("---\n\n")
            f.write(text)
        
        output_files.append({
            'type': 'è¦ä»¶å®šç¾©æ›¸ï¼ˆMarkdownï¼‰',
            'path': doc_path,
            'size': len(text)
        })
        logger.info(f"âœ… ä¿å­˜: {doc_filename} ({len(text):,}æ–‡å­—)")
        
        # 2. JSONæ§‹é€ ï¼ˆã‚‚ã—æŠ½å‡ºã§ãã‚Œã°ï¼‰
        json_data = self._extract_json_structures(text)
        if json_data:
            json_filename = f"data_structures_{task_id}_{timestamp}.json"
            json_path = self.output_folder / json_filename
            
            with open(json_path, 'w', encoding='utf-8') as f:
                json.dump(json_data, f, ensure_ascii=False, indent=2)
            
            output_files.append({
                'type': 'ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆJSONï¼‰',
                'path': json_path,
                'size': json_path.stat().st_size
            })
            logger.info(f"âœ… ä¿å­˜: {json_filename}")
        
        # 3. å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
        checklist_filename = f"checklist_{task_id}_{timestamp}.md"
        checklist_path = self.output_folder / checklist_filename
        
        checklist_content = self._generate_checklist()
        with open(checklist_path, 'w', encoding='utf-8') as f:
            f.write(checklist_content)
        
        output_files.append({
            'type': 'å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ',
            'path': checklist_path,
            'size': len(checklist_content)
        })
        logger.info(f"âœ… ä¿å­˜: {checklist_filename}")
        
        logger.info(f"âœ… åˆè¨ˆ {len(output_files)} ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜å®Œäº†")
        return output_files
        
    except Exception as e:
        logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
        return output_files

def _extract_json_structures(self, text: str) -> Optional[Dict]:
    """JSONãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º"""
    try:
        json_blocks = re.findall(r'```json\s*(.*?)```', text, re.DOTALL)
        
        if not json_blocks:
            return None
        
        combined_data = {}
        for i, json_str in enumerate(json_blocks, 1):
            try:
                data = json.loads(json_str)
                combined_data[f"block_{i}"] = data
            except json.JSONDecodeError:
                logger.warning(f"âš ï¸ JSONãƒ–ãƒ­ãƒƒã‚¯ {i} ã®ãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—")
                continue
        
        return combined_data if combined_data else None
        
    except Exception as e:
        logger.warning(f"âš ï¸ JSONæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
        return None

def _generate_checklist(self) -> str:
    """å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ"""
    return """# WordPress M&Aãƒãƒ¼ã‚¿ãƒ« å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬æ§‹ç¯‰ âœ…

 WordPress 6.4+ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
 Cocoonãƒ†ãƒ¼ãƒ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»æœ‰åŠ¹åŒ–
 Polylang Pro ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»è¨­å®šï¼ˆ7è¨€èªï¼‰
 å¿…é ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

 Advanced Custom Fields PRO
 Custom Post Type UI
 FacetWP
 Relevanssi
 Wordfence Security
 WP Rocket
 Contact Form 7
 User Role Editor



ãƒ•ã‚§ãƒ¼ã‚º2: ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— ğŸ”§

 M&Aæ¡ˆä»¶ï¼ˆma_caseï¼‰ä½œæˆ

 ãƒ©ãƒ™ãƒ«è¨­å®šï¼ˆ7è¨€èªï¼‰
 ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½è¨­å®š
 ãƒ‘ãƒ¼ãƒãƒªãƒ³ã‚¯è¨­å®š


 ä¼æ¥­æƒ…å ±ï¼ˆcompanyï¼‰ä½œæˆ
 ãƒ‹ãƒ¥ãƒ¼ã‚¹ï¼ˆnewsï¼‰ä½œæˆ

ãƒ•ã‚§ãƒ¼ã‚º3: ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼ ğŸ·ï¸

 æ¥­ç¨®åˆ†é¡ï¼ˆindustry_categoryï¼‰ä½œæˆ - éšå±¤å‹
 åœ°åŸŸï¼ˆregionï¼‰ä½œæˆ - éšå±¤å‹
 æ¡ˆä»¶ã‚¿ã‚¤ãƒ—ï¼ˆdeal_typeï¼‰ä½œæˆ - ééšå±¤å‹
 Polylangç¿»è¨³è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º4: ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ğŸ“

 M&Aæ¡ˆä»¶ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ

 åŸºæœ¬æƒ…å ±ï¼ˆcase_id, ma_scheme, etc.ï¼‰
 è²¡å‹™æƒ…å ±ï¼ˆdesired_price, revenue, etc.ï¼‰
 é€£çµ¡å…ˆæƒ…å ±


 ä¼æ¥­æƒ…å ±ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ä½œæˆ
 Polylangé€£æºè¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º5: æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ ğŸ”

 FacetWPè¨­å®š

 æ¥­ç¨®åˆ¥ãƒ•ã‚¡ã‚»ãƒƒãƒˆ
 åœ°åŸŸåˆ¥ãƒ•ã‚¡ã‚»ãƒƒãƒˆ
 ä¾¡æ ¼å¸¯ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼
 æ¡ˆä»¶ã‚¿ã‚¤ãƒ—ãƒ•ã‚¡ã‚»ãƒƒãƒˆ


 Relevanssiè¨­å®š

 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹ç¯‰
 ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰æ¤œç´¢è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º6: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»æœ€é©åŒ– ğŸ”’

 Wordfence Securityè¨­å®š

 ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«æœ‰åŠ¹åŒ–
 ã‚¹ã‚­ãƒ£ãƒ³ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š


 WP Rocketè¨­å®š

 ãƒ¢ãƒã‚¤ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ‰åŠ¹åŒ–
 CSS/JSç¸®å°åŒ–


 Cocooné«˜é€ŸåŒ–è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º7: ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç† ğŸ‘¥

 ã‚«ã‚¹ã‚¿ãƒ ãƒ­ãƒ¼ãƒ«ï¼ˆma_partnerï¼‰ä½œæˆ
 æ¨©é™è¨­å®š
 ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆãƒ»æ¤œè¨¼

ãƒ•ã‚§ãƒ¼ã‚º8: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç™»éŒ² ğŸ“„

 ã‚µãƒ³ãƒ—ãƒ«M&Aæ¡ˆä»¶ç™»éŒ²ï¼ˆå„è¨€èªï¼‰
 ã‚µãƒ³ãƒ—ãƒ«ä¼æ¥­æƒ…å ±ç™»éŒ²
 å›ºå®šãƒšãƒ¼ã‚¸ä½œæˆ
 ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¨­å®š

ãƒ•ã‚§ãƒ¼ã‚º9: ãƒ†ã‚¹ãƒˆ ğŸ§ª

 å¤šè¨€èªè¡¨ç¤ºç¢ºèª
 æ¤œç´¢æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
 ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
 ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡ãƒ†ã‚¹ãƒˆ
 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³

ãƒ•ã‚§ãƒ¼ã‚º10: æœ¬ç•ªå…¬é–‹ ğŸš€

 DNSè¨­å®š
 SSLè¨¼æ˜æ›¸è¨­å®š
 æœ¬ç•ªç’°å¢ƒç§»è¡Œ
 æœ€çµ‚ç¢ºèª


ä½œæˆæ—¥: {datetime}
ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.0
""".format(datetime=datetime.now().strftime('%Y-%m-%d %H:%M'))
def _create_error_result(self, task_id: str, error: str) -> Dict:
    """ã‚¨ãƒ©ãƒ¼çµæœã‚’ä½œæˆ"""
    logger.error(f"âŒ ã‚¨ãƒ©ãƒ¼: {error}")
    
    return {
        'success': False,
        'error': error,
        'task_id': task_id,
        'stats': self.stats.copy()
    }

def get_stats(self) -> Dict:
    """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
    return self.stats.copy()



### 3. `wordpress/wp_dev/wp_cpt_agent.py`ï¼ˆå®Œå…¨ç‰ˆï¼‰

"""
WordPressã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰
"""

import asyncio
import logging
from typing import Dict
from pathlib import Path
from datetime import datetime

logger = logging.getLogger(__name__)


class WordPressCPTAgent:
    """CPTä½œæˆå°‚é–€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆå®Œå…¨ç‰ˆï¼‰"""
    
    PROMPT_TEMPLATE = """ã‚ãªãŸã¯WordPressé–‹ç™ºã®å°‚é–€å®¶ã§ã™ã€‚

ã€ã‚¿ã‚¹ã‚¯ã€‘
ä»¥ä¸‹ã®ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆã™ã‚‹PHPã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ï¼š

**æŠ•ç¨¿ã‚¿ã‚¤ãƒ—æƒ…å ±**:
- ã‚¹ãƒ©ãƒƒã‚°: {cpt_slug}
- è¡¨ç¤ºåï¼ˆå˜æ•°ï¼‰: {cpt_singular}
- è¡¨ç¤ºåï¼ˆè¤‡æ•°ï¼‰: {cpt_plural}
- ã‚µãƒãƒ¼ãƒˆæ©Ÿèƒ½: {supports}
- ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼: {taxonomies}

ã€è¦ä»¶ã€‘
1. `register_post_type()` ã‚’ä½¿ç”¨ã—ãŸå®Œå…¨ãªPHPã‚³ãƒ¼ãƒ‰
2. Polylangå¤šè¨€èªå¯¾å¿œ
3. REST APIå¯¾å¿œï¼ˆshow_in_rest: trueï¼‰
4. has_archive: true
5. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ã
6. è©³ç´°ãªã‚³ãƒ¡ãƒ³ãƒˆä»˜ã

ã€å‡ºåŠ›å½¢å¼ã€‘
```php
<?php
/**
 * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_name}
 * ä½œæˆæ—¥: {date}
 * Polylangå¯¾å¿œ
 */

function register_cpt_{cpt_slug_clean}() {{
    $labels = array(
        'name' => __( '{cpt_plural}', 'textdomain' ),
        'singular_name' => __( '{cpt_singular}', 'textdomain' ),
        // ... ãã®ä»–ã®ãƒ©ãƒ™ãƒ«
    );
    
    $args = array(
        'labels' => $labels,
        'public' => true,
        'has_archive' => true,
        'show_in_rest' => true,
        'supports' => {supports_array},
        'taxonomies' => {taxonomies_array},
        // ... ãã®ä»–ã®è¨­å®š
    );
    
    register_post_type( '{cpt_slug}', $args );
}}
add_action( 'init', 'register_cpt_{cpt_slug_clean}', 0 );
?>
å®Œå…¨ã«å‹•ä½œã™ã‚‹PHPã‚³ãƒ¼ãƒ‰ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚
"""
def __init__(self, browser, output_folder: Path):
    self.browser = browser
    self.output_folder = output_folder
    self.output_folder.mkdir(parents=True, exist_ok=True)
    logger.info("âœ… WordPressCPTAgent åˆæœŸåŒ–")

async def execute(self, task: Dict) -> Dict:
    """CPTä½œæˆã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ"""
    task_id = task.get('task_id', 'UNKNOWN')
    description = task.get('description', '')
    
    try:
        logger.info("=" * 70)
        logger.info("ğŸ”§ ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ä½œæˆé–‹å§‹")
        logger.info("=" * 70)
        
        # CPTä»•æ§˜ã‚’æŠ½å‡º
        cpt_spec = self._extract_cpt_spec(description)
        logger.info(f"ğŸ“Š CPTä»•æ§˜: {cpt_spec['slug']}")
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ§‹ç¯‰
        prompt = self._build_prompt(cpt_spec)
        
        # Geminiã«é€ä¿¡
        await self.browser.send_prompt(prompt)
        
        # å¿œç­”å¾…æ©Ÿ
        success = await self.browser.wait_for_text_generation(max_wait=180)
        
        if not success:
            return {'success': False, 'error': 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ', 'task_id': task_id}
        
        # å¿œç­”å–å¾—
        response_text = await self.browser.extract_latest_text_response()
        
        if not response_text:
            return {'success': False, 'error': 'å¿œç­”å–å¾—å¤±æ•—', 'task_id': task_id}
        
        # PHPä¿å­˜
        output_file = await self._save_php_code(response_text, cpt_spec, task_id)
        
        logger.info("=" * 70)
        logger.info("âœ… CPTä½œæˆå®Œäº†")
        logger.info("=" * 70)
        
        return {
            'success': True,
            'message': f'CPTä½œæˆå®Œäº†: {cpt_spec["slug"]}',
            'output_file': str(output_file),
            'cpt_slug': cpt_spec['slug'],
            'task_id': task_id,
            'summary': f'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ— {cpt_spec["slug"]} ä½œæˆå®Œäº†'
        }
        
    except Exception as e:
        logger.error(f"âŒ CPTä½œæˆã‚¨ãƒ©ãƒ¼: {e}")
        return {'success': False, 'error': str(e), 'task_id': task_id}

def _extract_cpt_spec(self, description: str) -> Dict:
    """èª¬æ˜ã‹ã‚‰CPTä»•æ§˜ã‚’æŠ½å‡º"""
    desc_lower = description.lower()
    
    # M&Aæ¡ˆä»¶
    if 'ma_case' in desc_lower or 'm&aæ¡ˆä»¶' in desc_lower:
        return {
            'slug': 'ma_case',
            'singular': 'M&Aæ¡ˆä»¶',
            'plural': 'M&Aæ¡ˆä»¶ä¸€è¦§',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields', 'excerpt'],
            'taxonomies': ['industry_category', 'region', 'deal_type']
        }
    
    # ä¼æ¥­æƒ…å ±
    elif 'company' in desc_lower or 'ä¼æ¥­æƒ…å ±' in desc_lower:
        return {
            'slug': 'company',
            'singular': 'ä¼æ¥­æƒ…å ±',
            'plural': 'ä¼æ¥­æƒ…å ±ä¸€è¦§',
            'supports': ['title', 'editor', 'thumbnail', 'custom-fields'],
            'taxonomies': ['industry_category', 'region']
        }
    
    # ãƒ‹ãƒ¥ãƒ¼ã‚¹
    elif 'news' in desc_lower or 'ãƒ‹ãƒ¥ãƒ¼ã‚¹' in desc_lower:
        return {
            'slug': 'news',
            'singular': 'ãƒ‹ãƒ¥ãƒ¼ã‚¹',
            'plural': 'ãƒ‹ãƒ¥ãƒ¼ã‚¹ä¸€è¦§',
            'supports': ['title', 'editor', 'thumbnail', 'excerpt'],
            'taxonomies': []
        }
    
    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    return {
        'slug': 'custom_post',
        'singular': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿',
        'plural': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ä¸€è¦§',
        'supports': ['title', 'editor', 'thumbnail'],
        'taxonomies': []
    }

def _build_prompt(self, cpt_spec: Dict) -> str:
    """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰"""
    slug_clean = cpt_spec['slug'].replace('-', '_')
    
    return self.PROMPT_TEMPLATE.format(
        cpt_slug=cpt_spec['slug'],
        cpt_singular=cpt_spec['singular'],
        cpt_plural=cpt_spec['plural'],
        cpt_name=cpt_spec['singular'],
        cpt_slug_clean=slug_clean,
        supports=', '.join(cpt_spec['supports']),
        taxonomies=', '.join(cpt_spec['taxonomies']) if cpt_spec['taxonomies'] else 'ãªã—',
        supports_array=str(cpt_spec['supports']).replace("'", '"'),
        taxonomies_array=str(cpt_spec['taxonomies']).replace("'", '"'),
        date=datetime.now().strftime('%Y-%m-%d')
    )

async def _save_php_code(self, code: str, cpt_spec: Dict, task_id: str) -> Path:
    """PHPã‚³ãƒ¼ãƒ‰ã‚’ä¿å­˜"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    filename = f"cpt_{cpt_spec['slug']}_{task_id}_{timestamp}.php"
    output_path = self.output_folder / filename
    
    with open(output_path, 'w', encoding='utf-8') as f:
        # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ 
        f.write(f"<?php\n")
        f.write(f"/**\n")
        f.write(f" * ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—: {cpt_spec['singular']}\n")
        f.write(f" * ã‚¹ãƒ©ãƒƒã‚°: {cpt_spec['slug']}\n")
        f.write(f" * ä½œæˆæ—¥: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f" */\n\n")
        
        # ã‚³ãƒ¼ãƒ‰æœ¬ä½“
        if '<?php' in code:
            # æ—¢ã«PHPã‚¿ã‚°ãŒã‚ã‚‹å ´åˆã¯ãã®ã¾ã¾
            f.write(code)
        else:
            # PHPã‚¿ã‚°ãŒãªã„å ´åˆã¯è¿½åŠ 
            f.write(code)
    
    logger.info(f"âœ… PHPä¿å­˜: {filename}")
    return output_path



#wp_settings_manager.py
"""WordPressè¨­å®šç®¡ç†"""
import logging
from datetime import datetime
from typing import Dict
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressSettingsManager:
    """WordPressè¨­å®šç®¡ç†æ©Ÿèƒ½"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
    
    async def change_settings(self, page: Page, task: Dict) -> Dict:
        """WordPressè¨­å®šã‚’å¤‰æ›´"""
        try:
            logger.info("è¨­å®šå¤‰æ›´ã‚’å®Ÿè¡Œä¸­...")
            
            # è¨­å®šãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/options-general.php")
            await page.wait_for_timeout(2000)
            
            # ç¾åœ¨ã®è¨­å®šã‚’ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            screenshot_path = f"wp_settings_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("âœ… è¨­å®šç”»é¢ã‚’ç¢ºèªã—ã¾ã—ãŸ")
            logger.info("âš ï¸ å®Ÿéš›ã®è¨­å®šå¤‰æ›´ã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': 'è¨­å®šç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚å¤‰æ›´å†…å®¹ã‚’ç¢ºèªã—ã¦æ‰‹å‹•ã§é©ç”¨ã—ã¦ãã ã•ã„ã€‚',
                'screenshot': screenshot_path,
                'full_text': f'è¨­å®šç¢ºèªå®Œäº†\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"è¨­å®šå¤‰æ›´ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def change_theme(self, page: Page, task: Dict) -> Dict:
        """ãƒ†ãƒ¼ãƒã‚’å¤‰æ›´"""
        try:
            logger.info("ãƒ†ãƒ¼ãƒå¤‰æ›´ã‚’å®Ÿè¡Œä¸­...")
            
            # ãƒ†ãƒ¼ãƒãƒšãƒ¼ã‚¸ã«ç§»å‹•
            await page.goto(f"{self.wp_url}/wp-admin/themes.php")
            await page.wait_for_timeout(3000)
            
            # ç¾åœ¨ã®ãƒ†ãƒ¼ãƒã‚’ç¢ºèª
            screenshot_path = f"wp_themes_before_{datetime.now().strftime('%H%M%S')}.png"
            await page.screenshot(path=screenshot_path)
            
            logger.info("âœ… ãƒ†ãƒ¼ãƒç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸ")
            logger.info("âš ï¸ å®Ÿéš›ã®ãƒ†ãƒ¼ãƒå¤‰æ›´ã¯æ‰‹å‹•ã§ç¢ºèªã—ã¦ãã ã•ã„")
            
            return {
                'success': True,
                'summary': 'ãƒ†ãƒ¼ãƒç”»é¢ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚å¤‰æ›´å†…å®¹ã‚’ç¢ºèªã—ã¦æ‰‹å‹•ã§é©ç”¨ã—ã¦ãã ã•ã„ã€‚',
                'screenshot': screenshot_path,
                'full_text': f'ãƒ†ãƒ¼ãƒç¢ºèªå®Œäº†\nã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {screenshot_path}'
            }
            
        except Exception as e:
            logger.error(f"ãƒ†ãƒ¼ãƒå¤‰æ›´ã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }

#wp_tester.py
"""WordPressãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ï¼ˆå“è³ªç®¡ç†å¼·åŒ–ç‰ˆï¼‰"""
import logging
import re
from datetime import datetime
from typing import Dict, List, Tuple
from playwright.async_api import Page

logger = logging.getLogger(__name__)


class WordPressTester:
    """WordPressãƒ†ã‚¹ãƒˆæ©Ÿèƒ½ï¼ˆå“è³ªç®¡ç†å¼·åŒ–ç‰ˆï¼‰"""
    
    def __init__(self, wp_url: str):
        self.wp_url = wp_url
        self.test_frameworks = {
            'php': ['PHPUnit', 'Codeception', 'WP_UnitTestCase'],
            'javascript': ['Jest', 'Mocha', 'Chai', 'Cypress'],
            'wordpress': ['WP_UnitTestCase', 'WordPress PHPUnit']
        }
    
    async def test_functionality(self, page: Page, task: Dict) -> Dict:
        """æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆï¼ˆå“è³ªæ¤œè¨¼å¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info("ğŸ” æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œä¸­ï¼ˆå“è³ªæ¤œè¨¼ä»˜ãï¼‰...")
            
            test_results = []
            quality_issues = []
            
            # 1. ã‚µã‚¤ãƒˆã®è¡¨ç¤ºãƒ†ã‚¹ãƒˆ
            site_test_result = await self._test_site_accessibility(page)
            test_results.extend(site_test_result['results'])
            quality_issues.extend(site_test_result['quality_issues'])
            
            # 2. ç®¡ç†ç”»é¢ãƒ†ã‚¹ãƒˆ
            admin_test_result = await self._test_admin_access(page)
            test_results.extend(admin_test_result['results'])
            quality_issues.extend(admin_test_result['quality_issues'])
            
            # 3. ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
            plugin_test_result = await self._test_plugins_status(page)
            test_results.extend(plugin_test_result['results'])
            quality_issues.extend(plugin_test_result['quality_issues'])
            
            # 4. ã‚³ãƒ¼ãƒ‰å“è³ªæ¤œè¨¼ï¼ˆã‚¿ã‚¹ã‚¯ã«ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã‚‹å ´åˆï¼‰
            if self._has_test_code(task):
                code_quality_result = await self._validate_test_code_quality(task)
                test_results.extend(code_quality_result['results'])
                quality_issues.extend(code_quality_result['quality_issues'])
            
            # ãƒ†ã‚¹ãƒˆçµæœã®é›†è¨ˆ
            summary = self._generate_test_summary(test_results, quality_issues)
            
            logger.info("\n" + "="*60)
            logger.info("ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼")
            logger.info("="*60)
            logger.info(summary)
            
            return {
                'success': len(quality_issues) == 0,
                'summary': summary[:500],
                'full_text': summary,
                'quality_issues': quality_issues,
                'test_results': test_results
            }
            
        except Exception as e:
            logger.error(f"âŒ æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def _test_site_accessibility(self, page: Page) -> Dict:
        """ã‚µã‚¤ãƒˆã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"""
        results = []
        quality_issues = []
        
        try:
            # ã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹
            await page.goto(self.wp_url, wait_until='networkidle')
            await page.wait_for_timeout(3000)
            
            # ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«å–å¾—
            page_title = await page.title()
            results.append(f"âœ… ã‚µã‚¤ãƒˆè¡¨ç¤ºOK: {page_title}")
            
            # HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯
            response = await page.goto(self.wp_url)
            if response and response.status == 200:
                results.append("âœ… HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: 200 OK")
            else:
                quality_issues.append("âŒ HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒ200ã§ã¯ã‚ã‚Šã¾ã›ã‚“")
                results.append("âŒ HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚¨ãƒ©ãƒ¼")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            timestamp = datetime.now().strftime('%H%M%S')
            site_screenshot = f"wp_site_{timestamp}.png"
            await page.screenshot(path=site_screenshot, full_page=True)
            results.append(f"ğŸ“¸ ã‚µã‚¤ãƒˆå…¨ä½“: {site_screenshot}")
            
            # ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿é€Ÿåº¦ãƒã‚§ãƒƒã‚¯
            load_time = await self._measure_page_load_time(page, self.wp_url)
            if load_time < 5000:  # 5ç§’ä»¥å†…
                results.append(f"âœ… ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿é€Ÿåº¦: {load_time}ms")
            else:
                quality_issues.append(f"âš ï¸ ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿ãŒé…ã„: {load_time}ms")
                results.append(f"âš ï¸ ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿é€Ÿåº¦: {load_time}ms")
            
        except Exception as e:
            quality_issues.append(f"âŒ ã‚µã‚¤ãƒˆã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
            results.append(f"âŒ ã‚µã‚¤ãƒˆã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_admin_access(self, page: Page) -> Dict:
        """ç®¡ç†ç”»é¢ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆ"""
        results = []
        quality_issues = []
        
        try:
            # ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹
            admin_url = f"{self.wp_url}/wp-admin/"
            await page.goto(admin_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ã®å­˜åœ¨ç¢ºèª
            login_form = await page.query_selector('#loginform')
            if login_form:
                results.append("âœ… ç®¡ç†ç”»é¢ãƒ­ã‚°ã‚¤ãƒ³ãƒ•ã‚©ãƒ¼ãƒ ç¢ºèª")
            else:
                # æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
                admin_bar = await page.query_selector('#wpadminbar')
                if admin_bar:
                    results.append("âœ… ç®¡ç†ç”»é¢: æ—¢ã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿")
                else:
                    quality_issues.append("âŒ ç®¡ç†ç”»é¢ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“")
                    results.append("âŒ ç®¡ç†ç”»é¢ã‚¢ã‚¯ã‚»ã‚¹å¤±æ•—")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            timestamp = datetime.now().strftime('%H%M%S')
            admin_screenshot = f"wp_admin_{timestamp}.png"
            await page.screenshot(path=admin_screenshot)
            results.append(f"ğŸ“¸ ç®¡ç†ç”»é¢: {admin_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"âŒ ç®¡ç†ç”»é¢ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
            results.append(f"âŒ ç®¡ç†ç”»é¢ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _test_plugins_status(self, page: Page) -> Dict:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ†ã‚¹ãƒˆ"""
        results = []
        quality_issues = []
        
        try:
            # ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ãªå ´åˆï¼‰
            plugins_url = f"{self.wp_url}/wp-admin/plugins.php"
            await page.goto(plugins_url, wait_until='networkidle')
            await page.wait_for_timeout(2000)
            
            # ãƒšãƒ¼ã‚¸ã‚¿ã‚¤ãƒˆãƒ«ã§ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‹ç¢ºèª
            page_title = await page.title()
            if 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³' in page_title or 'Plugins' in page_title:
                results.append("âœ… ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€è¦§ãƒšãƒ¼ã‚¸ç¢ºèª")
                
                # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ•°ã‚’ãƒã‚§ãƒƒã‚¯
                active_plugins = await page.query_selector_all('.plugins .active')
                if len(active_plugins) > 0:
                    results.append(f"âœ… ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {len(active_plugins)}å€‹")
                else:
                    quality_issues.append("âš ï¸ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“")
                    results.append("âš ï¸ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: 0å€‹")
            else:
                quality_issues.append("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“")
                results.append("âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‚¢ã‚¯ã‚»ã‚¹å¤±æ•—")
            
            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            timestamp = datetime.now().strftime('%H%M%S')
            plugins_screenshot = f"wp_plugins_{timestamp}.png"
            await page.screenshot(path=plugins_screenshot)
            results.append(f"ğŸ“¸ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {plugins_screenshot}")
            
        except Exception as e:
            quality_issues.append(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
            results.append(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆå¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    async def _validate_test_code_quality(self, task: Dict) -> Dict:
        """ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å“è³ªæ¤œè¨¼"""
        results = []
        quality_issues = []
        
        try:
            # ã‚¿ã‚¹ã‚¯ã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º
            test_code = self._extract_test_code(task)
            
            if not test_code:
                results.append("â„¹ï¸ æ¤œè¨¼å¯¾è±¡ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãªã—")
                return {'results': results, 'quality_issues': quality_issues}
            
            # è¨€èªåˆ¥ã®å“è³ªæ¤œè¨¼
            if self._is_php_code(test_code):
                php_validation = self._validate_php_test_code(test_code)
                results.extend(php_validation['results'])
                quality_issues.extend(php_validation['quality_issues'])
            
            elif self._is_javascript_code(test_code):
                js_validation = self._validate_javascript_test_code(test_code)
                results.extend(js_validation['results'])
                quality_issues.extend(js_validation['quality_issues'])
            
            else:
                # ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ¤œè¨¼
                general_validation = self._validate_general_test_code(test_code)
                results.extend(general_validation['results'])
                quality_issues.extend(general_validation['quality_issues'])
            
        except Exception as e:
            quality_issues.append(f"âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {str(e)}")
            results.append(f"âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰æ¤œè¨¼å¤±æ•—: {str(e)}")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_php_test_code(self, code: str) -> Dict:
        """PHPãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼"""
        results = []
        quality_issues = []
        
        # PHPUnitã®åŸºæœ¬æ§‹é€ ãƒã‚§ãƒƒã‚¯
        if 'class' not in code and 'function' not in code:
            quality_issues.append("âŒ PHPãƒ†ã‚¹ãƒˆ: ã‚¯ãƒ©ã‚¹ã¾ãŸã¯é–¢æ•°ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            results.append("âŒ PHPãƒ†ã‚¹ãƒˆæ§‹é€ : ä¸å®Œå…¨")
        
        # ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        test_method_patterns = [
            r'function\s+test\w+',
            r'public\s+function\s+test\w+',
            r'public\s+function\s+test_\w+'
        ]
        
        has_test_methods = any(re.search(pattern, code) for pattern in test_method_patterns)
        if not has_test_methods:
            quality_issues.append("âŒ PHPãƒ†ã‚¹ãƒˆ: ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            results.append("âŒ PHPãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰: æœªå®šç¾©")
        else:
            results.append("âœ… PHPãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰: å®šç¾©æ¸ˆã¿")
        
        # ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        assertion_patterns = [
            r'\$this->assert',
            r'assertEquals',
            r'assertTrue',
            r'assertFalse',
            r'expectException'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("âŒ PHPãƒ†ã‚¹ãƒˆ: ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“")
            results.append("âŒ PHPãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: æœªå®šç¾©")
        else:
            results.append("âœ… PHPãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: å®šç¾©æ¸ˆã¿")
        
        # PHPUnitã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
        if 'PHPUnit' in code or 'use PHPUnit' in code:
            results.append("âœ… PHPUnitãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æ¤œå‡º")
        else:
            quality_issues.append("âš ï¸ PHPãƒ†ã‚¹ãƒˆ: PHPUnitãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒæ˜ç¤ºã•ã‚Œã¦ã„ã¾ã›ã‚“")
            results.append("âš ï¸ PHPUnitãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æœªæ¤œå‡º")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_javascript_test_code(self, code: str) -> Dict:
        """JavaScriptãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼"""
        results = []
        quality_issues = []
        
        # ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã®ãƒã‚§ãƒƒã‚¯
        frameworks = ['describe', 'it', 'test', 'expect']
        has_framework = any(framework in code for framework in frameworks)
        
        if not has_framework:
            quality_issues.append("âŒ JSãƒ†ã‚¹ãƒˆ: ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“")
            results.append("âŒ JSãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æœªæ¤œå‡º")
        else:
            results.append("âœ… JSãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: æ¤œå‡º")
        
        # ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
        assertion_patterns = [
            'expect',
            'assert',
            'should',
            'toBe',
            'toEqual'
        ]
        
        has_assertions = any(pattern in code for pattern in assertion_patterns)
        if not has_assertions:
            quality_issues.append("âŒ JSãƒ†ã‚¹ãƒˆ: ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“")
            results.append("âŒ JSãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: æœªå®šç¾©")
        else:
            results.append("âœ… JSãƒ†ã‚¹ãƒˆã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³: å®šç¾©æ¸ˆã¿")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _validate_general_test_code(self, code: str) -> Dict:
        """ä¸€èˆ¬çš„ãªãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®æ¤œè¨¼"""
        results = []
        quality_issues = []
        
        # ãƒ†ã‚¹ãƒˆé–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®ãƒã‚§ãƒƒã‚¯
        test_keywords = [
            'test', 'assert', 'expect', 'verify',
            'should', 'check', 'validate'
        ]
        
        has_test_keywords = any(keyword in code.lower() for keyword in test_keywords)
        if not has_test_keywords:
            quality_issues.append("âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰: ãƒ†ã‚¹ãƒˆé–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
            results.append("âŒ ãƒ†ã‚¹ãƒˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: ä¸è¶³")
        else:
            results.append("âœ… ãƒ†ã‚¹ãƒˆã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰: æ¤œå‡º")
        
        # å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã®ã¿ã§ãªã„ã‹ï¼‰
        lines = code.split('\n')
        code_lines = [line for line in lines if line.strip() and not line.strip().startswith(('//', '#'))]
        
        if len(code_lines) < 3:
            quality_issues.append("âŒ ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰: å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒ¼ãƒ‰ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
            results.append("âŒ å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰: ä¸è¶³")
        else:
            results.append("âœ… å®Ÿè¡Œå¯èƒ½ã‚³ãƒ¼ãƒ‰: ååˆ†")
        
        return {'results': results, 'quality_issues': quality_issues}
    
    def _has_test_code(self, task: Dict) -> bool:
        """ã‚¿ã‚¹ã‚¯ã«ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        description = task.get('description', '').lower()
        if any(keyword in description for keyword in ['test', 'ãƒ†ã‚¹ãƒˆ', 'testing']):
            return True
        
        # å‡ºåŠ›ã‚„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ¢ã™
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        test_indicators = ['function test', 'class Test', '@Test', 'describe(', 'it(']
        combined_text = f"{output} {parameters}".lower()
        
        return any(indicator in combined_text for indicator in test_indicators)
    
    def _extract_test_code(self, task: Dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã‹ã‚‰ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º"""
        # å‡ºåŠ›ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
        output = task.get('output', '')
        parameters = task.get('parameters', '')
        
        # ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ¤œç´¢
        code_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', output, re.DOTALL)
        if code_blocks:
            return '\n'.join(code_blocks)
        
        # ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã‚³ãƒ¼ãƒ‰ã‚’æŠ½å‡º
        if '```' in parameters:
            param_blocks = re.findall(r'```(?:\w+)?\n(.*?)```', parameters, re.DOTALL)
            if param_blocks:
                return '\n'.join(param_blocks)
        
        return output  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    
    def _is_php_code(self, code: str) -> bool:
        """PHPã‚³ãƒ¼ãƒ‰ã‹åˆ¤å®š"""
        php_indicators = ['<?php', 'function', 'class', '$this', '->']
        return any(indicator in code for indicator in php_indicators)
    
    def _is_javascript_code(self, code: str) -> bool:
        """JavaScriptã‚³ãƒ¼ãƒ‰ã‹åˆ¤å®š"""
        js_indicators = ['function', 'const', 'let', 'var', '=>', 'describe', 'it']
        return any(indicator in code for indicator in js_indicators)
    
    async def _measure_page_load_time(self, page: Page, url: str) -> float:
        """ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚é–“ã‚’è¨ˆæ¸¬"""
        try:
            start_time = datetime.now()
            await page.goto(url, wait_until='networkidle')
            end_time = datetime.now()
            return (end_time - start_time).total_seconds() * 1000  # ãƒŸãƒªç§’
        except:
            return 0
    
    def _generate_test_summary(self, test_results: List[str], quality_issues: List[str]) -> str:
        """ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼ã‚’ç”Ÿæˆ"""
        summary = []
        
        summary.append("ğŸ“Š ãƒ†ã‚¹ãƒˆçµæœã‚µãƒãƒªãƒ¼")
        summary.append("=" * 50)
        
        # ãƒ†ã‚¹ãƒˆçµæœ
        summary.append("\nâœ… æˆåŠŸãƒ†ã‚¹ãƒˆ:")
        success_tests = [r for r in test_results if 'âœ…' in r or 'OK' in r]
        for test in success_tests:
            summary.append(f"  â€¢ {test}")
        
        # å“è³ªå•é¡Œ
        if quality_issues:
            summary.append("\nâŒ å“è³ªå•é¡Œ:")
            for issue in quality_issues:
                summary.append(f"  â€¢ {issue}")
        else:
            summary.append("\nğŸ‰ å“è³ªå•é¡Œ: ãªã—")
        
        # çµ±è¨ˆ
        total_tests = len(test_results)
        success_count = len(success_tests)
        issue_count = len(quality_issues)
        
        summary.append("\nğŸ“ˆ çµ±è¨ˆ:")
        summary.append(f"  ç·ãƒ†ã‚¹ãƒˆæ•°: {total_tests}")
        summary.append(f"  æˆåŠŸãƒ†ã‚¹ãƒˆ: {success_count}")
        summary.append(f"  å“è³ªå•é¡Œ: {issue_count}")
        
        if total_tests > 0:
            success_rate = (success_count / total_tests) * 100
            summary.append(f"  æˆåŠŸç‡: {success_rate:.1f}%")
        
        return '\n'.join(summary)

#wp_tester_agent.py
# wp_tester_agent.py
"""
WordPressè‡ªå‹•ãƒ†ã‚¹ãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
WP-CLIã¨Pytestã‚’ä½¿ç”¨ã—ãŸè‡ªå‹•ãƒ†ã‚¹ãƒˆ
"""

import asyncio
import logging
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from pathlib import Path

logger = logging.getLogger(__name__)


class WPTesterAgent:
    """
    WordPressè‡ªå‹•ãƒ†ã‚¹ãƒˆã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    æ©Ÿèƒ½:
    - WP-CLIã‚³ãƒãƒ³ãƒ‰ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    - Pytestãƒ™ãƒ¼ã‚¹ã®ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
    - çµ±åˆãƒ†ã‚¹ãƒˆ
    - ãƒ†ã‚¹ãƒˆçµæœã®æ¤œè¨¼ã¨å ±å‘Š
    """
    
    def __init__(
        self,
        command_monitor,
        wp_path: str = "/var/www/html"
    ):
        """
        åˆæœŸåŒ–
        
        Args:
            command_monitor: CommandMonitorAgent
            wp_path: WordPressã®ãƒ‘ã‚¹
        """
        self.cmd_monitor = command_monitor
        self.wp_path = Path(wp_path)
        
        # ãƒ†ã‚¹ãƒˆçµæœä¿å­˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        self.test_results_dir = Path("./test_results")
        self.test_results_dir.mkdir(parents=True, exist_ok=True)
        
        # çµ±è¨ˆæƒ…å ±
        self.stats = {
            "total_tests": 0,
            "passed_tests": 0,
            "failed_tests": 0,
            "skipped_tests": 0
        }
        
        logger.info(f"âœ… WPTesterAgent åˆæœŸåŒ–å®Œäº† (WP_PATH={wp_path})")
    
    async def run_tests(self, task_id: str, test_type: str = "auto") -> Dict[str, Any]:
        """
        ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
        
        Args:
            task_id: ã‚¿ã‚¹ã‚¯ID
            test_type: ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ— (auto, unit, integration, wp-cli)
            
        Returns:
            Dict: ãƒ†ã‚¹ãƒˆçµæœ
        """
        start_time = datetime.now()
        
        try:
            logger.info("=" * 60)
            logger.info(f"ğŸ§ª ãƒ†ã‚¹ãƒˆå®Ÿè¡Œé–‹å§‹: {task_id} (ã‚¿ã‚¤ãƒ—={test_type})")
            logger.info("=" * 60)
            
            self.stats["total_tests"] += 1
            
            if test_type == "auto":
                # ã‚¿ã‚¹ã‚¯IDã‹ã‚‰é©åˆ‡ãªãƒ†ã‚¹ãƒˆã‚’è‡ªå‹•é¸æŠ
                result = await self._run_auto_tests(task_id)
            elif test_type == "unit":
                result = await self._run_unit_tests(task_id)
            elif test_type == "integration":
                result = await self._run_integration_tests(task_id)
            elif test_type == "wp-cli":
                result = await self._run_wp_cli_tests(task_id)
            else:
                result = {
                    "passed": False,
                    "error": f"Unknown test type: {test_type}"
                }
            
            # çµ±è¨ˆæ›´æ–°
            if result.get("passed"):
                self.stats["passed_tests"] += 1
            else:
                self.stats["failed_tests"] += 1
            
            execution_time = (datetime.now() - start_time).total_seconds()
            result["execution_time"] = execution_time
            
            # çµæœã‚’ä¿å­˜
            await self._save_test_result(task_id, result)
            
            logger.info(
                f"{'âœ…' if result.get('passed') else 'âŒ'} "
                f"ãƒ†ã‚¹ãƒˆ{'æˆåŠŸ' if result.get('passed') else 'å¤±æ•—'}: {task_id} "
                f"({execution_time:.2f}ç§’)"
            )
            
            return result
            
        except Exception as e:
            logger.error(f"ğŸ’¥ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
            self.stats["failed_tests"] += 1
            
            return {
                "passed": False,
                "error": str(e),
                "execution_time": (datetime.now() - start_time).total_seconds()
            }
    
    async def _run_auto_tests(self, task_id: str) -> Dict[str, Any]:
        """ã‚¿ã‚¹ã‚¯ã«å¿œã˜ãŸè‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ"""
        
        # ã‚¿ã‚¹ã‚¯IDã‹ã‚‰ç¨®é¡ã‚’åˆ¤å®š
        if "CPT" in task_id or "ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—" in task_id:
            return await self._test_custom_post_type(task_id)
        
        elif "ACF" in task_id or "ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰" in task_id:
            return await self._test_acf_fields(task_id)
        
        elif "æŠ•ç¨¿" in task_id or "post" in task_id.lower():
            return await self._test_post_creation(task_id)
        
        elif "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³" in task_id or "plugin" in task_id.lower():
            return await self._test_plugin_activation(task_id)
        
        else:
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: åŸºæœ¬çš„ãªWPãƒã‚§ãƒƒã‚¯
            return await self._test_wp_health()
    
    async def _run_unit_tests(self, task_id: str) -> Dict[str, Any]:
        """ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ"""
        try:
            # Pytestå®Ÿè¡Œ
            cmd = f"pytest tests/unit/ -v --tb=short --json-report --json-report-file={self.test_results_dir / f'{task_id}_unit.json'}"
            
            result = await self.cmd_monitor.execute_command(cmd)
            
            if result.get("success"):
                # JSONãƒ¬ãƒãƒ¼ãƒˆã‚’èª­ã¿è¾¼ã¿
                report_file = self.test_results_dir / f"{task_id}_unit.json"
                if report_file.exists():
                    report = json.loads(report_file.read_text())
                    
                    return {
                        "passed": report.get("summary", {}).get("failed", 0) == 0,
                        "total": report.get("summary", {}).get("total", 0),
                        "passed_count": report.get("summary", {}).get("passed", 0),
                        "failed_count": report.get("summary", {}).get("failed", 0),
                        "report": report
                    }
            
            return {
                "passed": False,
                "error": result.get("stderr", "Unit test execution failed")
            }
            
        except Exception as e:
            logger.error(f"âŒ ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _run_integration_tests(self, task_id: str) -> Dict[str, Any]:
        """çµ±åˆãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ"""
        try:
            cmd = f"pytest tests/integration/ -v --tb=short"
            result = await self.cmd_monitor.execute_command(cmd)
            
            return {
                "passed": result.get("success", False),
                "output": result.get("stdout", ""),
                "error": result.get("stderr") if not result.get("success") else None
            }
            
        except Exception as e:
            logger.error(f"âŒ çµ±åˆãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _run_wp_cli_tests(self, task_id: str) -> Dict[str, Any]:
        """WP-CLIåŸºæœ¬ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ"""
        tests = [
            ("wp core version", "WordPressãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª"),
            ("wp plugin list --status=active", "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€è¦§"),
            ("wp theme list --status=active", "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ†ãƒ¼ãƒç¢ºèª"),
        ]
        
        results = []
        all_passed = True
        
        for cmd, description in tests:
            logger.info(f"ğŸ” ãƒ†ã‚¹ãƒˆ: {description}")
            result = await self.cmd_monitor.execute_command(cmd)
            
            passed = result.get("success", False)
            results.append({
                "test": description,
                "command": cmd,
                "passed": passed,
                "output": result.get("stdout", "")
            })
            
            if not passed:
                all_passed = False
        
        return {
            "passed": all_passed,
            "tests": results
        }
    
    # ========================================
    # å°‚é–€ãƒ†ã‚¹ãƒˆé–¢æ•°
    # ========================================
    
    async def _test_custom_post_type(self, task_id: str) -> Dict[str, Any]:
        """ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ã®ãƒ†ã‚¹ãƒˆ"""
        try:
            # CPTä¸€è¦§ã‚’å–å¾—
            cmd = "wp post-type list --format=json"
            result = await self.cmd_monitor.execute_command(cmd)
            
            if not result.get("success"):
                return {
                    "passed": False,
                    "error": "Failed to list post types"
                }
            
            # ã‚¿ã‚¹ã‚¯IDã‹ã‚‰CPTåã‚’æ¨å®šï¼ˆä¾‹: Task 54 â†’ ma_caseï¼‰
            cpt_name = self._extract_cpt_name_from_task(task_id)
            
            if cpt_name:
                # ç‰¹å®šã®CPTã‚’ãƒã‚§ãƒƒã‚¯
                post_types = json.loads(result.get("stdout", "[]"))
                cpt_exists = any(pt.get("name") == cpt_name for pt in post_types)
                
                if cpt_exists:
                    logger.info(f"âœ… CPT '{cpt_name}' ãŒæ­£å¸¸ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™")
                    return {"passed": True, "cpt_name": cpt_name}
                else:
                    logger.warning(f"âš ï¸ CPT '{cpt_name}' ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                    return {
                        "passed": False,
                        "error": f"CPT '{cpt_name}' not found",
                        "cpt_name": cpt_name
                    }
            else:
                # æ±ç”¨ãƒã‚§ãƒƒã‚¯
                return {"passed": True, "message": "Post types list retrieved successfully"}
                
        except Exception as e:
            logger.error(f"âŒ CPTãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_acf_fields(self, task_id: str) -> Dict[str, Any]:
        """ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ†ã‚¹ãƒˆ"""
        try:
            # ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’å–å¾—
            cmd = "wp acf export --format=json"
            result = await self.cmd_monitor.execute_command(cmd)
            
            if not result.get("success"):
                # ACFã‚³ãƒãƒ³ãƒ‰ãŒãªã„å ´åˆ
                logger.warning("âš ï¸ ACF WP-CLIã‚³ãƒãƒ³ãƒ‰ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
                return {
                    "passed": False,
                    "error": "ACF CLI not available"
                }
            
            # ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã®å­˜åœ¨ç¢ºèª
            field_groups = json.loads(result.get("stdout", "[]"))
            
            if field_groups and len(field_groups) > 0:
                logger.info(f"âœ… ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—: {len(field_groups)}å€‹")
                return {
                    "passed": True,
                    "field_group_count": len(field_groups)
                }
            else:
                return {
                    "passed": False,
                    "error": "No ACF field groups found"
                }
                
        except Exception as e:
            logger.error(f"âŒ ACFãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_post_creation(self, task_id: str) -> Dict[str, Any]:
        """æŠ•ç¨¿ä½œæˆã®ãƒ†ã‚¹ãƒˆ"""
        try:
            # ãƒ†ã‚¹ãƒˆæŠ•ç¨¿ã‚’ä½œæˆ
            test_title = f"Test Post {datetime.now().strftime('%Y%m%d_%H%M%S')}"
            cmd = f'wp post create --post_title="{test_title}" --post_content="Test content" --post_status=draft --porcelain'
            
            result = await self.cmd_monitor.execute_command(cmd)
            
            if result.get("success"):
                post_id = result.get("stdout", "").strip()
                logger.info(f"âœ… ãƒ†ã‚¹ãƒˆæŠ•ç¨¿ä½œæˆæˆåŠŸ: ID={post_id}")
                
                # ä½œæˆã—ãŸæŠ•ç¨¿ã‚’å‰Šé™¤
                delete_cmd = f"wp post delete {post_id} --force"
                await self.cmd_monitor.execute_command(delete_cmd)
                
                return {
                    "passed": True,
                    "test_post_id": post_id
                }
            else:
                return {
                    "passed": False,
                    "error": result.get("stderr", "Post creation failed")
                }
                
        except Exception as e:
            logger.error(f"âŒ æŠ•ç¨¿ä½œæˆãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_plugin_activation(self, task_id: str) -> Dict[str, Any]:
        """ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æœ‰åŠ¹åŒ–ã®ãƒ†ã‚¹ãƒˆ"""
        try:
            # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³ä¸€è¦§
            cmd = "wp plugin list --status=active --format=json"
            result = await self.cmd_monitor.execute_command(cmd)
            
            if result.get("success"):
                plugins = json.loads(result.get("stdout", "[]"))
                logger.info(f"âœ… ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³: {len(plugins)}å€‹")
                
                return {
                    "passed": True,
                    "active_plugin_count": len(plugins),
                    "plugins": [p.get("name") for p in plugins]
                }
            else:
                return {
                    "passed": False,
                    "error": "Failed to list plugins"
                }
                
        except Exception as e:
            logger.error(f"âŒ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    async def _test_wp_health(self) -> Dict[str, Any]:
        """WordPresså…¨ä½“ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯"""
        try:
            checks = []
            
            # 1. WordPressãƒãƒ¼ã‚¸ãƒ§ãƒ³
            result = await self.cmd_monitor.execute_command("wp core version")
            checks.append({
                "check": "WordPress Version",
                "passed": result.get("success", False),
                "value": result.get("stdout", "").strip()
            })
            
            # 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
            result = await self.cmd_monitor.execute_command("wp db check")
            checks.append({
                "check": "Database Connection",
                "passed": result.get("success", False)
            })
            
            # 3. ãƒ†ãƒ¼ãƒ
            result = await self.cmd_monitor.execute_command("wp theme list --status=active")
            checks.append({
                "check": "Active Theme",
                "passed": result.get("success", False)
            })
            
            all_passed = all(c["passed"] for c in checks)
            
            return {
                "passed": all_passed,
                "checks": checks
            }
            
        except Exception as e:
            logger.error(f"âŒ å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
            return {"passed": False, "error": str(e)}
    
    # ========================================
    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    # ========================================
    
    def _extract_cpt_name_from_task(self, task_id: str) -> Optional[str]:
        """ã‚¿ã‚¹ã‚¯IDã‹ã‚‰CPTåã‚’æŠ½å‡º"""
        # ä¾‹: Task 54 â†’ ma_case
        if "54" in task_id or "M&Aæ¡ˆä»¶" in task_id:
            return "ma_case"
        
        # ä»–ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã“ã“ã«è¿½åŠ 
        
        return None
    
    async def _save_test_result(self, task_id: str, result: Dict[str, Any]):
        """ãƒ†ã‚¹ãƒˆçµæœã‚’ä¿å­˜"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = self.test_results_dir / f"{task_id}_{timestamp}.json"
            
            result_with_metadata = {
                "task_id": task_id,
                "timestamp": datetime.now().isoformat(),
                **result
            }
            
            await asyncio.to_thread(
                filename.write_text,
                json.dumps(result_with_metadata, indent=2, ensure_ascii=False)
            )
            
            logger.info(f"ğŸ’¾ ãƒ†ã‚¹ãƒˆçµæœä¿å­˜: {filename}")
            
        except Exception as e:
            logger.error(f"âŒ ãƒ†ã‚¹ãƒˆçµæœä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """çµ±è¨ˆæƒ…å ±ã‚’å–å¾—"""
        success_rate = 0.0
        if self.stats["total_tests"] > 0:
            success_rate = self.stats["passed_tests"] / self.stats["total_tests"]
        
        return {
            **self.stats,
            "success_rate": success_rate
        }

#wp_utils.py
"""WordPressãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Google Driveå¯¾å¿œç‰ˆ)
ã“ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€WordPressã‚¿ã‚¹ã‚¯ã®å‡¦ç†ã«å¿…è¦ãªå„ç¨®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
ä¸»ãªæ©Ÿèƒ½:
- ã‚¿ã‚¹ã‚¯å†…å®¹ã®å–å¾—ï¼ˆGoogle Driveã€JSONã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œï¼‰
- ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã®åˆ†æã¨åˆ¤å®š
- WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ»è¨­å®šç®¡ç†
- HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ»æœ€é©åŒ–
"""

import re
import logging
from typing import Optional, Tuple, Dict, List
from pathlib import Path
import json

# ãƒ­ã‚¬ãƒ¼ã®åˆæœŸåŒ–
logger = logging.getLogger(__name__)


# ============================================================================
# TaskContentFetcher: ã‚¿ã‚¹ã‚¯å†…å®¹å–å¾—ã‚¯ãƒ©ã‚¹
# ============================================================================

class TaskContentFetcher:
    """ã‚¿ã‚¹ã‚¯å†…å®¹å–å¾—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (Google Driveå¯¾å¿œ)
    
    è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨˜äº‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›:
    1. Google Driveãƒªãƒ³ã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
    2. JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
    3. ãƒ­ãƒ¼ã‚«ãƒ«Markdownãƒ•ã‚¡ã‚¤ãƒ«
    4. task_logã‚·ãƒ¼ãƒˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    """
    
    @staticmethod
    def extract_task_id(description: str) -> Optional[int]:
        """èª¬æ˜æ–‡ã‹ã‚‰task_idã‚’æŠ½å‡º
        
        å¯¾å¿œå½¢å¼:
        - task_id 39
        - task id 39
        - ã‚¿ã‚¹ã‚¯ID 39
        
        Args:
            description: ã‚¿ã‚¹ã‚¯èª¬æ˜æ–‡
            
        Returns:
            æŠ½å‡ºã•ã‚ŒãŸtask_idã€è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯None
        """
        # è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§task_idã‚’æ¤œç´¢
        patterns = [
            r'task[_\s]+id[\sã€€]*(\d+)',  # task_id, task idå½¢å¼
            r'ã‚¿ã‚¹ã‚¯[\sã€€]*ID[\sã€€]*(\d+)',  # æ—¥æœ¬èªå½¢å¼
        ]
        
        for pattern in patterns:
            match = re.search(pattern, description, re.IGNORECASE)
            if match:
                task_id = int(match.group(1))
                logger.info(f"âœ… task_idæŠ½å‡º: {task_id}")
                return task_id
        
        logger.debug("task_idãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
        return None

    @staticmethod
    async def get_task_content(sheets_manager, task_id: int) -> Optional[str]:
        """æŒ‡å®šã•ã‚ŒãŸtask_idã®è¨˜äº‹å†…å®¹ã‚’å–å¾—(è¶…å …ç‰¢ç‰ˆ)
        
        å„ªå…ˆé †ä½:
        1. task_execution_log ã‚·ãƒ¼ãƒˆã® Google Drive ãƒªãƒ³ã‚¯(æœ€å„ªå…ˆ)
        2. task_execution_log ã‚·ãƒ¼ãƒˆã® output_data ã‚«ãƒ©ãƒ (JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹)
        3. task_execution_log ã‚·ãƒ¼ãƒˆã®ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        4. task_log ã‚·ãƒ¼ãƒˆ(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            task_id: ã‚¿ã‚¹ã‚¯ID
            
        Returns:
            è¨˜äº‹å†…å®¹(ãƒ†ã‚­ã‚¹ãƒˆ)ã€å¤±æ•—æ™‚ã¯None
        """
        try:
            logger.info("="*60)
            logger.info(f"ã€è¨˜äº‹å–å¾—é–‹å§‹ã€‘task_id={task_id}")
            logger.info("="*60)
            
            # === ãƒ‘ãƒ¼ãƒˆ1: sheets_managerã®æ¤œè¨¼ ===
            if not TaskContentFetcher._validate_sheets_manager(sheets_manager):
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã ===
            sheet = TaskContentFetcher._open_spreadsheet(sheets_manager)
            if not sheet:
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ3: task_execution_logã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹ ===
            logger.info("\nã€å„ªå…ˆåº¦1ã€‘task_execution_logã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã¾ã™")
            content = await TaskContentFetcher._get_from_execution_log(
                sheet, task_id, sheets_manager
            )
            
            if content:
                logger.info(f"âœ… è¨˜äº‹å–å¾—æˆåŠŸ: {len(content)}æ–‡å­—")
                return content
            
            # === ãƒ‘ãƒ¼ãƒˆ4: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ - task_logã‹ã‚‰å–å¾— ===
            logger.info("\nã€å„ªå…ˆåº¦2ã€‘task_logã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã¾ã™(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)")
            content = await TaskContentFetcher._get_from_task_log(
                sheet, task_id
            )
            
            if content:
                logger.info(f"âœ… è¨˜äº‹å–å¾—æˆåŠŸ(task_log): {len(content)}æ–‡å­—")
                return content
            
            logger.error("âŒ ã™ã¹ã¦ã®æ–¹æ³•ã§è¨˜äº‹å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ")
            return None
            
        except Exception as e:
            logger.error(f"âŒ task_id {task_id} ã®å†…å®¹å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _validate_sheets_manager(sheets_manager) -> bool:
        """sheets_managerã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            æ¤œè¨¼æˆåŠŸæ™‚Trueã€å¤±æ•—æ™‚False
        """
        if not sheets_manager:
            logger.error("âŒ sheets_managerãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        
        if not sheets_manager.gc:
            logger.error("âŒ Google Sheetsã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return False
        
        logger.info("âœ… sheets_manageræ¤œè¨¼å®Œäº†")
        return True

    @staticmethod
    def _open_spreadsheet(sheets_manager):
        """ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã
        
        Args:
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å¤±æ•—æ™‚None
        """
        logger.info(f"ğŸ“Š ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚’é–‹ã: {sheets_manager.spreadsheet_id}")
        try:
            sheet = sheets_manager.gc.open_by_key(sheets_manager.spreadsheet_id)
            logger.info("âœ… ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šæˆåŠŸ")
            return sheet
        except Exception as e:
            logger.error(f"âŒ ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆæ¥ç¶šå¤±æ•—: {e}")
            return None

    @staticmethod
    async def _get_from_execution_log(sheet, task_id: int, sheets_manager) -> Optional[str]:
        """task_execution_log ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—(è¶…è©³ç´°ãƒ­ã‚°ç‰ˆ)
        
        å„ªå…ˆé †ä½:
        1. Google Driveãƒªãƒ³ã‚¯
        2. output_data(JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹)
        3. ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
        
        Args:
            sheet: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            task_id: ã‚¿ã‚¹ã‚¯ID
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        try:
            # === ãƒ‘ãƒ¼ãƒˆ1: ã‚·ãƒ¼ãƒˆã‚’é–‹ã ===
            logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘1ã€‘task_execution_logã‚·ãƒ¼ãƒˆã‚’é–‹ã")
            try:
                execution_log_sheet = sheet.worksheet("task_execution_log")
                logger.info("âœ… task_execution_logã‚·ãƒ¼ãƒˆç™ºè¦‹")
            except Exception as e:
                logger.warning(f"âŒ task_execution_logã‚·ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {e}")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ2: ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾— ===
            logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘2ã€‘ã‚·ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            execution_log_data = execution_log_sheet.get_all_values()
            
            if len(execution_log_data) == 0:
                logger.warning("âŒ task_execution_logã‚·ãƒ¼ãƒˆãŒç©ºã§ã™")
                return None
            
            logger.info(f"âœ… {len(execution_log_data)}è¡Œã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—")
            
            # === ãƒ‘ãƒ¼ãƒˆ3: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æã—ã¦ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š ===
            column_indices = TaskContentFetcher._parse_header_columns(execution_log_data[0])
            if column_indices['task_id_col'] is None:
                logger.warning("âŒ task_id ã‚«ãƒ©ãƒ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
            
            # === ãƒ‘ãƒ¼ãƒˆ4: å¯¾è±¡ã®task_idã‚’æ¤œç´¢ ===
            logger.debug(f"ã€åˆ‡ã‚Šåˆ†ã‘6ã€‘task_id={task_id}ã‚’æ¤œç´¢ä¸­...")
            for row_idx, row in enumerate(execution_log_data[1:], start=2):
                if len(row) <= column_indices['task_id_col']:
                    continue
                
                try:
                    task_id_in_row = int(row[column_indices['task_id_col']])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"âœ… task_id {task_id} ã‚’è¡Œ {row_idx} ã§ç™ºè¦‹")
                    logger.debug(f"è¡Œå†…å®¹: {row[:min(len(row), 10)]}...")
                    
                    # === ãƒ‘ãƒ¼ãƒˆ5: ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨˜äº‹ã‚’å–å¾— ===
                    content = await TaskContentFetcher._fetch_content_from_sources(
                        row, column_indices, sheets_manager
                    )
                    
                    if content:
                        return content
                    
                    logger.warning(f"âŒ task_id {task_id} ã®ãƒ‡ãƒ¼ã‚¿ãŒã™ã¹ã¦ç©ºã§ã™")
                    return None
            
            logger.warning(f"âŒ task_id {task_id} ãŒ task_execution_log ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            return None
            
        except Exception as e:
            logger.error(f"âŒ task_execution_log ã‹ã‚‰ã®å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None

    @staticmethod
    def _parse_header_columns(headers: List[str]) -> Dict[str, Optional[int]]:
        """ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æã—ã¦ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š
        
        Args:
            headers: ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã®ãƒªã‚¹ãƒˆ
            
        Returns:
            ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¾æ›¸
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘3ã€‘ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’è§£æ")
        logger.debug(f"ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
        
        column_indices = {
            'task_id_col': None,
            'output_data_col': None,
            'markdown_file_col': None,
            'drive_link_col': None
        }
        
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘4ã€‘ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š")
        for i, header in enumerate(headers):
            header_lower = header.lower().strip()
            
            if 'task_id' in header_lower or 'ã‚¿ã‚¹ã‚¯id' in header_lower:
                column_indices['task_id_col'] = i
                logger.debug(f"  â†’ task_idåˆ—: {i}")
            elif 'output_data' in header_lower or 'full_text' in header_lower or 'å‡ºåŠ›ãƒ‡ãƒ¼ã‚¿' in header_lower or 'å‡ºåŠ›' in header_lower:
                column_indices['output_data_col'] = i
                logger.debug(f"  â†’ output_dataåˆ—: {i}")
            elif 'drive' in header_lower or 'link' in header_lower or 'url' in header_lower or 'ãƒªãƒ³ã‚¯' in header_lower:
                column_indices['drive_link_col'] = i
                logger.debug(f"  â†’ drive_linkåˆ—: {i}")
            elif 'markdown' in header_lower or 'file' in header_lower or 'ãƒ•ã‚¡ã‚¤ãƒ«' in header_lower:
                column_indices['markdown_file_col'] = i
                logger.debug(f"  â†’ markdownåˆ—: {i}")
        
        logger.debug(f"ã€åˆ‡ã‚Šåˆ†ã‘5ã€‘ã‚«ãƒ©ãƒ ç‰¹å®šçµæœ")
        for key, value in column_indices.items():
            logger.debug(f"  {key}: {value}")
        
        return column_indices

    @staticmethod
    async def _fetch_content_from_sources(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰è¨˜äº‹å†…å®¹ã‚’å–å¾—ï¼ˆå„ªå…ˆé †ä½ä»˜ãï¼‰
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        # å„ªå…ˆåº¦1: Google Driveãƒªãƒ³ã‚¯
        content = await TaskContentFetcher._fetch_from_drive_link(
            row, column_indices, sheets_manager
        )
        if content:
            return content
        
        # å„ªå…ˆåº¦2: output_data(JSONãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ç›´æ¥ãƒ†ã‚­ã‚¹ãƒˆ)
        content = TaskContentFetcher._fetch_from_output_data(
            row, column_indices
        )
        if content:
            return content
        
        # å„ªå…ˆåº¦3: ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«
        content = TaskContentFetcher._fetch_from_markdown_file(
            row, column_indices
        )
        if content:
            return content
        
        return None

    @staticmethod
    async def _fetch_from_drive_link(
        row: List[str], 
        column_indices: Dict[str, Optional[int]], 
        sheets_manager
    ) -> Optional[str]:
        """Google Driveãƒªãƒ³ã‚¯ã‹ã‚‰è¨˜äº‹ã‚’å–å¾—
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            sheets_manager: GoogleSheetsManagerã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘7ã€‘Google Driveãƒªãƒ³ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯")
        drive_link_col = column_indices.get('drive_link_col')
        
        if drive_link_col is not None and len(row) > drive_link_col:
            drive_link = row[drive_link_col].strip()
            logger.debug(f"  drive_linkåˆ—ã®å€¤: '{drive_link}'")
            
            if drive_link and len(drive_link) > 0:
                logger.info(f"ğŸ”— Google Drive ãƒªãƒ³ã‚¯ã‚’ç™ºè¦‹")
                logger.debug(f"  URL: {drive_link[:80]}...")
                
                # Google Driveã‹ã‚‰èª­ã¿è¾¼ã¿
                logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘8ã€‘Google Driveã‹ã‚‰è¨˜äº‹ã‚’èª­ã¿è¾¼ã¿ä¸­...")
                content = sheets_manager.read_file_from_drive(drive_link)
                
                if content:
                    logger.info(f"âœ… Google Driveã‹ã‚‰è¨˜äº‹å–å¾—æˆåŠŸ")
                    logger.debug(f"  æ–‡å­—æ•°: {len(content)}")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
                    return content
                else:
                    logger.warning("âŒ Google Driveã‹ã‚‰ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—")
            else:
                logger.debug("  â†’ drive_linkåˆ—ãŒç©º")
        else:
            logger.debug("  â†’ drive_linkåˆ—ãªã—")
        
        return None

    @staticmethod
    def _fetch_from_output_data(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """output_dataã‚«ãƒ©ãƒ ã‹ã‚‰è¨˜äº‹ã‚’å–å¾—ï¼ˆJSONã¾ãŸã¯ç›´æ¥ãƒ†ã‚­ã‚¹ãƒˆï¼‰
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘9ã€‘output_dataã‚’ãƒã‚§ãƒƒã‚¯")
        output_data_col = column_indices.get('output_data_col')
        
        if output_data_col is not None and len(row) > output_data_col:
            output_data = row[output_data_col].strip()
            logger.debug(f"  output_dataåˆ—ã®é•·ã•: {len(output_data)}æ–‡å­—")
            
            if output_data and len(output_data) > 0:
                # JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                if output_data.endswith('.json'):
                    logger.info(f"  â†’ JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨åˆ¤å®š: {output_data}")
                    return TaskContentFetcher._read_json_file(output_data)
                else:
                    # é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦æ‰±ã†
                    logger.info(f"âœ… output_data ã‹ã‚‰è¨˜äº‹å–å¾—(ç›´æ¥)")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {output_data[:100]}...")
                    return output_data
            else:
                logger.debug("  â†’ output_dataåˆ—ãŒç©º")
        else:
            logger.debug("  â†’ output_dataåˆ—ãªã—")
        
        return None

    @staticmethod
    def _read_json_file(json_path_str: str) -> Optional[str]:
        """JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨˜äº‹ã‚’èª­ã¿è¾¼ã‚€
        
        Args:
            json_path_str: JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        json_path = Path(json_path_str)
        
        # çµ¶å¯¾ãƒ‘ã‚¹ã§ãªã„å ´åˆã€å€™è£œãƒ‘ã‚¹ã‚’è©¦ã™
        if not json_path.is_absolute():
            candidates = [
                Path.cwd() / json_path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / json_path.name,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / json_path.name,
            ]
            for candidate in candidates:
                if candidate.exists():
                    json_path = candidate
                    break
        
        if json_path.exists():
            logger.info(f"  â†’ JSONãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿: {json_path}")
            try:
                with open(json_path, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                # html_contentã‚’å–å¾—
                html_content = json_data.get('html_content', '')
                if html_content:
                    logger.info(f"âœ… JSONã‹ã‚‰HTMLè¨˜äº‹å–å¾—æˆåŠŸ: {len(html_content)}æ–‡å­—")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {html_content[:100]}...")
                    return html_content
                else:
                    logger.warning("âŒ JSONã«html_contentãŒã‚ã‚Šã¾ã›ã‚“")
            except Exception as e:
                logger.error(f"âŒ JSONãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
        else:
            logger.warning(f"âŒ JSONãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {json_path}")
        
        return None

    @staticmethod
    def _fetch_from_markdown_file(
        row: List[str], 
        column_indices: Dict[str, Optional[int]]
    ) -> Optional[str]:
        """ãƒ­ãƒ¼ã‚«ãƒ«ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰è¨˜äº‹ã‚’å–å¾—
        
        Args:
            row: ãƒ‡ãƒ¼ã‚¿è¡Œ
            column_indices: ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¾æ›¸
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        logger.debug("ã€åˆ‡ã‚Šåˆ†ã‘10ã€‘ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯")
        markdown_file_col = column_indices.get('markdown_file_col')
        
        if markdown_file_col is not None and len(row) > markdown_file_col:
            markdown_path = row[markdown_file_col]
            logger.debug(f"  markdownåˆ—ã®å€¤: '{markdown_path}'")
            
            if markdown_path and len(markdown_path.strip()) > 0:
                content = TaskContentFetcher._read_local_markdown_file(markdown_path)
                if content:
                    return content
            else:
                logger.debug("  â†’ markdownåˆ—ãŒç©º")
        else:
            logger.debug("  â†’ markdownåˆ—ãªã—")
        
        return None

    @staticmethod
    async def _get_from_task_log(sheet, task_id: int) -> Optional[str]:
        """task_log ã‚·ãƒ¼ãƒˆã‹ã‚‰å–å¾—(ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
        
        Args:
            sheet: ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            task_id: ã‚¿ã‚¹ã‚¯ID
            
        Returns:
            è¨˜äº‹å†…å®¹ã€å¤±æ•—æ™‚None
        """
        try:
            task_log_sheet = sheet.worksheet("task_log")
            task_log_data = task_log_sheet.get_all_values()
            
            if len(task_log_data) == 0:
                return None
            
            headers = task_log_data[0]
            
            # ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç‰¹å®š
            task_id_col = None
            output_data_col = None
            
            for i, header in enumerate(headers):
                if 'task_id' in header.lower():
                    task_id_col = i
                elif 'output_data' in header.lower() or 'full_text' in header.lower():
                    output_data_col = i
            
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
            if task_id_col is None:
                task_id_col = 1
            
            if output_data_col is None:
                output_data_col = len(headers) - 1
            
            # task_idã‚’æ¤œç´¢
            for row_idx, row in enumerate(task_log_data[1:], start=2):
                if len(row) <= task_id_col:
                    continue
                
                try:
                    task_id_in_row = int(row[task_id_col])
                except (ValueError, IndexError):
                    continue
                
                if task_id_in_row == task_id:
                    logger.info(f"âœ… task_id {task_id} ã‚’ task_log ã®è¡Œ {row_idx} ã§ç™ºè¦‹")
                    
                    if output_data_col and len(row) > output_data_col:
                        full_text = row[output_data_col]
                        if full_text and len(full_text) > 0:
                            logger.info(f"âœ… task_log ã‹ã‚‰å–å¾— ({len(full_text)}æ–‡å­—)")
                            return full_text
            
            return None
            
        except Exception as e:
            logger.error(f"task_log ã‹ã‚‰ã®å–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return None

    @staticmethod
    def _read_local_markdown_file(file_path: str) -> Optional[str]:
        """ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€(å¼·åŒ–ç‰ˆ)
        
        Args:
            file_path: ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
            
        Returns:
            ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã€å¤±æ•—æ™‚None
        """
        try:
            logger.debug("ã€ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€‘")
            logger.debug(f"  ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹: {file_path}")
            
            path = Path(file_path.strip())
            
            # çµ¶å¯¾ãƒ‘ã‚¹ã®å ´åˆ
            if path.is_absolute():
                logger.debug("  â†’ çµ¶å¯¾ãƒ‘ã‚¹ã¨ã—ã¦å‡¦ç†")
                if path.exists():
                    logger.debug(f"  â†’ ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèª: OK")
                    with open(path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: {len(content)}æ–‡å­—")
                    logger.debug(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
                    
                    # ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
                    content = TaskContentFetcher._extract_title_and_body(content)
                    
                    return content
                else:
                    logger.warning(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {path}")
                    return None
            
            # ç›¸å¯¾ãƒ‘ã‚¹ã®å ´åˆã€å€™è£œãƒ‘ã‚¹ã‚’è©¦ã™
            logger.debug("  â†’ ç›¸å¯¾ãƒ‘ã‚¹ã¨ã—ã¦å‡¦ç†")
            candidates = [
                Path.cwd() / path,
                Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "AI_Agent" / "agent_outputs" / path.name,
                Path.home() / "Documents" / "gemini_AI_Agent" / "agent_outputs" / path.name,
            ]
            
            logger.debug(f"  å€™è£œãƒ‘ã‚¹æ•°: {len(candidates)}")
            
            for i, candidate in enumerate(candidates, 1):
                logger.debug(f"  å€™è£œ{i}: {candidate}")
                if candidate.exists():
                    logger.info(f"  â†’ ãƒ•ã‚¡ã‚¤ãƒ«ç™ºè¦‹: {candidate}")
                    path = candidate
                    break
            
            if not path.exists():
                logger.warning(f"âŒ ã™ã¹ã¦ã®å€™è£œã§ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                for candidate in candidates:
                    logger.warning(f"  è©¦è¡Œ: {candidate}")
                return None
            
            logger.info(f"ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ä¸­: {path}")
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            logger.info(f"âœ… ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ: {len(content)}æ–‡å­—")
            logger.debug(f"  å…ˆé ­100æ–‡å­—: {content[:100]}...")
            
            # ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
            content = TaskContentFetcher._extract_title_and_body(content)
            
            return content
            
        except Exception as e:
            logger.error(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    @staticmethod
    def _extract_title_and_body(content: str) -> str:
        """ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’æŠ½å‡º
        
        <!-- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ --> ã‚„ <!-- ã‚³ãƒ¡ãƒ³ãƒˆ --> ã‚’é™¤å»ã—ã€
        ã‚¿ã‚¤ãƒˆãƒ«(# ã§å§‹ã¾ã‚‹è¡Œ)ã¨æœ¬æ–‡ã®ã¿ã‚’æŠ½å‡º
        
        Args:
            content: å…ƒã®ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸã‚³ãƒ³ãƒ†ãƒ³ãƒ„
        """
        try:
            lines = content.split('\n')
            result_lines = []
            in_comment = False
            
            for line in lines:
                # HTMLã‚³ãƒ¡ãƒ³ãƒˆé–‹å§‹
                if '<!--' in line:
                    in_comment = True
                    continue
                
                # HTMLã‚³ãƒ¡ãƒ³ãƒˆçµ‚äº†
                if '-->' in line:
                    in_comment = False
                    continue
                
                # ã‚³ãƒ¡ãƒ³ãƒˆå†…ã¯ã‚¹ã‚­ãƒƒãƒ—
                if in_comment:
                    continue
                
                # ç©ºè¡ŒãŒé€£ç¶šã™ã‚‹å ´åˆã¯1ã¤ã ã‘ã«ã™ã‚‹
                if line.strip() == '':
                    if result_lines and result_lines[-1].strip() == '':
                        continue
                
                result_lines.append(line)
            
            # å…ˆé ­ã¨æœ«å°¾ã®ç©ºè¡Œã‚’å‰Šé™¤
            while result_lines and result_lines[0].strip() == '':
                result_lines.pop(0)
            
            while result_lines and result_lines[-1].strip() == '':
                result_lines.pop()
            
            cleaned_content = '\n'.join(result_lines)
            
            logger.debug(f"ã€è¨˜äº‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†ã€‘")
            logger.debug(f"  å…ƒã®æ–‡å­—æ•°: {len(content)}")
            logger.debug(f"  å‡¦ç†å¾Œã®æ–‡å­—æ•°: {len(cleaned_content)}")
            logger.debug(f"  å…ˆé ­100æ–‡å­—: {cleaned_content[:100]}...")
            
            return cleaned_content
            
        except Exception as e:
            logger.warning(f"è¨˜äº‹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
            return content


# ============================================================================
# TaskTypeAnalyzer: ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—åˆ†æã‚¯ãƒ©ã‚¹
# ============================================================================

class TaskTypeAnalyzer:
    """ã‚¿ã‚¹ã‚¯å†…å®¹ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
    
    ã‚¿ã‚¹ã‚¯ã®èª¬æ˜æ–‡ã‚’è§£æã—ã¦ã€é©åˆ‡ãªã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã‚’è¿”ã™ã€‚
    """

    @staticmethod
    def analyze(description: str) -> str:
        """ã‚¿ã‚¹ã‚¯å†…å®¹ã‹ã‚‰ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            description: ã‚¿ã‚¹ã‚¯èª¬æ˜æ–‡
            
        Returns:
            ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—æ–‡å­—åˆ—
        """
        description_lower = description.lower()
        
        # æ–°ã—ã„åˆ¤å®šãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ 
        if 'polylang' in description_lower and 'è¨€èª' in description_lower:
            return 'edit_post'
        
        if 'æŠ•ç¨¿' in description and 'æ¢ã—ã¦' in description and (
            'å¤‰æ›´' in description or 'ç·¨é›†' in description or 'æ›¸ãæ›ãˆ' in description
        ):
            return 'edit_post'
        
        if 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³' in description and (
            'å¤‰æ›´' in description or 'è¨­å®š' in description
        ) and 'ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«' not in description:
            return 'plugin_settings'
        
        if 'ãƒ—ãƒ©ã‚°ã‚¤ãƒ³' in description and 'ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«' in description:
            return 'plugin_install'
        
        if 'ãƒ†ãƒ¼ãƒ' in description or 'theme' in description_lower:
            return 'theme_change'
        
        if 'è¨­å®š' in description or 'setting' in description_lower:
            return 'setting_change'
        
        if ('æŠ•ç¨¿' in description or 'è¨˜äº‹' in description or 'post' in description_lower) and (
            'ä½œæˆ' in description or 'ä¿å­˜' in description
        ):
            return 'content_create'
        
        if 'ãƒ†ã‚¹ãƒˆ' in description or 'test' in description_lower:
            return 'test_functionality'
        
        return 'generic'


# ============================================================================
# WordPressConfig: WordPressè¨­å®šã‚¯ãƒ©ã‚¹
# ============================================================================

class WordPressConfig:
    """WordPressè¨­å®šã‚¯ãƒ©ã‚¹
    
    WordPressé–¢é€£ã®è¨­å®šå€¤ã‚’ä¸€å…ƒç®¡ç†ã™ã‚‹ã€‚
    - WordPress URL
    - Polylangè¨€èªã‚³ãƒ¼ãƒ‰
    - ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—
    - æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³
    - M&Aæ¡ˆä»¶ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
    - FacetWPãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
    """
    
    # WordPress URLã®è¨­å®š(å®Ÿéš›ã®ã‚µã‚¤ãƒˆURLã«å¤‰æ›´ã—ã¦ãã ã•ã„)
    WORDPRESS_URL = "https://your-site.com"
    
    # Polylangè¨€èªã‚³ãƒ¼ãƒ‰å®šç¾©
    POLYLANG_LANGS = {
        'ja': 'ja',           # æ—¥æœ¬èª
        'en': 'en',           # è‹±èª
        'ru': 'ru',           # ãƒ­ã‚·ã‚¢èª
        'uz': 'uz_UZ',        # ã‚¦ã‚ºãƒ™ã‚¯èª
        'zh': 'zh_CN',        # ä¸­å›½èª(ç°¡ä½“å­—)
        'ko': 'ko_KR',        # éŸ“å›½èª
        'tr': 'tr_TR'         # ãƒˆãƒ«ã‚³èª
    }
    
    # ACFãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—å®šç¾©
    ACF_FIELD_TYPES = {
        # ãƒ†ã‚­ã‚¹ãƒˆç³»
        'text': 'ãƒ†ã‚­ã‚¹ãƒˆ(1è¡Œ)',
        'textarea': 'ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢(è¤‡æ•°è¡Œ)',
        'number': 'æ•°å€¤',
        'email': 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹',
        'url': 'URL',
        'password': 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰',
        
        # é¸æŠç³»
        'select': 'ã‚»ãƒ¬ã‚¯ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼',
        'checkbox': 'ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹',
        'radio': 'ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³',
        'true_false': 'çœŸå½å€¤',
        
        # æ—¥ä»˜æ™‚åˆ»ç³»
        'date_picker': 'æ—¥ä»˜é¸æŠ',
        'date_time_picker': 'æ—¥ä»˜æ™‚åˆ»é¸æŠ',
        'time_picker': 'æ™‚åˆ»é¸æŠ',
        
        # ãƒ•ã‚¡ã‚¤ãƒ«ç³»
        'file': 'ãƒ•ã‚¡ã‚¤ãƒ«',
        'image': 'ç”»åƒ',
        'gallery': 'ã‚®ãƒ£ãƒ©ãƒªãƒ¼',
        
        # ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç³»
        'post_object': 'æŠ•ç¨¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ',
        'relationship': 'ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—',
        'taxonomy': 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼',
        'user': 'ãƒ¦ãƒ¼ã‚¶ãƒ¼',
        
        # ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆç³»
        'repeater': 'ãƒªãƒ”ãƒ¼ã‚¿ãƒ¼',
        'flexible_content': 'ãƒ•ãƒ¬ã‚­ã‚·ãƒ–ãƒ«ã‚³ãƒ³ãƒ†ãƒ³ãƒ„',
        'group': 'ã‚°ãƒ«ãƒ¼ãƒ—',
        
        # ãã®ä»–
        'wysiwyg': 'WYSIWYGã‚¨ãƒ‡ã‚£ã‚¿',
        'oembed': 'oEmbed',
        'google_map': 'Googleãƒãƒƒãƒ—',
        'color_picker': 'ã‚«ãƒ©ãƒ¼ãƒ”ãƒƒã‚«ãƒ¼'
    }
    
    # WordPressãƒ—ãƒ©ã‚°ã‚¤ãƒ³å®šç¾©
    WORDPRESS_PLUGINS = {
        # å¿…é ˆãƒ—ãƒ©ã‚°ã‚¤ãƒ³
        'required': [
            {
                'name': 'Advanced Custom Fields PRO',
                'slug': 'advanced-custom-fields-pro',
                'version': '6.2+',
                'purpose': 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç®¡ç†',
                'priority': 'critical'
            },
            {
                'name': 'Custom Post Type UI',
                'slug': 'custom-post-type-ui',
                'version': '1.15+',
                'purpose': 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—ç®¡ç†',
                'priority': 'critical'
            },
            {
                'name': 'Polylang Pro',
                'slug': 'polylang-pro',
                'version': '3.5+',
                'purpose': 'å¤šè¨€èªå¯¾å¿œ',
                'priority': 'critical'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(æ¤œç´¢å¼·åŒ–)
        'search': [
            {
                'name': 'FacetWP',
                'slug': 'facetwp',
                'purpose': 'çµã‚Šè¾¼ã¿æ¤œç´¢',
                'priority': 'high'
            },
            {
                'name': 'Relevanssi',
                'slug': 'relevanssi',
                'purpose': 'æ¤œç´¢ç²¾åº¦å‘ä¸Š',
                'priority': 'high'
            },
            {
                'name': 'SearchWP',
                'slug': 'searchwp',
                'purpose': 'æ¤œç´¢æ©Ÿèƒ½å¼·åŒ–',
                'priority': 'medium'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†)
        'user_management': [
            {
                'name': 'User Role Editor',
                'slug': 'user-role-editor',
                'purpose': 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«ç®¡ç†',
                'priority': 'high'
            },
            {
                'name': 'Members',
                'slug': 'members',
                'purpose': 'æ¨©é™ç®¡ç†',
                'priority': 'medium'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
        'security': [
            {
                'name': 'Wordfence Security',
                'slug': 'wordfence',
                'purpose': 'ç·åˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£',
                'priority': 'high'
            },
            {
                'name': 'iThemes Security',
                'slug': 'ithemes-security-pro',
                'purpose': 'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–',
                'priority': 'medium'
            }
        ],
        
        # æ¨å¥¨ãƒ—ãƒ©ã‚°ã‚¤ãƒ³(ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹)
        'performance': [
            {
                'name': 'WP Rocket',
                'slug': 'wp-rocket',
                'purpose': 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ»æœ€é©åŒ–',
                'priority': 'high'
            },
            {
                'name': 'Autoptimize',
                'slug': 'autoptimize',
                'purpose': 'CSS/JSæœ€é©åŒ–',
                'priority': 'medium'
            }
        ]
    }
    
    # M&Aæ¡ˆä»¶ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¨­å®š
    MA_CASE_DEFAULT_FIELDS = {
        'case_id': {
            'type': 'text',
            'label': 'æ¡ˆä»¶ID',
            'required': True
        },
        'ma_scheme': {
            'type': 'select',
            'label': 'M&Aã‚¹ã‚­ãƒ¼ãƒ ',
            'choices': ['æ ªå¼è­²æ¸¡', 'äº‹æ¥­è­²æ¸¡', 'åˆä½µ', 'ä¼šç¤¾åˆ†å‰²'],
            'required': True
        },
        'desired_price': {
            'type': 'number',
            'label': 'å¸Œæœ›ä¾¡æ ¼',
            'min': 0,
            'step': 1000000,
            'required': False
        },
        'industry_category': {
            'type': 'taxonomy',
            'label': 'æ¥­ç¨®',
            'taxonomy': 'industry_category',
            'required': True
        },
        'region': {
            'type': 'taxonomy',
            'label': 'åœ°åŸŸ',
            'taxonomy': 'region',
            'required': True
        },
        'established_year': {
            'type': 'number',
            'label': 'è¨­ç«‹å¹´',
            'min': 1900,
            'max': 2025,
            'required': False
        },
        'employees': {
            'type': 'number',
            'label': 'å¾“æ¥­å“¡æ•°',
            'min': 0,
            'required': False
        },
        'annual_revenue': {
            'type': 'number',
            'label': 'å¹´å•†',
            'min': 0,
            'required': False
        },
        'annual_profit': {
            'type': 'number',
            'label': 'å¹´é–“åˆ©ç›Š',
            'required': False
        },
        'reason_for_sale': {
            'type': 'textarea',
            'label': 'å£²å´ç†ç”±',
            'required': False
        },
        'strengths': {
            'type': 'textarea',
            'label': 'å¼·ã¿',
            'required': False
        }
    }
    
    # FacetWPãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
    FACETWP_DEFAULT_FACETS = [
        {
            'name': 'æ¥­ç¨®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'checkboxes',
            'source': 'tax/industry_category',
            'label': 'æ¥­ç¨®ã§çµã‚Šè¾¼ã‚€'
        },
        {
            'name': 'ä¾¡æ ¼å¸¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'slider',
            'source': 'cf/desired_price',
            'label': 'å¸Œæœ›ä¾¡æ ¼',
            'min': 0,
            'max': 1000000000,
            'step': 10000000,
            'format': 'Â¥{value}'
        },
        {
            'name': 'åœ°åŸŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'dropdown',
            'source': 'tax/region',
            'label': 'åœ°åŸŸã§çµã‚Šè¾¼ã‚€'
        },
        {
            'name': 'å¾“æ¥­å“¡æ•°ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼',
            'type': 'slider',
            'source': 'cf/employees',
            'label': 'å¾“æ¥­å“¡æ•°',
            'min': 0,
            'max': 1000,
            'step': 10
        }
    ]


# ============================================================================
# TaskRouter: ã‚¿ã‚¹ã‚¯æŒ¯ã‚Šåˆ†ã‘ã‚¯ãƒ©ã‚¹
# ============================================================================

class TaskRouter:
    """ã‚¿ã‚¹ã‚¯ã®æŒ¯ã‚Šåˆ†ã‘ã‚’è¡Œã†ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¯ãƒ©ã‚¹
    
    ã‚¿ã‚¹ã‚¯ã®å†…å®¹ã‚’è§£æã—ã¦ã€é©åˆ‡ãªã‚¿ã‚¤ãƒ—(M&A/è¨˜äº‹ç”Ÿæˆ/ãƒ¬ãƒ“ãƒ¥ãƒ¼/ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ)ã‚’åˆ¤å®šã™ã‚‹ã€‚
    """
    
    # M&Aé–¢é€£ã®å¼·åŠ›ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    MA_STRONG_KEYWORDS = [
        'custom post type', 'ã‚«ã‚¹ã‚¿ãƒ æŠ•ç¨¿ã‚¿ã‚¤ãƒ—', 'cpt',
        'acfè¨­å®š', 'acf', 'ã‚«ã‚¹ã‚¿ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', 'custom field',
        'taxonomy', 'ã‚¿ã‚¯ã‚½ãƒãƒŸãƒ¼', 'ã‚«ãƒ†ã‚´ãƒªä½œæˆ',
        'm&aæ¡ˆä»¶', 'ma_case', 'ma case',
        'ä¼æ¥­æ¤œç´¢', 'æ¡ˆä»¶ç®¡ç†', 'æ¡ˆä»¶æŠ•ç¨¿',
        'facetwp', 'facet', 'çµã‚Šè¾¼ã¿æ¤œç´¢',
        'user role', 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«', 'æ¨©é™ç®¡ç†'
    ]
    
    # è¨˜äº‹ç”Ÿæˆé–¢é€£ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    CONTENT_KEYWORDS = [
        'è¨˜äº‹ä½œæˆ', 'è¨˜äº‹åŸ·ç­†', 'article', 'content creation',
        'ã€æ—¥æœ¬èªã€‘', 'ã€è‹±èªã€‘', 'ã€ãƒ­ã‚·ã‚¢èªã€‘', 'ã€ã‚¦ã‚ºãƒ™ã‚¯èªã€‘',
        'ã€ä¸­å›½èªã€‘', 'ã€éŸ“å›½èªã€‘', 'ã€ãƒˆãƒ«ã‚³èªã€‘',
        'ãƒ–ãƒ­ã‚°', 'blog post', 'seoè¨˜äº‹'
    ]
    
    # è¨˜äº‹ç”Ÿæˆç³»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    CONTENT_AGENTS = [
        'writer', 'writer_ja', 'writer_en', 'writer_ru',
        'writer_uz', 'writer_zh', 'writer_ko', 'writer_tr',
        'content'
    ]
    
    # M&Aé–¢é€£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚­ãƒ¼
    MA_PARAMETER_KEYS = [
        'cpt_slug', 'cpt_labels', 'cpt_supports',
        'acf_field_group_name', 'acf_fields', 'acf_location_rules',
        'taxonomy_slug', 'taxonomy_labels', 'taxonomy_post_types',
        'facets', 'role_slug', 'role_name'
    ]
    
    # è¨˜äº‹ç”Ÿæˆé–¢é€£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚­ãƒ¼
    CONTENT_PARAMETER_KEYS = [
        'language', 'polylang_lang', 'seo_keywords',
        'target_audience', 'target_url', 'article_type'
    ]
    
    @staticmethod
    def determine_task_type(task: dict) -> str:
        """ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            'ma' - M&A/ä¼æ¥­æ¤œç´¢ã‚¿ã‚¹ã‚¯
            'content' - è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯
            'review' - ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯
            'default' - ãã®ä»–ã®ã‚¿ã‚¹ã‚¯
        """
        description = task.get('description', '').lower()
        agent = task.get('required_role', '').lower()
        parameters = task.get('parameters', {})
        
        # 1. ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®åˆ¤å®š(æœ€å„ªå…ˆ)
        if agent == 'review' or 'review_target_task_id' in parameters:
            return 'review'
        
        # 2. M&Aé–¢é€£ã‚¿ã‚¹ã‚¯ã®åˆ¤å®š
        # 2-1. å¼·åŠ›ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒãƒ³ã‚°
        if any(keyword in description for keyword in TaskRouter.MA_STRONG_KEYWORDS):
            logger.debug(f"M&Aã‚¿ã‚¹ã‚¯åˆ¤å®š: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ")
            return 'ma'
        
        # 2-2. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆ¤å®š
        if any(key in parameters for key in TaskRouter.MA_PARAMETER_KEYS):
            logger.debug(f"M&Aã‚¿ã‚¹ã‚¯åˆ¤å®š: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒƒãƒ")
            return 'ma'
        
        # 2-3. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨èª¬æ˜ã®çµ„ã¿åˆã‚ã›
        if agent in ['wordpress', 'plugin']:
            # WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ç‰¹å®šã®æ©Ÿèƒ½
            if any(word in description for word in ['è¨­å®š', 'ä½œæˆ', 'setup', 'configure']):
                logger.debug(f"M&Aã‚¿ã‚¹ã‚¯åˆ¤å®š: WordPressã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ+è¨­å®š")
                return 'ma'
        
        # 3. è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã®åˆ¤å®š
        # 3-1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆåˆ¤å®š(æœ€ã‚‚ç¢ºå®Ÿ)
        if agent in TaskRouter.CONTENT_AGENTS:
            logger.debug(f"è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯åˆ¤å®š: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒãƒƒãƒ")
            return 'content'
        
        # 3-2. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆ¤å®š
        if any(key in parameters for key in TaskRouter.CONTENT_PARAMETER_KEYS):
            logger.debug(f"è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯åˆ¤å®š: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒãƒƒãƒ")
            return 'content'
        
        # 3-3. ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰åˆ¤å®š
        if any(keyword in description for keyword in TaskRouter.CONTENT_KEYWORDS):
            logger.debug(f"è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯åˆ¤å®š: ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒãƒ")
            return 'content'
        
        # 4. ãã®ä»–ã®ã‚¿ã‚¹ã‚¯
        logger.debug(f"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¹ã‚¯åˆ¤å®š")
        return 'default'
    
    @staticmethod
    def is_ma_task(task: dict) -> bool:
        """M&Aé–¢é€£ã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            M&Aã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        return TaskRouter.determine_task_type(task) == 'ma'
    
    @staticmethod
    def is_content_task(task: dict) -> bool:
        """è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            è¨˜äº‹ç”Ÿæˆã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        return TaskRouter.determine_task_type(task) == 'content'
    
    @staticmethod
    def is_review_task(task: dict) -> bool:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        
        Args:
            task: ã‚¿ã‚¹ã‚¯è¾æ›¸
            
        Returns:
            ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã®å ´åˆTrue
        """
        return TaskRouter.determine_task_type(task) == 'review'


# ============================================================================
# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ä½œæˆ
# ============================================================================

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
wp_config = WordPressConfig()
task_router = TaskRouter()


# ============================================================================
# PluginNameExtractor: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åæŠ½å‡ºã‚¯ãƒ©ã‚¹
# ============================================================================

class PluginNameExtractor:
    """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º"""

    @staticmethod
    def extract(description: str) -> str:
        """ã‚¿ã‚¹ã‚¯èª¬æ˜ã‹ã‚‰ãƒ—ãƒ©ã‚°ã‚¤ãƒ³åã‚’æŠ½å‡º
        
        Args:
            description: ã‚¿ã‚¹ã‚¯èª¬æ˜æ–‡
            
        Returns:
            æŠ½å‡ºã•ã‚ŒãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³å
        """
        # ã€Œã€ã€ã€ã§å›²ã¾ã‚ŒãŸéƒ¨åˆ†ã‚’æŠ½å‡º
        match = re.search(r'[ã€Œã€](.+?)[ã€ã€]', description)
        if match:
            return match.group(1)
        
        # è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯èª¬æ˜ã®å…ˆé ­50æ–‡å­—ã‚’è¿”ã™
        return description[:50]


# ============================================================================
# HTMLCleaner: HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã‚¯ãƒ©ã‚¹
# ============================================================================

class HTMLCleaner:
    """HTMLè¨˜äº‹ã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    
    WordPressæŠ•ç¨¿ç”¨ã«HTMLã‚’æœ€é©åŒ–ãƒ»ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã€‚
    - ä¸æ­£ãªãƒã‚¹ãƒˆã®ä¿®æ­£
    - WordPressã‚¯ãƒ©ã‚¹ã®è¿½åŠ 
    - Gutenbergãƒ–ãƒ­ãƒƒã‚¯å¯¾å¿œ
    - ã‚¿ã‚¤ãƒˆãƒ«ãƒ»æœ¬æ–‡ã®åˆ†é›¢
    """
        
    @staticmethod
    def clean_html_content(html_content: str) -> str:
        """HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚° - WordPressç”¨ã«æœ€é©åŒ–
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸHTML
        """
        try:
            logger.info("WordPressç”¨ã«HTMLã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ä¸­...")
            
            # åŸºæœ¬çš„ãªã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
            cleaned = html_content
            
            # 1. ä¸æ­£ãªãƒã‚¹ãƒˆã‚’ä¿®æ­£
            cleaned = re.sub(r'<p>\s*<div', '<div', cleaned)
            cleaned = re.sub(r'</div>\s*</p>', '</div>', cleaned)
            cleaned = re.sub(r'<p>\s*</p>', '', cleaned)
            
            # 2. é©åˆ‡ãªæ”¹è¡Œã‚’è¿½åŠ (èª­ã¿ã‚„ã™ã•ã®ãŸã‚)
            cleaned = re.sub(r'></(h1|h2|h3|h4|h5|h6|p|div|section|article)>', r'></\1>\n\n', cleaned)
            cleaned = re.sub(r'<(h1|h2|h3|h4|h5|h6|p|div|section|article)([^>]*)>', r'<\1\2>\n', cleaned)
            
            # 3. é€£ç¶šã™ã‚‹ç©ºç™½ã‚’å˜ä¸€ã‚¹ãƒšãƒ¼ã‚¹ã«
            cleaned = re.sub(r'\s+', ' ', cleaned)
            
            # 4. ã‚¿ã‚°é–“ã®ç©ºç™½ã‚’æ­£è¦åŒ–
            cleaned = re.sub(r'>\s+<', '> <', cleaned)
            
            # 5. WordPressç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            cleaned = HTMLCleaner._add_wordpress_classes(cleaned)
            
            # 6. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãªæ§‹é€ ã‚’ç¢ºèª
            lines = cleaned.split('\n')
            cleaned_lines = []
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                    
                # æ˜ã‚‰ã‹ã«ä¸æ­£ãªè¡Œã‚’ã‚¹ã‚­ãƒƒãƒ—
                if line in ['<p><div', '</div></p>']:
                    continue
                    
                cleaned_lines.append(line)
            
            cleaned = '\n'.join(cleaned_lines)
            
            logger.info(f"HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°å®Œäº†: {len(html_content)} â†’ {len(cleaned)}æ–‡å­—")
            return cleaned
            
        except Exception as e:
            logger.error(f"HTMLã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
    
    @staticmethod
    def _add_wordpress_classes(html_content: str) -> str:
        """WordPressç”¨ã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ã—ã¦ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            WordPressã‚¯ãƒ©ã‚¹ãŒè¿½åŠ ã•ã‚ŒãŸHTML
        """
        try:
            # è¦‹å‡ºã—ã«WordPressã®ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            html_content = re.sub(r'<h1([^>]*)>', r'<h1\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h2([^>]*)>', r'<h2\1 class="wp-block-heading has-large-font-size">', html_content)
            html_content = re.sub(r'<h3([^>]*)>', r'<h3\1 class="wp-block-heading has-medium-font-size">', html_content)
            
            # æ®µè½ã«ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            html_content = re.sub(r'<p([^>]*)>', r'<p\1 class="wp-block-paragraph">', html_content)
            
            # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
            html_content = re.sub(r'<section([^>]*)>', r'<section\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<article([^>]*)>', r'<article\1 class="wp-block-group">', html_content)
            html_content = re.sub(r'<div class="article-meta"', r'<div class="wp-block-group article-meta"', html_content)
            html_content = re.sub(r'<div class="intro"', r'<div class="wp-block-group intro"', html_content)
            html_content = re.sub(r'<div class="main-content"', r'<div class="wp-block-group main-content"', html_content)
            
            return html_content
            
        except Exception as e:
            logger.error(f"WordPressã‚¯ãƒ©ã‚¹è¿½åŠ ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
        
    @staticmethod
    def validate_html_structure(html_content: str) -> bool:
        """HTMLæ§‹é€ ã®åŸºæœ¬çš„ãªæ¤œè¨¼
        
        Args:
            html_content: æ¤œè¨¼ã™ã‚‹HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            æ§‹é€ ãŒæ­£ã—ã„å ´åˆTrue
        """
        try:
            # åŸºæœ¬çš„ãªã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
            open_tags = len(re.findall(r'<(\w+)[^>]*>', html_content))
            close_tags = len(re.findall(r'</(\w+)>', html_content))
                
            # divã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ç‰¹åˆ¥ã«ãƒã‚§ãƒƒã‚¯
            div_open = html_content.count('<div')
            div_close = html_content.count('</div>')
                
            logger.info(f"HTMLæ§‹é€ æ¤œè¨¼: ã‚¿ã‚°{open_tags}/{close_tags}, div{div_open}/{div_close}")
                
            # divã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ã‚‹ã‹
            if div_open != div_close:
                logger.warning(f"divã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ãŒå–ã‚Œã¦ã„ã¾ã›ã‚“: {div_open} != {div_close}")
                return False
                    
            return True
                
        except Exception as e:
            logger.error(f"HTMLæ¤œè¨¼ã‚¨ãƒ©ãƒ¼: {e}")
            return False
        
    @staticmethod
    def extract_title_from_html(html_content: str) -> Tuple[str, str]:
        """HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            (ã‚¿ã‚¤ãƒˆãƒ«, ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã•ã‚ŒãŸHTMLæœ¬æ–‡)ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            logger.info("HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºä¸­...")
                
            # è¤‡æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¤œç´¢
            title_patterns = [
                r'<h1[^>]*>(.*?)</h1>',
                r'<title[^>]*>(.*?)</title>',
                r'<h2[^>]*>(.*?)</h2>',
                r'<h3[^>]*>(.*?)</h3>'
            ]
                
            for pattern in title_patterns:
                match = re.search(pattern, html_content, re.IGNORECASE | re.DOTALL)
                if match:
                    title_html = match.group(1)
                    # HTMLã‚¿ã‚°ã‚’é™¤å»ã—ã¦ã‚¿ã‚¤ãƒˆãƒ«ã‚’å–å¾—
                    title = re.sub(r'<[^>]+>', '', title_html).strip()
                        
                    if title and len(title) > 5:  # æœ€ä½5æ–‡å­—ä»¥ä¸Š
                        logger.info(f"âœ… HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºæˆåŠŸ: {title}")
                            
                        # ã‚¿ã‚¤ãƒˆãƒ«éƒ¨åˆ†ã‚’é™¤å»ã—ãŸæœ¬æ–‡ã‚’ä½œæˆ
                        body = re.sub(pattern, '', html_content, flags=re.IGNORECASE | re.DOTALL)
                        body = body.strip()
                            
                        # æœ¬æ–‡ã‚’ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
                        body = HTMLCleaner.clean_html_content(body)
                            
                        return title, body
                
            logger.warning("âŒ HTMLã‹ã‚‰ã‚¿ã‚¤ãƒˆãƒ«ã‚’æŠ½å‡ºã§ãã¾ã›ã‚“ã§ã—ãŸ")
            return "ã‚¿ã‚¤ãƒˆãƒ«ä¸æ˜", HTMLCleaner.clean_html_content(html_content)
                
        except Exception as e:
            logger.error(f"HTMLã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return "ã‚¿ã‚¤ãƒˆãƒ«æŠ½å‡ºã‚¨ãƒ©ãƒ¼", html_content
        
    @staticmethod
    def prepare_html_for_wordpress(html_content: str) -> Tuple[str, str]:
        """WordPressç”¨ã«HTMLã‚’æº–å‚™(æ”¹å–„ç‰ˆ)
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            (ã‚¿ã‚¤ãƒˆãƒ«, WordPressç”¨HTMLæœ¬æ–‡)ã®ã‚¿ãƒ—ãƒ«
        """
        try:
            logger.info("WordPressç”¨ã«HTMLã‚’æº–å‚™ä¸­...")
            
            # ã‚¿ã‚¤ãƒˆãƒ«ã¨æœ¬æ–‡ã‚’åˆ†é›¢
            title, body = HTMLCleaner.extract_title_from_html(html_content)
            
            # HTMLã‚’WordPressç”¨ã«æœ€é©åŒ–
            wp_html = HTMLCleaner._optimize_for_wordpress_gutenberg(body)
            
            logger.info(f"âœ… WordPressç”¨HTMLæº–å‚™å®Œäº†: ã‚¿ã‚¤ãƒˆãƒ«='{title}', æœ¬æ–‡={len(wp_html)}æ–‡å­—")
            return title, wp_html
            
        except Exception as e:
            logger.error(f"WordPressç”¨HTMLæº–å‚™ã‚¨ãƒ©ãƒ¼: {e}")
            return "HTMLå‡¦ç†ã‚¨ãƒ©ãƒ¼", html_content
        
    @staticmethod
    def _optimize_for_wordpress(html_content: str) -> str:
        """WordPressç”¨ã«HTMLã‚’æœ€é©åŒ–
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            æœ€é©åŒ–ã•ã‚ŒãŸHTML
        """
        try:
            optimized = html_content
                
            # 1. ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯ãªã‚¿ã‚°ã‚’ç¶­æŒ
            # 2. ä¸æ­£ãªãƒã‚¹ãƒˆã‚’ä¿®æ­£
            optimized = re.sub(r'<p>\s*<(div|section|article)', r'<\1', optimized)
            optimized = re.sub(r'</(div|section|article)>\s*</p>', r'</\1>', optimized)
                
            # 3. ç©ºã®æ®µè½ã‚’å‰Šé™¤
            optimized = re.sub(r'<p>\s*</p>', '', optimized)
                
            # 4. é€£ç¶šã™ã‚‹æ”¹è¡Œã‚’æ•´ç†
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
                
            # 5. åŸºæœ¬çš„ãªHTMLæ§‹é€ ã‚’ç¢ºä¿
            if not optimized.strip().startswith('<'):
                optimized = f'<div class="article-content">\n{optimized}\n</div>'
                
            return optimized
                
        except Exception as e:
            logger.error(f"HTMLæœ€é©åŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
    
    @staticmethod
    def _optimize_for_wordpress_gutenberg(html_content: str) -> str:
        """Gutenbergã‚¨ãƒ‡ã‚£ã‚¿ç”¨ã«HTMLã‚’æœ€é©åŒ–
        
        Args:
            html_content: å…ƒã®HTMLã‚³ãƒ³ãƒ†ãƒ³ãƒ„
            
        Returns:
            Gutenbergæœ€é©åŒ–ã•ã‚ŒãŸHTML
        """
        try:
            # ã¾ãšåŸºæœ¬ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
            optimized = HTMLCleaner.clean_html_content(html_content)
            
            # Gutenbergãƒ–ãƒ­ãƒƒã‚¯ç”¨ã®æ§‹é€ ã‚’è¿½åŠ 
            optimized = HTMLCleaner._wrap_in_gutenberg_blocks(optimized)
            
            # æœ€çµ‚çš„ãªæ”¹è¡Œèª¿æ•´
            optimized = re.sub(r'\n\s*\n', '\n\n', optimized)
            optimized = optimized.strip()
            
            return optimized
            
        except Exception as e:
            logger.error(f"Gutenbergæœ€é©åŒ–ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
    
    @staticmethod
    def _wrap_in_gutenberg_blocks(html_content: str) -> str:
        """
        HTMLã‚’Gutenbergãƒ–ãƒ­ãƒƒã‚¯ã§ãƒ©ãƒƒãƒ—
        """
        try:
            blocks = []
            lines = html_content.split('\n')
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # è¦‹å‡ºã—ãƒ–ãƒ­ãƒƒã‚¯
                if line.startswith('<h1') or line.startswith('<h2') or line.startswith('<h3'):
                    blocks.append(f'<!-- wp:heading -->\n{line}\n<!-- /wp:heading -->')
                
                # æ®µè½ãƒ–ãƒ­ãƒƒã‚¯
                elif line.startswith('<p'):
                    blocks.append(f'<!-- wp:paragraph -->\n{line}\n<!-- /wp:paragraph -->')
                
                # ã‚°ãƒ«ãƒ¼ãƒ—ãƒ–ãƒ­ãƒƒã‚¯(ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã€è¨˜äº‹ãƒ¡ã‚¿ãªã©)
                elif line.startswith('<section') or line.startswith('<article') or line.startswith('<div class="wp-block-group"'):
                    if line.startswith('</section') or line.startswith('</article') or line.startswith('</div'):
                        blocks.append(line)
                    else:
                        blocks.append(f'<!-- wp:group -->\n{line}')
                
                # ãã®ä»–ã®è¦ç´ 
                else:
                    blocks.append(line)
            
            # é–‰ã˜ã‚¿ã‚°ã®å‡¦ç†
            result = []
            for block in blocks:
                if any(tag in block for tag in ['</section>', '</article>', '</div>']):
                    result.append(f'{block}\n<!-- /wp:group -->')
                else:
                    result.append(block)
            
            return '\n\n'.join(result)
            
        except Exception as e:
            logger.error(f"Gutenbergãƒ–ãƒ­ãƒƒã‚¯ãƒ©ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
            return html_content
        
    @staticmethod
    def is_valid_html(html_content: str) -> bool:
        """
        HTMLãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
        """
        try:
            # åŸºæœ¬çš„ãªãƒã‚§ãƒƒã‚¯
            if not html_content or len(html_content.strip()) < 10:
                return False
                
            # HTMLã‚¿ã‚°ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯
            if '<' not in html_content or '>' not in html_content:
                return False
                
            # åŸºæœ¬çš„ãªã‚¿ã‚°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
            return HTMLCleaner.validate_html_structure(html_content)
                
        except Exception as e:
            logger.error(f"HTMLæœ‰åŠ¹æ€§ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: {e}")
            return False