import asyncio
import time
import json
import re
import aiohttp
from pathlib import Path
from typing import Optional, Dict, List
from playwright.async_api import async_playwright, Page, BrowserContext
import logging
from datetime import datetime

from config_utils import config, ErrorHandler, FileNameGenerator

logger = logging.getLogger(__name__)

class BrowserController:
    """ブラウザ制御クラス（拡張版：画像・テキスト両対応・DeepSeek対応）"""
    
    def __init__(self, download_folder: Path, mode: str = "image", service: str = "google", credentials: Dict = None):
        self.download_folder = download_folder
        self.mode = mode
        self.service = service.lower()  # "google" or "deepseek"
        self.credentials = credentials or {}
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.cookies_file = Path(config.COOKIES_FILE) if config.COOKIES_FILE else None
        self.browser_data_dir = Path(config.BROWSER_DATA_DIR) if config.BROWSER_DATA_DIR else None
        
        self.download_folder.mkdir(exist_ok=True, parents=True)
        if self.browser_data_dir:
            self.browser_data_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup_browser(self) -> None:
        """ブラウザの初期化（マルチモニター対応版）"""
        try:
            logger.info("="*60)
            logger.info("ブラウザ起動開始...")
            logger.info("="*60)
            
            # 既存のプロセスクリーンアップ
            await self._cleanup_existing_browser_processes()
            
            playwright = await async_playwright().start()
            logger.info(f"ユーザーデータディレクトリ: {self.browser_data_dir}")
            
            # ★★★ マルチモニター対応: ウィンドウ位置とサイズを指定 ★★★
            # 5画面環境の右上に配置
            # モニター解像度に応じて調整してください
            window_width = 1280   # ウィンドウ幅 1920  右上だった　1600
            window_height = 700  # ウィンドウ高さ 1080  右上だった　900
            
            # 5画面目（右端）の座標
            # 例: 各モニターが1920x1080の場合
            # 5画面目の左上は x=7680 (1920*4)
            x_position = 5000  # 5画面目の左端 1st 7680  右上だった、2nd 6000　右下だった
            y_position = 1500     # 上端 1st 0  右上だった、2nd 500右下だった
            
            # ブラウザ起動（位置とサイズ指定）
            self.context = await playwright.chromium.launch_persistent_context(
                user_data_dir=str(self.browser_data_dir),
                viewport={'width': window_width, 'height': window_height},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                accept_downloads=True,
                ignore_https_errors=True,
                # ★★★ ウィンドウ位置を指定 ★★★
                no_viewport=False,
                **config.BROWSER_CONFIG
            )
            
            logger.info("✅ ブラウザコンテキスト作成成功")
            
            # ページ作成
            self.page = await self.context.new_page()
            
            # ★★★ ウィンドウを指定位置に移動 ★★★
            await self.page.evaluate(f"""
                window.moveTo({x_position}, {y_position});
                window.resizeTo({window_width}, {window_height});
            """)
            
            logger.info(f"✅ ウィンドウを位置 ({x_position}, {y_position}) に配置")
            
            # ブラウザが正常に起動したか確認
            await asyncio.sleep(2)
            if not await self._is_browser_alive():
                raise Exception("ブラウザが起動直後にクラッシュしました")
            
            logger.info("✅ ブラウザ生存確認完了")
            
            # 自動化検出を回避
            await self.page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false,
                });
                window.navigator.chrome = {
                    runtime: {},
                };
                const originalQuery = window.navigator.permissions.query;
                window.navigator.permissions.query = (parameters) => (
                    parameters.name === 'notifications' ?
                        Promise.resolve({ state: Notification.permission }) :
                        originalQuery(parameters)
                );
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['ja-JP', 'ja', 'en-US', 'en'],
                });
            """)
            
            self.page.set_default_timeout(config.PAGE_TIMEOUT)
            self.page.set_default_navigation_timeout(config.PAGE_TIMEOUT)
            
            logger.info("="*60)
            logger.info(f"✅ ブラウザ起動完了（モード: {self.mode}、サービス: {self.service}）")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ブラウザ起動")
            logger.error("="*60)
            logger.error("❌ ブラウザ起動失敗")
            logger.error("="*60)
            
            # 詳細なエラー情報
            logger.error(f"エラー詳細: {str(e)}")
            logger.error(f"ブラウザデータディレクトリ: {self.browser_data_dir}")
            
            # クリーンアップを試みる
            await self._cleanup_existing_browser_processes()
            
            raise Exception(f"ブラウザ起動に失敗しました: {str(e)}")
    
    async def _is_browser_alive(self) -> bool:
        """ブラウザが生きているか確認"""
        try:
            if not self.page:
                return False
            
            # 簡単なJavaScript実行で生存確認
            result = await self.page.evaluate("1 + 1")
            return result == 2
        except Exception as e:
            logger.warning(f"ブラウザ生存確認失敗: {e}")
            return False
    
    async def _cleanup_existing_browser_processes(self):
        """既存のChromiumプロセスをクリーンアップ"""
        try:
            import psutil
            
            logger.info("既存のChromiumプロセスを確認中...")
            
            killed_count = 0
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if 'chrome' in proc.info['name'].lower() or 'chromium' in proc.info['name'].lower():
                        # 自分のブラウザデータディレクトリを使用しているプロセスのみ終了
                        cmdline = proc.cmdline()
                        if str(self.browser_data_dir) in ' '.join(cmdline):
                            logger.warning(f"既存のChromiumプロセスを終了: PID={proc.info['pid']}")
                            proc.kill()
                            killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if killed_count > 0:
                logger.info(f"✅ {killed_count}個のプロセスを終了しました")
                await asyncio.sleep(2)  # プロセス終了を待つ
            else:
                logger.info("既存プロセスなし")
                
        except ImportError:
            logger.warning("psutilがインストールされていません。プロセスクリーンアップをスキップ")
        except Exception as e:
            logger.warning(f"プロセスクリーンアップエラー: {e}")
    
    async def navigate_to_gemini(self) -> None:
        """Geminiサイトにアクセス（クラッシュ検知強化版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            
            # ブラウザが生きているか確認
            if not await self._is_browser_alive():
                raise Exception("ブラウザが既にクラッシュしています")
            
            logger.info("Geminiサイトにアクセス中...")
            
            # クッキー読み込み
            cookies_loaded = await self.load_cookies()
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiサイトへのアクセス試行 {attempt}/{max_attempts}")
                    
                    # ブラウザ生存確認
                    if not await self._is_browser_alive():
                        raise Exception("ブラウザがアクセス前にクラッシュしました")
                    
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    
                    # アクセス後も生存確認
                    await asyncio.sleep(3)
                    if not await self._is_browser_alive():
                        raise Exception("ブラウザがアクセス後にクラッシュしました")
                    
                    logger.info("✅ Geminiサイトへのアクセスが成功しました")
                    break
                    
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    
                    # ブラウザがクラッシュしていないか確認
                    if not await self._is_browser_alive():
                        logger.error("❌ ブラウザがクラッシュしました")
                        raise Exception("ブラウザクラッシュを検出")
                    
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました")
                        logger.error("手動でページをリロードしてください")
                        
                        # ブラウザが生きている場合のみ手動介入を求める
                        if await self._is_browser_alive():
                            input("Geminiページが読み込まれたら、Enterキーを押してください: ")
                        else:
                            raise Exception("ブラウザがクラッシュしているため、続行できません")
                    else:
                        logger.info("5秒後に再試行します...")
                        await asyncio.sleep(5)
            
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            
            await self.save_cookies()
            await self.handle_welcome_screens()
            
            logger.info("✅ Geminiサイトの準備が完了しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiアクセス")
            
            # ブラウザ状態を確認
            if await self._is_browser_alive():
                logger.info("ブラウザは生きています。手動でGeminiページを開いてください")
                input("準備完了後、Enterキーを押してください: ")
            else:
                logger.error("❌ ブラウザがクラッシュしています。再起動が必要です")
                raise Exception("ブラウザクラッシュのため続行不可")
    
    async def save_cookies(self) -> None:
        """クッキーを保存（強化版）"""
        try:
            if not self.context or not self.cookies_file:
                logger.warning("クッキー保存: コンテキストまたはファイルパスがありません")
                return
            
            # 現在のページのクッキーを取得
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("保存するクッキーがありません")
                return
                
            # ファイルに保存
            with open(self.cookies_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"✅ クッキーを保存しました: {len(cookies)}個のクッキー")
            
        except Exception as e:
            ErrorHandler.log_error(e, "クッキー保存")
            logger.warning("クッキー保存に失敗しましたが続行します")

    async def load_cookies(self) -> bool:
        """クッキーを読み込み（強化版）"""
        try:
            if not self.cookies_file or not self.cookies_file.exists():
                logger.warning("クッキーファイルが存在しません")
                return False
                
            if not self.context:
                logger.warning("コンテキストが初期化されていません")
                return False
                
            with open(self.cookies_file, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
            
            if not cookies:
                logger.warning("クッキーファイルが空です")
                return False
                
            # 現在のURLにクッキーを追加
            current_url = self.page.url if self.page else "https://gemini.google.com"
            domain_cookies = []
            
            for cookie in cookies:
                # ドメインを調整
                if 'domain' in cookie and cookie['domain'].startswith('.'):
                    cookie['domain'] = cookie['domain'][1:]
                
                # 有効期限をチェック
                if 'expires' in cookie and cookie['expires'] < time.time():
                    continue
                    
                domain_cookies.append(cookie)
            
            if domain_cookies:
                await self.context.add_cookies(domain_cookies)
                logger.info(f"✅ クッキーを読み込みました: {len(domain_cookies)}個")
                
                # クッキー読み込み後にページをリフレッシュ
                if self.page:
                    await self.page.reload()
                    await self.page.wait_for_timeout(3000)
                
                return True
            else:
                logger.warning("有効なクッキーがありません")
                return False
                
        except Exception as e:
            ErrorHandler.log_error(e, "クッキー読み込み")
            return False
    
    async def check_google_login_status(self) -> bool:
        """現在のGoogleログイン状態をチェック"""
        try:
            if not self.page:
                return False
            logger.info("Googleログイン状態を確認中...")
            await self.page.goto("https://myaccount.google.com/", timeout=15000, wait_until="domcontentloaded")
            await self.page.wait_for_timeout(2000)
            current_url = self.page.url
            if "myaccount.google.com" in current_url:
                logger.info("既にGoogleアカウントにログイン済みです")
                return True
            elif "accounts.google.com" in current_url:
                logger.info("Googleアカウントへのログインが必要です")
                return False
            else:
                logger.info("ログイン状態が不明です")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "ログイン状態確認")
            return False
    
    async def navigate_to_gemini(self) -> None:
        """Geminiサイトにアクセス"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            logger.info("Geminiサイトにアクセス中...")
            cookies_loaded = await self.load_cookies()
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiサイトへのアクセス試行 {attempt}/{max_attempts}")
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(8000)
                    logger.info("Geminiサイトへのアクセスが成功しました")
                    break
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました。手動でページをリロードしてください")
                        input("Geminiページが読み込まれたら、Enterキーを押してください: ")
                    else:
                        logger.info("5秒後に再試行します...")
                        await self.page.wait_for_timeout(5000)
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            await self.save_cookies()
            await self.handle_welcome_screens()
            logger.info("Geminiサイトの準備が完了しました")
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiアクセス")
            logger.info("手動でGeminiページを開いてください")
            input("準備完了後、Enterキーを押してください: ")
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekサイトにアクセス（Cloudflareボット検証対応版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            logger.info("DeepSeekサイトにアクセス中...")
            cookies_loaded = await self.load_cookies()
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"DeepSeekサイトへのアクセス試行 {attempt}/{max_attempts}")
                    await self.page.goto("https://chat.deepseek.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(5000)
                    logger.info("DeepSeekサイトへのアクセスが成功しました")
                    break
                except Exception as e:
                    logger.warning(f"試行 {attempt} 失敗: {e}")
                    if attempt == max_attempts:
                        logger.error("全ての試行が失敗しました。手動でページをリロードしてください")
                        input("DeepSeekページが読み込まれたら、Enterキーを押してください: ")
                    else:
                        logger.info("5秒後に再試行します...")
                        await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            logger.info(f"現在のURL: {current_url}")
            
            # Cloudflareボット検証チェック
            logger.info("Cloudflareボット検証をチェック中...")
            cloudflare_check = await self.page.evaluate('''
                () => {
                    const body = document.body.innerText || '';
                    if (body.includes('Verifying you are human') || 
                        body.includes('あなたがボットではないことを確認') ||
                        body.includes('Just a moment') ||
                        body.includes('Checking your browser')) {
                        return true;
                    }
                    return false;
                }
            ''')
            
            if cloudflare_check:
                logger.warning("⚠️ Cloudflareボット検証が検出されました")
                logger.info("ブラウザで自動的にチェックが完了するまで待機します...")
                logger.info("（通常5-30秒で完了します。手動操作は不要です）")
                
                # 最大60秒待つ
                start_time = time.time()
                while time.time() - start_time < 60:
                    await self.page.wait_for_timeout(3000)
                    
                    # チェックが完了したか確認
                    still_checking = await self.page.evaluate('''
                        () => {
                            const body = document.body.innerText || '';
                            if (body.includes('Verifying you are human') || 
                                body.includes('あなたがボットではないことを確認') ||
                                body.includes('Just a moment') ||
                                body.includes('Checking your browser')) {
                                return true;
                            }
                            return false;
                        }
                    ''')
                    
                    if not still_checking:
                        logger.info("✅ Cloudflare検証が完了しました")
                        break
                    
                    elapsed = int(time.time() - start_time)
                    if elapsed % 10 == 0:
                        logger.info(f"待機中... {elapsed}秒経過")
                
                # 完了後、URLを再確認
                await self.page.wait_for_timeout(3000)
                current_url = self.page.url
                logger.info(f"検証後のURL: {current_url}")
            
            # ログインページにいるかチェック
            if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                logger.info("\n" + "="*60)
                logger.info("⚠️ DeepSeekへのログインが必要です")
                logger.info("="*60)
                logger.info("")
                logger.info("📌 ログイン手順：")
                logger.info("1. ブラウザで「Log in with Google」ボタンをクリック")
                logger.info("2. Googleアカウントを選択（または入力）")
                logger.info(f"   使用するアカウント: {self.credentials.get('email', 'B2セルのGoogle ID') if hasattr(self, 'credentials') else 'B2セルのGoogle ID'}")
                logger.info("3. ログイン完了を待つ")
                logger.info("4. チャット画面が表示されたら、このコンソールに戻ってEnterキーを押す")
                logger.info("")
                logger.info("💡 ヒント：")
                logger.info("  - 「Chrome は自動テスト...」メッセージは無視してください")
                logger.info("  - Googleログインは通常通り動作します")
                logger.info("  - 2回目以降はCookieで自動ログインされます")
                logger.info("="*60)
                
                input("\n✅ ログイン完了後、Enterキーを押してください: ")
                
                # ログイン後のURLを確認
                await self.page.wait_for_timeout(2000)
                current_url = self.page.url
                logger.info(f"ログイン後のURL: {current_url}")
                
                # まだログインページにいる場合
                if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                    logger.warning("⚠️ まだログインページにいます")
                    logger.info("もう一度「Log in with Google」をクリックしてください")
                    input("完了後、Enterキーを押してください: ")
                    await self.page.wait_for_timeout(2000)
            
            # チャット画面に到達できているか確認
            await self.page.wait_for_timeout(3000)
            chat_ready = await self.page.evaluate('''
                () => {
                    // テキストエリアやinputがあればOK
                    const inputs = document.querySelectorAll('textarea, input[type="text"]');
                    return inputs.length > 0;
                }
            ''')
            
            if not chat_ready:
                logger.warning("⚠️ チャット画面が見つかりません")
                logger.info("ブラウザでチャット画面が表示されるまで待機してください")
                logger.info("（ページを手動でリロードする必要がある場合があります）")
                input("\n✅ チャット画面が表示されたら、Enterキーを押してください: ")
            else:
                logger.info("✅ チャット画面を確認しました")
            
            await self.save_cookies()
            logger.info("✅ DeepSeekサイトの準備が完了しました")
            logger.info("💾 Cookieを保存しました - 次回から自動ログインされます")
            
        except Exception as e:
            ErrorHandler.log_error(e, "DeepSeekアクセス")
            logger.info("手動でDeepSeekページを開いてください")
            input("準備完了後、Enterキーを押してください: ")
    
    async def handle_welcome_screens(self) -> None:
        """利用規約やウェルカム画面を処理"""
        try:
            if not self.page:
                return
            logger.info("ウェルカム画面やポップアップを確認中...")
            continue_buttons = [
                'text=続行', 'text=開始', 'text=同意', 'text=Continue',
                'text=Get started', 'text=Agree', 'text=Got it', 'text=OK',
                '[data-testid="continue-button"]'
            ]
            start_time = time.time()
            found_buttons = 0
            while time.time() - start_time < 10 and found_buttons < 3:
                for button_selector in continue_buttons:
                    try:
                        button = await self.page.query_selector(button_selector)
                        if button and await button.is_visible():
                            await button.click()
                            await self.page.wait_for_timeout(2000)
                            logger.info(f"ボタンをクリックしました: {button_selector}")
                            found_buttons += 1
                            break
                    except Exception:
                        continue
                await self.page.wait_for_timeout(1000)
            if found_buttons > 0:
                logger.info(f"{found_buttons}個のウェルカム画面を処理しました")
            else:
                logger.info("ウェルカム画面は見つかりませんでした（正常）")
        except Exception as e:
            ErrorHandler.log_error(e, "ウェルカム画面処理")
    
    async def ensure_normal_chat_mode(self) -> None:
        """通常のチャットモードであることを確認（Storybookを回避）- 強化版"""
        try:
            if not self.page:
                return
            logger.info("チャットモードを確認中...")
            current_url = self.page.url
            if 'storybook' in current_url.lower():
                logger.warning("StorybookのURLが検出されました。通常モードに戻します...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("通常のチャットモードに戻しました")
                return
            storybook_active = await self.page.evaluate('''
                () => {
                    const buttons = document.querySelectorAll('button');
                    for (const btn of buttons) {
                        const text = btn.textContent || '';
                        const ariaLabel = btn.getAttribute('aria-label') || '';
                        if ((text.includes('Storybook') || ariaLabel.includes('Storybook')) &&
                            (btn.getAttribute('aria-pressed') === 'true' || 
                             btn.classList.contains('active') ||
                             btn.classList.contains('selected'))) {
                            return true;
                        }
                    }
                    return false;
                }
            ''')
            if storybook_active:
                logger.warning("Storybookモードが検出されました。通常モードに戻します...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("通常のチャットモードに戻しました")
            else:
                logger.info("通常のチャットモードです")
        except Exception as e:
            ErrorHandler.log_error(e, "チャットモード確認")
    
    async def send_prompt(self, prompt: str) -> None:
        """プロンプトを入力して送信（サービス自動判別版）"""
        try:
            if not self.page:
                raise Exception("ページが初期化されていません")
            await self.ensure_normal_chat_mode()
            logger.info(f"プロンプトを送信中: {prompt[:50]}...")
            
            if self.service == "deepseek":
                await self.send_prompt_deepseek(prompt)
            else:
                await self.send_prompt_gemini(prompt)
                
        except Exception as e:
            ErrorHandler.log_error(e, "プロンプト送信")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_gemini(self, prompt: str) -> None:
        """Geminiでプロンプトを送信（ポップアップ対応版）"""
        try:
            # 入力欄を探す
            input_selectors = [
                'textarea[placeholder*="メッセージを Gemini に送信"]',
                'textarea[placeholder*="Send a message to Gemini"]',
                'div[contenteditable="true"][role="textbox"]',
                'textarea[data-testid="message-input"]',
                'div.ql-editor[contenteditable="true"]',
                'textarea.ql-editor'
            ]
            
            input_element = None
            for selector in input_selectors:
                try:
                    await self.page.wait_for_selector(selector, timeout=5000)
                    input_element = await self.page.query_selector(selector)
                    if input_element:
                        logger.info(f"入力欄を発見: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                await self.page.screenshot(path="debug_input_not_found.png")
                raise Exception("入力欄が見つかりません")
            
            # ★★★ ポップアップ・オーバーレイを閉じる処理（追加） ★★★
            try:
                # 1. メール配信登録ポップアップの「後で」ボタンをクリック
                later_button_selectors = [
                    'button:has-text("後で")',
                    'button:has-text("Later")',
                    '[aria-label*="後で"]',
                    '[aria-label*="Later"]'
                ]
                
                for selector in later_button_selectors:
                    try:
                        later_button = await self.page.query_selector(selector)
                        if later_button and await later_button.is_visible():
                            await later_button.click()
                            await self.page.wait_for_timeout(1000)
                            logger.info("✅ メール配信ポップアップを閉じました")
                            break
                    except:
                        continue
                
                # 2. オーバーレイ全体を閉じる（バックドロップクリック）
                overlay_backdrop = await self.page.query_selector('.cdk-overlay-backdrop')
                if overlay_backdrop:
                    try:
                        await overlay_backdrop.click()
                        await self.page.wait_for_timeout(500)
                        logger.info("✅ オーバーレイを閉じました")
                    except:
                        pass
                
                # 3. Escキーでポップアップを閉じる（最終手段）
                await self.page.keyboard.press('Escape')
                await self.page.wait_for_timeout(500)
                
            except Exception as e:
                logger.debug(f"ポップアップ処理: {e}")
            # ★★★ ここまで追加 ★★★
            
            # 入力欄をクリック
            await input_element.click()
            await self.page.wait_for_timeout(500)
            
            # 既存のテキストをクリア
            await self.page.keyboard.press("Control+a")
            await self.page.wait_for_timeout(500)
            
            # プロンプトを入力
            await input_element.fill(prompt)
            await self.page.wait_for_timeout(1500)
            
            # 送信ボタンをクリック
            send_selectors = [
                'button[data-testid="send-button"]',
                '[data-testid="send-button"]'
            ]
            
            sent = False
            for selector in send_selectors:
                try:
                    send_button = await self.page.query_selector(selector)
                    if send_button and await send_button.is_enabled():
                        await send_button.click()
                        logger.info("送信ボタンをクリックしました")
                        sent = True
                        break
                except:
                    continue
            
            if not sent:
                await input_element.press('Enter')
                logger.info("Enterキーで送信しました")
            
            await self.page.wait_for_timeout(3000)
            
        except Exception as e:
            ErrorHandler.log_error(e, "プロンプト送信")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_deepseek(self, prompt: str) -> None:
        """DeepSeekでプロンプトを送信（改善版）"""
        # まずスクリーンショットを撮って状態を確認
        debug_screenshot = f"debug_deepseek_before_input_{datetime.now().strftime('%H%M%S')}.png"
        try:
            await self.page.screenshot(path=debug_screenshot)
            logger.info(f"📸 入力前のスクリーンショット: {debug_screenshot}")
        except:
            pass
        
        # 複数の可能性のあるセレクタを試す
        input_selectors = [
            # DeepSeek特有のセレクタ
            'textarea[placeholder*="Ask"]',
            'textarea[placeholder*="Type"]',
            'textarea[placeholder*="message"]',
            'textarea[placeholder*="メッセージ"]',
            'textarea[placeholder*="入力"]',
            # 汎用的なセレクタ
            'div[contenteditable="true"][role="textbox"]',
            'div[contenteditable="true"]',
            'textarea',
            'input[type="text"]',
        ]
        
        input_element = None
        used_selector = None
        
        # 各セレクタを順番に試す
        for selector in input_selectors:
            try:
                logger.info(f"入力欄を探索中: {selector}")
                element = await self.page.query_selector(selector)
                if element:
                    # 要素が見えているか確認
                    is_visible = await element.is_visible()
                    if is_visible:
                        input_element = element
                        used_selector = selector
                        logger.info(f"✅ 入力欄を発見: {selector}")
                        break
                    else:
                        logger.info(f"要素は存在するが非表示: {selector}")
            except Exception as e:
                logger.debug(f"セレクタ {selector} でエラー: {e}")
                continue
        
        if not input_element:
            # 全セレクタで失敗した場合
            await self.page.screenshot(path="debug_deepseek_input_not_found.png")
            logger.error("❌ DeepSeek入力欄が見つかりません")
            logger.error("以下を確認してください：")
            logger.error("1. ログインが完了していますか？")
            logger.error("2. チャット画面が表示されていますか？")
            logger.error("3. Cloudflareの検証は完了しましたか？")
            
            # ページのHTMLをデバッグ出力
            page_content = await self.page.evaluate('document.body.innerText')
            logger.info(f"ページ内容（先頭500文字）:\n{page_content[:500]}")
            
            # 手動介入を促す
            logger.info("\n手動で入力欄が見えるまで操作してください")
            input("入力欄が表示されたら、Enterキーを押してください: ")
            
            # 再度探す
            for selector in input_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element and await element.is_visible():
                        input_element = element
                        used_selector = selector
                        logger.info(f"✅ 入力欄を発見（2回目）: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                raise Exception("入力欄が見つかりません（2回目の試行後）")
        
        # 入力欄にフォーカス
        await input_element.click()
        await self.page.wait_for_timeout(500)
        
        # プロンプトを入力
        await input_element.fill(prompt)
        await self.page.wait_for_timeout(1500)
        
        # 送信ボタンを探す
        send_button = None
        send_selectors = [
            'button[type="submit"]',
            'button[aria-label*="Send"]',
            'button[aria-label*="送信"]',
            'button:has-text("送信")',
            'button:has-text("Send")',
            'button svg',  # アイコンボタン
        ]
        
        for selector in send_selectors:
            try:
                btn = await self.page.query_selector(selector)
                if btn and await btn.is_visible() and await btn.is_enabled():
                    send_button = btn
                    logger.info(f"送信ボタンを発見: {selector}")
                    break
            except:
                continue
        
        if send_button:
            await send_button.click()
            logger.info("✅ DeepSeek送信ボタンをクリックしました")
        else:
            # ボタンが見つからない場合はEnterキーで送信
            logger.info("送信ボタンが見つからないため、Enterキーで送信します")
            await input_element.press("Enter")
            logger.info("✅ Enterキーで送信しました")
        
        await self.page.wait_for_timeout(3000)
    
    async def wait_for_text_generation(self, max_wait: int = 120) -> bool:
        """テキスト生成完了まで待機"""
        try:
            if not self.page:
                return False
            logger.info("テキスト生成を待機中...")
            start_time = time.time()
            check_interval = 2
            await self.page.wait_for_timeout(5000)
            while time.time() - start_time < max_wait:
                await self.page.wait_for_timeout(check_interval * 1000)
                elapsed = int(time.time() - start_time)
                is_complete = await self.page.evaluate('''
                    () => {
                        const allButtons = document.querySelectorAll('button');
                        for (const btn of allButtons) {
                            const text = btn.textContent || '';
                            const ariaLabel = btn.getAttribute('aria-label') || '';
                            if (text.includes('再生成') || text.includes('Regenerate') ||
                                ariaLabel.includes('再生成') || ariaLabel.includes('Regenerate')) {
                                return true;
                            }
                        }
                        const sendButtons = document.querySelectorAll('[data-testid="send-button"], button[type="submit"]');
                        for (const btn of sendButtons) {
                            if (!btn.disabled && !btn.hasAttribute('disabled')) {
                                return true;
                            }
                        }
                        const loadingElements = document.querySelectorAll('[data-testid="loading"], .loading, .spinner');
                        if (loadingElements.length === 0) {
                            return true;
                        }
                        return false;
                    }
                ''')
                if is_complete:
                    logger.info(f"✅ テキスト生成完了を検出")
                    await self.page.wait_for_timeout(2000)
                    return True
                if elapsed % 10 == 0 and elapsed > 0:
                    logger.info(f"⏳ 待機中... {elapsed}秒経過")
            logger.warning(f"⏰ タイムアウト（{max_wait}秒）")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, "テキスト生成待機")
            return False

    async def extract_latest_text_response(self) -> str:
        """最新のテキスト応答を抽出（サービス自動判別版）"""
        try:
            if self.service == "deepseek":
                return await self.extract_latest_text_response_deepseek()
            else:
                return await self.extract_latest_text_response_gemini()
        except Exception as e:
            ErrorHandler.log_error(e, "テキスト抽出")
            return None
    
    async def extract_latest_text_response_gemini(self) -> str:
        """Geminiの最新のテキスト応答を抽出（ユーザー入力を除外）"""
        try:
            logger.info("=" * 60)
            logger.info("★★★ Geminiテキスト抽出開始 ★★★")
            logger.info("=" * 60)
            
            all_results = {}
            
            # 方法1: model-response（最優先）
            logger.info("\n【方法1】model-response")
            try:
                r1 = await self.page.evaluate('''() => {
                    // Geminiの応答のみを取得（data-message-author="model"）
                    const modelMessages = document.querySelectorAll('[data-message-author="model"]');
                    if (modelMessages.length > 0) {
                        const lastMessage = modelMessages[modelMessages.length - 1];
                        return lastMessage.innerText || '';
                    }
                    return '';
                }''')
                all_results['方法1'] = r1
                logger.info(f"結果: {len(r1)}文字 {'✅' if len(r1)>50 else '❌'}")
                if len(r1) > 50: 
                    logger.info(f"先頭: {r1[:100]}")
            except Exception as e:
                logger.error(f"エラー: {e}")
                all_results['方法1'] = ""
            
            # 方法2: markdown-container（Geminiの応答のみ）
            logger.info("\n【方法2】markdown-container")
            try:
                r2 = await self.page.evaluate('''() => {
                    const containers = document.querySelectorAll('.markdown-container, [class*="markdown"]');
                    // ユーザープロンプトを含むものを除外
                    for (let i = containers.length - 1; i >= 0; i--) {
                        const text = containers[i].innerText || '';
                        // プロンプトの特徴的な文字列を除外
                        if (text.includes('あなたは経験豊富な') || 
                            text.includes('【あなたの役割】') ||
                            text.includes('【執筆依頼】')) {
                            continue;
                        }
                        if (text.length > 100) {
                            return text;
                        }
                    }
                    return '';
                }''')
                all_results['方法2'] = r2
                logger.info(f"結果: {len(r2)}文字 {'✅' if len(r2)>50 else '❌'}")
                if len(r2) > 50: 
                    logger.info(f"先頭: {r2[:100]}")
            except Exception as e:
                logger.error(f"エラー: {e}")
                all_results['方法2'] = ""
            
            # 方法3: 会話履歴から最後のGemini応答を抽出
            logger.info("\n【方法3】会話履歴分析")
            try:
                r3 = await self.page.evaluate('''() => {
                    // すべてのメッセージブロックを取得
                    const messages = document.querySelectorAll('[class*="message"]');
                    
                    // 最後から順に確認し、Geminiの応答を探す
                    for (let i = messages.length - 1; i >= 0; i--) {
                        const msg = messages[i];
                        const text = msg.innerText || '';
                        
                        // ユーザーメッセージの特徴を持つものをスキップ
                        if (text.includes('あなたは経験豊富な') ||
                            text.includes('【あなたの役割】') ||
                            text.includes('【執筆依頼】') ||
                            text.length < 200) {
                            continue;
                        }
                        
                        // Geminiの応答らしい要素
                        if (text.includes('#') || // マークダウン見出し
                            text.includes('**') || // 太字
                            text.length > 500) {
                            return text;
                        }
                    }
                    return '';
                }''')
                all_results['方法3'] = r3
                logger.info(f"結果: {len(r3)}文字 {'✅' if len(r3)>50 else '❌'}")
                if len(r3) > 50: 
                    logger.info(f"先頭: {r3[:100]}")
            except Exception as e:
                logger.error(f"エラー: {e}")
                all_results['方法3'] = ""
            
            # 優先順位で選択: 方法1 > 方法2 > 方法3
            priority_order = ['方法1', '方法2', '方法3']
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 100:
                    text = all_results[method]
                    
                    # プロンプトが混入していないか最終チェック
                    if ('あなたは経験豊富な' in text or 
                        '【あなたの役割】' in text or
                        '【執筆依頼】' in text):
                        logger.warning(f"{method}にプロンプトが混入 - スキップ")
                        continue
                    
                    logger.info(f"\n🎯 採用: {method} ({len(text)}文字)")
                    logger.info(f"先頭200文字:\n{text[:200]}")
                    return text.strip()
            
            # すべて失敗した場合
            logger.error("\n❌ 全方法失敗 - Geminiの応答が取得できませんでした")
            
            # デバッグ用: ページの構造を確認
            page_structure = await self.page.evaluate('''() => {
                return {
                    messageCount: document.querySelectorAll('[class*="message"]').length,
                    modelMessages: document.querySelectorAll('[data-message-author="model"]').length,
                    markdownContainers: document.querySelectorAll('[class*="markdown"]').length
                };
            }''')
            logger.info(f"ページ構造: {page_structure}")
            
            return None
                    
        except Exception as e:
            logger.error(f"❌ 抽出全体エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    async def extract_latest_text_response_deepseek(self) -> str:
        """DeepSeekの最新のテキスト応答を抽出"""
        try:
            logger.info("=" * 60)
            logger.info("★★★ DeepSeekテキスト抽出開始 ★★★")
            logger.info("=" * 60)
            
            # DeepSeek特有のセレクタで応答を取得
            response_text = await self.page.evaluate('''() => {
                // メッセージコンテナを探す
                const messages = document.querySelectorAll('[class*="message"], [class*="chat"], div[role="article"]');
                let longest = '';
                
                for (const msg of messages) {
                    const text = msg.innerText || '';
                    // ユーザーのメッセージは除外
                    if (text.length > 100 && text.length > longest.length) {
                        // システムやアシスタントのメッセージのみ
                        const isUserMessage = msg.querySelector('[class*="user"]') || 
                                            msg.classList.toString().includes('user');
                        if (!isUserMessage) {
                            longest = text;
                        }
                    }
                }
                
                if (!longest) {
                    // フォールバック: 最後の長いdivを取得
                    const divs = document.querySelectorAll('div');
                    for (const d of divs) {
                        const t = d.innerText || '';
                        if (t.length > longest.length && t.length > 200) {
                            longest = t;
                        }
                    }
                }
                
                return longest;
            }''')
            
            if response_text and len(response_text) > 50:
                logger.info(f"✅ DeepSeek応答抽出成功: {len(response_text)}文字")
                logger.info(f"先頭500文字:\n{response_text[:500]}")
                
                # JSON部分を抽出
                extracted_json = self.extract_json_from_text(response_text)
                if extracted_json:
                    logger.info(f"✅ JSON抽出成功: {len(extracted_json)}文字")
                    return extracted_json
                else:
                    return response_text.strip()
            else:
                logger.error("❌ DeepSeek応答が見つかりません")
                return None
                
        except Exception as e:
            logger.error(f"❌ DeepSeek抽出エラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def extract_json_from_text(self, text: str) -> str:
        """テキストからJSON部分を抽出"""
        try:
            if not text:
                return None
                
            # パターン1: ```json ... ``` に囲まれたJSON
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # パターン2: 単純なJSONオブジェクトの抽出
            json_match = re.search(r'^\s*(\{.*\})\s*$', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # パターン3: 先頭からJSONを探す
            start_idx = text.find('{')
            if start_idx != -1:
                # { から始めて、対応する } までを探す
                brace_count = 0
                for i, char in enumerate(text[start_idx:]):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            potential_json = text[start_idx:start_idx+i+1]
                            try:
                                json.loads(potential_json)
                                return potential_json.strip()
                            except:
                                continue
            return None
        except Exception as e:
            logger.error(f"JSON抽出エラー: {e}")
            return None
    
    async def save_text_to_file(self, text: str, filename: str) -> bool:
        """テキストをファイルに保存（ローカル一時保存用）"""
        try:
            save_path = self.download_folder / filename
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(text)
            if save_path.exists():
                file_size = save_path.stat().st_size
                logger.info(f"✅ テキスト保存成功: {filename} ({file_size:,} bytes)")
                return True
            else:
                logger.error(f"❌ テキスト保存失敗: {filename}")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "テキストファイル保存")
            return False
    
    async def cleanup(self) -> None:
        """リソースのクリーンアップを強化（Windows非同期問題対応版）"""
        try:
            logger.info("🔄 リソースクリーンアップを開始します...")

            # 非同期タスクのキャンセル
            try:
                tasks = [t for t in asyncio.all_tasks() 
                        if t is not asyncio.current_task()]
                        
                if tasks:
                    logger.info(f"🔄 {len(tasks)}個の非同期タスクをキャンセル中...")
                    for task in tasks:
                        task.cancel()
                            
                    # タスクの完了待機（タイムアウト付き）
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=5.0
                    )
                    logger.info("✅ 非同期タスククリーンアップ完了")
            except asyncio.TimeoutError:
                logger.warning("⚠️ タスクキャンセルのタイムアウト")
            except Exception as e:
                logger.warning(f"⚠️ タスクキャンセル中のエラー: {e}")

            # ページのクローズ
            if hasattr(self, 'page') and self.page:
                try:
                    await self.page.close()
                    logger.info("✅ ページをクローズしました")
                except Exception as e:
                    logger.warning(f"⚠️ ページクローズ中の警告: {e}")

            # コンテキストのクローズ
            if hasattr(self, 'context') and self.context:
                try:
                    await self.context.close()
                    logger.info("✅ ブラウザコンテキストをクローズしました")
                except Exception as e:
                    logger.warning(f"⚠️ コンテキストクローズ中の警告: {e}")

            # Playwrightの停止
            if hasattr(self, 'playwright') and self.playwright:
                try:
                    await self.playwright.stop()
                    logger.info("✅ Playwrightを停止しました")
                except Exception as e:
                    logger.warning(f"⚠️ Playwright停止中の警告: {e}")

            logger.info("✅ リソースクリーンアップ完了")

        except Exception as e:
            logger.error(f"❌ クリーンアップ中のエラー: {e}")