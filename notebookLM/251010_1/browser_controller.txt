import asyncio
import time
import json
import re
import aiohttp
from pathlib import Path
from typing import Optional, Dict, List
from playwright.async_api import async_playwright, Page, BrowserContext
import logging
from datetime import datetime

from config_utils import config, ErrorHandler, FileNameGenerator

logger = logging.getLogger(__name__)

class BrowserController:
    """ãƒ–ãƒ©ã‚¦ã‚¶åˆ¶å¾¡ã‚¯ãƒ©ã‚¹ï¼ˆæ‹¡å¼µç‰ˆï¼šç”»åƒãƒ»ãƒ†ã‚­ã‚¹ãƒˆä¸¡å¯¾å¿œãƒ»DeepSeekå¯¾å¿œï¼‰"""
    
    def __init__(self, download_folder: Path, mode: str = "image", service: str = "google", credentials: Dict = None):
        self.download_folder = download_folder
        self.mode = mode
        self.service = service.lower()  # "google" or "deepseek"
        self.credentials = credentials or {}
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.cookies_file = Path(config.COOKIES_FILE) if config.COOKIES_FILE else None
        self.browser_data_dir = Path(config.BROWSER_DATA_DIR) if config.BROWSER_DATA_DIR else None
        
        self.download_folder.mkdir(exist_ok=True, parents=True)
        if self.browser_data_dir:
            self.browser_data_dir.mkdir(parents=True, exist_ok=True)
    
    async def setup_browser(self) -> None:
        """ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆæœŸåŒ–ï¼ˆãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œç‰ˆï¼‰"""
        try:
            logger.info("="*60)
            logger.info("ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•é–‹å§‹...")
            logger.info("="*60)
            
            # æ—¢å­˜ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            await self._cleanup_existing_browser_processes()
            
            playwright = await async_playwright().start()
            logger.info(f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.browser_data_dir}")
            
            # â˜…â˜…â˜… ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œ: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’æŒ‡å®š â˜…â˜…â˜…
            # 5ç”»é¢ç’°å¢ƒã®å³ä¸Šã«é…ç½®
            # ãƒ¢ãƒ‹ã‚¿ãƒ¼è§£åƒåº¦ã«å¿œã˜ã¦èª¿æ•´ã—ã¦ãã ã•ã„
            window_width = 1280   # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å¹… 1920  å³ä¸Šã ã£ãŸã€€1600
            window_height = 700  # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦é«˜ã• 1080  å³ä¸Šã ã£ãŸã€€900
            
            # 5ç”»é¢ç›®ï¼ˆå³ç«¯ï¼‰ã®åº§æ¨™
            # ä¾‹: å„ãƒ¢ãƒ‹ã‚¿ãƒ¼ãŒ1920x1080ã®å ´åˆ
            # 5ç”»é¢ç›®ã®å·¦ä¸Šã¯ x=7680 (1920*4)
            x_position = 5000  # 5ç”»é¢ç›®ã®å·¦ç«¯ 1st 7680  å³ä¸Šã ã£ãŸã€2nd 6000ã€€å³ä¸‹ã ã£ãŸ
            y_position = 1500     # ä¸Šç«¯ 1st 0  å³ä¸Šã ã£ãŸã€2nd 500å³ä¸‹ã ã£ãŸ
            
            # ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ï¼ˆä½ç½®ã¨ã‚µã‚¤ã‚ºæŒ‡å®šï¼‰
            self.context = await playwright.chromium.launch_persistent_context(
                user_data_dir=str(self.browser_data_dir),
                viewport={'width': window_width, 'height': window_height},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
                accept_downloads=True,
                ignore_https_errors=True,
                # â˜…â˜…â˜… ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½ç½®ã‚’æŒ‡å®š â˜…â˜…â˜…
                no_viewport=False,
                **config.BROWSER_CONFIG
            )
            
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½œæˆæˆåŠŸ")
            
            # ãƒšãƒ¼ã‚¸ä½œæˆ
            self.page = await self.context.new_page()
            
            # â˜…â˜…â˜… ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æŒ‡å®šä½ç½®ã«ç§»å‹• â˜…â˜…â˜…
            await self.page.evaluate(f"""
                window.moveTo({x_position}, {y_position});
                window.resizeTo({window_width}, {window_height});
            """)
            
            logger.info(f"âœ… ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½ç½® ({x_position}, {y_position}) ã«é…ç½®")
            
            # ãƒ–ãƒ©ã‚¦ã‚¶ãŒæ­£å¸¸ã«èµ·å‹•ã—ãŸã‹ç¢ºèª
            await asyncio.sleep(2)
            if not await self._is_browser_alive():
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒèµ·å‹•ç›´å¾Œã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ")
            
            logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèªå®Œäº†")
            
            # è‡ªå‹•åŒ–æ¤œå‡ºã‚’å›é¿
            await self.page.add_init_script("""
                Object.defineProperty(navigator, 'webdriver', {
                    get: () => false,
                });
                window.navigator.chrome = {
                    runtime: {},
                };
                const originalQuery = window.navigator.permissions.query;
                window.navigator.permissions.query = (parameters) => (
                    parameters.name === 'notifications' ?
                        Promise.resolve({ state: Notification.permission }) :
                        originalQuery(parameters)
                );
                Object.defineProperty(navigator, 'plugins', {
                    get: () => [1, 2, 3, 4, 5],
                });
                Object.defineProperty(navigator, 'languages', {
                    get: () => ['ja-JP', 'ja', 'en-US', 'en'],
                });
            """)
            
            self.page.set_default_timeout(config.PAGE_TIMEOUT)
            self.page.set_default_navigation_timeout(config.PAGE_TIMEOUT)
            
            logger.info("="*60)
            logger.info(f"âœ… ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•å®Œäº†ï¼ˆãƒ¢ãƒ¼ãƒ‰: {self.mode}ã€ã‚µãƒ¼ãƒ“ã‚¹: {self.service}ï¼‰")
            logger.info("="*60)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•")
            logger.error("="*60)
            logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•å¤±æ•—")
            logger.error("="*60)
            
            # è©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            logger.error(f"ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {self.browser_data_dir}")
            
            # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’è©¦ã¿ã‚‹
            await self._cleanup_existing_browser_processes()
            
            raise Exception(f"ãƒ–ãƒ©ã‚¦ã‚¶èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: {str(e)}")
    
    async def _is_browser_alive(self) -> bool:
        """ãƒ–ãƒ©ã‚¦ã‚¶ãŒç”Ÿãã¦ã„ã‚‹ã‹ç¢ºèª"""
        try:
            if not self.page:
                return False
            
            # ç°¡å˜ãªJavaScriptå®Ÿè¡Œã§ç”Ÿå­˜ç¢ºèª
            result = await self.page.evaluate("1 + 1")
            return result == 2
        except Exception as e:
            logger.warning(f"ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèªå¤±æ•—: {e}")
            return False
    
    async def _cleanup_existing_browser_processes(self):
        """æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        try:
            import psutil
            
            logger.info("æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’ç¢ºèªä¸­...")
            
            killed_count = 0
            for proc in psutil.process_iter(['pid', 'name']):
                try:
                    if 'chrome' in proc.info['name'].lower() or 'chromium' in proc.info['name'].lower():
                        # è‡ªåˆ†ã®ãƒ–ãƒ©ã‚¦ã‚¶ãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ—ãƒ­ã‚»ã‚¹ã®ã¿çµ‚äº†
                        cmdline = proc.cmdline()
                        if str(self.browser_data_dir) in ' '.join(cmdline):
                            logger.warning(f"æ—¢å­˜ã®Chromiumãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†: PID={proc.info['pid']}")
                            proc.kill()
                            killed_count += 1
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
            
            if killed_count > 0:
                logger.info(f"âœ… {killed_count}å€‹ã®ãƒ—ãƒ­ã‚»ã‚¹ã‚’çµ‚äº†ã—ã¾ã—ãŸ")
                await asyncio.sleep(2)  # ãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ã‚’å¾…ã¤
            else:
                logger.info("æ—¢å­˜ãƒ—ãƒ­ã‚»ã‚¹ãªã—")
                
        except ImportError:
            logger.warning("psutilãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ—")
        except Exception as e:
            logger.warning(f"ãƒ—ãƒ­ã‚»ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {e}")
    
    async def navigate_to_gemini(self) -> None:
        """Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆã‚¯ãƒ©ãƒƒã‚·ãƒ¥æ¤œçŸ¥å¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            
            # ãƒ–ãƒ©ã‚¦ã‚¶ãŒç”Ÿãã¦ã„ã‚‹ã‹ç¢ºèª
            if not await self._is_browser_alive():
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒæ—¢ã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã„ã¾ã™")
            
            logger.info("Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            
            # ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿
            cookies_loaded = await self.load_cookies()
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    
                    # ãƒ–ãƒ©ã‚¦ã‚¶ç”Ÿå­˜ç¢ºèª
                    if not await self._is_browser_alive():
                        raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚¢ã‚¯ã‚»ã‚¹å‰ã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ")
                    
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    
                    # ã‚¢ã‚¯ã‚»ã‚¹å¾Œã‚‚ç”Ÿå­˜ç¢ºèª
                    await asyncio.sleep(3)
                    if not await self._is_browser_alive():
                        raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚¢ã‚¯ã‚»ã‚¹å¾Œã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ")
                    
                    logger.info("âœ… Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                    
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    
                    # ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã„ãªã„ã‹ç¢ºèª
                    if not await self._is_browser_alive():
                        logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¾ã—ãŸ")
                        raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚’æ¤œå‡º")
                    
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸ")
                        logger.error("æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        
                        # ãƒ–ãƒ©ã‚¦ã‚¶ãŒç”Ÿãã¦ã„ã‚‹å ´åˆã®ã¿æ‰‹å‹•ä»‹å…¥ã‚’æ±‚ã‚ã‚‹
                        if await self._is_browser_alive():
                            input("Geminiãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                        else:
                            raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã„ã‚‹ãŸã‚ã€ç¶šè¡Œã§ãã¾ã›ã‚“")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await asyncio.sleep(5)
            
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            
            await self.save_cookies()
            await self.handle_welcome_screens()
            
            logger.info("âœ… Geminiã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
            
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiã‚¢ã‚¯ã‚»ã‚¹")
            
            # ãƒ–ãƒ©ã‚¦ã‚¶çŠ¶æ…‹ã‚’ç¢ºèª
            if await self._is_browser_alive():
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã¯ç”Ÿãã¦ã„ã¾ã™ã€‚æ‰‹å‹•ã§Geminiãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
                input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            else:
                logger.error("âŒ ãƒ–ãƒ©ã‚¦ã‚¶ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ã¦ã„ã¾ã™ã€‚å†èµ·å‹•ãŒå¿…è¦ã§ã™")
                raise Exception("ãƒ–ãƒ©ã‚¦ã‚¶ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã®ãŸã‚ç¶šè¡Œä¸å¯")
    
    async def save_cookies(self) -> None:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.context or not self.cookies_file:
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")
                return
            
            # ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã®ã‚¯ãƒƒã‚­ãƒ¼ã‚’å–å¾—
            cookies = await self.context.cookies()
            
            if not cookies:
                logger.warning("ä¿å­˜ã™ã‚‹ã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return
                
            # ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
            with open(self.cookies_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ: {len(cookies)}å€‹ã®ã‚¯ãƒƒã‚­ãƒ¼")
            
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜")
            logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸãŒç¶šè¡Œã—ã¾ã™")

    async def load_cookies(self) -> bool:
        """ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ï¼ˆå¼·åŒ–ç‰ˆï¼‰"""
        try:
            if not self.cookies_file or not self.cookies_file.exists():
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“")
                return False
                
            if not self.context:
                logger.warning("ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
                return False
                
            with open(self.cookies_file, 'r', encoding='utf-8') as f:
                cookies = json.load(f)
            
            if not cookies:
                logger.warning("ã‚¯ãƒƒã‚­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ãŒç©ºã§ã™")
                return False
                
            # ç¾åœ¨ã®URLã«ã‚¯ãƒƒã‚­ãƒ¼ã‚’è¿½åŠ 
            current_url = self.page.url if self.page else "https://gemini.google.com"
            domain_cookies = []
            
            for cookie in cookies:
                # ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’èª¿æ•´
                if 'domain' in cookie and cookie['domain'].startswith('.'):
                    cookie['domain'] = cookie['domain'][1:]
                
                # æœ‰åŠ¹æœŸé™ã‚’ãƒã‚§ãƒƒã‚¯
                if 'expires' in cookie and cookie['expires'] < time.time():
                    continue
                    
                domain_cookies.append(cookie)
            
            if domain_cookies:
                await self.context.add_cookies(domain_cookies)
                logger.info(f"âœ… ã‚¯ãƒƒã‚­ãƒ¼ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ: {len(domain_cookies)}å€‹")
                
                # ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿å¾Œã«ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
                if self.page:
                    await self.page.reload()
                    await self.page.wait_for_timeout(3000)
                
                return True
            else:
                logger.warning("æœ‰åŠ¹ãªã‚¯ãƒƒã‚­ãƒ¼ãŒã‚ã‚Šã¾ã›ã‚“")
                return False
                
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¯ãƒƒã‚­ãƒ¼èª­ã¿è¾¼ã¿")
            return False
    
    async def check_google_login_status(self) -> bool:
        """ç¾åœ¨ã®Googleãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯"""
        try:
            if not self.page:
                return False
            logger.info("Googleãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã‚’ç¢ºèªä¸­...")
            await self.page.goto("https://myaccount.google.com/", timeout=15000, wait_until="domcontentloaded")
            await self.page.wait_for_timeout(2000)
            current_url = self.page.url
            if "myaccount.google.com" in current_url:
                logger.info("æ—¢ã«Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ã§ã™")
                return True
            elif "accounts.google.com" in current_url:
                logger.info("Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¸ã®ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
                return False
            else:
                logger.info("ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ãŒä¸æ˜ã§ã™")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèª")
            return False
    
    async def navigate_to_gemini(self) -> None:
        """Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            logger.info("Geminiã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            cookies_loaded = await self.load_cookies()
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    await self.page.goto("https://gemini.google.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(8000)
                    logger.info("Geminiã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        input("Geminiãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await self.page.wait_for_timeout(5000)
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            await self.save_cookies()
            await self.handle_welcome_screens()
            logger.info("Geminiã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
        except Exception as e:
            ErrorHandler.log_error(e, "Geminiã‚¢ã‚¯ã‚»ã‚¹")
            logger.info("æ‰‹å‹•ã§Geminiãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
            input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
    
    async def navigate_to_deepseek(self) -> None:
        """DeepSeekã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆCloudflareãƒœãƒƒãƒˆæ¤œè¨¼å¯¾å¿œç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            logger.info("DeepSeekã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ä¸­...")
            cookies_loaded = await self.load_cookies()
            
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                try:
                    logger.info(f"DeepSeekã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è©¦è¡Œ {attempt}/{max_attempts}")
                    await self.page.goto("https://chat.deepseek.com/", timeout=60000, wait_until="domcontentloaded")
                    await self.page.wait_for_timeout(5000)
                    logger.info("DeepSeekã‚µã‚¤ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã¾ã—ãŸ")
                    break
                except Exception as e:
                    logger.warning(f"è©¦è¡Œ {attempt} å¤±æ•—: {e}")
                    if attempt == max_attempts:
                        logger.error("å…¨ã¦ã®è©¦è¡ŒãŒå¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„")
                        input("DeepSeekãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    else:
                        logger.info("5ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™...")
                        await self.page.wait_for_timeout(5000)
            
            current_url = self.page.url
            logger.info(f"ç¾åœ¨ã®URL: {current_url}")
            
            # Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ãƒã‚§ãƒƒã‚¯
            logger.info("Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...")
            cloudflare_check = await self.page.evaluate('''
                () => {
                    const body = document.body.innerText || '';
                    if (body.includes('Verifying you are human') || 
                        body.includes('ã‚ãªãŸãŒãƒœãƒƒãƒˆã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèª') ||
                        body.includes('Just a moment') ||
                        body.includes('Checking your browser')) {
                        return true;
                    }
                    return false;
                }
            ''')
            
            if cloudflare_check:
                logger.warning("âš ï¸ Cloudflareãƒœãƒƒãƒˆæ¤œè¨¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ")
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã§è‡ªå‹•çš„ã«ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã™ã‚‹ã¾ã§å¾…æ©Ÿã—ã¾ã™...")
                logger.info("ï¼ˆé€šå¸¸5-30ç§’ã§å®Œäº†ã—ã¾ã™ã€‚æ‰‹å‹•æ“ä½œã¯ä¸è¦ã§ã™ï¼‰")
                
                # æœ€å¤§60ç§’å¾…ã¤
                start_time = time.time()
                while time.time() - start_time < 60:
                    await self.page.wait_for_timeout(3000)
                    
                    # ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ãŸã‹ç¢ºèª
                    still_checking = await self.page.evaluate('''
                        () => {
                            const body = document.body.innerText || '';
                            if (body.includes('Verifying you are human') || 
                                body.includes('ã‚ãªãŸãŒãƒœãƒƒãƒˆã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèª') ||
                                body.includes('Just a moment') ||
                                body.includes('Checking your browser')) {
                                return true;
                            }
                            return false;
                        }
                    ''')
                    
                    if not still_checking:
                        logger.info("âœ… Cloudflareæ¤œè¨¼ãŒå®Œäº†ã—ã¾ã—ãŸ")
                        break
                    
                    elapsed = int(time.time() - start_time)
                    if elapsed % 10 == 0:
                        logger.info(f"å¾…æ©Ÿä¸­... {elapsed}ç§’çµŒé")
                
                # å®Œäº†å¾Œã€URLã‚’å†ç¢ºèª
                await self.page.wait_for_timeout(3000)
                current_url = self.page.url
                logger.info(f"æ¤œè¨¼å¾Œã®URL: {current_url}")
            
            # ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                logger.info("\n" + "="*60)
                logger.info("âš ï¸ DeepSeekã¸ã®ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™")
                logger.info("="*60)
                logger.info("")
                logger.info("ğŸ“Œ ãƒ­ã‚°ã‚¤ãƒ³æ‰‹é †ï¼š")
                logger.info("1. ãƒ–ãƒ©ã‚¦ã‚¶ã§ã€ŒLog in with Googleã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯")
                logger.info("2. Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’é¸æŠï¼ˆã¾ãŸã¯å…¥åŠ›ï¼‰")
                logger.info(f"   ä½¿ç”¨ã™ã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ: {self.credentials.get('email', 'B2ã‚»ãƒ«ã®Google ID') if hasattr(self, 'credentials') else 'B2ã‚»ãƒ«ã®Google ID'}")
                logger.info("3. ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†ã‚’å¾…ã¤")
                logger.info("4. ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€ã“ã®ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«æˆ»ã£ã¦Enterã‚­ãƒ¼ã‚’æŠ¼ã™")
                logger.info("")
                logger.info("ğŸ’¡ ãƒ’ãƒ³ãƒˆï¼š")
                logger.info("  - ã€ŒChrome ã¯è‡ªå‹•ãƒ†ã‚¹ãƒˆ...ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–ã—ã¦ãã ã•ã„")
                logger.info("  - Googleãƒ­ã‚°ã‚¤ãƒ³ã¯é€šå¸¸é€šã‚Šå‹•ä½œã—ã¾ã™")
                logger.info("  - 2å›ç›®ä»¥é™ã¯Cookieã§è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³ã•ã‚Œã¾ã™")
                logger.info("="*60)
                
                input("\nâœ… ãƒ­ã‚°ã‚¤ãƒ³å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                
                # ãƒ­ã‚°ã‚¤ãƒ³å¾Œã®URLã‚’ç¢ºèª
                await self.page.wait_for_timeout(2000)
                current_url = self.page.url
                logger.info(f"ãƒ­ã‚°ã‚¤ãƒ³å¾Œã®URL: {current_url}")
                
                # ã¾ã ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã‚‹å ´åˆ
                if 'sign_in' in current_url.lower() or 'login' in current_url.lower():
                    logger.warning("âš ï¸ ã¾ã ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«ã„ã¾ã™")
                    logger.info("ã‚‚ã†ä¸€åº¦ã€ŒLog in with Googleã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„")
                    input("å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
                    await self.page.wait_for_timeout(2000)
            
            # ãƒãƒ£ãƒƒãƒˆç”»é¢ã«åˆ°é”ã§ãã¦ã„ã‚‹ã‹ç¢ºèª
            await self.page.wait_for_timeout(3000)
            chat_ready = await self.page.evaluate('''
                () => {
                    // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚„inputãŒã‚ã‚Œã°OK
                    const inputs = document.querySelectorAll('textarea, input[type="text"]');
                    return inputs.length > 0;
                }
            ''')
            
            if not chat_ready:
                logger.warning("âš ï¸ ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                logger.info("ãƒ–ãƒ©ã‚¦ã‚¶ã§ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ãã ã•ã„")
                logger.info("ï¼ˆãƒšãƒ¼ã‚¸ã‚’æ‰‹å‹•ã§ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ï¼‰")
                input("\nâœ… ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            else:
                logger.info("âœ… ãƒãƒ£ãƒƒãƒˆç”»é¢ã‚’ç¢ºèªã—ã¾ã—ãŸ")
            
            await self.save_cookies()
            logger.info("âœ… DeepSeekã‚µã‚¤ãƒˆã®æº–å‚™ãŒå®Œäº†ã—ã¾ã—ãŸ")
            logger.info("ğŸ’¾ Cookieã‚’ä¿å­˜ã—ã¾ã—ãŸ - æ¬¡å›ã‹ã‚‰è‡ªå‹•ãƒ­ã‚°ã‚¤ãƒ³ã•ã‚Œã¾ã™")
            
        except Exception as e:
            ErrorHandler.log_error(e, "DeepSeekã‚¢ã‚¯ã‚»ã‚¹")
            logger.info("æ‰‹å‹•ã§DeepSeekãƒšãƒ¼ã‚¸ã‚’é–‹ã„ã¦ãã ã•ã„")
            input("æº–å‚™å®Œäº†å¾Œã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
    
    async def handle_welcome_screens(self) -> None:
        """åˆ©ç”¨è¦ç´„ã‚„ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’å‡¦ç†"""
        try:
            if not self.page:
                return
            logger.info("ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚„ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’ç¢ºèªä¸­...")
            continue_buttons = [
                'text=ç¶šè¡Œ', 'text=é–‹å§‹', 'text=åŒæ„', 'text=Continue',
                'text=Get started', 'text=Agree', 'text=Got it', 'text=OK',
                '[data-testid="continue-button"]'
            ]
            start_time = time.time()
            found_buttons = 0
            while time.time() - start_time < 10 and found_buttons < 3:
                for button_selector in continue_buttons:
                    try:
                        button = await self.page.query_selector(button_selector)
                        if button and await button.is_visible():
                            await button.click()
                            await self.page.wait_for_timeout(2000)
                            logger.info(f"ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ: {button_selector}")
                            found_buttons += 1
                            break
                    except Exception:
                        continue
                await self.page.wait_for_timeout(1000)
            if found_buttons > 0:
                logger.info(f"{found_buttons}å€‹ã®ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã‚’å‡¦ç†ã—ã¾ã—ãŸ")
            else:
                logger.info("ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼ˆæ­£å¸¸ï¼‰")
        except Exception as e:
            ErrorHandler.log_error(e, "ã‚¦ã‚§ãƒ«ã‚«ãƒ ç”»é¢å‡¦ç†")
    
    async def ensure_normal_chat_mode(self) -> None:
        """é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆStorybookã‚’å›é¿ï¼‰- å¼·åŒ–ç‰ˆ"""
        try:
            if not self.page:
                return
            logger.info("ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’ç¢ºèªä¸­...")
            current_url = self.page.url
            if 'storybook' in current_url.lower():
                logger.warning("Storybookã®URLãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã™...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã—ãŸ")
                return
            storybook_active = await self.page.evaluate('''
                () => {
                    const buttons = document.querySelectorAll('button');
                    for (const btn of buttons) {
                        const text = btn.textContent || '';
                        const ariaLabel = btn.getAttribute('aria-label') || '';
                        if ((text.includes('Storybook') || ariaLabel.includes('Storybook')) &&
                            (btn.getAttribute('aria-pressed') === 'true' || 
                             btn.classList.contains('active') ||
                             btn.classList.contains('selected'))) {
                            return true;
                        }
                    }
                    return false;
                }
            ''')
            if storybook_active:
                logger.warning("Storybookãƒ¢ãƒ¼ãƒ‰ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã™...")
                if self.service == "deepseek":
                    await self.page.goto("https://chat.deepseek.com/", wait_until="domcontentloaded")
                else:
                    await self.page.goto("https://gemini.google.com/app", wait_until="domcontentloaded")
                await self.page.wait_for_timeout(3000)
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã—ã¾ã—ãŸ")
            else:
                logger.info("é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ã§ã™")
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒãƒ£ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰ç¢ºèª")
    
    async def send_prompt(self, prompt: str) -> None:
        """ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›ã—ã¦é€ä¿¡ï¼ˆã‚µãƒ¼ãƒ“ã‚¹è‡ªå‹•åˆ¤åˆ¥ç‰ˆï¼‰"""
        try:
            if not self.page:
                raise Exception("ãƒšãƒ¼ã‚¸ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“")
            await self.ensure_normal_chat_mode()
            logger.info(f"ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ä¸­: {prompt[:50]}...")
            
            if self.service == "deepseek":
                await self.send_prompt_deepseek(prompt)
            else:
                await self.send_prompt_gemini(prompt)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_gemini(self, prompt: str) -> None:
        """Geminiã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å¯¾å¿œç‰ˆï¼‰"""
        try:
            # å…¥åŠ›æ¬„ã‚’æ¢ã™
            input_selectors = [
                'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ Gemini ã«é€ä¿¡"]',
                'textarea[placeholder*="Send a message to Gemini"]',
                'div[contenteditable="true"][role="textbox"]',
                'textarea[data-testid="message-input"]',
                'div.ql-editor[contenteditable="true"]',
                'textarea.ql-editor'
            ]
            
            input_element = None
            for selector in input_selectors:
                try:
                    await self.page.wait_for_selector(selector, timeout=5000)
                    input_element = await self.page.query_selector(selector)
                    if input_element:
                        logger.info(f"å…¥åŠ›æ¬„ã‚’ç™ºè¦‹: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                await self.page.screenshot(path="debug_input_not_found.png")
                raise Exception("å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # â˜…â˜…â˜… ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãƒ»ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã‚‹å‡¦ç†ï¼ˆè¿½åŠ ï¼‰ â˜…â˜…â˜…
            try:
                # 1. ãƒ¡ãƒ¼ãƒ«é…ä¿¡ç™»éŒ²ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã€Œå¾Œã§ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
                later_button_selectors = [
                    'button:has-text("å¾Œã§")',
                    'button:has-text("Later")',
                    '[aria-label*="å¾Œã§"]',
                    '[aria-label*="Later"]'
                ]
                
                for selector in later_button_selectors:
                    try:
                        later_button = await self.page.query_selector(selector)
                        if later_button and await later_button.is_visible():
                            await later_button.click()
                            await self.page.wait_for_timeout(1000)
                            logger.info("âœ… ãƒ¡ãƒ¼ãƒ«é…ä¿¡ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã¾ã—ãŸ")
                            break
                    except:
                        continue
                
                # 2. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤å…¨ä½“ã‚’é–‰ã˜ã‚‹ï¼ˆãƒãƒƒã‚¯ãƒ‰ãƒ­ãƒƒãƒ—ã‚¯ãƒªãƒƒã‚¯ï¼‰
                overlay_backdrop = await self.page.query_selector('.cdk-overlay-backdrop')
                if overlay_backdrop:
                    try:
                        await overlay_backdrop.click()
                        await self.page.wait_for_timeout(500)
                        logger.info("âœ… ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’é–‰ã˜ã¾ã—ãŸ")
                    except:
                        pass
                
                # 3. Escã‚­ãƒ¼ã§ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹ï¼ˆæœ€çµ‚æ‰‹æ®µï¼‰
                await self.page.keyboard.press('Escape')
                await self.page.wait_for_timeout(500)
                
            except Exception as e:
                logger.debug(f"ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å‡¦ç†: {e}")
            # â˜…â˜…â˜… ã“ã“ã¾ã§è¿½åŠ  â˜…â˜…â˜…
            
            # å…¥åŠ›æ¬„ã‚’ã‚¯ãƒªãƒƒã‚¯
            await input_element.click()
            await self.page.wait_for_timeout(500)
            
            # æ—¢å­˜ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªã‚¢
            await self.page.keyboard.press("Control+a")
            await self.page.wait_for_timeout(500)
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›
            await input_element.fill(prompt)
            await self.page.wait_for_timeout(1500)
            
            # é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
            send_selectors = [
                'button[data-testid="send-button"]',
                '[data-testid="send-button"]'
            ]
            
            sent = False
            for selector in send_selectors:
                try:
                    send_button = await self.page.query_selector(selector)
                    if send_button and await send_button.is_enabled():
                        await send_button.click()
                        logger.info("é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
                        sent = True
                        break
                except:
                    continue
            
            if not sent:
                await input_element.press('Enter')
                logger.info("Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã—ãŸ")
            
            await self.page.wait_for_timeout(3000)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆé€ä¿¡")
            if self.page:
                await self.page.screenshot(path="debug_send_error.png")
            raise
    
    async def send_prompt_deepseek(self, prompt: str) -> None:
        """DeepSeekã§ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’é€ä¿¡ï¼ˆæ”¹å–„ç‰ˆï¼‰"""
        # ã¾ãšã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®ã£ã¦çŠ¶æ…‹ã‚’ç¢ºèª
        debug_screenshot = f"debug_deepseek_before_input_{datetime.now().strftime('%H%M%S')}.png"
        try:
            await self.page.screenshot(path=debug_screenshot)
            logger.info(f"ğŸ“¸ å…¥åŠ›å‰ã®ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ: {debug_screenshot}")
        except:
            pass
        
        # è¤‡æ•°ã®å¯èƒ½æ€§ã®ã‚ã‚‹ã‚»ãƒ¬ã‚¯ã‚¿ã‚’è©¦ã™
        input_selectors = [
            # DeepSeekç‰¹æœ‰ã®ã‚»ãƒ¬ã‚¯ã‚¿
            'textarea[placeholder*="Ask"]',
            'textarea[placeholder*="Type"]',
            'textarea[placeholder*="message"]',
            'textarea[placeholder*="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸"]',
            'textarea[placeholder*="å…¥åŠ›"]',
            # æ±ç”¨çš„ãªã‚»ãƒ¬ã‚¯ã‚¿
            'div[contenteditable="true"][role="textbox"]',
            'div[contenteditable="true"]',
            'textarea',
            'input[type="text"]',
        ]
        
        input_element = None
        used_selector = None
        
        # å„ã‚»ãƒ¬ã‚¯ã‚¿ã‚’é †ç•ªã«è©¦ã™
        for selector in input_selectors:
            try:
                logger.info(f"å…¥åŠ›æ¬„ã‚’æ¢ç´¢ä¸­: {selector}")
                element = await self.page.query_selector(selector)
                if element:
                    # è¦ç´ ãŒè¦‹ãˆã¦ã„ã‚‹ã‹ç¢ºèª
                    is_visible = await element.is_visible()
                    if is_visible:
                        input_element = element
                        used_selector = selector
                        logger.info(f"âœ… å…¥åŠ›æ¬„ã‚’ç™ºè¦‹: {selector}")
                        break
                    else:
                        logger.info(f"è¦ç´ ã¯å­˜åœ¨ã™ã‚‹ãŒéè¡¨ç¤º: {selector}")
            except Exception as e:
                logger.debug(f"ã‚»ãƒ¬ã‚¯ã‚¿ {selector} ã§ã‚¨ãƒ©ãƒ¼: {e}")
                continue
        
        if not input_element:
            # å…¨ã‚»ãƒ¬ã‚¯ã‚¿ã§å¤±æ•—ã—ãŸå ´åˆ
            await self.page.screenshot(path="debug_deepseek_input_not_found.png")
            logger.error("âŒ DeepSeekå…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            logger.error("ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š")
            logger.error("1. ãƒ­ã‚°ã‚¤ãƒ³ãŒå®Œäº†ã—ã¦ã„ã¾ã™ã‹ï¼Ÿ")
            logger.error("2. ãƒãƒ£ãƒƒãƒˆç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿ")
            logger.error("3. Cloudflareã®æ¤œè¨¼ã¯å®Œäº†ã—ã¾ã—ãŸã‹ï¼Ÿ")
            
            # ãƒšãƒ¼ã‚¸ã®HTMLã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
            page_content = await self.page.evaluate('document.body.innerText')
            logger.info(f"ãƒšãƒ¼ã‚¸å†…å®¹ï¼ˆå…ˆé ­500æ–‡å­—ï¼‰:\n{page_content[:500]}")
            
            # æ‰‹å‹•ä»‹å…¥ã‚’ä¿ƒã™
            logger.info("\næ‰‹å‹•ã§å…¥åŠ›æ¬„ãŒè¦‹ãˆã‚‹ã¾ã§æ“ä½œã—ã¦ãã ã•ã„")
            input("å…¥åŠ›æ¬„ãŒè¡¨ç¤ºã•ã‚ŒãŸã‚‰ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„: ")
            
            # å†åº¦æ¢ã™
            for selector in input_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element and await element.is_visible():
                        input_element = element
                        used_selector = selector
                        logger.info(f"âœ… å…¥åŠ›æ¬„ã‚’ç™ºè¦‹ï¼ˆ2å›ç›®ï¼‰: {selector}")
                        break
                except:
                    continue
            
            if not input_element:
                raise Exception("å…¥åŠ›æ¬„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆ2å›ç›®ã®è©¦è¡Œå¾Œï¼‰")
        
        # å…¥åŠ›æ¬„ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹
        await input_element.click()
        await self.page.wait_for_timeout(500)
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å…¥åŠ›
        await input_element.fill(prompt)
        await self.page.wait_for_timeout(1500)
        
        # é€ä¿¡ãƒœã‚¿ãƒ³ã‚’æ¢ã™
        send_button = None
        send_selectors = [
            'button[type="submit"]',
            'button[aria-label*="Send"]',
            'button[aria-label*="é€ä¿¡"]',
            'button:has-text("é€ä¿¡")',
            'button:has-text("Send")',
            'button svg',  # ã‚¢ã‚¤ã‚³ãƒ³ãƒœã‚¿ãƒ³
        ]
        
        for selector in send_selectors:
            try:
                btn = await self.page.query_selector(selector)
                if btn and await btn.is_visible() and await btn.is_enabled():
                    send_button = btn
                    logger.info(f"é€ä¿¡ãƒœã‚¿ãƒ³ã‚’ç™ºè¦‹: {selector}")
                    break
            except:
                continue
        
        if send_button:
            await send_button.click()
            logger.info("âœ… DeepSeeké€ä¿¡ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã—ãŸ")
        else:
            # ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯Enterã‚­ãƒ¼ã§é€ä¿¡
            logger.info("é€ä¿¡ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã™")
            await input_element.press("Enter")
            logger.info("âœ… Enterã‚­ãƒ¼ã§é€ä¿¡ã—ã¾ã—ãŸ")
        
        await self.page.wait_for_timeout(3000)
    
    async def wait_for_text_generation(self, max_wait: int = 120) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã¾ã§å¾…æ©Ÿ"""
        try:
            if not self.page:
                return False
            logger.info("ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆã‚’å¾…æ©Ÿä¸­...")
            start_time = time.time()
            check_interval = 2
            await self.page.wait_for_timeout(5000)
            while time.time() - start_time < max_wait:
                await self.page.wait_for_timeout(check_interval * 1000)
                elapsed = int(time.time() - start_time)
                is_complete = await self.page.evaluate('''
                    () => {
                        const allButtons = document.querySelectorAll('button');
                        for (const btn of allButtons) {
                            const text = btn.textContent || '';
                            const ariaLabel = btn.getAttribute('aria-label') || '';
                            if (text.includes('å†ç”Ÿæˆ') || text.includes('Regenerate') ||
                                ariaLabel.includes('å†ç”Ÿæˆ') || ariaLabel.includes('Regenerate')) {
                                return true;
                            }
                        }
                        const sendButtons = document.querySelectorAll('[data-testid="send-button"], button[type="submit"]');
                        for (const btn of sendButtons) {
                            if (!btn.disabled && !btn.hasAttribute('disabled')) {
                                return true;
                            }
                        }
                        const loadingElements = document.querySelectorAll('[data-testid="loading"], .loading, .spinner');
                        if (loadingElements.length === 0) {
                            return true;
                        }
                        return false;
                    }
                ''')
                if is_complete:
                    logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå®Œäº†ã‚’æ¤œå‡º")
                    await self.page.wait_for_timeout(2000)
                    return True
                if elapsed % 10 == 0 and elapsed > 0:
                    logger.info(f"â³ å¾…æ©Ÿä¸­... {elapsed}ç§’çµŒé")
            logger.warning(f"â° ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ{max_wait}ç§’ï¼‰")
            return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆå¾…æ©Ÿ")
            return False

    async def extract_latest_text_response(self) -> str:
        """æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆã‚µãƒ¼ãƒ“ã‚¹è‡ªå‹•åˆ¤åˆ¥ç‰ˆï¼‰"""
        try:
            if self.service == "deepseek":
                return await self.extract_latest_text_response_deepseek()
            else:
                return await self.extract_latest_text_response_gemini()
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡º")
            return None
    
    async def extract_latest_text_response_gemini(self) -> str:
        """Geminiã®æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡ºï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’é™¤å¤–ï¼‰"""
        try:
            logger.info("=" * 60)
            logger.info("â˜…â˜…â˜… Geminiãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºé–‹å§‹ â˜…â˜…â˜…")
            logger.info("=" * 60)
            
            all_results = {}
            
            # æ–¹æ³•1: model-responseï¼ˆæœ€å„ªå…ˆï¼‰
            logger.info("\nã€æ–¹æ³•1ã€‘model-response")
            try:
                r1 = await self.page.evaluate('''() => {
                    // Geminiã®å¿œç­”ã®ã¿ã‚’å–å¾—ï¼ˆdata-message-author="model"ï¼‰
                    const modelMessages = document.querySelectorAll('[data-message-author="model"]');
                    if (modelMessages.length > 0) {
                        const lastMessage = modelMessages[modelMessages.length - 1];
                        return lastMessage.innerText || '';
                    }
                    return '';
                }''')
                all_results['æ–¹æ³•1'] = r1
                logger.info(f"çµæœ: {len(r1)}æ–‡å­— {'âœ…' if len(r1)>50 else 'âŒ'}")
                if len(r1) > 50: 
                    logger.info(f"å…ˆé ­: {r1[:100]}")
            except Exception as e:
                logger.error(f"ã‚¨ãƒ©ãƒ¼: {e}")
                all_results['æ–¹æ³•1'] = ""
            
            # æ–¹æ³•2: markdown-containerï¼ˆGeminiã®å¿œç­”ã®ã¿ï¼‰
            logger.info("\nã€æ–¹æ³•2ã€‘markdown-container")
            try:
                r2 = await self.page.evaluate('''() => {
                    const containers = document.querySelectorAll('.markdown-container, [class*="markdown"]');
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’å«ã‚€ã‚‚ã®ã‚’é™¤å¤–
                    for (let i = containers.length - 1; i >= 0; i--) {
                        const text = containers[i].innerText || '';
                        // ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®ç‰¹å¾´çš„ãªæ–‡å­—åˆ—ã‚’é™¤å¤–
                        if (text.includes('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª') || 
                            text.includes('ã€ã‚ãªãŸã®å½¹å‰²ã€‘') ||
                            text.includes('ã€åŸ·ç­†ä¾é ¼ã€‘')) {
                            continue;
                        }
                        if (text.length > 100) {
                            return text;
                        }
                    }
                    return '';
                }''')
                all_results['æ–¹æ³•2'] = r2
                logger.info(f"çµæœ: {len(r2)}æ–‡å­— {'âœ…' if len(r2)>50 else 'âŒ'}")
                if len(r2) > 50: 
                    logger.info(f"å…ˆé ­: {r2[:100]}")
            except Exception as e:
                logger.error(f"ã‚¨ãƒ©ãƒ¼: {e}")
                all_results['æ–¹æ³•2'] = ""
            
            # æ–¹æ³•3: ä¼šè©±å±¥æ­´ã‹ã‚‰æœ€å¾Œã®Geminiå¿œç­”ã‚’æŠ½å‡º
            logger.info("\nã€æ–¹æ³•3ã€‘ä¼šè©±å±¥æ­´åˆ†æ")
            try:
                r3 = await self.page.evaluate('''() => {
                    // ã™ã¹ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ–ãƒ­ãƒƒã‚¯ã‚’å–å¾—
                    const messages = document.querySelectorAll('[class*="message"]');
                    
                    // æœ€å¾Œã‹ã‚‰é †ã«ç¢ºèªã—ã€Geminiã®å¿œç­”ã‚’æ¢ã™
                    for (let i = messages.length - 1; i >= 0; i--) {
                        const msg = messages[i];
                        const text = msg.innerText || '';
                        
                        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ç‰¹å¾´ã‚’æŒã¤ã‚‚ã®ã‚’ã‚¹ã‚­ãƒƒãƒ—
                        if (text.includes('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª') ||
                            text.includes('ã€ã‚ãªãŸã®å½¹å‰²ã€‘') ||
                            text.includes('ã€åŸ·ç­†ä¾é ¼ã€‘') ||
                            text.length < 200) {
                            continue;
                        }
                        
                        // Geminiã®å¿œç­”ã‚‰ã—ã„è¦ç´ 
                        if (text.includes('#') || // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¦‹å‡ºã—
                            text.includes('**') || // å¤ªå­—
                            text.length > 500) {
                            return text;
                        }
                    }
                    return '';
                }''')
                all_results['æ–¹æ³•3'] = r3
                logger.info(f"çµæœ: {len(r3)}æ–‡å­— {'âœ…' if len(r3)>50 else 'âŒ'}")
                if len(r3) > 50: 
                    logger.info(f"å…ˆé ­: {r3[:100]}")
            except Exception as e:
                logger.error(f"ã‚¨ãƒ©ãƒ¼: {e}")
                all_results['æ–¹æ³•3'] = ""
            
            # å„ªå…ˆé †ä½ã§é¸æŠ: æ–¹æ³•1 > æ–¹æ³•2 > æ–¹æ³•3
            priority_order = ['æ–¹æ³•1', 'æ–¹æ³•2', 'æ–¹æ³•3']
            for method in priority_order:
                if method in all_results and all_results[method] and len(all_results[method]) > 100:
                    text = all_results[method]
                    
                    # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ··å…¥ã—ã¦ã„ãªã„ã‹æœ€çµ‚ãƒã‚§ãƒƒã‚¯
                    if ('ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãª' in text or 
                        'ã€ã‚ãªãŸã®å½¹å‰²ã€‘' in text or
                        'ã€åŸ·ç­†ä¾é ¼ã€‘' in text):
                        logger.warning(f"{method}ã«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŒæ··å…¥ - ã‚¹ã‚­ãƒƒãƒ—")
                        continue
                    
                    logger.info(f"\nğŸ¯ æ¡ç”¨: {method} ({len(text)}æ–‡å­—)")
                    logger.info(f"å…ˆé ­200æ–‡å­—:\n{text[:200]}")
                    return text.strip()
            
            # ã™ã¹ã¦å¤±æ•—ã—ãŸå ´åˆ
            logger.error("\nâŒ å…¨æ–¹æ³•å¤±æ•— - Geminiã®å¿œç­”ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ")
            
            # ãƒ‡ãƒãƒƒã‚°ç”¨: ãƒšãƒ¼ã‚¸ã®æ§‹é€ ã‚’ç¢ºèª
            page_structure = await self.page.evaluate('''() => {
                return {
                    messageCount: document.querySelectorAll('[class*="message"]').length,
                    modelMessages: document.querySelectorAll('[data-message-author="model"]').length,
                    markdownContainers: document.querySelectorAll('[class*="markdown"]').length
                };
            }''')
            logger.info(f"ãƒšãƒ¼ã‚¸æ§‹é€ : {page_structure}")
            
            return None
                    
        except Exception as e:
            logger.error(f"âŒ æŠ½å‡ºå…¨ä½“ã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    async def extract_latest_text_response_deepseek(self) -> str:
        """DeepSeekã®æœ€æ–°ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”ã‚’æŠ½å‡º"""
        try:
            logger.info("=" * 60)
            logger.info("â˜…â˜…â˜… DeepSeekãƒ†ã‚­ã‚¹ãƒˆæŠ½å‡ºé–‹å§‹ â˜…â˜…â˜…")
            logger.info("=" * 60)
            
            # DeepSeekç‰¹æœ‰ã®ã‚»ãƒ¬ã‚¯ã‚¿ã§å¿œç­”ã‚’å–å¾—
            response_text = await self.page.evaluate('''() => {
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒŠã‚’æ¢ã™
                const messages = document.querySelectorAll('[class*="message"], [class*="chat"], div[role="article"]');
                let longest = '';
                
                for (const msg of messages) {
                    const text = msg.innerText || '';
                    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯é™¤å¤–
                    if (text.length > 100 && text.length > longest.length) {
                        // ã‚·ã‚¹ãƒ†ãƒ ã‚„ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿
                        const isUserMessage = msg.querySelector('[class*="user"]') || 
                                            msg.classList.toString().includes('user');
                        if (!isUserMessage) {
                            longest = text;
                        }
                    }
                }
                
                if (!longest) {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æœ€å¾Œã®é•·ã„divã‚’å–å¾—
                    const divs = document.querySelectorAll('div');
                    for (const d of divs) {
                        const t = d.innerText || '';
                        if (t.length > longest.length && t.length > 200) {
                            longest = t;
                        }
                    }
                }
                
                return longest;
            }''')
            
            if response_text and len(response_text) > 50:
                logger.info(f"âœ… DeepSeekå¿œç­”æŠ½å‡ºæˆåŠŸ: {len(response_text)}æ–‡å­—")
                logger.info(f"å…ˆé ­500æ–‡å­—:\n{response_text[:500]}")
                
                # JSONéƒ¨åˆ†ã‚’æŠ½å‡º
                extracted_json = self.extract_json_from_text(response_text)
                if extracted_json:
                    logger.info(f"âœ… JSONæŠ½å‡ºæˆåŠŸ: {len(extracted_json)}æ–‡å­—")
                    return extracted_json
                else:
                    return response_text.strip()
            else:
                logger.error("âŒ DeepSeekå¿œç­”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return None
                
        except Exception as e:
            logger.error(f"âŒ DeepSeekæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None

    def extract_json_from_text(self, text: str) -> str:
        """ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰JSONéƒ¨åˆ†ã‚’æŠ½å‡º"""
        try:
            if not text:
                return None
                
            # ãƒ‘ã‚¿ãƒ¼ãƒ³1: ```json ... ``` ã«å›²ã¾ã‚ŒãŸJSON
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³2: å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æŠ½å‡º
            json_match = re.search(r'^\s*(\{.*\})\s*$', text, re.DOTALL)
            if json_match:
                return json_match.group(1).strip()
            
            # ãƒ‘ã‚¿ãƒ¼ãƒ³3: å…ˆé ­ã‹ã‚‰JSONã‚’æ¢ã™
            start_idx = text.find('{')
            if start_idx != -1:
                # { ã‹ã‚‰å§‹ã‚ã¦ã€å¯¾å¿œã™ã‚‹ } ã¾ã§ã‚’æ¢ã™
                brace_count = 0
                for i, char in enumerate(text[start_idx:]):
                    if char == '{':
                        brace_count += 1
                    elif char == '}':
                        brace_count -= 1
                        if brace_count == 0:
                            potential_json = text[start_idx:start_idx+i+1]
                            try:
                                json.loads(potential_json)
                                return potential_json.strip()
                            except:
                                continue
            return None
        except Exception as e:
            logger.error(f"JSONæŠ½å‡ºã‚¨ãƒ©ãƒ¼: {e}")
            return None
    
    async def save_text_to_file(self, text: str, filename: str) -> bool:
        """ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ä¸€æ™‚ä¿å­˜ç”¨ï¼‰"""
        try:
            save_path = self.download_folder / filename
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(text)
            if save_path.exists():
                file_size = save_path.stat().st_size
                logger.info(f"âœ… ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜æˆåŠŸ: {filename} ({file_size:,} bytes)")
                return True
            else:
                logger.error(f"âŒ ãƒ†ã‚­ã‚¹ãƒˆä¿å­˜å¤±æ•—: {filename}")
                return False
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜")
            return False
    
    async def cleanup(self) -> None:
        """ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’å¼·åŒ–ï¼ˆWindowséåŒæœŸå•é¡Œå¯¾å¿œç‰ˆï¼‰"""
        try:
            logger.info("ğŸ”„ ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™...")

            # éåŒæœŸã‚¿ã‚¹ã‚¯ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            try:
                tasks = [t for t in asyncio.all_tasks() 
                        if t is not asyncio.current_task()]
                        
                if tasks:
                    logger.info(f"ğŸ”„ {len(tasks)}å€‹ã®éåŒæœŸã‚¿ã‚¹ã‚¯ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­...")
                    for task in tasks:
                        task.cancel()
                            
                    # ã‚¿ã‚¹ã‚¯ã®å®Œäº†å¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
                    await asyncio.wait_for(
                        asyncio.gather(*tasks, return_exceptions=True),
                        timeout=5.0
                    )
                    logger.info("âœ… éåŒæœŸã‚¿ã‚¹ã‚¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")
            except asyncio.TimeoutError:
                logger.warning("âš ï¸ ã‚¿ã‚¹ã‚¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
            except Exception as e:
                logger.warning(f"âš ï¸ ã‚¿ã‚¹ã‚¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")

            # ãƒšãƒ¼ã‚¸ã®ã‚¯ãƒ­ãƒ¼ã‚º
            if hasattr(self, 'page') and self.page:
                try:
                    await self.page.close()
                    logger.info("âœ… ãƒšãƒ¼ã‚¸ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ãƒšãƒ¼ã‚¸ã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

            # ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¯ãƒ­ãƒ¼ã‚º
            if hasattr(self, 'context') and self.context:
                try:
                    await self.context.close()
                    logger.info("âœ… ãƒ–ãƒ©ã‚¦ã‚¶ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®è­¦å‘Š: {e}")

            # Playwrightã®åœæ­¢
            if hasattr(self, 'playwright') and self.playwright:
                try:
                    await self.playwright.stop()
                    logger.info("âœ… Playwrightã‚’åœæ­¢ã—ã¾ã—ãŸ")
                except Exception as e:
                    logger.warning(f"âš ï¸ Playwrightåœæ­¢ä¸­ã®è­¦å‘Š: {e}")

            logger.info("âœ… ãƒªã‚½ãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")

        except Exception as e:
            logger.error(f"âŒ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ä¸­ã®ã‚¨ãƒ©ãƒ¼: {e}")