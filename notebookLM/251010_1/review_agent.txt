# review_agent.py
"""ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

from config_utils import ErrorHandler
from browser_controller import BrowserController
from sheets_manager import GoogleSheetsManager

logger = logging.getLogger(__name__)

class ReviewAgent:
    """ãƒ¬ãƒ“ãƒ¥ãƒ¼AI - ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’è©•ä¾¡ã—ã€å¤±æ•—åŸå› ã‚’åˆ†æã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ"""
    
    REVIEW_SYSTEM_PROMPT = """ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã§ã™ã€‚

ã€ã‚ãªãŸã®å½¹å‰²ã€‘
- ã‚¿ã‚¹ã‚¯ã®å®Œæˆåº¦ã‚’è©•ä¾¡ã™ã‚‹
- å‡ºåŠ›ç‰©ã®å“è³ªã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
- **å¤±æ•—åŸå› ã‚’ç‰¹å®šã—åˆ†é¡ã™ã‚‹**
- æ¬¡ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã‚’ç‰¹å®šã™ã‚‹
- æ”¹å–„ç‚¹ã‚„å•é¡Œç‚¹ã‚’æŒ‡æ‘˜ã™ã‚‹

ã€å¤±æ•—åŸå› ã®åˆ†é¡ã€‘
ã‚¿ã‚¹ã‚¯ãŒå¤±æ•—ã—ãŸå ´åˆã€ä»¥ä¸‹ã®ã‚«ãƒ†ã‚´ãƒªã§åŸå› ã‚’ç‰¹å®šã—ã¦ãã ã•ã„ï¼š

1. **è¦ä»¶ä¸æ˜ç­** - ã‚¿ã‚¹ã‚¯ã®èª¬æ˜ãŒä¸ååˆ†ã€æ›–æ˜§
2. **æŠ€è¡“çš„å•é¡Œ** - å®Ÿè£…ã®é›£æ˜“åº¦ãŒé«˜ã„ã€æŠ€è¡“çš„åˆ¶ç´„
3. **ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³** - å¿…è¦ãªæƒ…å ±ã€ãƒ„ãƒ¼ãƒ«ã€æ¨©é™ãŒä¸è¶³
4. **ä¾å­˜é–¢ä¿‚** - å‰æã‚¿ã‚¹ã‚¯ãŒæœªå®Œäº†ã€å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ãŒãªã„
5. **ç’°å¢ƒå•é¡Œ** - ã‚·ã‚¹ãƒ†ãƒ ã€ãƒ–ãƒ©ã‚¦ã‚¶ã€APIã®å•é¡Œ
6. **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ** - å‡¦ç†æ™‚é–“ãŒé•·ã™ãã‚‹
7. **å‡ºåŠ›ä¸å®Œå…¨** - å‡ºåŠ›ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã€æ§‹é€ ãŒä¸å®Œå…¨
8. **å“è³ªä¸è¶³** - æˆæœç‰©ã®å“è³ªãŒåŸºæº–ã‚’æº€ãŸã—ã¦ã„ãªã„

ã€é‡è¦ãªåˆ¤æ–­åŸºæº– - èª¤åˆ¤æ–­é˜²æ­¢ã€‘
â˜… ä»¥ä¸‹ã®å ´åˆã¯ã€Œå®Œäº†ã€ã¨åˆ¤æ–­ã—ã¦ãã ã•ã„ï¼š
- è¨˜äº‹ãƒ»æ–‡æ›¸ãŒå°å…¥â†’æœ¬ç·¨â†’çµè«–ã®æ§‹é€ ã«ãªã£ã¦ã„ã‚‹
- ä¸»è¦ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå…¨ã¦å«ã¾ã‚Œã¦ã„ã‚‹
- å†…å®¹çš„ã«å®Œçµã—ã¦ã„ã‚‹ï¼ˆé€”ä¸­ã§æ–‡ãŒåˆ‡ã‚Œã¦ã„ãªã„ï¼‰
- HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³æ§‹é€ ãŒé©åˆ‡ã«é–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹
- æ–‡å­—æ•°ãŒå¤šå°‘å°‘ãªãã¦ã‚‚ã€å†…å®¹ãŒå……å®Ÿã—ã¦ã„ã‚‹
- æ–‡æ›¸ã®æœ€å¾Œã«æ˜ç¢ºãªçµè«–ã‚„ã¾ã¨ã‚ãŒã‚ã‚‹

â˜… ã€Œéƒ¨åˆ†çš„ã€ã¨åˆ¤æ–­ã™ã‚‹ã®ã¯æœ¬å½“ã«æ˜ã‚‰ã‹ã«æœªå®Œæˆã®å ´åˆã®ã¿ï¼š
- æ˜ã‚‰ã‹ã«æ–‡ã®é€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ï¼ˆä¸»èªã ã‘ã€å‹•è©ãŒãªã„ãªã©ï¼‰
- ä¸»è¦ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Œå…¨ã«æ¬ è½ã—ã¦ã„ã‚‹
- ã€Œç¶šãã€ã€Œå¾Œè¿°ã€ãªã©ã®æœªå®Œæˆã‚’ç¤ºã™è¡¨ç¾ãŒã‚ã‚‹
- HTMLã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ãªã„ãªã©ã®æ§‹é€ çš„å•é¡Œ

ã€è©•ä¾¡åŸºæº–ã€‘
1. å®Œæˆåº¦: ã‚¿ã‚¹ã‚¯ãŒè¦æ±‚ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹
2. å“è³ª: å®Ÿè£…å¯èƒ½ã§å…·ä½“çš„ã‹
3. å¤±æ•—åŸå› : ãªãœå¤±æ•—ã—ãŸã®ã‹ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
4. æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: ä½•ãŒä¸è¶³ã—ã¦ã„ã‚‹ã‹

ã€å‡ºåŠ›å½¢å¼ã€‘
å¿…ãšJSONå½¢å¼ã§å‡ºåŠ›ã—ã¦ãã ã•ã„ï¼š

```json
{
  "evaluation": {
    "completeness": "å®Œäº†|éƒ¨åˆ†çš„|ä¸å®Œå…¨|å¤±æ•—",
    "quality_score": 1-10,
    "issues": ["å•é¡Œç‚¹1", "å•é¡Œç‚¹2"],
    "good_points": ["è‰¯ã„ç‚¹1", "è‰¯ã„ç‚¹2"],
    "overall_assessment": "ç·åˆè©•ä¾¡ã®ã‚µãƒãƒªãƒ¼ï¼ˆ100æ–‡å­—ç¨‹åº¦ï¼‰",
    "failure_analysis": {
      "is_failed": true|false,
      "failure_category": "è¦ä»¶ä¸æ˜ç­|æŠ€è¡“çš„å•é¡Œ|ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³|ä¾å­˜é–¢ä¿‚|ç’°å¢ƒå•é¡Œ|ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ|å‡ºåŠ›ä¸å®Œå…¨|å“è³ªä¸è¶³",
      "root_cause": "å¤±æ•—ã®æ ¹æœ¬åŸå› ã®è©³ç´°èª¬æ˜",
      "impact": "ã“ã®å¤±æ•—ãŒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ä¸ãˆã‚‹å½±éŸ¿",
      "recommended_action": "immediate_retry|modify_task|add_prerequisite|escalate|skip",
      "prerequisites": ["å‰ææ¡ä»¶1", "å‰ææ¡ä»¶2"]
    }
  },
  "next_actions": {
    "required": true|false,
    "reasoning": "æ¬¡ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
    "suggested_tasks": [
      {
        "description": "å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯å†…å®¹",
        "required_role": "design|dev|ui|review|writer|wordpress",
        "priority": "high|medium|low",
        "reasoning": "ã“ã®ã‚¿ã‚¹ã‚¯ãŒå¿…è¦ãªç†ç”±",
        "dependencies": ["ä¾å­˜ã™ã‚‹ã‚¿ã‚¹ã‚¯ID"],
        "estimated_time": "äºˆæƒ³æ™‚é–“"
      }
    ]
  }
}
```

ã€å¤±æ•—æ™‚ã®æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é¸æŠåŸºæº–ã€‘
- **immediate_retry**: ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ï¼‰
- **modify_task**: è¦ä»¶ãŒä¸æ˜ç­ã€ã‚¿ã‚¹ã‚¯å†…å®¹ã®ä¿®æ­£ãŒå¿…è¦
- **add_prerequisite**: å‰æã‚¿ã‚¹ã‚¯ãŒä¸è¶³ã—ã¦ã„ã‚‹
- **escalate**: äººé–“ã®åˆ¤æ–­ãŒå¿…è¦ãªå•é¡Œ
- **skip**: ã“ã®ã‚¿ã‚¹ã‚¯ã¯ä¸è¦ã¾ãŸã¯å¾Œå›ã—ã«ã™ã¹ã

ã€é‡è¦ãªåˆ¤æ–­åŸºæº–ã€‘
- è¦ä»¶å®šç¾©ã ã‘ã§å®Ÿè£…ãŒãªã„å ´åˆ â†’ å®Ÿè£…ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ
- è¨­è¨ˆæ›¸ã ã‘ã§ã‚³ãƒ¼ãƒ‰ãŒãªã„å ´åˆ â†’ é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ
- ã‚³ãƒ¼ãƒ‰ã«ãƒ†ã‚¹ãƒˆãŒãªã„å ´åˆ â†’ ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ
- ä¸å®Œå…¨ãªå‡ºåŠ›ã®å ´åˆ â†’ æ”¹å–„ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆ
- ååˆ†ã«å®Œæˆã—ã¦ã„ã‚‹å ´åˆ â†’ æ¬¡ã®ã‚¿ã‚¹ã‚¯ã¯ä¸è¦ã¨åˆ¤æ–­

ã‚¿ã‚¹ã‚¯ã‚’ææ¡ˆã—ã™ããªã„ã“ã¨ã€‚æœ¬å½“ã«å¿…è¦ãªã‚¿ã‚¹ã‚¯ã®ã¿ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚"""

    def __init__(self):
        """ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ - å¾Œã§ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®šã™ã‚‹"""
        self.browser = None
        self.sheets_manager = None

    async def process_task(self, task: Dict) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰"""
        return await self.review_completed_task(task, task.get('output_content', ''))

    async def review_completed_task(self, task: Dict, output_content: str) -> Dict:
        """å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå¤±æ•—åŸå› åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        try:
            logger.info("="*60)
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¹ã‚¯ {task['task_id']} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹")
            logger.info("="*60)
            
            # ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ç¢ºèª
            task_status = task.get('status', 'unknown')
            is_failed_task = task_status in ['failed', 'error', 'timeout']
            
            # äº‹å‰ãƒã‚§ãƒƒã‚¯ï¼šå‡ºåŠ›å†…å®¹ã®æ§‹é€ ã‚’æ¤œè¨¼
            pre_check_result = self._pre_check_content(output_content, task['required_role'])
            if pre_check_result:
                logger.info(f"äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœ: {pre_check_result}")
            
            # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’å–å¾—
            error_info = task.get('error', '')
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
            full_prompt = f"""{self.REVIEW_SYSTEM_PROMPT}

ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾è±¡ã‚¿ã‚¹ã‚¯ã€‘
ã‚¿ã‚¹ã‚¯ID: {task['task_id']}
å†…å®¹: {task['description']}
æ‹…å½“: {task['required_role']}
ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {task_status}
å‡ºåŠ›æ–‡å­—æ•°: {len(output_content)}æ–‡å­—

ã€ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ã€‘
{'âŒ ã“ã®ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸ' if is_failed_task else 'âœ… ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã—ã¾ã—ãŸ'}
{f'ã‚¨ãƒ©ãƒ¼æƒ…å ±: {error_info}' if error_info else ''}

ã€äº‹å‰ãƒã‚§ãƒƒã‚¯çµæœã€‘
{pre_check_result if pre_check_result else 'ç‰¹è¨˜äº‹é …ãªã—'}

ã€ã‚¿ã‚¹ã‚¯ã®å‡ºåŠ›ã€‘
{output_content[:4000] if output_content else 'ï¼ˆå‡ºåŠ›ãªã—ï¼‰'}

ä¸Šè¨˜ã®ã‚¿ã‚¹ã‚¯å‡ºåŠ›ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã€æŒ‡å®šã•ã‚ŒãŸJSONå½¢å¼ã§è©•ä¾¡ã¨æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚
{'ç‰¹ã«å¤±æ•—åŸå› ã‚’è©³ç´°ã«åˆ†æã—ã€é©åˆ‡ãªæ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚' if is_failed_task else 'ç‰¹ã«ã€æ§‹é€ çš„ã«å®Œçµã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’é‡ç‚¹çš„ã«ç¢ºèªã—ã¦ãã ã•ã„ã€‚'}
"""

            # Geminiã«é€ä¿¡
            logger.info("ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’Geminiã«ä¾é ¼ä¸­...")
            await self.browser.send_prompt(full_prompt)
            
            # å¿œç­”å¾…æ©Ÿ
            success = await self.browser.wait_for_text_generation(max_wait=120)
            
            if not success:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ")
                return self._create_default_review(task, is_failed_task)
            
            # å¿œç­”ã‚’å–å¾—
            response_text = await self.browser.extract_latest_text_response()
            
            if not response_text:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
            
            logger.info(f"ãƒ¬ãƒ“ãƒ¥ãƒ¼AI: å¿œç­”å–å¾—å®Œäº†ï¼ˆ{len(response_text)}æ–‡å­—ï¼‰")
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            review_result = self._parse_review_json(response_text)
            
            if review_result:
                # ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
                validated_review = self._validate_review_result(review_result, output_content)
                self._display_review_summary(validated_review, is_failed_task)
                return {
                    'success': True,
                    'review': validated_review,
                    'summary': validated_review.get('evaluation', {}).get('overall_assessment', ''),
                    'full_text': response_text
                }
            else:
                logger.warning("ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONè§£æã«å¤±æ•—")
                return self._create_default_review(task, is_failed_task)
                
        except Exception as e:
            ErrorHandler.log_error(e, "ãƒ¬ãƒ“ãƒ¥ãƒ¼AIå‡¦ç†")
            return self._create_default_review(task, False)

    def _pre_check_content(self, content: str, role: str) -> str:
        """å‡ºåŠ›å†…å®¹ã®äº‹å‰ãƒã‚§ãƒƒã‚¯"""
        checks = []
        
        # æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯
        if len(content) < 100:
            checks.append("âš ï¸ æ–‡å­—æ•°ãŒå°‘ãªã™ãã¾ã™ï¼ˆ100æ–‡å­—æœªæº€ï¼‰")
        elif len(content) > 5000:
            checks.append("âœ… æ–‡å­—æ•°ãŒååˆ†ã§ã™")
        
        # æ§‹é€ ãƒã‚§ãƒƒã‚¯ï¼ˆè¨˜äº‹ãƒ»æ–‡æ›¸ç³»ã‚¿ã‚¹ã‚¯ã®å ´åˆï¼‰
        if role in ['writer', 'content', 'wordpress', 'writer_ja', 'writer_en', 'writer_ru']:
            if '<h1' in content or '<h2' in content or '# ' in content:
                checks.append("âœ… è¦‹å‡ºã—æ§‹é€ ãŒã‚ã‚Šã¾ã™")
            
            if any(phrase in content for phrase in ['ã¾ã¨ã‚', 'çµè«–', 'çµ‚ã‚ã‚Š', 'ä»¥ä¸Š', 'æœ€å¾Œã«', 'Conclusion', 'Summary']):
                checks.append("âœ… çµè«–ãƒ»ã¾ã¨ã‚ãŒã‚ã‚Šã¾ã™")
            else:
                checks.append("âš ï¸ æ˜ç¤ºçš„ãªçµè«–ãƒ»ã¾ã¨ã‚ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            
            # HTML/ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã®é–‰ã˜å¿˜ã‚Œãƒã‚§ãƒƒã‚¯
            if content.count('<div') > content.count('</div'):
                checks.append("âš ï¸ HTMLã®divã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
            if content.count('<p>') > content.count('</p>'):
                checks.append("âš ï¸ HTMLã®pã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã¾ã›ã‚“")
        
        # ã‚³ãƒ¼ãƒ‰ç³»ã‚¿ã‚¹ã‚¯ã®å ´åˆ
        if role in ['dev', 'programming']:
            if 'def ' in content or 'function ' in content or 'class ' in content:
                checks.append("âœ… é–¢æ•°/ã‚¯ãƒ©ã‚¹å®šç¾©ãŒã‚ã‚Šã¾ã™")
            if 'import ' in content or 'require ' in content:
                checks.append("âœ… ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ–‡ãŒã‚ã‚Šã¾ã™")
        
        return " | ".join(checks) if checks else "âœ… åŸºæœ¬çš„ãªæ§‹é€ ã¯å•é¡Œã‚ã‚Šã¾ã›ã‚“"

    def _validate_review_result(self, review: Dict, original_content: str) -> Dict:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®å¦¥å½“æ€§ã‚’æ¤œè¨¼"""
        evaluation = review.get('evaluation', {})
        next_actions = review.get('next_actions', {})
        
        # ã€Œéƒ¨åˆ†çš„ã€åˆ¤å®šã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        if evaluation.get('completeness') == 'éƒ¨åˆ†çš„':
            issues = evaluation.get('issues', [])
            new_issues = []
            
            for issue in issues:
                # æ–‡å­—æ•°é–¢é€£ã®æŒ‡æ‘˜ã‚’æ¤œè¨¼
                if any(word in issue for word in ['æ–‡å­—æ•°', 'æ–‡å­—', 'çŸ­ã„', 'å°‘ãªã„']):
                    if len(original_content) > 1000:  # 1000æ–‡å­—ä»¥ä¸Šã‚ã‚Œã°æ–‡å­—æ•°ä¸è¶³ã§ã¯ãªã„
                        continue
                # æ§‹é€ çš„ãªæŒ‡æ‘˜ã‚’æ¤œè¨¼
                elif 'åˆ‡ã‚Œã¦' in issue or 'é€”åˆ‡ã‚Œ' in issue:
                    # å®Ÿéš›ã«æ–‡ãŒé€”ä¸­ã§åˆ‡ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                    if self._is_content_properly_ended(original_content):
                        continue
                
                new_issues.append(issue)
            
            # å•é¡Œç‚¹ã‚’æ›´æ–°
            evaluation['issues'] = new_issues
            
            # å•é¡Œç‚¹ãŒãªããªã£ãŸå ´åˆã¯ã€Œå®Œäº†ã€ã«å¤‰æ›´
            if not new_issues and len(original_content) > 500:
                evaluation['completeness'] = 'å®Œäº†'
                evaluation['overall_assessment'] = 'å†è©•ä¾¡: å†…å®¹ã¯å®Œçµã—ã¦ãŠã‚Šã€æ–‡å­—æ•°ã‚‚ååˆ†ã§ã™'
                next_actions['required'] = False
                next_actions['suggested_tasks'] = []
        
        return review

    def _is_content_properly_ended(self, content: str) -> bool:
        """ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒé©åˆ‡ã«çµ‚äº†ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        # æœ€å¾Œã®æ–‡ãŒå®Œå…¨ã‹ãƒã‚§ãƒƒã‚¯
        sentences = re.split(r'[ã€‚ï¼ï¼Ÿ!?\.]', content.strip())
        if sentences and sentences[-1].strip():
            return False  # æœ€å¾Œã®æ–‡ãŒçµ‚äº†è¨˜å·ã§çµ‚ã‚ã£ã¦ã„ãªã„
        
        # HTMLã‚¿ã‚°ãŒé–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        if content.count('<') > 0 and content.count('>') > 0:
            open_tags = len(re.findall(r'<(?!\/)[^>]+>', content))
            close_tags = len(re.findall(r'<\/[^>]+>', content))
            if open_tags != close_tags:
                return False
        
        return True

    def _parse_review_json(self, text: str) -> Optional[Dict]:
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã®JSONã‚’ãƒ‘ãƒ¼ã‚¹"""
        try:
            import re
            
            # ```json ... ``` ã§å›²ã¾ã‚Œã¦ã„ã‚‹å ´åˆ
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            # å˜ç´”ãªJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            json_match = re.search(r'(\{.*\})', text, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                return json.loads(json_str)
            
            logger.warning("JSONå½¢å¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None
            
        except json.JSONDecodeError as e:
            logger.error(f"JSONè§£æã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def _create_default_review(self, task: Dict, is_failed: bool = False) -> Dict:
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœï¼ˆå¤±æ•—æ™‚ï¼‰"""
        if is_failed:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å¤±æ•—',
                        'quality_score': 3,
                        'issues': ['ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ'],
                        'good_points': [],
                        'overall_assessment': 'ã‚¿ã‚¹ã‚¯ã¯å¤±æ•—ã—ã¾ã—ãŸãŒã€ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚‚å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸ',
                        'failure_analysis': {
                            'is_failed': True,
                            'failure_category': 'ç’°å¢ƒå•é¡Œ',
                            'root_cause': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—',
                            'impact': 'å¤±æ•—åŸå› ã®è©³ç´°ãŒä¸æ˜',
                            'recommended_action': 'immediate_retry',
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': True,
                        'reasoning': 'ã‚¿ã‚¹ã‚¯ã®å†å®Ÿè¡Œã¾ãŸã¯ä¿®æ­£ãŒå¿…è¦',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ã‚¿ã‚¹ã‚¯å¤±æ•—',
                'full_text': ''
            }
        else:
            return {
                'success': True,
                'review': {
                    'evaluation': {
                        'completeness': 'å®Œäº†',
                        'quality_score': 7,
                        'issues': [],
                        'good_points': ['ã‚¿ã‚¹ã‚¯å®Œäº†'],
                        'overall_assessment': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸãŒã€ã‚¿ã‚¹ã‚¯ã¯å®Œäº†ã¨ã¿ãªã—ã¾ã™',
                        'failure_analysis': {
                            'is_failed': False,
                            'failure_category': None,
                            'root_cause': None,
                            'impact': None,
                            'recommended_action': None,
                            'prerequisites': []
                        }
                    },
                    'next_actions': {
                        'required': False,
                        'reasoning': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼AIã®å¿œç­”å–å¾—ã«å¤±æ•—ã—ãŸãŸã‚ã€è¿½åŠ ã‚¿ã‚¹ã‚¯ãªã—',
                        'suggested_tasks': []
                    }
                },
                'summary': 'ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè©•ä¾¡',
                'full_text': ''
            }

    def _display_review_summary(self, review: Dict, is_failed_task: bool = False):
        """ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœã‚’è¡¨ç¤ºï¼ˆå¤±æ•—åˆ†æå¼·åŒ–ç‰ˆï¼‰"""
        
        print("\n" + "ğŸ¯" * 30)
        print("ğŸ“‹ ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ")
        print("ğŸ¯" * 30)
        
        evaluation = review.get('evaluation', {})
        
        # åŸºæœ¬æƒ…å ±
        completeness = evaluation.get('completeness', 'N/A')
        completeness_icon = {
            'å®Œäº†': 'âœ…',
            'éƒ¨åˆ†çš„': 'âš ï¸',
            'ä¸å®Œå…¨': 'âŒ',
            'å¤±æ•—': 'ğŸ’¥'
        }.get(completeness, 'â“')
        
        print(f"\n{completeness_icon} å®Œæˆåº¦: {completeness}")
        print(f"â­ å“è³ªã‚¹ã‚³ã‚¢: {evaluation.get('quality_score', 'N/A')}/10")
        
        # å¤±æ•—åˆ†æï¼ˆå¤±æ•—ã—ãŸå ´åˆã®ã¿ï¼‰
        failure_analysis = evaluation.get('failure_analysis', {})
        if failure_analysis.get('is_failed'):
            print("\n" + "ğŸ’¥" * 30)
            print("ğŸ” å¤±æ•—åŸå› åˆ†æ")
            print("ğŸ’¥" * 30)
            
            category = failure_analysis.get('failure_category', 'N/A')
            category_icon = {
                'è¦ä»¶ä¸æ˜ç­': 'ğŸ“',
                'æŠ€è¡“çš„å•é¡Œ': 'âš™ï¸',
                'ãƒªã‚½ãƒ¼ã‚¹ä¸è¶³': 'ğŸ“¦',
                'ä¾å­˜é–¢ä¿‚': 'ğŸ”—',
                'ç’°å¢ƒå•é¡Œ': 'ğŸŒ',
                'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ': 'â±ï¸',
                'å‡ºåŠ›ä¸å®Œå…¨': 'âœ‚ï¸',
                'å“è³ªä¸è¶³': 'ğŸ“‰'
            }.get(category, 'â“')
            
            print(f"\n{category_icon} å¤±æ•—ã‚«ãƒ†ã‚´ãƒª: {category}")
            print(f"ğŸ” æ ¹æœ¬åŸå› : {failure_analysis.get('root_cause', 'N/A')}")
            print(f"ğŸ’¡ å½±éŸ¿: {failure_analysis.get('impact', 'N/A')}")
            
            action = failure_analysis.get('recommended_action', 'N/A')
            action_map = {
                'immediate_retry': 'ğŸ”„ å³åº§ã«å†å®Ÿè¡Œ',
                'modify_task': 'âœï¸ ã‚¿ã‚¹ã‚¯ã‚’ä¿®æ­£',
                'add_prerequisite': 'â• å‰æã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ',
                'escalate': 'ğŸš¨ ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆäººé–“ã®åˆ¤æ–­ãŒå¿…è¦ï¼‰',
                'skip': 'â­ï¸ ã‚¹ã‚­ãƒƒãƒ—ã¾ãŸã¯å¾Œå›ã—'
            }
            print(f"ğŸ“Œ æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_map.get(action, action)}")
            
            prereqs = failure_analysis.get('prerequisites', [])
            if prereqs:
                print(f"\nğŸ“‹ å‰ææ¡ä»¶:")
                for prereq in prereqs:
                    print(f"   â€¢ {prereq}")
            
            print("ğŸ’¥" * 30)
        
        # è‰¯ã„ç‚¹
        good_points = evaluation.get('good_points', [])
        if good_points:
            print(f"\nâœ¨ è‰¯ã„ç‚¹:")
            for point in good_points:
                print(f"   âœ… {point}")
        
        # å•é¡Œç‚¹
        issues = evaluation.get('issues', [])
        if issues:
            print(f"\nâš ï¸ å•é¡Œç‚¹:")
            for issue in issues:
                print(f"   âŒ {issue}")
        
        # ç·åˆè©•ä¾¡
        overall = evaluation.get('overall_assessment', '')
        if overall:
            print(f"\nğŸ’ ç·åˆè©•ä¾¡:")
            print(f"   {overall}")
        
        # æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        next_actions = review.get('next_actions', {})
        required = next_actions.get('required', False)
        
        action_icon = 'ğŸ”´' if required else 'ğŸŸ¢'
        print(f"\nğŸ¯ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: {action_icon} {'å¿…è¦' if required else 'ä¸è¦'}")
        
        if required:
            reasoning = next_actions.get('reasoning', '')
            if reasoning:
                print(f"   ğŸ“Œ ç†ç”±: {reasoning}")
            
            # ææ¡ˆã‚¿ã‚¹ã‚¯
            suggested_tasks = next_actions.get('suggested_tasks', [])
            if suggested_tasks:
                print(f"\nğŸš€ ææ¡ˆã‚¿ã‚¹ã‚¯ ({len(suggested_tasks)}ä»¶):")
                for i, task in enumerate(suggested_tasks, 1):
                    priority_icon = {
                        'high': 'ğŸ”´',
                        'medium': 'ğŸŸ¡',
                        'low': 'ğŸŸ¢'
                    }.get(task.get('priority', 'medium'), 'âšª')
                    
                    role_icon = {
                        'design': 'ğŸ“',
                        'dev': 'ğŸ’»',
                        'ui': 'ğŸ¨',
                        'review': 'âœ…',
                        'wordpress': 'ğŸŒ',
                        'content': 'âœï¸',
                        'writer': 'ğŸ“',
                        'writer_ja': 'ğŸ—¾',
                        'writer_en': 'ğŸ” ',
                        'writer_ru': 'ğŸ‡·ğŸ‡º'
                    }.get(task.get('required_role', 'dev'), 'ğŸ“‹')
                    
                    print(f"   {i}. {priority_icon} {role_icon} {task.get('description', 'N/A')}")
                    
                    deps = task.get('dependencies', [])
                    if deps:
                        print(f"      ğŸ“ ä¾å­˜: {', '.join(map(str, deps))}")
        
        print("ğŸ¯" * 30 + "\n")

    async def add_suggested_tasks_to_sheet(self, parent_task_id: str, suggested_tasks: List[Dict]) -> int:
        """ææ¡ˆã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ã‚’pm_tasksã‚·ãƒ¼ãƒˆã«è¿½åŠ ï¼ˆæ­£ã—ã„åˆ—é…ç½®ç‰ˆï¼‰"""
        try:
            if not suggested_tasks:
                return 0
            
            logger.info(f"ææ¡ˆã‚¿ã‚¹ã‚¯ {len(suggested_tasks)} ä»¶ã‚’ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã«è¿½åŠ ä¸­...")
            
            sheet = self.sheets_manager.gc.open_by_key(self.sheets_manager.spreadsheet_id)
            task_sheet = sheet.worksheet("pm_tasks")
            
            # æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            all_values = task_sheet.get_all_values()
            
            if len(all_values) < 1:
                logger.error("pm_tasksã‚·ãƒ¼ãƒˆãŒç©ºã§ã™")
                return 0
            
            # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’ç¢ºèª
            headers = all_values[0]
            logger.info(f"åˆ—ãƒ˜ãƒƒãƒ€ãƒ¼: {headers}")
            
            # æ—¢å­˜ã®ã‚¿ã‚¹ã‚¯IDã‹ã‚‰æ¬¡ã®IDã‚’æ±ºå®š
            existing_task_ids = []
            for row in all_values[1:]:  # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—
                if row and len(row) > 0:
                    try:
                        task_id = int(row[0])
                        existing_task_ids.append(task_id)
                    except (ValueError, IndexError):
                        continue
            
            # æ¬¡ã®ã‚¿ã‚¹ã‚¯IDã‚’æ±ºå®š
            if existing_task_ids:
                next_task_id = max(existing_task_ids) + 1
            else:
                next_task_id = 1
            
            logger.info(f"æ¬¡ã®ã‚¿ã‚¹ã‚¯ID: {next_task_id}")
            
            # åˆ—ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆpm_tasksã‚·ãƒ¼ãƒˆã®æ¨™æº–æ§‹é€ ï¼‰
            # A: task_id
            # B: parent_goal_id
            # C: task_description (description)
            # D: required_role
            # E: status
            # F: priority
            # G: estimated_time
            # H: dependencies
            # I: created_at
            # J: batch_id / notes
            
            # æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ 
            rows_to_add = []
            for task in suggested_tasks:
                row = [
                    next_task_id,  # A: task_id
                    '',  # B: parent_goal_idï¼ˆç©ºæ¬„ï¼‰
                    task.get('description', ''),  # C: task_description
                    task.get('required_role', 'dev'),  # D: required_role
                    'pending',  # E: status
                    task.get('priority', 'medium'),  # F: priority
                    task.get('estimated_time', ''),  # G: estimated_time
                    ','.join(map(str, task.get('dependencies', [parent_task_id]))),  # H: dependencies
                    datetime.now().isoformat(),  # I: created_at
                    f"Review suggested from task {parent_task_id}"  # J: notes
                ]
                rows_to_add.append(row)
                logger.info(f"è¿½åŠ äºˆå®šã‚¿ã‚¹ã‚¯: ID={next_task_id}, å†…å®¹={task.get('description', '')[:50]}")
                next_task_id += 1
            
            # ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ 
            if rows_to_add:
                # æœ€çµ‚è¡Œã®æ¬¡ã®è¡Œã‹ã‚‰è¿½åŠ 
                start_row = len(all_values) + 1
                
                # ã‚»ãƒ«ç¯„å›²ã‚’æŒ‡å®šã—ã¦è¿½åŠ 
                range_notation = f'A{start_row}:J{start_row + len(rows_to_add) - 1}'
                
                logger.info(f"ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ : {range_notation}")
                task_sheet.update(range_notation, rows_to_add)
                
                logger.info(f"âœ… ææ¡ˆã‚¿ã‚¹ã‚¯ {len(rows_to_add)} ä»¶ã‚’è¿½åŠ ã—ã¾ã—ãŸ")
                
                # è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯IDã‚’ãƒ­ã‚°å‡ºåŠ›
                added_ids = [row[0] for row in rows_to_add]
                logger.info(f"è¿½åŠ ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯ID: {added_ids}")
            
            return len(rows_to_add)
            
        except Exception as e:
            ErrorHandler.log_error(e, "ææ¡ˆã‚¿ã‚¹ã‚¯è¿½åŠ ")
            logger.error(f"ã‚¨ãƒ©ãƒ¼è©³ç´°: {str(e)}")
            import traceback
            logger.error(traceback.format_exc())
            return 0