"""
task_executor.py - タスク実行コントローラー（完全版）
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime

# ===== 設定とユーティリティ =====
from config_utils import ErrorHandler, config

# ===== データ管理 =====
from sheets_manager import GoogleSheetsManager

# ===== エラーハンドラー（オプション） =====
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        TaskErrorHandler
    )
    HAS_ENHANCED_HANDLER = True
except ImportError:
    HAS_ENHANCED_HANDLER = False
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced未検出（標準エラーハンドラー使用）")

# ===== 分離モジュール =====
try:
    from task_executor_content import ContentTaskExecutor
    from task_executor_ma import MATaskExecutor
    HAS_SPECIALIZED_EXECUTORS = True
except ImportError:
    HAS_SPECIALIZED_EXECUTORS = False
    ContentTaskExecutor = None
    MATaskExecutor = None

# ===== WordPress連携（オプション） =====
try:
    from wordpress.wp_utils import task_router
    HAS_TASK_ROUTER = True
except ImportError:
    HAS_TASK_ROUTER = False
    task_router = None

logger = logging.getLogger(__name__)


class TaskExecutor:
    """タスク実行コントローラー（エラーハンドリング強化版）"""
    
    def __init__(
        self, 
        sheets_manager: GoogleSheetsManager, 
        browser_controller=None, 
        max_iterations: int = None
    ):
        """
        初期化
        
        Args:
            sheets_manager: GoogleSheetsManager インスタンス
            browser_controller: BrowserController インスタンス（オプション）
            max_iterations: 最大反復回数
        """
        self.sheets_manager = sheets_manager
        self.browser = browser_controller
        self.agents = {}
        self.review_agent = None
        
        if max_iterations is None:
            self.max_iterations = config.MAX_ITERATIONS
        else:
            self.max_iterations = max_iterations
        
        self.current_iteration = 0
        
        logger.info(f"TaskExecutor: 最大反復回数 = {self.max_iterations}")
        
        # エージェントを自動初期化
        self._initialize_agents()
        
        # === 分離モジュール初期化 ===
        if HAS_SPECIALIZED_EXECUTORS and ContentTaskExecutor and MATaskExecutor:
            try:
                # 記事生成専用エグゼキューター
                self.content_executor = ContentTaskExecutor(self.agents)
                logger.info("✅ ContentTaskExecutor 初期化完了")
                
                # M&A専用エグゼキューター
                self.ma_executor = MATaskExecutor(self.agents)
                logger.info("✅ MATaskExecutor 初期化完了")
                
                logger.info("="*60)
                logger.info("分離モジュール初期化完了")
                logger.info("  - ContentTaskExecutor (記事生成専用)")
                logger.info("  - MATaskExecutor (M&A/企業検索専用)")
                logger.info("="*60)
            except Exception as e:
                logger.warning(f"⚠️ 分離モジュール初期化失敗: {e}")
                self.content_executor = None
                self.ma_executor = None
        else:
            logger.warning("⚠️ 分離モジュールが利用できません")
            self.content_executor = None
            self.ma_executor = None
    
    def _initialize_agents(self):
        """エージェントの自動初期化"""
        logger.info("エージェントを初期化中...")
        # エージェントは外部から register_agent() で登録される
        logger.info("エージェント初期化完了")
    
    def register_agent(self, role: str, agent):
        """エージェントを登録"""
        self.agents[role] = agent
        logger.info(f"エージェント '{role}' を登録しました")
    
    def register_review_agent(self, review_agent):
        """レビューエージェントを登録"""
        self.review_agent = review_agent
        logger.info("レビューエージェントを登録しました")
    

    async def load_pending_tasks(self) -> List[Dict]:
        """保留中のタスクを読み込む（エラーハンドリング強化版）"""
        try:
            logger.info("📋 保留中のタスクを読み込み中...")
            tasks = await self.sheets_manager.load_tasks_from_sheet('pm_tasks')
            
            if not tasks:
                logger.info("📭 pm_tasksシートにタスクがありません")
                return []
            
            # statusが'pending'のタスクのみをフィルタ
            pending_tasks = [
                task for task in tasks 
                if task.get('status', '').lower() == 'pending'
            ]
            
            logger.info(f"📊 保留中のタスク: {len(pending_tasks)}件")
            
            # デバッグ情報
            if pending_tasks:
                for i, task in enumerate(pending_tasks[:3]):  # 最初の3件を表示
                    logger.info(f"  {i+1}. {task.get('description', '')[:60]}...")
                if len(pending_tasks) > 3:
                    logger.info(f"  ... 他 {len(pending_tasks)-3}件")
            
            return pending_tasks
            
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー: {e}")
            return []
    
    async def update_task_status(self, task: Dict, status: str, error: str = None):
        """タスクのステータスを更新"""
        try:
            task_id = task.get('task_id', 'UNKNOWN')
            logger.info(f"タスク {task_id} のステータスを '{status}' に更新")
            
            await self.sheets_manager.update_task_status(
                task_id, 
                status, 
                error_message=error
            )
            
        except Exception as e:
            logger.warning(f"⚠️ ステータス更新失敗（続行）: {e}")
    
    async def save_task_output(self, task: Dict, result: Dict):
        """タスクの出力を保存"""
        try:
            task_id = task.get('task_id', 'UNKNOWN')
            logger.info(f"タスク {task_id} の出力を保存中...")
            
            output_data = {
                'task_id': task_id,
                'summary': result.get('summary', ''),
                'full_text': result.get('full_text', ''),
                'screenshot': result.get('screenshot', ''),
                'timestamp': datetime.now().isoformat()
            }
            
            await self.sheets_manager.save_task_output(output_data)
            logger.info("✅ 出力保存完了")
            
        except Exception as e:
            logger.warning(f"⚠️ 出力保存失敗（無視）: {e}")
    
    async def execute_task(self, task: Dict) -> bool:
        """
        単一タスクを実行（エラーハンドリング強化版 + wp_dev/M&A対応）
        """
        task_id = task.get('task_id', 'UNKNOWN')
        
        try:
            # === タスク開始ヘッダー ===
            print("\n" + "🔷"*40)
            print("=" * 80)
            print(f"🎯 タスク開始: {task_id}")
            print("=" * 80)
            print(f"📝 内容: {task['description'][:70]}...")
            print(f"👤 担当エージェント: {task['required_role'].upper()}")
            
            # === タスクタイプの判定 ===
            task_type = 'default'
            if HAS_TASK_ROUTER and task_router:
                try:
                    task_type = task_router.determine_task_type(task)
                    logger.info(f"📊 タスクタイプ判定: {task_type}")
                    print(f"🔍 タスクタイプ: {task_type.upper()}")
                except Exception as e:
                    logger.warning(f"⚠️ タスクタイプ判定失敗、デフォルト処理: {e}")
            
            print("=" * 80)
            print("🔷"*40 + "\n")
            
            logger.info(f"タスク {task_id} 実行開始")
            
            # タスクのステータスを'in_progress'に更新
            try:
                await self.update_task_status(task, 'in_progress')
            except Exception as e:
                logger.warning(f"⚠️ ステータス更新失敗（続行）: {e}")
            
            # 担当AIエージェントを取得
            role = task['required_role'].lower()
            
            # === タスクタイムアウト設定 ===
            timeout_map = {
                'ma': 300.0,
                'content': 240.0,
                'review': 180.0,
                'wordpress': 300.0,
                'wp_dev': 300.0,  # ← wp_dev を追加
                'wp_design': 300.0,  # ← wp_design を追加
                'default': 180.0
            }
            task_timeout = timeout_map.get(task_type, 180.0)
            
            # === タスク実行（タイムアウト付き） ===
            result = None
            
            try:
                # タスク実行のコルーチンを作成
                if task_type == 'ma' and self.ma_executor:
                    logger.info("="*60)
                    logger.info("📊 M&A/企業検索タスクとして処理")
                    logger.info("="*60)
                    task_coro = self.ma_executor.execute_ma_task(task)
                
                elif task_type == 'content' and self.content_executor:
                    logger.info("="*60)
                    logger.info("✏️ 記事生成タスクとして処理")
                    logger.info("="*60)
                    task_coro = self.content_executor.execute_writer_task(task, role)
                
                elif task_type == 'review':
                    logger.info("="*60)
                    logger.info("✅ レビュータスクとして処理")
                    logger.info("="*60)
                    task_coro = self._execute_review_task(task)
                
                # === wp_dev と wp_design の処理を追加 ===
                elif role == 'wp_dev':
                    logger.info("="*60)
                    logger.info("🔧 WordPress開発タスクとして処理")
                    logger.info("="*60)
                    agent = self.agents.get('wp_dev')
                    if agent:
                        task_coro = agent.process_task(task)
                    else:
                        logger.warning("⚠️ wp_dev エージェントが見つかりません - 通常処理にフォールバック")
                        task_coro = self._execute_wordpress_task(task)
                
                elif role == 'wp_design':
                    logger.info("="*60)
                    logger.info("🎨 WordPress設計タスクとして処理")
                    logger.info("="*60)
                    agent = self.agents.get('wp_design')
                    if agent:
                        task_coro = agent.process_task(task)
                    else:
                        logger.warning("⚠️ wp_design エージェントが見つかりません - 通常処理にフォールバック")
                        task_coro = self._execute_design_task(task)
                
                else:
                    logger.info("="*60)
                    logger.info(f"📋 デフォルトタスク ({role}) として処理")
                    logger.info("="*60)
                    
                    # 従来のロジック
                    if role == 'design':
                        task_coro = self._execute_design_task(task)
                    elif role == 'dev':
                        task_coro = self._execute_dev_task(task)
                    elif role == 'ui':
                        task_coro = self._execute_ui_task(task)
                    elif role == 'wordpress':
                        task_coro = self._execute_wordpress_task(task)
                    elif role == 'plugin':
                        task_coro = self._execute_plugin_task(task)
                    else:
                        # 未登録エージェント
                        agent = self.agents.get(role)
                        if not agent:
                            logger.warning(f"担当エージェント '{role}' が見つかりません - スキップします")
                            await self.update_task_status(task, 'skipped')
                            return False
                        task_coro = agent.process_task(task)
                
                # タイムアウト付きで実行
                if HAS_ENHANCED_HANDLER:
                    result = await EnhancedErrorHandler.timeout_wrapper(
                        task_coro,
                        timeout=task_timeout,
                        context=f"タスク {task_id} 実行"
                    )
                else:
                    result = await asyncio.wait_for(task_coro, timeout=task_timeout)
            
            except asyncio.TimeoutError:
                logger.error("="*60)
                logger.error(f"⏱️ タスク {task_id} タイムアウト（{task_timeout}秒）")
                logger.error("="*60)
                
                await self.update_task_status(task, 'failed')
                
                print("\n" + "🔷"*40)
                print("=" * 80)
                print(f"⏱️ タスクタイムアウト: {task_id}")
                print(f"制限時間: {task_timeout}秒")
                print("=" * 80)
                print("🔷"*40 + "\n")
                
                return False
            
            except Exception as e:
                logger.error("="*60)
                logger.error(f"❌ タスク {task_id} 実行中に例外発生")
                logger.error(f"エラー: {str(e)}")
                logger.error("="*60)
                
                if HAS_ENHANCED_HANDLER:
                    EnhancedErrorHandler.log_error_with_context(
                        e, 
                        f"タスク {task_id} 実行"
                    )
                
                await self.update_task_status(task, 'failed')
                
                print("\n" + "🔷"*40)
                print("=" * 80)
                print(f"💥 タスク例外: {task_id}")
                print(f"例外: {str(e)}")
                print("=" * 80)
                print("🔷"*40 + "\n")
                
                return False
            
            # === 実行結果の処理 ===
            if result and result.get('success'):
                logger.info("="*60)
                logger.info(f"✅ タスク {task_id} 実行成功")
                logger.info("="*60)
                
                try:
                    await self.update_task_status(task, 'completed')
                    await self.save_task_output(task, result)
                except Exception as e:
                    logger.warning(f"⚠️ 結果保存失敗（タスク自体は成功）: {e}")
                
                # レビューAIでレビュー
                if self.review_agent and role != 'review' and task_type != 'review':
                    try:
                        logger.info("="*60)
                        logger.info("✅ レビューAIでチェックを開始")
                        logger.info("="*60)
                        
                        if HAS_ENHANCED_HANDLER:
                            await EnhancedErrorHandler.timeout_wrapper(
                                self.perform_review_and_add_tasks(task, result),
                                timeout=120.0,
                                context=f"レビュー（タスク {task_id}）"
                            )
                        else:
                            await asyncio.wait_for(
                                self.perform_review_and_add_tasks(task, result),
                                timeout=120.0
                            )
                    except Exception as e:
                        logger.warning(f"⚠️ レビュー失敗（無視）: {e}")
                
                print("\n" + "🔷"*40)
                print("=" * 80)
                print(f"✅ タスク完了: {task_id}")
                print(f"タイプ: {task_type.upper()}")
                print(f"ステータス: 成功")
                print("=" * 80)
                print("🔷"*40 + "\n")
                
                return True
            else:
                error_msg = result.get('error', '不明') if result else '結果なし'
                logger.error("="*60)
                logger.error(f"❌ タスク {task_id} 実行失敗")
                logger.error(f"エラー: {error_msg}")
                logger.error("="*60)
                
                await self.update_task_status(task, 'failed')
                
                print("\n" + "🔷"*40)
                print("=" * 80)
                print(f"❌ タスク失敗: {task_id}")
                print(f"タイプ: {task_type.upper()}")
                print(f"エラー: {error_msg}")
                print("=" * 80)
                print("🔷"*40 + "\n")
                
                return False
        
        except Exception as e:
            logger.error(f"❌ タスク {task_id} 処理全体で予期しないエラー")
            
            if HAS_ENHANCED_HANDLER:
                EnhancedErrorHandler.log_error_with_context(
                    e, 
                    f"タスク {task_id} 全体処理"
                )
            else:
                ErrorHandler.log_error(e, f"タスク {task_id} 実行")
            
            try:
                await self.update_task_status(task, 'failed')
            except:
                pass
            
            print("\n" + "🔷"*40)
            print("=" * 80)
            print(f"💥 タスク重大エラー: {task_id}")
            print(f"例外: {str(e)}")
            print("=" * 80)
            print("🔷"*40 + "\n")
            
            return False
    
    async def _execute_design_task(self, task: Dict) -> Dict:
        """設計タスクを実行"""
        agent = self.agents.get('design')
        if not agent:
            return {'success': False, 'error': 'デザインエージェントが登録されていません'}
        return await agent.process_task(task)
    
    async def _execute_dev_task(self, task: Dict) -> Dict:
        """開発タスクを実行"""
        agent = self.agents.get('dev')
        if not agent:
            return {'success': False, 'error': '開発エージェントが登録されていません'}
        return await agent.process_task(task)
    
    async def _execute_ui_task(self, task: Dict) -> Dict:
        """UIタスクを実行"""
        agent = self.agents.get('ui')
        if not agent:
            return {'success': False, 'error': 'UIエージェントが登録されていません'}
        return await agent.process_task(task)
    
    async def _execute_wordpress_task(self, task: Dict) -> Dict:
        """WordPressタスクを実行"""
        logger.info("┌" + "─"*58 + "┐")
        logger.info("│ 🌐 WordPress AIエージェント実行中")
        logger.info("├" + "─"*58 + "┤")
        logger.info(f"│ アクション: {task.get('post_action', 'N/A')}")
        logger.info(f"│ 言語: {task.get('language', 'N/A')}")
        logger.info(f"│ Polylang: {task.get('polylang_lang', 'N/A')}")
        logger.info("└" + "─"*58 + "┘")
        
        try:
            # M&A関連タスクの再判定
            if HAS_TASK_ROUTER and task_router and task_router.is_ma_task(task):
                logger.info("📊 M&A関連タスクとして再振り分け")
                if self.ma_executor:
                    return await self.ma_executor.execute_ma_task(task)
            
            # パラメータのデフォルト設定
            if 'post_action' not in task:
                task['post_action'] = 'edit'
            if 'polylang_lang' not in task:
                task['polylang_lang'] = 'ja'
            
            agent = self.agents.get('wordpress')
            if not agent:
                logger.error("❌ WordPress AIエージェントが登録されていません")
                return {
                    'success': False,
                    'error': 'wordpress エージェントが登録されていません'
                }
            
            result = await agent.process_task(task)
            
            if result.get('success'):
                logger.info("✅ WordPress AI: タスク完了")
            else:
                logger.error(f"❌ WordPress AI: 失敗 - {result.get('error', '不明')}")
            
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "WordPressタスク実行")
            logger.error(f"❌ WordPress AIエージェント: 例外発生 - {str(e)}")
            return {
                'success': False,
                'error': f'WordPressタスク実行エラー: {str(e)}'
            }
    
    async def _execute_plugin_task(self, task: Dict) -> Dict:
        """プラグインタスクを実行"""
        agent = self.agents.get('plugin')
        if not agent:
            return {'success': False, 'error': 'プラグインエージェントが登録されていません'}
        return await agent.process_task(task)
    
    async def _execute_review_task(self, task: Dict) -> Dict:
        """レビュータスクを実行"""
        if not self.review_agent:
            return {'success': False, 'error': 'レビューエージェントが登録されていません'}
        
        try:
            review_target_id = task.get('review_target_task_id')
            if not review_target_id:
                return {'success': False, 'error': 'レビュー対象タスクIDが指定されていません'}
            
            # レビュー実行
            result = await self.review_agent.review_task(review_target_id)
            return result
            
        except Exception as e:
            ErrorHandler.log_error(e, "レビュータスク実行")
            return {'success': False, 'error': str(e)}
    
    async def perform_review_and_add_tasks(self, task: Dict, result: Dict):
        """タスク完了後のレビューと追加タスク生成"""
        try:
            logger.info(f"\nタスク {task['task_id']} のレビューを開始...")
            
            output_content = result.get('full_text', result.get('summary', ''))
            
            task['output_content'] = output_content
            review_result = await self.review_agent.review_completed_task(task, output_content)
            
            if not review_result.get('success'):
                logger.warning("レビューに失敗しました")
                return
            
            review_data = review_result.get('review', {})
            next_actions = review_data.get('next_actions', {})
            
            if next_actions.get('required'):
                suggested_tasks = next_actions.get('suggested_tasks', [])
                
                if suggested_tasks:
                    print(f"\n提案タスク: {len(suggested_tasks)}件")
                    
                    while True:
                        choice = input("\n提案タスクをどうしますか?\n"
                                     "(y)追加 / (n)スキップ / (v)確認 / (e)編集 / (m)手動入力 / (c)キャンセル: ").lower()
                        
                        if choice == 'y':
                            added_count = await self.review_agent.add_suggested_tasks_to_sheet(
                                task['task_id'], 
                                suggested_tasks
                            )
                            print(f"{added_count}件のタスクを追加しました")
                            logger.info(f"{added_count}件のタスクを追加しました")
                            break
                        
                        elif choice == 'n':
                            print("タスク追加をスキップしました")
                            break
                        
                        elif choice == 'v':
                            if self.content_executor:
                                self.content_executor.display_suggested_tasks(suggested_tasks)
                            else:
                                self._display_suggested_tasks(suggested_tasks)
                            continue
                        
                        elif choice == 'e':
                            if self.content_executor:
                                edited_tasks = await self.content_executor.edit_suggested_tasks(suggested_tasks)
                            else:
                                edited_tasks = await self._edit_suggested_tasks(suggested_tasks)
                            
                            if edited_tasks:
                                confirm = input(f"編集後のタスク {len(edited_tasks)} 件を追加しますか? (y/n): ").lower()
                                if confirm == 'y':
                                    added_count = await self.review_agent.add_suggested_tasks_to_sheet(
                                        task['task_id'], 
                                        edited_tasks
                                    )
                                    print(f"{added_count}件のタスクを追加しました")
                                    break
                            continue
                        
                        elif choice == 'm':
                            if self.content_executor:
                                manual_tasks = await self.content_executor.create_manual_tasks()
                            else:
                                manual_tasks = await self._create_manual_tasks()
                            
                            if manual_tasks:
                                confirm = input(f"手動入力したタスク {len(manual_tasks)} 件を追加しますか? (y/n): ").lower()
                                if confirm == 'y':
                                    added_count = await self.review_agent.add_suggested_tasks_to_sheet(
                                        task['task_id'], 
                                        manual_tasks
                                    )
                                    print(f"{added_count}件のタスクを追加しました")
                                    break
                            continue
                        
                        elif choice == 'c':
                            print("タスク追加をキャンセルしました")
                            break
                        
                        else:
                            print("不正な入力です。y, n, v, e, m, c のいずれかを入力してください。")
                            continue
                else:
                    logger.info("レビュー結果: 追加タスク不要")
            else:
                logger.info("レビュー結果: 追加タスク不要")
        
        except Exception as e:
            ErrorHandler.log_error(e, "レビューとタスク追加")
    
    def _display_suggested_tasks(self, tasks: List[Dict]):
        """提案タスクを表示（フォールバック）"""
        print("\n" + "="*60)
        print("提案されたタスク:")
        print("="*60)
        for i, task in enumerate(tasks, 1):
            print(f"\n{i}. {task.get('description', 'N/A')}")
            print(f"   担当: {task.get('required_role', 'N/A')}")
            print(f"   優先度: {task.get('priority', 'medium')}")
        print("="*60)
    
    async def _edit_suggested_tasks(self, tasks: List[Dict]) -> List[Dict]:
        """提案タスクを編集（フォールバック）"""
        print("\n編集機能は利用できません")
        return tasks
    
    async def _create_manual_tasks(self) -> List[Dict]:
        """手動タスク作成（フォールバック）"""
        print("\n手動作成機能は利用できません")
        return []
    
    async def run_all_tasks(self, auto_continue: bool = False, enable_review: bool = True):
        """
        全タスクを実行（エラーハンドリング強化版）
        """
        try:
            logger.info("="*60)
            logger.info("タスク実行開始")
            logger.info("="*60)
            
            iteration = 0
            tasks_executed = 0
            tasks_success = 0
            tasks_failed = 0
            failed_tasks_list = []
            
            while iteration < self.max_iterations:
                iteration += 1
                
                logger.info(f"\n{'='*60}")
                logger.info(f"反復 {iteration}/{self.max_iterations}")
                logger.info(f"{'='*60}")
                
                try:
                    pending_tasks = await self.load_pending_tasks()
                    
                    if not pending_tasks:
                        logger.info("✅ 全タスク完了または保留タスクなし")
                        break
                    
                    logger.info(f"📋 実行予定タスク: {len(pending_tasks)}件")
                    
                    for task in pending_tasks:
                        task_id = task.get('task_id', 'UNKNOWN')
                        
                        try:
                            logger.info(f"\n{'─'*60}")
                            logger.info(f"タスク実行: {task_id}")
                            logger.info(f"{'─'*60}")
                            
                            tasks_executed += 1
                            
                            success = await self.execute_task(task)
                            
                            if success:
                                tasks_success += 1
                                logger.info(f"✅ タスク {task_id} 成功")
                            else:
                                tasks_failed += 1
                                failed_tasks_list.append({
                                    'task_id': task_id,
                                    'description': task.get('description', 'N/A')
                                })
                                logger.error(f"❌ タスク {task_id} 失敗")
                            
                            if not auto_continue:
                                continue_task = input(
                                    f"\n次のタスクに進みますか? "
                                    f"(y/n/a=以降全て実行): "
                                ).lower()
                                
                                if continue_task == 'n':
                                    logger.info("ユーザーによる中断")
                                    return
                                elif continue_task == 'a':
                                    auto_continue = True
                                    logger.info("自動実行モードに切り替え")
                            
                            await asyncio.sleep(2)
                            
                        except KeyboardInterrupt:
                            logger.warning("⏸️ ユーザーによる中断")
                            raise
                        
                        except Exception as e:
                            tasks_failed += 1
                            failed_tasks_list.append({
                                'task_id': task_id,
                                'description': task.get('description', 'N/A'),
                                'error': str(e)
                            })
                            
                            logger.error(f"❌ タスク {task_id} で予期しないエラー")
                            
                            if HAS_ENHANCED_HANDLER:
                                EnhancedErrorHandler.log_error_with_context(
                                    e,
                                    f"タスク {task_id} 実行中"
                                )
                            
                            if not auto_continue:
                                cont = input(
                                    f"\n⚠️ エラーが発生しました。続行しますか? (y/n): "
                                ).lower()
                                if cont != 'y':
                                    logger.info("ユーザーによる中断")
                                    break
                
                except Exception as e:
                    logger.error(f"❌ 反復 {iteration} 全体でエラー発生")
                    
                    if HAS_ENHANCED_HANDLER:
                        EnhancedErrorHandler.log_error_with_context(
                            e,
                            f"反復 {iteration}"
                        )
                    
                    if "critical" in str(e).lower():
                        logger.error("💥 致命的エラー検出 - 実行中断")
                        raise
                    
                    logger.warning("⚠️ 非致命的エラー - 次の反復へ")
                    continue
            
            # 最終レポート
            self._print_execution_report(
                tasks_executed,
                tasks_success,
                tasks_failed,
                failed_tasks_list
            )
            
        except KeyboardInterrupt:
            logger.warning("\n⏸️ ユーザーによる中断")
            raise
        
        except Exception as e:
            logger.error("❌ タスク実行全体で重大エラー")
            
            if HAS_ENHANCED_HANDLER:
                EnhancedErrorHandler.log_error_with_context(
                    e,
                    "タスク実行全体"
                )
            
            raise
    
    def _print_execution_report(
        self, 
        total: int, 
        success: int, 
        failed: int, 
        failed_list: list
    ):
        """実行レポートを出力"""
        print("\n" + "="*80)
        print("📊 タスク実行レポート")
        print("="*80)
        print(f"総実行数: {total}")
        print(f"✅ 成功: {success}")
        print(f"❌ 失敗: {failed}")
        
        if total > 0:
            success_rate = (success / total) * 100
            print(f"📈 成功率: {success_rate:.1f}%")
        
        if failed_list:
            print("\n❌ 失敗したタスク:")
            for item in failed_list:
                print(f"  - {item['task_id']}: {item['description'][:50]}...")
                if 'error' in item:
                    print(f"    エラー: {item['error'][:100]}")
        
        print("="*80)