# sheets_manager.py
"""Google Sheets管理クラス(拡張版: Google Drive対応)"""
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from google.auth import default
from google.auth.transport.requests import Request
from pathlib import Path
from typing import List, Dict, Optional
import logging
import re

from config_utils import config, ErrorHandler

logger = logging.getLogger(__name__)

class GoogleSheetsManager:
    """Google Sheets管理クラス(拡張版: Google Drive対応)"""
    
    # Google API スコープの定義
    GOOGLE_SHEETS_SCOPE = [
        'https://spreadsheets.google.com/feeds',
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file',
        'https://www.googleapis.com/auth/drive.readonly'
    ]
    
    def __init__(self, spreadsheet_id: str, service_account_file: Optional[str] = None):
        self.spreadsheet_id = spreadsheet_id
        self.service_account_file = service_account_file
        self.gc: Optional[gspread.Client] = None
        self.drive_service = None  # Google Drive API用
        self.setup_client()
    
    def setup_client(self) -> None:
        """Google Sheets クライアントの設定"""
        try:
            if self.service_account_file and Path(self.service_account_file).exists():
                # サービスアカウント認証
                creds = ServiceAccountCredentials.from_json_keyfile_name(
                    self.service_account_file, self.GOOGLE_SHEETS_SCOPE)
                self.gc = gspread.authorize(creds)
                
                # Google Drive API用のサービスも初期化
                self._setup_drive_service(creds)
                
                logger.info("✅ サービスアカウントで Google Sheets に接続しました")
            else:
                # デフォルト認証にフォールバック
                try:
                    creds, project = default(scopes=self.GOOGLE_SHEETS_SCOPE)
                    if creds.expired and creds.refresh_token:
                        creds.refresh(Request())
                    self.gc = gspread.authorize(creds)
                    
                    # Google Drive API用
                    self._setup_drive_service(creds)
                    
                    logger.info("✅ デフォルト認証で Google Sheets に接続しました")
                except Exception as e:
                    logger.warning(f"⚠️ デフォルト認証に失敗しました: {e}")
                    logger.warning("サービスアカウントファイルが必要です")
                    self.gc = None
                    
        except Exception as e:
            ErrorHandler.log_error(e, "Google Sheets クライアント設定")
            self.gc = None
    
    def _setup_drive_service(self, creds):
        """Google Drive APIサービスを初期化"""
        try:
            from googleapiclient.discovery import build
            self.drive_service = build('drive', 'v3', credentials=creds)
            logger.info("✅ Google Drive APIサービスを初期化しました")
        except Exception as e:
            logger.warning(f"⚠️ Google Drive APIサービスの初期化に失敗: {e}")
            self.drive_service = None
    
    def _ensure_client(self) -> None:
        """クライアントが初期化されているか確認"""
        if not self.gc:
            raise Exception("Google Sheets クライアントが初期化されていません。サービスアカウントファイルを設定してください。")
    
    async def load_tasks_from_sheet(self, sheet_name: str = "pm_tasks") -> List[Dict]:
        """指定されたシートからタスクを読み込む（エラー修正版）"""
        try:
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            try:
                task_sheet = sheet.worksheet(sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.error(f"❌ シート '{sheet_name}' が見つかりません")
                return []
        
            # ★★★ 修正: ヘッダー行の問題を回避する方法 ★★★
            try:
                # 方法1: get_all_records() を試す
                records = task_sheet.get_all_records()
                logger.info(f"✅ get_all_records() でデータ取得成功: {len(records)}行")
            except Exception as e:
                logger.warning(f"⚠️ get_all_records() 失敗: {e}")
                logger.info("🔧 代替方法でデータを取得します...")
                
                # 方法2: 生データを取得して手動で処理
                all_values = task_sheet.get_all_values()
                
                if len(all_values) <= 1:
                    logger.info("📭 データ行がありません")
                    return []
                
                # ヘッダー行を取得
                headers = all_values[0]
                logger.info(f"📋 ヘッダー: {headers}")
                
                # データ行を処理
                records = []
                for i, row in enumerate(all_values[1:], start=2):
                    if not any(row):  # 空行をスキップ
                        continue
                    
                    record = {}
                    for j, header in enumerate(headers):
                        if j < len(row) and header:  # ヘッダーが空でない場合のみ
                            record[header] = row[j]
                        elif j < len(row):
                            record[f'column_{j+1}'] = row[j]  # 空ヘッダーの場合
                    
                    records.append(record)
                
                logger.info(f"✅ 代替方法でデータ取得成功: {len(records)}行")
        
            tasks = []
            for i, record in enumerate(records, start=2):
                # タスクIDの処理を改善
                task_id = str(record.get('task_id', '')).strip()
                if not task_id and 'task_id' not in record:
                    # 最初の列をタスクIDとして使用
                    first_col = list(record.values())[0] if record else ''
                    task_id = str(first_col).strip()
                
                task = {
                    'task_id': task_id,
                    'description': record.get('task_description', record.get('description', '')),
                    'required_role': record.get('required_role', ''),
                    'status': record.get('status', ''),
                    'priority': record.get('priority', 'medium'),
                    'estimated_time': record.get('estimated_time', ''),
                    'dependencies': record.get('dependencies', ''),
                    'created_at': record.get('created_at', ''),
                    'batch_id': record.get('batch_id', ''),
                    'review_target_task_id': record.get('review_target_task_id', ''),
                    'post_action': record.get('post_action', ''),
                    'language': record.get('language', ''),
                    'polylang_lang': record.get('polylang_lang', '')
                }
                
                # 基本的な検証
                if task['description'] and task['required_role']:
                    tasks.append(task)
        
            logger.info(f"📊 タスク読み込み: {len(tasks)}件（シート: {sheet_name}）")
            
            # デバッグ情報
            if tasks:
                logger.info(f"📝 最初のタスク: {tasks[0].get('description', '')[:50]}...")
            else:
                logger.info("📭 読み込まれたタスクは0件です")
                
            return tasks
        
        except Exception as e:
            logger.error(f"❌ タスク読み込みエラー（シート: {sheet_name}）: {e}")
            return []

    async def load_tasks_from_sheet(self, sheet_name: str = 'pm_tasks') -> List[Dict]:
        """
        スプレッドシートからタスクを読み込む（エラー対策強化版）
        """
        try:
            logger.info(f"タスク読み込み開始: シート={sheet_name}")
                
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            task_sheet = sheet.worksheet(sheet_name)
                
            all_values = task_sheet.get_all_values()
                
            if not all_values or len(all_values) < 2:
                logger.warning(f"シート '{sheet_name}' にデータがありません")
                return []
                
            # ヘッダー行を取得（空白を除去）
            raw_headers = all_values[0]
                
            # ヘッダーのクリーンアップとマッピング
            header_mapping = {}
            for col_index, header in enumerate(raw_headers):
                clean_header = str(header).strip().lower()
                if clean_header:
                    header_mapping[clean_header] = col_index
                
            logger.info(f"検出されたヘッダー: {list(header_mapping.keys())}")
                
            # タスクを読み込み
            tasks = []
            for row_index, row in enumerate(all_values[1:], start=2):
                try:
                    task = {}
                        
                    # 各列の値を取得
                    for header, col_index in header_mapping.items():
                        if col_index < len(row):
                            value = row[col_index]
                                
                            # フィールド名の正規化
                            if header in ['task_id', 'id']:
                                task['task_id'] = value
                            elif header in ['description', 'task_description']:
                                task['description'] = value
                            elif header in ['required_role', 'role']:
                                task['required_role'] = value
                            elif header == 'status':
                                task['status'] = value
                            elif header == 'priority':
                                task['priority'] = value
                            elif header in ['dependencies', 'depends_on']:
                                task['dependencies'] = value
                            elif header == 'parameters':
                                task['parameters'] = value
                            else:
                                task[header] = value
                        
                    # 必須フィールドのチェック
                    if not task.get('task_id'):
                        logger.warning(f"行 {row_index}: task_id がありません - スキップ")
                        continue
                        
                    if not task.get('description'):
                        logger.warning(f"行 {row_index}: description がありません - スキップ")
                        continue
                        
                    if not task.get('required_role'):
                        logger.warning(f"行 {row_index}: required_role がありません - デフォルト 'dev' を使用")
                        task['required_role'] = 'dev'
                        
                    if not task.get('status'):
                        logger.warning(f"行 {row_index}: status がありません - デフォルト 'pending' を使用")
                        task['status'] = 'pending'
                        
                    tasks.append(task)
                    logger.debug(f"タスク読み込み: {task['task_id']} - {task['description'][:50]}...")
                        
                except Exception as e:
                    logger.error(f"行 {row_index} の読み込みエラー: {e}")
                    continue
                
            logger.info(f"✅ タスク読み込み完了: {len(tasks)}件")
            return tasks
                
        except Exception as e:
            logger.error(f"タスク読み込みエラー: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return []

    async def save_task_output(self, output_data: Dict):
        """タスクの出力を保存"""
        try:
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
        
            # 出力シートが存在するか確認
            try:
                output_sheet = sheet.worksheet("task_outputs")
            except gspread.exceptions.WorksheetNotFound:
                # シートが存在しない場合は作成
                logger.info("'task_outputs' シートを作成します")
                output_sheet = sheet.add_worksheet(title="task_outputs", rows=1000, cols=10)
                # ヘッダーを設定
                headers = ["task_id", "summary", "full_text", "screenshot", "timestamp"]
                output_sheet.append_row(headers)
        
            # データを追加
            row = [
                output_data.get('task_id', ''),
                output_data.get('summary', ''),
                output_data.get('full_text', ''),
                output_data.get('screenshot', ''),
                output_data.get('timestamp', '')
            ]
            output_sheet.append_row(row)
        
            logger.info(f"✅ タスク出力を保存: {output_data.get('task_id', '')}")
            return True
        
        except Exception as e:
            ErrorHandler.log_error(e, "タスク出力保存")
            return False
    
    def save_result_to_sheet(self, results: List[Dict], mode: str = "text") -> None:
        """
        結果をスプレッドシートに保存
        
        Args:
            results: 結果のリスト
            mode: "text" または "image"
        """
        try:
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            # 結果シート名を決定
            result_sheet_name = f"result_{mode}"
            
            # シートが存在しない場合は作成
            try:
                result_sheet = sheet.worksheet(result_sheet_name)
            except gspread.exceptions.WorksheetNotFound:
                logger.info(f"シート '{result_sheet_name}' を作成します")
                result_sheet = sheet.add_worksheet(title=result_sheet_name, rows=1000, cols=10)
                
                # ヘッダーを設定
                headers = ['Index', 'Prompt', 'Status', 'Filename', 'Timestamp', 'Error', 'Mode']
                result_sheet.append_row(headers)
            
            # 結果を追加
            for result in results:
                row = [
                    result.get('index', ''),
                    result.get('prompt', '')[:100],  # プロンプトは最初の100文字
                    result.get('status', ''),
                    result.get('filename', ''),
                    result.get('timestamp', ''),
                    result.get('error', ''),
                    result.get('mode', mode)
                ]
                result_sheet.append_row(row)
            
            logger.info(f"✅ {len(results)}件の結果を '{result_sheet_name}' に保存しました")
            
        except Exception as e:
            ErrorHandler.log_error(e, "結果保存")
            logger.warning("結果の保存に失敗しましたが、処理を続行します")
    
    def extract_file_id_from_url(self, url: str) -> Optional[str]:
        """
        Google DriveのURLからファイルIDを抽出
        
        対応形式:
        - https://drive.google.com/file/d/FILE_ID/view
        - https://drive.google.com/open?id=FILE_ID
        - https://docs.google.com/document/d/FILE_ID/edit
        """
        patterns = [
            r'/file/d/([a-zA-Z0-9_-]+)',
            r'id=([a-zA-Z0-9_-]+)',
            r'/d/([a-zA-Z0-9_-]+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                file_id = match.group(1)
                logger.info(f"✅ ファイルIDを抽出: {file_id}")
                return file_id
        
        logger.warning(f"⚠️ URLからファイルIDを抽出できませんでした: {url}")
        return None
    
    def read_file_from_drive(self, file_id_or_url: str) -> Optional[str]:
        """
        Google Driveからファイルをダウンロードして読み込む（超詳細ログ版）
        
        Args:
            file_id_or_url: ファイルID または Google DriveのURL
            
        Returns:
            ファイルの内容（テキスト）、失敗時はNone
        """
        try:
            logger.info("="*60)
            logger.info("【Google Drive読み込み開始】")
            logger.info("="*60)
            
            # 切り分け1: Drive APIサービスの確認
            logger.info("【切り分け1】Drive APIサービスを確認")
            if not self.drive_service:
                logger.error("❌ Google Drive APIサービスが初期化されていません")
                logger.error("  → サービスアカウント認証を確認してください")
                return None
            logger.info("✅ Drive APIサービス: 正常")
            
            # 切り分け2: URLかファイルIDかを判定
            logger.info("【切り分け2】入力値を解析")
            logger.info(f"  入力: {file_id_or_url[:100]}")
            
            if file_id_or_url.startswith('http'):
                logger.info("  → URL形式と判定")
                file_id = self.extract_file_id_from_url(file_id_or_url)
                if not file_id:
                    logger.error("❌ URLからファイルIDを抽出できませんでした")
                    return None
                logger.info(f"✅ ファイルID抽出成功: {file_id}")
            else:
                file_id = file_id_or_url
                logger.info(f"  → ファイルID形式: {file_id}")
            
            # 切り分け3: ファイル情報を取得
            logger.info("【切り分け3】ファイルメタデータを取得")
            try:
                from googleapiclient.http import MediaIoBaseDownload
                import io
                
                file_metadata = self.drive_service.files().get(
                    fileId=file_id, 
                    fields='name,mimeType,size,permissions'
                ).execute()
                
                file_name = file_metadata.get('name', 'Unknown')
                mime_type = file_metadata.get('mimeType', '')
                file_size = file_metadata.get('size', '0')
                
                logger.info("✅ ファイルメタデータ取得成功")
                logger.info(f"  ファイル名: {file_name}")
                logger.info(f"  MIME Type: {mime_type}")
                logger.info(f"  サイズ: {file_size} bytes")
                
            except Exception as e:
                logger.error(f"❌ ファイルメタデータ取得エラー: {e}")
                logger.error("  考えられる原因:")
                logger.error("  - ファイルIDが間違っている")
                logger.error("  - サービスアカウントに権限がない")
                logger.error("  - ファイルが削除されている")
                return None
            
            # 切り分け4: ファイルをダウンロード
            logger.info("【切り分け4】ファイルをダウンロード")
            try:
                request = self.drive_service.files().get_media(fileId=file_id)
                
                fh = io.BytesIO()
                downloader = MediaIoBaseDownload(fh, request)
                
                done = False
                chunk_count = 0
                while not done:
                    status, done = downloader.next_chunk()
                    chunk_count += 1
                    if status:
                        progress = int(status.progress() * 100)
                        logger.debug(f"  ⏳ チャンク{chunk_count}: {progress}%")
                
                logger.info(f"✅ ダウンロード完了: {chunk_count}チャンク")
                
            except Exception as e:
                logger.error(f"❌ ダウンロードエラー: {e}")
                return None
            
            # 切り分け5: テキストに変換
            logger.info("【切り分け5】バイトデータをテキストに変換")
            try:
                content = fh.getvalue().decode('utf-8')
                logger.info(f"✅ 変換成功: {len(content)}文字")
                logger.info(f"  先頭100文字: {content[:100]}...")
                
                # 内容の検証
                if len(content) < 10:
                    logger.warning(f"⚠️ 内容が短すぎます: {len(content)}文字")
                
                return content
                
            except UnicodeDecodeError as e:
                logger.error(f"❌ UTF-8デコードエラー: {e}")
                logger.error("  → ファイルがテキスト形式ではない可能性")
                return None
            except Exception as e:
                logger.error(f"❌ 変換エラー: {e}")
                return None
            
        except Exception as e:
            logger.error(f"❌ Google Driveファイル読み込みエラー: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def get_current_pc_id(self) -> int:
        """スプレッドシートのB12セルからPC_IDを読み取る"""
        try:
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
            
            pc_id_value = setting_sheet.cell(12, 2).value
            
            if pc_id_value:
                try:
                    pc_id = int(pc_id_value)
                    logger.info(f"✅ スプレッドシートからPC_ID={pc_id}を読み取りました(セルB12)")
                    return pc_id
                except ValueError:
                    logger.warning(f"⚠️ B12セルの値 '{pc_id_value}' を整数に変換できません。デフォルト値1を使用します")
                    return 1
            else:
                logger.warning("⚠️ B12セルが空です。デフォルト値1を使用します")
                return 1
                
        except Exception as e:
            ErrorHandler.log_error(e, "PC_ID読み取り")
            logger.warning("⚠️ PC_IDの読み取りに失敗しました。デフォルト値1を使用します")
            return 1
    
    def load_pc_settings(self, pc_id: int = 1) -> Dict[str, str]:
        """PC固有の設定をsettingシートから読み込み"""
        try:
            self._ensure_client()
        
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            setting_sheet = sheet.worksheet("setting")
        
            col_index = 1 + pc_id
        
            settings = {
                'google_id': self._get_cell_value(setting_sheet, 2, col_index),
                'google_pass': self._get_cell_value(setting_sheet, 3, col_index),
                'service_mail': self._get_cell_value(setting_sheet, 4, col_index),
                'download_image_folder': self._get_cell_value(setting_sheet, 5, col_index),
                'download_text_folder': self._get_cell_value(setting_sheet, 6, col_index),
                'browser_data_dir': self._get_cell_value(setting_sheet, 7, col_index),
                'service_account_file': self._get_cell_value(setting_sheet, 8, col_index),
                'cookies_file': self._get_cell_value(setting_sheet, 9, col_index),
                'generation_mode': self._get_cell_value(setting_sheet, 10, col_index),
                'text_format': self._get_cell_value(setting_sheet, 11, col_index),
                'service_type': self._get_cell_value(setting_sheet, 13, col_index),
                'agent_output_folder': self._get_cell_value(setting_sheet, 14, col_index),
                'max_iterations': self._get_cell_value(setting_sheet, 15, col_index),
                'wp_url': self._get_cell_value(setting_sheet, 16, col_index),
                'wp_user': self._get_cell_value(setting_sheet, 17, col_index),
                'wp_pass': self._get_cell_value(setting_sheet, 18, col_index),
            }
        
            # 検証処理
            mode = settings.get('generation_mode', '').strip().lower()
            if mode not in ['text', 'image']:
                logger.warning(f"⚠️ 不正なgeneration_mode値: '{mode}' → デフォルト 'image' を使用")
                settings['generation_mode'] = 'image'
            else:
                settings['generation_mode'] = mode
        
            try:
                max_iter = int(settings.get('max_iterations', '3'))
                if max_iter < 1 or max_iter > 10:
                    logger.warning(f"⚠️ 不正なmax_iterations値: {max_iter} → デフォルト 3 を使用")
                    settings['max_iterations'] = 3
                else:
                    settings['max_iterations'] = max_iter
            except (ValueError, TypeError):
                logger.warning(f"⚠️ max_iterationsの変換エラー → デフォルト 3 を使用")
                settings['max_iterations'] = 3
        
            logger.info(f"✅ PC_ID={pc_id} の設定を読み込みました")
            return settings
        
        except Exception as e:
            ErrorHandler.log_error(e, f"PC_ID={pc_id} の設定読み込み")
            raise

    def _get_cell_value(self, sheet, row: int, col: int) -> str:
        """セルの値を安全に取得"""
        try:
            value = sheet.cell(row, col).value
            return value if value is not None else ""
        except Exception:
            return ""
    
    def _get_column_letter(self, col_index: int) -> str:
        """列インデックスを列文字に変換(1→A, 2→B, ...)"""
        result = ""
        while col_index > 0:
            col_index -= 1
            result = chr(col_index % 26 + ord('A')) + result
            col_index //= 26
        return result
    
    def load_credentials_from_sheet(self, pc_id: int = 1) -> Dict[str, str]:
        """認証情報を読み込み(PC_ID対応版)"""
        try:
            settings = self.load_pc_settings(pc_id)
            
            credentials = {
                'email': settings['google_id'],
                'password': settings['google_pass'],
                'service_mail': settings.get('service_mail')
            }
            
            return credentials
            
        except Exception as e:
            ErrorHandler.log_error(e, "認証情報読み込み")
            raise
    
    def validate_sheet_structure(self) -> bool:
        """シート構造の妥当性をチェック"""
        try:
            self._ensure_client()
            
            sheet = self.gc.open_by_key(self.spreadsheet_id)
            
            required_sheets = ["setting"]
            existing_sheets = [ws.title for ws in sheet.worksheets()]
            
            for required_sheet in required_sheets:
                if required_sheet not in existing_sheets:
                    logger.error(f"❌ 必要なシート '{required_sheet}' が見つかりません")
                    return False
            
            if "prompt_text" not in existing_sheets and "prompt" not in existing_sheets:
                logger.error("❌ プロンプトシート ('prompt_text' または 'prompt') が見つかりません")
                return False
            
            logger.info("✅ シート構造の妥当性チェック完了")
            return True
            
        except Exception as e:
            ErrorHandler.log_error(e, "シート構造チェック")
            return False