# run_multi_agent.py
# マルチエージェントシステムの統合オーケストレーター（エラー対策強化版）
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import asyncio
import logging
from pathlib import Path
import argparse

# ===== 最優先: ログ設定 =====
from config_utils import config, ErrorHandler, PathManager

# エラーハンドラーのインポート
try:
    from error_handler_enhanced import (
        EnhancedErrorHandler,
        BrowserErrorHandler,
        SheetErrorHandler,
        TaskErrorHandler
    )
    logger = logging.getLogger(__name__)
    logger.info("✅ 強化版エラーハンドラー読み込み成功")
except ImportError:
    logger = logging.getLogger(__name__)
    logger.warning("⚠️ error_handler_enhanced.py が見つかりません（標準エラーハンドラー使用）")
    EnhancedErrorHandler = None
    BrowserErrorHandler = None

# その他のモジュールをインポート
from sheets_manager import GoogleSheetsManager
from browser_controller import BrowserController
from pm_agent import PMAgent
from task_executor import TaskExecutor
from design_agent import DesignAgent
from dev_agent import DevAgent
from review_agent import ReviewAgent


class MultiAgentOrchestrator:
    """マルチエージェントシステムの統合オーケストレーター（エラー対策強化版）"""

    def __init__(self, pc_id: int = None, max_iterations: int = None):
        self.pc_id = pc_id or 1
        self.max_iterations = max_iterations
        self.sheets_manager = None
        self.browser = None
        self.pm_agent = None
        self.task_executor = None
        self.design_agent = None
        self.dev_agent = None
        self.review_agent = None
        self.content_writer = None
        self.wordpress_agent = None
        self.output_folder = None
        self.initialization_success = False

    def _is_url(self, path_str: str) -> bool:
        """文字列がURLかどうかを判定"""
        if not path_str:
            return False
        path_lower = path_str.lower().strip()
        return path_lower.startswith('http://') or path_lower.startswith('https://')

    async def _find_service_account_file(self) -> str:
        """サービスアカウントファイルを探す（エラーハンドリング強化版）"""
        logger.info("📁 サービスアカウントファイルを検索中...")
        
        possible_paths = [
            Path.cwd() / "service_account.json",
            Path.home() / "Documents" / "gemini_auto_generate" / "service_account.json",
            Path.home() / "Documents" / "AI_Agent" / "service_account.json",
            Path.home() / "Documents" / "gemini_AI_Agent" / "service_account.json",
            Path(__file__).parent / "service_account.json",
        ]
        
        # 環境変数からも試行
        env_path = os.environ.get('SERVICE_ACCOUNT_FILE')
        if env_path:
            possible_paths.insert(0, Path(env_path))
        
        # バリデーション付きで検索
        for path in possible_paths:
            if not path:
                continue
            
            if EnhancedErrorHandler:
                validated_path = EnhancedErrorHandler.validate_file_path(path, must_exist=True)
                if validated_path:
                    logger.info(f"✅ サービスアカウントファイル発見: {validated_path}")
                    return str(validated_path)
            else:
                if path.exists():
                    logger.info(f"✅ サービスアカウントファイル発見: {path}")
                    return str(path)
        
        raise FileNotFoundError(
            "サービスアカウントファイルが見つかりません。\n"
            "以下の場所を確認してください:\n" +
            "\n".join(f"  - {p}" for p in possible_paths if p)
        )

    async def _initialize_browser_with_retry(self, max_retries: int = 3) -> bool:
        """ブラウザ初期化（リトライ付き）"""
        logger.info("="*60)
        logger.info("🌐 ブラウザ初期化開始...")
        logger.info("="*60)
        
        for retry in range(1, max_retries + 1):
            try:
                logger.info(f"ブラウザ起動試行 {retry}/{max_retries}")
                
                self.browser = BrowserController(self.output_folder, mode='text', service='google')
                
                # タイムアウト付きで起動
                if EnhancedErrorHandler:
                    await EnhancedErrorHandler.timeout_wrapper(
                        self.browser.setup_browser(),
                        timeout=60.0,
                        context="ブラウザ初期化"
                    )
                else:
                    await asyncio.wait_for(self.browser.setup_browser(), timeout=60.0)
                
                # 起動確認（少し待機）
                await asyncio.sleep(2)
                
                if self.browser.page:
                    # 動作確認
                    test_result = await self.browser.page.evaluate("1 + 1")
                    if test_result == 2:
                        logger.info(f"✅ ブラウザ起動成功（試行 {retry}）")
                        return True
                
                raise Exception("ブラウザ動作確認失敗")
                
            except asyncio.TimeoutError:
                logger.error(f"⏱️ ブラウザ起動タイムアウト（試行 {retry}）")
                
            except Exception as e:
                logger.error(f"❌ ブラウザ起動失敗（試行 {retry}）: {e}")
            
            # クリーンアップ
            if EnhancedErrorHandler:
                await EnhancedErrorHandler.safe_cleanup(
                    self.browser.cleanup if self.browser else lambda: None,
                    f"ブラウザ（試行 {retry}）"
                )
            else:
                try:
                    if self.browser:
                        await self.browser.cleanup()
                except:
                    pass
            
            if retry < max_retries:
                logger.info(f"⏳ 5秒後に再試行します...")
                await asyncio.sleep(5)
            else:
                logger.error("="*60)
                logger.error("❌ ブラウザ起動が全て失敗しました")
                logger.error("="*60)
                self._print_browser_troubleshooting()
                return False
        
        return False

    def _print_browser_troubleshooting(self):
        """ブラウザトラブルシューティングガイド"""
        logger.error("\n📋 トラブルシューティング:")
        logger.error("1. ✅ 既存のChromeプロセスを全て終了")
        logger.error("2. 📁 ブラウザデータディレクトリの権限確認")
        logger.error(f"     → {config.BROWSER_DATA_DIR}")
        logger.error("3. 🔧 Playwrightの再インストール:")
        logger.error("     → playwright install chromium")
        logger.error("4. 🗑️ ブラウザキャッシュのクリア:")
        logger.error(f"     → {config.BROWSER_DATA_DIR} を削除")
        logger.error("5. 🔄 システムの再起動")

    async def _initialize_wordpress_agent(self, wp_url: str, wp_user: str, wp_pass: str):
        """WordPressエージェント初期化（エラーハンドリング強化版）"""
        try:
            # インポートチェック
            if EnhancedErrorHandler:
                has_module = EnhancedErrorHandler.handle_import_error(
                    'wordpress.wp_agent',
                    optional=True
                )
                if not has_module:
                    logger.warning("⚠️ WordPressモジュールが見つかりません")
                    return None
            
            from wordpress.wp_agent import WordPressAgent
            
            wp_credentials = {
                'wp_url': wp_url,
                'wp_user': wp_user,
                'wp_pass': wp_pass
            }
            
            logger.info("🌐 WordPressエージェント初期化中...")
            self.wordpress_agent = WordPressAgent(self.browser, wp_credentials)
            self.wordpress_agent.sheets_manager = self.sheets_manager
            
            logger.info("🔐 WordPressへのログイン試行中...")
            
            # タイムアウト付きログイン
            if EnhancedErrorHandler:
                wp_login_success = await EnhancedErrorHandler.timeout_wrapper(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=60.0,
                    context="WordPressログイン"
                )
            else:
                wp_login_success = await asyncio.wait_for(
                    self.wordpress_agent.initialize_wp_session(),
                    timeout=60.0
                )
            
            if wp_login_success:
                self.task_executor.register_agent('wordpress', self.wordpress_agent)
                logger.info("✅ WordPressエージェント登録完了")
                return self.wordpress_agent
            else:
                logger.warning("⚠️ WordPressログイン失敗（スキップ）")
                return None
                
        except Exception as e:
            logger.error(f"WordPressエージェント初期化エラー: {e}")
            if EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "WordPress初期化")
            return None

    async def initialize(self):
        """システムの初期化（エラー対策強化版）"""
        try:
            print("="*60)
            print("🚀 マルチエージェントシステム起動中...")
            print("="*60)
        
            # 1. サービスアカウントファイル取得
            service_account_file = await self._find_service_account_file()
            
            # 2. Sheets Manager初期化
            logger.info("📊 Google Sheets 接続を初期化中...")
            self.sheets_manager = GoogleSheetsManager(config.SPREADSHEET_ID, service_account_file)
        
            # 3. PC設定読み込み
            if self.pc_id is None:
                self.pc_id = self.sheets_manager.get_current_pc_id()
                logger.info(f"PC_ID={self.pc_id} をスプレッドシートから取得")
        
            logger.info(f"⚙️ PC_ID={self.pc_id} の設定を読み込み中...")
            settings = self.sheets_manager.load_pc_settings(self.pc_id)
            
            # 4. 設定の適用
            config.BROWSER_DATA_DIR = settings.get('browser_data_dir')
            config.COOKIES_FILE = settings.get('cookies_file')
            config.GENERATION_MODE = 'text'
            config.SERVICE_TYPE = 'google'
            
            # 5. 出力フォルダ設定
            agent_output_setting = settings.get('agent_output_folder', '').strip()
            
            if not agent_output_setting or self._is_url(agent_output_setting):
                if agent_output_setting:
                    logger.warning(f"⚠️ B14がURL形式のため、デフォルトフォルダを使用")
                user_docs = Path.home() / "Documents" / "gemini_auto_generate" / "agent_outputs"
                self.output_folder = user_docs
                self.output_folder.mkdir(exist_ok=True, parents=True)
                logger.info(f"📁 Agent出力先: {self.output_folder}")
            else:
                config.AGENT_OUTPUT_FOLDER = agent_output_setting
                self.output_folder = PathManager.get_safe_path(config.AGENT_OUTPUT_FOLDER)
                logger.info(f"📁 Agent出力先(B14から取得): {self.output_folder}")
            
            config.MAX_ITERATIONS = settings.get('max_iterations', 3)
            
            if self.max_iterations is None:
                self.max_iterations = config.MAX_ITERATIONS
        
            # 6. ブラウザ初期化（リトライ付き）
            browser_success = await self._initialize_browser_with_retry(max_retries=3)
            
            if not browser_success:
                raise Exception("ブラウザの初期化に失敗しました")
            
            # 7. Geminiナビゲーション
            logger.info("="*60)
            logger.info("🌐 Geminiサイトへのナビゲーション開始...")
            logger.info("="*60)
            
            if EnhancedErrorHandler:
                await EnhancedErrorHandler.timeout_wrapper(
                    self.browser.navigate_to_gemini(),
                    timeout=60.0,
                    context="Geminiナビゲーション"
                )
            else:
                await asyncio.wait_for(self.browser.navigate_to_gemini(), timeout=60.0)
        
            # 8. WordPress認証情報を取得
            wp_url = settings.get('wp_url', '').strip()
            wp_user = settings.get('wp_user', '').strip()
            wp_pass = settings.get('wp_pass', '').strip()
        
            # 9. 各エージェントの初期化
            logger.info("="*60)
            logger.info("🤖 AIエージェント初期化開始...")
            logger.info("="*60)
            
            self.pm_agent = PMAgent(self.sheets_manager, self.browser)
            self.task_executor = TaskExecutor(
                self.sheets_manager, 
                self.browser,
                max_iterations=self.max_iterations
            )
        
            self.design_agent = DesignAgent(self.browser)
            self.dev_agent = DevAgent(self.browser)
            
            # ReviewAgentの初期化
            self.review_agent = ReviewAgent()
            self.review_agent.browser = self.browser
            self.review_agent.sheets_manager = self.sheets_manager
        
            # エージェント登録
            self.task_executor.register_agent('design', self.design_agent)
            self.task_executor.register_agent('dev', self.dev_agent)
            self.task_executor.register_review_agent(self.review_agent)
            
            # 10. コンテンツライター（オプション）
            try:
                from content_writer_agent import ContentWriterAgent
                self.content_writer = ContentWriterAgent(self.browser)
                self.task_executor.register_agent('writer', self.content_writer)
                self.task_executor.register_agent('content', self.content_writer)
                logger.info("✅ コンテンツライターエージェント登録完了")
            except ImportError:
                logger.warning("⚠️ content_writer_agent が見つかりません(スキップ)")
                self.content_writer = None
        
            # 11. WordPress（オプション）
            if wp_url and wp_user and wp_pass:
                self.wordpress_agent = await self._initialize_wordpress_agent(wp_url, wp_user, wp_pass)
            else:
                logger.info("⚠️ WordPress認証情報が未設定です(スキップ)")
                self.wordpress_agent = None
        
            logger.info("="*60)
            logger.info("✅ マルチエージェントシステム初期化完了")
            logger.info("="*60)
            logger.info(f"⚙️ 最大反復回数: {self.max_iterations}")
            logger.info(f"🆔 使用中のPC_ID: {self.pc_id}")
            
            self.initialization_success = True
        
        except Exception as e:
            logger.error("❌ システム初期化失敗")
            if EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "システム初期化")
            else:
                ErrorHandler.log_error(e, "システム初期化")
            raise

    async def run_full_workflow(self, goal: str = None, auto_continue: bool = False, enable_review: bool = True):
        """完全なワークフローを実行"""
        if not self.initialization_success:
            raise Exception("システムが初期化されていません")
        
        try:
            print("\n" + "="*60)
            print("📋 フェーズ1: PM AIによるタスク分解")
            print("="*60)
            
            if goal:
                goal_description = goal
                logger.info(f"🎯 指定された目標: {goal_description}")
            else:
                goal_data = await self.pm_agent.load_project_goal()
                if not goal_data:
                    print("\n❌ エラー: 目標が見つかりません")
                    print("--goal オプションで目標を指定するか、")
                    print("スプレッドシートの'project_goal'シートに目標を設定してください")
                    return
                goal_description = goal_data['description']
            
            task_plan = await self.pm_agent.analyze_and_create_tasks(goal_description)
            self.pm_agent.display_task_summary(task_plan)
            
            if not auto_continue:
                save = input("\n💾 タスクをスプレッドシートに保存しますか? (y/n): ")
                if save.lower() != 'y':
                    print("⏸️ 実行をキャンセルしました")
                    return
            
            await self.pm_agent.save_tasks_to_sheet(task_plan)
            
            print("\n" + "="*60)
            print("⚙️ フェーズ2: タスクの実行")
            print("="*60)
            
            if enable_review:
                print("✅ レビューAI: 有効")
            else:
                print("⏭️ レビューAI: 無効")
            
            if not auto_continue:
                execute = input("\n▶️ タスクの実行を開始しますか? (y/n): ")
                if execute.lower() != 'y':
                    print("⏸️ タスク実行をスキップしました")
                    return
            
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            print("\n" + "="*60)
            print("🎉 ワークフロー完了")
            print("="*60)
            print(f"📁 出力フォルダ: {self.output_folder}")
            print("📊 スプレッドシートで結果を確認してください")
            
        except Exception as e:
            logger.error("ワークフロー実行エラー")
            if EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "ワークフロー実行")
            else:
                ErrorHandler.log_error(e, "ワークフロー実行")
            raise

    async def run_tasks_only(self, auto_continue: bool = False, enable_review: bool = True):
        """既存のタスクのみを実行"""
        if not self.initialization_success:
            raise Exception("システムが初期化されていません")
        
        try:
            print("\n" + "="*60)
            print("⚙️ 既存タスクの実行")
            print("="*60)
            
            if enable_review:
                print("✅ レビューAI: 有効")
            else:
                print("⏭️ レビューAI: 無効")
            
            await self.task_executor.run_all_tasks(
                auto_continue=auto_continue,
                enable_review=enable_review
            )
            
            print("\n" + "="*60)
            print("🎉 タスク実行完了")
            print("="*60)
            
        except Exception as e:
            logger.error("タスク実行エラー")
            if EnhancedErrorHandler:
                EnhancedErrorHandler.log_error_with_context(e, "タスク実行")
            else:
                ErrorHandler.log_error(e, "タスク実行")
            raise

    async def cleanup(self):
        """リソースのクリーンアップ（強化版）"""
        logger.info("🧹 クリーンアップ開始...")
        
        # WordPressエージェント
        if self.wordpress_agent:
            if EnhancedErrorHandler:
                await EnhancedErrorHandler.safe_cleanup(
                    self.wordpress_agent.cleanup,
                    "WordPressエージェント"
                )
            else:
                try:
                    await self.wordpress_agent.cleanup()
                except Exception as e:
                    logger.warning(f"WordPressクリーンアップ失敗: {e}")
        
        # ブラウザ
        if self.browser:
            if EnhancedErrorHandler:
                await EnhancedErrorHandler.safe_cleanup(
                    self.browser.cleanup,
                    "ブラウザ"
                )
            else:
                try:
                    await self.browser.cleanup()
                except Exception as e:
                    logger.warning(f"ブラウザクリーンアップ失敗: {e}")
        
        # asyncioタスクのキャンセル
        try:
            tasks = [t for t in asyncio.all_tasks() 
                    if t is not asyncio.current_task()]
            
            if tasks:
                logger.info(f"🔄 {len(tasks)}個の非同期タスクをキャンセル中...")
                for task in tasks:
                    task.cancel()
                
                # タスクの完了待機
                await asyncio.gather(*tasks, return_exceptions=True)
                logger.info("✅ 非同期タスククリーンアップ完了")
                
        except Exception as e:
            logger.warning(f"非同期タスククリーンアップ失敗: {e}")
        
        logger.info("✅ 全リソースクリーンアップ完了")


async def main():
    parser = argparse.ArgumentParser(description='マルチエージェントシステム(エラー対策強化版)')
    parser.add_argument('--goal', type=str, help='プロジェクト目標を直接指定')
    parser.add_argument('--tasks-only', action='store_true', help='既存タスクのみ実行(PM AIスキップ)')
    parser.add_argument('--auto', action='store_true', help='自動実行(確認なし)')
    parser.add_argument('--no-review', action='store_true', help='レビュー機能を無効化')
    parser.add_argument('--max-iterations', type=int, default=3, help='最大反復回数(デフォルト: 3)')
    parser.add_argument('--pc-id', type=int, help='PC_IDを指定')
    
    args = parser.parse_args()
    
    orchestrator = MultiAgentOrchestrator(
        pc_id=args.pc_id,
        max_iterations=args.max_iterations
    )
    
    try:
        await orchestrator.initialize()
        
        enable_review = not args.no_review
        
        if args.tasks_only:
            await orchestrator.run_tasks_only(
                auto_continue=args.auto,
                enable_review=enable_review
            )
        else:
            await orchestrator.run_full_workflow(
                goal=args.goal,
                auto_continue=args.auto,
                enable_review=enable_review
            )
        
    except KeyboardInterrupt:
        print("\n\n⏸️ 処理を中断しました")
    except Exception as e:
        logger.error(f"❌ 実行エラー: {e}")
        import traceback
        traceback.print_exc()
    finally:
        await orchestrator.cleanup()
        print("\n👋 システムを終了しました")


if __name__ == "__main__":
    asyncio.run(main())